/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/**********************************************************
 * paramdef.RefractCalib
 *
 * This file contains the TDRP parameter definitions for
 * RefractCalib
 */


commentdef
{
  p_header = "RefractCalib";
  p_text = "RefractCalib (a) reads radar scan files, in polar coordinates; (b) identifies suitable clutter targets; (c) computes the mean phase of those targets for a baseline calibration; and (d) writes the calibration details to a file. Typically we use 6 hours of scans for this purpose. Ideally the moisture field should be uniform for this procedure to work well.";
};

///////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "DEBUGGING AND PROCESS CONTROL";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE
} debug_t;

paramdef enum debug_t
{
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef boolean
{
  p_descr = "Flag indicating whether to write debug MDV files";
  p_default = false;
} write_debug_mdv_files;

paramdef string
{
  p_descr = "Debug MDV file URL";
  p_default = "mdvp:://localhost::mdv/debug/RefractCalib";
} debug_mdv_url;

paramdef double
{
  p_descr = "debug latitude";
  p_help = "Extreme debugging at a point, set to -9999 to disable";
  p_default = -9999.0;
} debug_lat;

paramdef double
{
  p_descr = "debug longitude";
  p_help = "Extreme debugging at a point, set to -9999 to disable";
  p_default = -9999;
} debug_lon;

paramdef int
{
  p_descr = "debug npt";
  p_help = "Extreme debugging radius around the debug point to keep showing debugging, number of gridpoints";
  p_default = 1;
} debug_npt;

///////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "DATA INPUT";
}

typedef enum {
  ARCHIVE, FILELIST
} mode_t;

paramdef enum mode_t {
  p_default = ARCHIVE;
  p_descr = "Processing mode";
  p_help = "In ARCHIVE mode, we loop through the data between the start and end times. In FILELIST mode, we moves through the list of files specified on the command line. Typically we use about 6 hours of data for this step.";
} mode;

paramdef string
{
  p_descr = "Directory for input data files";
  p_default = "/tmp/Refract/input_dir";
} input_dir;

paramdef string {
  p_default = "2017 03 21 00 00 00";
  p_descr = "Set the start time for ARCHIVE mode analysis.";
  p_help = "Format is 'yyyy mm dd hh mm ss'.";
} start_time;

paramdef string {
  p_default = "2017 03 21 06 00 00";
  p_descr = "Set the end time for ARCHIVE mode analysis.";
  p_help = "Format is 'yyyy mm dd hh mm ss'.";
} end_time;

///////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "DATA OUTPUT";
}

paramdef string
{
  p_default = "/tmp/RefractCalib.mdv.nc";
  p_descr = "Full path, including file name, for output";
  p_help = "Full path for the file containing calibration information. This is the file that is created by the calibration and used as input to the RefractCompute algorithm.";
} output_file_path;

paramdef string
{
  p_default = "/tmp/Refract/output_dir";
  p_descr = "Directory for output data files";
  p_descr = "This is a copy of the output file, using the standard time stamps for day directories and output file name. It is suitable for displaying in CIDD and Lucid.";
} output_dir;

///////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "DATA FIELD DETAILS";
  p_text = "Details of the fields to be retrieved from the data files.";
};

paramdef boolean
{
  p_descr = "Flag indicating whether the raw I and Q values are included in "
            "the input stream.";
  p_help = "If true, the raw fields will be read from the input stream. "
           "If false, the raw fields will be calculated from the NIQ/AIQ "
           "values which must be inluded in the input stream instead.";
  p_default = true;
} raw_iq_in_input;

paramdef string
{
  p_descr = "Raw I field name in the input stream.";
  p_help = "Used only if raw_iq_in_input is set to TRUE.";
  p_default = "MeanI";
} raw_i_field_name;

paramdef string
{
  p_descr = "Raw Q field name in the input stream.";
  p_help = "Used only if raw_iq_in_input is set to TRUE.";
  p_default = "MeanQ";
} raw_q_field_name;

paramdef string
{
  p_descr = "NIQ field name in the input stream.";
  p_help = "Used only if raw_iq_in_input is set to FALSE.";
  p_default = "NIQ";
} niq_field_name;

paramdef double
{
  p_descr = "Input NIQ scale value";
  p_help = "The NIQ value from the input source is multiplied by this "
           "value before the data is used. "
           "For most radars this value should be 0.1. "
           "For SPOL this value should be 0.025.";
  p_default = 0.1;
} input_niq_scale;

paramdef boolean
{
  p_descr = "Flag indicating whether to invert the sign of the target angles.";
  p_help = "This fix should be done upstream, but is added here "
           "just in case.\n"
           "Used only if raw_iq_in_input is set to FALSE.";
  p_default = false;
} invert_target_angle_sign;

paramdef string
{
  p_descr = "AIQ field name in the input stream.";
  p_help = "Used only if raw_iq_in_input is set to FALSE.";
  p_default = "AIQ";
} aiq_field_name;

paramdef boolean {
  p_default = TRUE;
  p_descr = "Is SNR data available?";
  p_help = "If not, SNR will be computed from the DBZ field. See 'noise_dbz_at_100km'.";
} snr_available;

paramdef string {
  p_default = "SNR";
  p_descr = "Field name for SNR.";
  p_help = "Signal-to-noise ratio (dB).";
} snr_field_name;

paramdef double {
  p_default = 0.0;
  p_descr = "The noise value, represented as dBZ at a range of 100km.";
  p_help = "This is used for computing the SNR from the DBZ field. It is only used if SNR_available is FALSE. The SNR will be computed by range-correcting this value and using it as the noise value.";
} noise_dbz_at_100km;

paramdef string {
  p_default = "DBZ";
  p_descr = "Field name for DBZ.";
  p_help = "Horizontally-polarized reflectivity factor.";
} dbz_field_name;

typedef enum
{
  QUALITY_FROM_WIDTH,
  QUALITY_FROM_CPA
} quality_source_t;

paramdef enum quality_source_t
{
  p_descr = "Which field to use when calculating the quality value.";
  p_help = "\tQUALITY_FROM_WIDTH - The quality field is calculated using "
           "a spectrum width field.\n"
           "\tQUALITY_FROM_CPA - The quality field is calculated using "
           "a CPA field.\n";
  p_default = QUALITY_FROM_WIDTH;
} quality_source;

paramdef string
{
  p_descr = "Name of field to use in the quality calculations.";
  p_help = "If quality_source is set to QUALITY_FROM_WIDTH then this should be "
           "a spectrum width field.\n"
           "If quality_source is set to QUALITY_FROM_CPA then this shoudl be a "
           "probability of clutter field. "
           "The probability of clutter field should range from 0.0 to 1.0 with "
           "0.0 indicating the gate definitely doesn't contain clutter and 1.0 "
           "indicating that the gate definitely is clutter.\n";
  p_default = "WIDTH";
} quality_field_name;

typedef struct
{
  double min_angle;
  double max_angle;
} elevation_angle_t;

paramdef struct elevation_angle_t
{
  p_descr = "The angle limits for the desired elevation angle. "
            "Only sweeps with elevation angles between these limits will "
            "be used in the calibration.";
  p_help = "Used only if specify_elevation_by_index is set to false.";
  p_default = { 0.3, 0.5 };
} elevation_angle;

paramdef long
{
  p_descr = "Number of azimuths used in data processing";
  p_min = 1;
  p_default = 360;
} num_azim;

paramdef long
{
  p_descr = "Number of range bins used in data processing";
  p_min = 1;
  p_default = 450;
} num_range_bins;

///////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "ALGORITHM PARAMETERS";
};

paramdef double
{
  p_descr = "Antenna beam width in degrees";
  p_default = 0.92;
} beam_width;

paramdef long
{
  p_descr = "Min range gate of ground echo";
  p_min = 1;
  p_default = 4;
} r_min;

paramdef double
{
  p_descr = "Side lobe power";
  p_help = "Echoes below this value of integrated power are considered "
           "to be from sidelobes.";
  p_max = -10.0;
  p_default = -75.0;
} side_lobe_pow;

typedef enum
{
  ENTER_N,
  ENTER_P_T_TD
} entry_type_t;

paramdef enum entry_type_t
{
  p_descr = "Type of data entry for the calibration calculation.";
  p_help = "\tENTER_N - N is entered directly in the calib_n parameter.\n"
           "\tENTER_P_T_TD - Pressure is entered in the calib_pressure "
           "parameter, temperature is entered in the calib_temperature "
           "parameter and dew point temperature is entered in the "
           "calib_dewpoint_temperature paramtere.\n";
  p_default = ENTER_N;
} entry_type;

paramdef double
{
  p_descr = "Default N value to use in the calibration.";
  p_help = "Used only if entry_type is set to ENTER_N.";
  p_default = 1.0;
} calib_n;

paramdef double
{
  p_descr = "Pressure value to use in the calibration.";
  p_help = "This is the station pressure, NOT the sea level pressure. "
           "Used only if entry_type is set to ENTER_P_T_TD.";
  p_default = 260.0;
} calib_pressure;

paramdef double
{
  p_descr = "Temperature value to use in the calibration.";
  p_help = "Used only if entry_type is set to ENTER_P_T_TD.";
  p_default = 1.0;
} calib_temperature;

paramdef double
{
  p_descr = "Dewpoint temperature to use in the calibration.";
  p_help = "Unsed only if entry_type is set to ENTER_P_T_TD.";
  p_default = 1.0;
} calib_dewpoint_temperature;


