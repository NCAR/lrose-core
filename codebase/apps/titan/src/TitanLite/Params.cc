/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program TitanLite
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Titan it the Thunderstorm Identification, Tracking, Analysis and Nowcasting appliction. It identifies storms in 3-D radar data stored in MDV format, tracks the storms and forecasts their position using extrapolation.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[2].val = DEBUG_EXTRA;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[3].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("PROGRAM MODE OF OPERATION.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("\nREALTIME mode: Titan waits for a new input MDV file.\n\nARCHIVE mode: Titan iterates through the files between the start and end times set by the user. \n\nFORECAST mode: similar to ARCHIVE mode, except that Titan is run on the output from a model run, specified by the model generate (gen) time. In this case the output files are written to a subdirectory of storm_data_dir, named from the generate time, e.g. 'g_20121205_030000'.\n\nRETRACK mode: only the tracking algorithm is rerun, using the data stored in the existing storm (.sh5, .sd5) files.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
      tt->enum_def.fields[2].name = tdrpStrDup("RETRACK");
      tt->enum_def.fields[2].val = RETRACK;
      tt->enum_def.fields[3].name = tdrpStrDup("FORECAST");
      tt->enum_def.fields[3].val = FORECAST;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("AUTO-RESTART OPTION.");
    tt->comment_text = tdrpStrDup("This allows you to automatically restart the program at a given time of day (GMT). This keeps the output files simple - there is one series of files per day. If storm tracking is running it is also restarted.");
    tt++;
    
    // Parameter 'auto_restart'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_restart");
    tt->descr = tdrpStrDup("Auto-restart option. Always forced TRUE for REALTIME mode.");
    tt->help = tdrpStrDup("If set, the program restarts at restart_time (GMT). The data from the previous 'restart_overlap_period' is copied into the new file, so that tracks at restart time will have some history. Use of this option ensures that the storm and track files will not grow forever.");
    tt->val_offset = (char *) &auto_restart - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'restart_time'
    // ctype is '_restart_time_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("restart_time");
    tt->descr = tdrpStrDup("The time in the day (UCT/GMT) at which restart occurs.");
    tt->help = tdrpStrDup("The program will check for the passing of this time. Once data beyond this time is found, restart will occur.\n");
    tt->val_offset = (char *) &restart_time - &_start_;
    tt->struct_def.name = tdrpStrDup("restart_time_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("hour");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &restart_time.hour - (char *) &restart_time;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("min");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &restart_time.min - (char *) &restart_time;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].i = 0;
    tt++;
    
    // Parameter 'restart_overlap_period'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("restart_overlap_period");
    tt->descr = tdrpStrDup("The period copied to the new file on restart (secs).");
    tt->help = tdrpStrDup("On restart, the program copies some of the previous file, to provide history for storm_track. This is the duration of the copied data.");
    tt->val_offset = (char *) &restart_overlap_period - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("DATA INPUT.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_url");
    tt->descr = tdrpStrDup("URL for input MDV data.");
    tt->help = tdrpStrDup("The input MDV data files are stored at this URL. In REALTIME mode the program monitors the latest_data_info file for this URL and processes a new scan each time new data arrives.");
    tt->val_offset = (char *) &input_url - &_start_;
    tt->single_val.s = tdrpStrDup("input");
    tt++;
    
    // Parameter 'max_realtime_valid_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_realtime_valid_age");
    tt->descr = tdrpStrDup("Max valid age of rdata input files in realtime mode (secs)");
    tt->help = tdrpStrDup("This the max valid age for an incoming file. The program will wait for a data file more recent than this age.");
    tt->val_offset = (char *) &max_realtime_valid_age - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 360;
    tt++;
    
    // Parameter 'input_search_sleep_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("input_search_sleep_msecs");
    tt->descr = tdrpStrDup("Sleep interval which searching for new data - (millisecs).");
    tt->help = tdrpStrDup("This is the period of sleep time between successive checks for new data. If you are searching on a remote URL, and the DataMapper is not active, this should be set to 5000 or greater to avoid over-frequent server requests.");
    tt->val_offset = (char *) &input_search_sleep_msecs - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1000;
    tt->single_val.i = 1000;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("DATA FIELDS IN INPUT FILES.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'dbz_field'
    // ctype is '_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("dbz_field");
    tt->descr = tdrpStrDup("Reflectivity field details.");
    tt->help = tdrpStrDup("If the field name is specified, that is used. If the field name is empty, the field number is used.");
    tt->val_offset = (char *) &dbz_field - &_start_;
    tt->struct_def.name = tdrpStrDup("field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &dbz_field.name - (char *) &dbz_field;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("num");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &dbz_field.num - (char *) &dbz_field;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].i = 0;
    tt++;
    
    // Parameter 'negate_dbz_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("negate_dbz_field");
    tt->descr = tdrpStrDup("Option to negate the data values in the dBZ field.");
    tt->help = tdrpStrDup("If true, the data values in the dbz field will be multiplied by -1. This is useful for running Titan on fields such as satellite IR fields, in which 'storms' are areas of high negaive instead of high positive values.");
    tt->val_offset = (char *) &negate_dbz_field - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vel_available'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vel_available");
    tt->descr = tdrpStrDup("Flag to indicate if velocity data is available");
    tt->help = tdrpStrDup("If this is set, velocity data is available in the radar volumes. Velocity-based computations will be carried out. If not, velocity-based computations will be omitted.");
    tt->val_offset = (char *) &vel_available - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vel_field'
    // ctype is '_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("vel_field");
    tt->descr = tdrpStrDup("Velocity field details.");
    tt->help = tdrpStrDup("If the field name is specified, that is used. If the field name is empty, the field number is used. Note that the usage must be consistent with the dbz_field parameter, i.e. if you specify the name for reflectivity you must also specify the name for velocity, and vice versa.");
    tt->val_offset = (char *) &vel_field - &_start_;
    tt->struct_def.name = tdrpStrDup("field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &vel_field.name - (char *) &vel_field;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("num");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &vel_field.num - (char *) &vel_field;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("VEL");
      tt->struct_vals[1].i = 0;
    tt++;
    
    // Parameter 'vel_to_m_per_sec_scale'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("vel_to_m_per_sec_scale");
    tt->descr = tdrpStrDup("Factor to convert velocity field units to m/s.");
    tt->help = tdrpStrDup("This is included in case the velocity is not in m/s units.");
    tt->val_offset = (char *) &vel_to_m_per_sec_scale - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("REMAPPING THE VERTICAL LEVELS TO CONSTANT SPACING.");
    tt->comment_text = tdrpStrDup("If the input files do not have constant vertical levels, you will need to remap the vertical levels appropriately. See the following parameters.");
    tt++;
    
    // Parameter 'remap_z_to_constant_grid'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_z_to_constant_grid");
    tt->descr = tdrpStrDup("Option to remap the Z levels onto a grid with constant dz.");
    tt->help = tdrpStrDup("Field data will be remapped onto the specified Z levels using the nearest neighbor method. See 'remap_z_grid'. Note that this actually changes the data. Whereas 'override_vlevels' only changes the vlevels in the headers, and does not change the data.");
    tt->val_offset = (char *) &remap_z_to_constant_grid - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_z_grid'
    // ctype is '_remap_z_grid_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("remap_z_grid");
    tt->descr = tdrpStrDup("Specified Z levels for remapping.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &remap_z_grid - &_start_;
    tt->struct_def.name = tdrpStrDup("remap_z_grid_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nz");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &remap_z_grid.nz - (char *) &remap_z_grid;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("minz");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &remap_z_grid.minz - (char *) &remap_z_grid;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("dz");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &remap_z_grid.dz - (char *) &remap_z_grid;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 10;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 1;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("STORM IDENTIFICATION PARAMETERS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'low_dbz_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("low_dbz_threshold");
    tt->descr = tdrpStrDup("Lower dBZ threshold for storm identification (dBZ).");
    tt->help = tdrpStrDup("Storms are defined as regions with reflectivity values in excess of this value.");
    tt->val_offset = (char *) &low_dbz_threshold - &_start_;
    tt->single_val.d = 35;
    tt++;
    
    // Parameter 'high_dbz_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("high_dbz_threshold");
    tt->descr = tdrpStrDup("Upper dBZ threshold (dBZ).");
    tt->help = tdrpStrDup("If a storm contains reflectivity in excess of this value, it will not be processed.");
    tt->val_offset = (char *) &high_dbz_threshold - &_start_;
    tt->single_val.d = 80;
    tt++;
    
    // Parameter 'discard_high_threshold_storms'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("discard_high_threshold_storms");
    tt->descr = tdrpStrDup("Option to discard storms with dBZ exceeding the high threshold.");
    tt->help = tdrpStrDup("If true, a storm with reflectivity in excess of the high_dbz_threshold will be discarded. If false, the storm will be kept, but only those portions below the threshold will be regarded as part of the storm.");
    tt->val_offset = (char *) &discard_high_threshold_storms - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_grid_overlap'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_grid_overlap");
    tt->descr = tdrpStrDup("Min overlap between storm fragments.");
    tt->help = tdrpStrDup("A storm is made up of a series of adjacent 'runs' of data in the EW direction. When testing for overlap, some minimum number of overlap grids must be used. This is that minimum overlap in grid units.");
    tt->val_offset = (char *) &min_grid_overlap - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'set_dbz_threshold_for_tops'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_dbz_threshold_for_tops");
    tt->descr = tdrpStrDup("Option to set specific dbz threshold for storm tops.");
    tt->help = tdrpStrDup("If FALSE, 'low_dbz_threshold' will be used to determine storm tops. If TRUE, 'tops_dbz_threshold' will be used to determine storm tops.");
    tt->val_offset = (char *) &set_dbz_threshold_for_tops - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tops_dbz_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tops_dbz_threshold");
    tt->descr = tdrpStrDup("dBZ threshold for identification of storm tops (dBZ).");
    tt->help = tdrpStrDup("See 'set_dbz_threshold_for_tops'.");
    tt->val_offset = (char *) &tops_dbz_threshold - &_start_;
    tt->single_val.d = 18;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("OPTIONS TO USE DUAL THRESHOLDS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_dual_threshold'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_dual_threshold");
    tt->descr = tdrpStrDup("Option to perform identification using dual thresholds.");
    tt->help = tdrpStrDup("If set, the identification is performed in multiple stages. First, an outer storm envelope is computed, using the low_dbz_threshold. This is the default method which has always been used in TITAN. Then, using the dual_threshold parameters, a search is performed for storms within the envelope exceeding the dbz_threshold. If there is only one region at the higher reflectivity, the entire outer envelope is used. If there are two or more regions which meet or exceed the required characteristics, these regions are grown back out to the original envelop, but stop growing where they meet between the higher-reflectivity areas. The final storms are computed by breaking the original storm into regions based upon these secondary areas.\n\nNOTE: work done in South Africa by the SAWS found the following parameter settings to be optimal for strong convection and squall lines:\n\tlow_dbz_threshold: 33 dBZ\n\tmin_storm_size: 100 km3\n\tdual dbz_threshold: 45 dBZ\n\tmin_fraction_all_parts: 0.10\n\tmin_fration_each_part: 0.005\n\tmin_area_each_part: 10 km2\n\n");
    tt->val_offset = (char *) &use_dual_threshold - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'dual_threshold'
    // ctype is '_dual_threshold_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("dual_threshold");
    tt->descr = tdrpStrDup("Parameters for dual threshold identification.");
    tt->help = tdrpStrDup("See 'use_dual_threshold'. dbz_threshold: threshold for this stage. A number of regions may be identified at the higher threshold. min_fraction_all_parts: we sum the sizes of the parts at the higher threshold, and the sum divided by the original size of the envelope must exceed this fraction. If it does not the original envelope is used. min_fraction_each_part: for any part to be valid its size as a fraction of all of the parts must exceed this value. min_area_each_part: for any part to be valid its area must exceed this value. If it does not the part is ignored. If only 1 part is valid, the entire envelope is used.");
    tt->val_offset = (char *) &dual_threshold - &_start_;
    tt->struct_def.name = tdrpStrDup("dual_threshold_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("dbz_threshold");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &dual_threshold.dbz_threshold - (char *) &dual_threshold;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_fraction_all_parts");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &dual_threshold.min_fraction_all_parts - (char *) &dual_threshold;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("min_fraction_each_part");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &dual_threshold.min_fraction_each_part - (char *) &dual_threshold;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("min_area_each_part");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &dual_threshold.min_area_each_part - (char *) &dual_threshold;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 45;
      tt->struct_vals[1].d = 0.5;
      tt->struct_vals[2].d = 0.05;
      tt->struct_vals[3].d = 20;
    tt++;
    
    // Parameter 'create_dual_threshold_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_dual_threshold_files");
    tt->descr = tdrpStrDup("Option to create dual threshold files for debugging.");
    tt->help = tdrpStrDup("If this is set, dual threshold files will be stored at dual_threshold_url.");
    tt->val_offset = (char *) &create_dual_threshold_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'dual_threshold_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("dual_threshold_url");
    tt->descr = tdrpStrDup("URL for dual_threshold data.");
    tt->help = tdrpStrDup("If create_dual_threshold_files is TRUE, the dual_threshold debugging MDV files are stored at this URL.");
    tt->val_offset = (char *) &dual_threshold_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdv/dual_threshold");
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("LIMITS TO BASE, TOP, STORM SIZE.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'base_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("base_threshold");
    tt->descr = tdrpStrDup("Storm base threshold (km).");
    tt->help = tdrpStrDup("Storms identification is only performed using CAPPIs at or above this threshold. Reflectivity values in CAPPIs below the base are ignored.");
    tt->val_offset = (char *) &base_threshold - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'top_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("top_threshold");
    tt->descr = tdrpStrDup("Storm top threshold (km).");
    tt->help = tdrpStrDup("Storms identification is only performed using CAPPIs at or below this threshold. Reflectivity values in CAPPIs above the top are ignored.");
    tt->val_offset = (char *) &top_threshold - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'min_storm_size'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_storm_size");
    tt->descr = tdrpStrDup("Minimum storm size (km2 or km3 depending on input grid type).");
    tt->help = tdrpStrDup("Storms must exceed this size to be considered valie.  If the data is 2D (i.e. nz == 1), the units are km2; if the data is 3D, units are km3.");
    tt->val_offset = (char *) &min_storm_size - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'max_storm_size'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_storm_size");
    tt->descr = tdrpStrDup("Maximum storm size (km2 or km3 depending on input grid type).");
    tt->help = tdrpStrDup("Storms must not exceed this size to be considered valid.  If the data is 2D (i.e. nz == 1), the units are km2; if the data is 3D, the units are km3.");
    tt->val_offset = (char *) &max_storm_size - &_start_;
    tt->single_val.d = 1e+09;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("OPTIONS TO CHECK SECOND TRIP.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'check_range_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_range_limits");
    tt->descr = tdrpStrDup("Option to check for storm range limits.");
    tt->help = tdrpStrDup("If the storm is at the limit of radar range, a flag is set.");
    tt->val_offset = (char *) &check_range_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'check_second_trip'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_second_trip");
    tt->descr = tdrpStrDup("Option to check for second trip characteristics.");
    tt->help = tdrpStrDup("If set, the storm orientation and shape are checked for second trip characteristics. An elongated, low storm with a major axis lined up with the radar indicates a likely second-trip echo. For a storm to be considered second-trip, all 3 of the following tests must be passwd: (a) the horizontal aspect ratio exceeds the given parameter; (b) the vertical aspect ratio exceeds the given parameter; (c) the horizontal orientation lies close to the line from the radra. If the storm is thought to be second-trip, the second-trip flag is set.");
    tt->val_offset = (char *) &check_second_trip - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'sectrip_vert_aspect'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sectrip_vert_aspect");
    tt->descr = tdrpStrDup("Second trip detection vertical aspect threshold.");
    tt->help = tdrpStrDup("If the vertical aspect ratio exceeds this value, the storm may be flagged as second-trip.");
    tt->val_offset = (char *) &sectrip_vert_aspect - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 1;
    tt->max_val.d = 20;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'sectrip_horiz_aspect'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sectrip_horiz_aspect");
    tt->descr = tdrpStrDup("Second trip detection horizontal aspect threshold.");
    tt->help = tdrpStrDup("If the horizontal aspect ratio (based on the ellipse) exceeds this value, the storm may be flagged as second-trip.");
    tt->val_offset = (char *) &sectrip_horiz_aspect - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 1;
    tt->max_val.d = 20;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'sectrip_orientation_error'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sectrip_orientation_error");
    tt->descr = tdrpStrDup("Allowable second trip orientation error.");
    tt->help = tdrpStrDup("For a storm to be flagged as second-trip, the orientation must be aligned with the storm azimuth from the radar, within this allowable error.");
    tt->val_offset = (char *) &sectrip_orientation_error - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 1;
    tt->max_val.d = 90;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("PRECIP RATE AND MASS PARAMETERS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'hail_dbz_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("hail_dbz_threshold");
    tt->descr = tdrpStrDup("Hail reflectivity threshold");
    tt->help = tdrpStrDup("The threshold between rain and hail (dBZ)");
    tt->val_offset = (char *) &hail_dbz_threshold - &_start_;
    tt->single_val.d = 55;
    tt++;
    
    // Parameter 'ZR'
    // ctype is '_zr_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ZR");
    tt->descr = tdrpStrDup("Z-R parameters for rainfall");
    tt->help = tdrpStrDup("Parameters in Z-R relationship for rainfall.");
    tt->val_offset = (char *) &ZR - &_start_;
    tt->struct_def.name = tdrpStrDup("zr_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("coeff");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ZR.coeff - (char *) &ZR;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("expon");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ZR.expon - (char *) &ZR;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 200;
      tt->struct_vals[1].d = 1.6;
    tt++;
    
    // Parameter 'ZM'
    // ctype is '_zr_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ZM");
    tt->descr = tdrpStrDup("Z-M parameters for rain");
    tt->help = tdrpStrDup("Parameters in Z-M relationship for rain.");
    tt->val_offset = (char *) &ZM - &_start_;
    tt->struct_def.name = tdrpStrDup("zr_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("coeff");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ZM.coeff - (char *) &ZM;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("expon");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ZM.expon - (char *) &ZM;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 20465;
      tt->struct_vals[1].d = 1.75;
    tt++;
    
    // Parameter 'precip_computation_mode'
    // ctype is '_precip_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("precip_computation_mode");
    tt->descr = tdrpStrDup("Mode for computing precipitation.");
    tt->help = tdrpStrDup("PRECIP_FROM_COLUMN_MAX: compute precip from the column-max reflectivity.\n\nPRECIP_AT_SPECIFIED_HT: specify the height of the plane from which precip is to be computed. See 'precip_plane_ht'.\n\nPRECIP_FROM_LOWEST_VALID_HT: compute precip from the lowest valid plane in the storm, i.e. the CAPPI corresponding to 'base_threshold'.\n\nPRECIP_FROM_LOWEST_AVAILABLE_REFL: compute precip from lowest available reflectivity in a column, i.e. from the lowest point at which non-missing reflectivity appears.");
    tt->val_offset = (char *) &precip_computation_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("precip_mode_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PRECIP_FROM_COLUMN_MAX");
      tt->enum_def.fields[0].val = PRECIP_FROM_COLUMN_MAX;
      tt->enum_def.fields[1].name = tdrpStrDup("PRECIP_AT_SPECIFIED_HT");
      tt->enum_def.fields[1].val = PRECIP_AT_SPECIFIED_HT;
      tt->enum_def.fields[2].name = tdrpStrDup("PRECIP_AT_LOWEST_VALID_HT");
      tt->enum_def.fields[2].val = PRECIP_AT_LOWEST_VALID_HT;
      tt->enum_def.fields[3].name = tdrpStrDup("PRECIP_FROM_LOWEST_AVAILABLE_REFL");
      tt->enum_def.fields[3].val = PRECIP_FROM_LOWEST_AVAILABLE_REFL;
    tt->single_val.e = PRECIP_FROM_COLUMN_MAX;
    tt++;
    
    // Parameter 'precip_min_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("precip_min_ht");
    tt->descr = tdrpStrDup("Minimum height for computing precip (km).");
    tt->help = tdrpStrDup("See 'precip_mode'. This is the minimum height, in km MSL, of any plane used for computing precip, for the following modes: PRECIP_FROM_COLUMN_MAX or PRECIP_FROM_LOWEST_AVAILABLE_REFL. Data from planes outside these limits will not be used.");
    tt->val_offset = (char *) &precip_min_ht - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'precip_max_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("precip_max_ht");
    tt->descr = tdrpStrDup("Maximum height for computing precip (km).");
    tt->help = tdrpStrDup("See 'precip_mode'. This is the maximum height, in km MSL, of any plane used for computing precip, for the following modes: PRECIP_FROM_COLUMN_MAX or PRECIP_FROM_LOWEST_AVAILABLE_REFL. Data from planes outside these limits will not be used.");
    tt->val_offset = (char *) &precip_max_ht - &_start_;
    tt->single_val.d = 6;
    tt++;
    
    // Parameter 'precip_plane_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("precip_plane_ht");
    tt->descr = tdrpStrDup("Height of precip plane (km).");
    tt->help = tdrpStrDup("See 'precip_mode'. This is the height, in km MSL, of the plane from which precip will be computed if precip_mode is PRECIP_AT_SPECIFIED_HT.");
    tt->val_offset = (char *) &precip_plane_ht - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("REFLECTIVITY DISTRIBUTION.");
    tt->comment_text = tdrpStrDup("NOTE: the 2D reflectivity histogram will be computed for a plane in the same manner as precipitation. See 'precip_mode' parameter for more details.");
    tt++;
    
    // Parameter 'dbz_hist_interval'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dbz_hist_interval");
    tt->descr = tdrpStrDup("Dbz histogram interval.");
    tt->help = tdrpStrDup("Reflectivity interval for the 2-D and 3-D reflectivity distributions.");
    tt->val_offset = (char *) &dbz_hist_interval - &_start_;
    tt->single_val.d = 3;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("OPTION FOR CALCULATING HAIL METRICS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'special_feature'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("special_feature");
    tt->descr = tdrpStrDup("Option for calculating additional special features.");
    tt->help = tdrpStrDup("Currently, 'hail' is the only special feature available. More features may be available to choose from in the future.");
    tt->val_offset = (char *) &special_feature - &_start_;
    tt->single_val.s = tdrpStrDup("hail");
    tt++;
    
    // Parameter 'hail_ZM'
    // ctype is '_zr_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("hail_ZM");
    tt->descr = tdrpStrDup("Z-M parameters for hail");
    tt->help = tdrpStrDup("Parameters in Z-M relationship for hail.");
    tt->val_offset = (char *) &hail_ZM - &_start_;
    tt->struct_def.name = tdrpStrDup("zr_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("coeff");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &hail_ZM.coeff - (char *) &hail_ZM;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("expon");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &hail_ZM.expon - (char *) &hail_ZM;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 3.6683e+06;
      tt->struct_vals[1].d = 1.416;
    tt++;
    
    // Parameter 'ht_of_freezing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ht_of_freezing");
    tt->descr = tdrpStrDup("Height of the 0C isotherm (km)");
    tt->help = tdrpStrDup("This value may be dynamically set in the future.");
    tt->val_offset = (char *) &ht_of_freezing - &_start_;
    tt->single_val.d = 6;
    tt++;
    
    // Parameter 'hail_mass_dbz_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("hail_mass_dbz_threshold");
    tt->descr = tdrpStrDup("Reflectivity threshold (dBZ) for hail mass");
    tt->help = tdrpStrDup("This value is used for calculating VIHM (vertically integrated hail mass) and Hail Mass Aloft");
    tt->val_offset = (char *) &hail_mass_dbz_threshold - &_start_;
    tt->single_val.d = 45;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("The Foote-Krauss Category (FOKR)");
    tt->comment_text = tdrpStrDup("The FOKR Category is intended to separate non-hailstorms (Category 0 and 1) from potentially developing hailers (Cat. 2), likely hailstorms (Cat. 3) and severe hailstorms (Cat. 4)");
    tt++;
    
    // Parameter 'FOKR_cat1_zmax_thresh'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("FOKR_cat1_zmax_thresh");
    tt->descr = tdrpStrDup("For S-band use 40, for C-band use use 40");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &FOKR_cat1_zmax_thresh - &_start_;
    tt->single_val.d = 40;
    tt++;
    
    // Parameter 'FOKR_cat2_zmax_thresh'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("FOKR_cat2_zmax_thresh");
    tt->descr = tdrpStrDup("For S-band use 45, for C-band use 45.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &FOKR_cat2_zmax_thresh - &_start_;
    tt->single_val.d = 45;
    tt++;
    
    // Parameter 'FOKR_cat3_zmax_thresh'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("FOKR_cat3_zmax_thresh");
    tt->descr = tdrpStrDup("For S-band use 55, for C-band use 45.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &FOKR_cat3_zmax_thresh - &_start_;
    tt->single_val.d = 55;
    tt++;
    
    // Parameter 'FOKR_cat4_zmax_thresh'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("FOKR_cat4_zmax_thresh");
    tt->descr = tdrpStrDup("For S-band use 65, for C-band use 55.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &FOKR_cat4_zmax_thresh - &_start_;
    tt->single_val.d = 65;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("OPTION TO CHECK STORM MORPHOLOGY.");
    tt->comment_text = tdrpStrDup("The storm morphology check allows you to erode minor connections between storms when these connections really have no phyical significance.");
    tt++;
    
    // Parameter 'check_morphology'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_morphology");
    tt->descr = tdrpStrDup("Option to check morphology");
    tt->help = tdrpStrDup("If this is set, morphology will be used for storm definition. A check is performed on storm morphology to reduce apparent mergers. The technique is as follows: 1. Compute euclidean distance (ed) of each point from edge of storm clump 2. Compute reflectivity excess above threshold, and divide by morphology_refl_divisor (in dbz/km). 3. Add ed to refl excess, to get interest map 4. Threshold interest map using morphology_erosion_threshold (in km). 5. Erode points which do not exceed the threshold, and which are not adjacent to a point which exceeds the threshold.");
    tt->val_offset = (char *) &check_morphology - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'create_morphology_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_morphology_files");
    tt->descr = tdrpStrDup("Option to create morphology files for debugging.");
    tt->help = tdrpStrDup("If this is set, morphology MDV files will be stored at morphology_url.");
    tt->val_offset = (char *) &create_morphology_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'morphology_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("morphology_url");
    tt->descr = tdrpStrDup("URL for morphology data.");
    tt->help = tdrpStrDup("If create_morphology_files is TRUE, the morphology MDV files are stored at this URL.");
    tt->val_offset = (char *) &morphology_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdv/morph");
    tt++;
    
    // Parameter 'morphology_erosion_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("morphology_erosion_threshold");
    tt->descr = tdrpStrDup("Erosion threshold for morphology check (km).");
    tt->help = tdrpStrDup("Threshold to which morphology erosion is performed.");
    tt->val_offset = (char *) &morphology_erosion_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 0;
    tt->max_val.d = 100;
    tt->single_val.d = 5;
    tt++;
    
    // Parameter 'morphology_refl_divisor'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("morphology_refl_divisor");
    tt->descr = tdrpStrDup("Reflectivity divisor for morphology check (dbz/km).");
    tt->help = tdrpStrDup("The morphology value for a point (km) is obtained by adding the euclidean distance to storm edge (km) to the reflectivity excess (above threshold) divided by this value (dbz/km).");
    tt->val_offset = (char *) &morphology_refl_divisor - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 0.1;
    tt->max_val.d = 100;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("OPTION TO CHECK STORM TOPS.");
    tt->comment_text = tdrpStrDup("The storm tops check allows you to remove areas with low tops prior to performing the storm identification. In this manner you can ignore regions of stratiform rain.");
    tt++;
    
    // Parameter 'check_tops'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_tops");
    tt->descr = tdrpStrDup("Option to check tops");
    tt->help = tdrpStrDup("If this is active, areas with radar tops below min_radar_tops will be removed from the data prior to storm identification. The tops_edge_margin parameter allows you to account for tilted storms, leaving a  margin around the area to be removed.");
    tt->val_offset = (char *) &check_tops - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'create_tops_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_tops_files");
    tt->descr = tdrpStrDup("Option to create tops files for debugging.");
    tt->help = tdrpStrDup("If this is set, tops MDV files will be stored at tops_url.");
    tt->val_offset = (char *) &create_tops_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tops_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("tops_url");
    tt->descr = tdrpStrDup("Radar tops data directory.");
    tt->help = tdrpStrDup("If create_tops_files is TRUE, the tops MDV files are stored at this URL.");
    tt->val_offset = (char *) &tops_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdv/tops");
    tt++;
    
    // Parameter 'min_radar_tops'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_radar_tops");
    tt->descr = tdrpStrDup("Minimum radar tops (km).");
    tt->help = tdrpStrDup("Minimum radar tops for valid radar data - see check_tops.");
    tt->val_offset = (char *) &min_radar_tops - &_start_;
    tt->single_val.d = 4.5;
    tt++;
    
    // Parameter 'tops_edge_margin'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tops_edge_margin");
    tt->descr = tdrpStrDup("Margin placed around tops when computing min_tops field (km).");
    tt->help = tdrpStrDup("This takes into account the fact that some storms may be tilted. Grid points within this margin are left intact.");
    tt->val_offset = (char *) &tops_edge_margin - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0;
    tt->single_val.d = 1.5;
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("DATA OUTPUT.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'storm_data_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("storm_data_dir");
    tt->descr = tdrpStrDup("Storms data directory. The storm files are written to this directory.");
    tt->help = tdrpStrDup("It is strongly recommended that you use an absolute path for this directory - i.e. start either with '/' or '.'. It is also common to start with an environment variable, e.g. $(DATA_DIR).");
    tt->val_offset = (char *) &storm_data_dir - &_start_;
    tt->single_val.s = tdrpStrDup("$(DATA_DIR)/titan/storms");
    tt++;
    
    // Parameter 'store_storm_runs'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("store_storm_runs");
    tt->descr = tdrpStrDup("Option to store runs in storm file");
    tt->help = tdrpStrDup("If set, the raw storm runs are stored in the storm file. A run is a contiguous block of reflectivity in the X direction for a given Y and Z. This is a useful way of storing storm grid locations reasonably efficiently. If the runs are stored, the exact 3D storm shape can be recreated from the storm file.");
    tt->val_offset = (char *) &store_storm_runs - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("OPTION TO CREATE VERIFICATION FILES.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'create_verification_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_verification_files");
    tt->descr = tdrpStrDup("Option to create verification files.");
    tt->help = tdrpStrDup("If this is set, verification files will be stored at verify_url. The verification files allow forecast verification against the regions which were actually used by the program to compute the storms. There are 2 fields: field 0 is the ALL_STORMS_FIELD - all storms above threshold are stored even if they do not meet other criteria such as minimum storm volume. Field 1 is the VALID_STORMS_FIELD, which only include the valid storms included in the storm file.");
    tt->val_offset = (char *) &create_verification_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'verify_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("verify_url");
    tt->descr = tdrpStrDup("URL for verify data.");
    tt->help = tdrpStrDup("If create_verification_files is TRUE, the verification MDV files are stored at this URL.");
    tt->val_offset = (char *) &verify_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdv/verify");
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("TRACKING PARAMETERS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'perform_tracking'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("perform_tracking");
    tt->descr = tdrpStrDup("Option to run tracking automatically.");
    tt->help = tdrpStrDup("If this is set, StormIdent will communicate with the storm tracking program, so that the tracking is performed after each scan.");
    tt->val_offset = (char *) &perform_tracking - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'tracking_max_speed'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_max_speed");
    tt->descr = tdrpStrDup("Maximum allowable speed for tracks");
    tt->help = tdrpStrDup("This value is used to limit the search for a match in the tracking algorithm.");
    tt->val_offset = (char *) &tracking_max_speed - &_start_;
    tt->single_val.d = 100;
    tt++;
    
    // Parameter 'tracking_max_delta_time'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("tracking_max_delta_time");
    tt->descr = tdrpStrDup("Max allowable time between scans (secs).");
    tt->help = tdrpStrDup("Max delta time (secs) for valid tracking - if there is a larger break than this in the data, all tracks are terminated and new ones started.");
    tt->val_offset = (char *) &tracking_max_delta_time - &_start_;
    tt->single_val.i = 1200;
    tt++;
    
    // Parameter 'tracking_weight_distance'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_weight_distance");
    tt->descr = tdrpStrDup("Matching parameter.");
    tt->help = tdrpStrDup("The weight for distance moved in the matching algorithm.");
    tt->val_offset = (char *) &tracking_weight_distance - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'tracking_weight_delta_cube_root_volume'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_weight_delta_cube_root_volume");
    tt->descr = tdrpStrDup("Matching parameter.");
    tt->help = tdrpStrDup("The weight for delta_cube_root_volume in the matching algorithm.");
    tt->val_offset = (char *) &tracking_weight_delta_cube_root_volume - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'tracking_use_runs_for_overlaps'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_use_runs_for_overlaps");
    tt->descr = tdrpStrDup("Option to use storm runs for overlaps");
    tt->help = tdrpStrDup("If this is set, runs are used to compute the overlaps for identifying mergers and splits. If not, the storm polygons are used.");
    tt->val_offset = (char *) &tracking_use_runs_for_overlaps - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'tracking_min_sum_fraction_overlap'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_min_sum_fraction_overlap");
    tt->descr = tdrpStrDup("Min sum overlap fraction.");
    tt->help = tdrpStrDup("To characterize the overap of storm shapes at successive scan times, two overlap fractions can be computed: (1) the overlap area divided by the area of the storm at time 1, and (2) the overlap area divided by the area of the storm at time 2. These two fractions are summed and tested against this parameter. If the sum is less than the parameter value, the overlap is not considered valid. For a perfect overlap the sum will be 2.0. For no overlap at all the sum will be 0.0.");
    tt->val_offset = (char *) &tracking_min_sum_fraction_overlap - &_start_;
    tt->has_max = TRUE;
    tt->max_val.d = 2;
    tt->single_val.d = 0.6;
    tt++;
    
    // Parameter 'Comment 20'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 20");
    tt->comment_hdr = tdrpStrDup("FORECAST PARAMETERS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'tracking_forecast_type'
    // ctype is '_forecast_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("tracking_forecast_type");
    tt->descr = tdrpStrDup("Forecast mode");
    tt->help = tdrpStrDup("TREND - linear trend. PARABOLIC - parabolic trend on growth, linear trend on decay. The parabola peaks at time parabolic_growth_period from present. REGRESSION - uses regression equations for forecast (experimental).");
    tt->val_offset = (char *) &tracking_forecast_type - &_start_;
    tt->enum_def.name = tdrpStrDup("forecast_type_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("TREND");
      tt->enum_def.fields[0].val = TREND;
      tt->enum_def.fields[1].name = tdrpStrDup("PARABOLIC");
      tt->enum_def.fields[1].val = PARABOLIC;
      tt->enum_def.fields[2].name = tdrpStrDup("REGRESSION");
      tt->enum_def.fields[2].val = REGRESSION;
    tt->single_val.e = TREND;
    tt++;
    
    // Parameter 'tracking_parabolic_growth_period'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("tracking_parabolic_growth_period");
    tt->descr = tdrpStrDup("Parabolic growth period (secs)");
    tt->help = tdrpStrDup("Time at which parabolic growth curve becomes flat");
    tt->val_offset = (char *) &tracking_parabolic_growth_period - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 60;
    tt->single_val.i = 1800;
    tt++;
    
    // Parameter 'tracking_zero_growth'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_zero_growth");
    tt->descr = tdrpStrDup("Option to force storm growth to be zero");
    tt->help = tdrpStrDup("If this is set, the storm growth will be forced to zero. Storm decay will be normal. Forecast movement will be normal.");
    tt->val_offset = (char *) &tracking_zero_growth - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tracking_zero_decay'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_zero_decay");
    tt->descr = tdrpStrDup("Option to force storm decay to be zero");
    tt->help = tdrpStrDup("If this is set, the storm decay will be forced to zero. Storm growth will be normal. Forecast movement will be normal.");
    tt->val_offset = (char *) &tracking_zero_decay - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tracking_forecast_weights'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_forecast_weights");
    tt->descr = tdrpStrDup("Weights for making the trend forecast.");
    tt->help = tdrpStrDup("A trend forecast is made using a weighted linear fit to the storm history. These are the weights used. The first applies to the most recent scan, and the last to the earliest scan used.");
    tt->array_offset = (char *) &_tracking_forecast_weights - &_start_;
    tt->array_n_offset = (char *) &tracking_forecast_weights_n - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 7;
    tt->min_val.d = 0;
    tt->max_val.d = 1;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = 1;
      tt->array_vals[1].d = 0.9;
      tt->array_vals[2].d = 0.8;
      tt->array_vals[3].d = 0.7;
      tt->array_vals[4].d = 0.6;
      tt->array_vals[5].d = 0.5;
      tt->array_vals[6].d = 0.4;
    tt++;
    
    // Parameter 'tracking_max_speed_for_valid_forecast'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_max_speed_for_valid_forecast");
    tt->descr = tdrpStrDup("Max allowable speed for valid forecast (km/hr).");
    tt->help = tdrpStrDup("If the speed exceeds this value, the forecast is marked invalid.");
    tt->val_offset = (char *) &tracking_max_speed_for_valid_forecast - &_start_;
    tt->single_val.d = 100;
    tt++;
    
    // Parameter 'tracking_min_history_for_valid_forecast'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("tracking_min_history_for_valid_forecast");
    tt->descr = tdrpStrDup("Min history for valid forecast (secs).");
    tt->help = tdrpStrDup("If the history is less than this value, the forecast is marked invalid.");
    tt->val_offset = (char *) &tracking_min_history_for_valid_forecast - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'tracking_scale_forecasts_by_history'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_scale_forecasts_by_history");
    tt->descr = tdrpStrDup("Option to scale forecasts by history");
    tt->help = tdrpStrDup("If this is set, forecasts are scaled by the ratio of history over min_history_for_scaling.");
    tt->val_offset = (char *) &tracking_scale_forecasts_by_history - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'tracking_history_for_scaling'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_history_for_scaling");
    tt->descr = tdrpStrDup("History value for scaling forecasts (secs).");
    tt->help = tdrpStrDup("If a storm has a history less than this value, the forecast values are scaled by the ratio of history over history_for_scaling. If the storm history exceeds this value, the scale factor is 1.0");
    tt->val_offset = (char *) &tracking_history_for_scaling - &_start_;
    tt->single_val.d = 1200;
    tt++;
    
    // Parameter 'tracking_limit_rel_speed_change'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_limit_rel_speed_change");
    tt->descr = tdrpStrDup("Option to limit relative changes in track speed.");
    tt->help = tdrpStrDup("If this is TRUE, a check is made for significant speed changes in the track. First, the movements of the centroid from scan to scan for the recent history are put into a list. The median of this list is computed. If any value in the list exceeds the median by a given factor, the value is replaced by the median. After this is done, the history is updated. See 'tracking_max_rel_speed_change.'");
    tt->val_offset = (char *) &tracking_limit_rel_speed_change - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tracking_rel_speed_max_change'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_rel_speed_max_change");
    tt->descr = tdrpStrDup("Maximum relative change in speed.");
    tt->help = tdrpStrDup("See 'tracking_limit_rel_speed_change'. This is the maximum allowable relative change in speed relative to the median speed for the history.");
    tt->val_offset = (char *) &tracking_rel_speed_max_change - &_start_;
    tt->single_val.d = 12;
    tt++;
    
    // Parameter 'tracking_rel_speed_min_nscans'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("tracking_rel_speed_min_nscans");
    tt->descr = tdrpStrDup("Min number of scans for relative speed check.");
    tt->help = tdrpStrDup("See 'tracking_limit_rel_speed_change'. The track must have this number of scans before the check can be applied. For the speed check to work this number must be less than on equal to the size of the tracking_forecast_weights array.");
    tt->val_offset = (char *) &tracking_rel_speed_min_nscans - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 3;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'Comment 21'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 21");
    tt->comment_hdr = tdrpStrDup("SMOOTHING THE MOTION FORECAST.");
    tt->comment_text = tdrpStrDup("Options for smoothing motion forecasts. The smoothed motion is computed using the motion of surrounding storms. The storms included are out to a given radius from the storm undergoing smoothing.");
    tt++;
    
    // Parameter 'Comment 22'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 22");
    tt->comment_hdr = tdrpStrDup("SMOOTHING CATEGORIES.");
    tt->comment_text = tdrpStrDup("For smoothing, you can turn on the following options separately or together: (a) tracking_smooth_invalid_forecasts: smooth motion for storms without a valid forecast; (b) tracking_spatial_smoothing: smooth motion for storms with a valid forecast; (c) tracking_smooth_fast_growth_decay: smooth the forecast for storms which have a rapid growth or decay. In addition to these main categories, you can set other parameters to control the way the smoothing is done.");
    tt++;
    
    // Parameter 'tracking_smooth_invalid_forecasts'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_smooth_invalid_forecasts");
    tt->descr = tdrpStrDup("Option to perform motion smoothing on invalid forecasts.");
    tt->help = tdrpStrDup("If this is TRUE, forecast motion is smoothed for storms WITHOUT a valid forecast. The smoothed motion DOES NOT INCLUDE the motion of the storm being smoothed. See also tracking_max_speed_for_valid_forecast and tracking_min_history_for_valid_forecast.");
    tt->val_offset = (char *) &tracking_smooth_invalid_forecasts - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'tracking_spatial_smoothing'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_spatial_smoothing");
    tt->descr = tdrpStrDup("Option to perform motion smoothing on valid forecasts.");
    tt->help = tdrpStrDup("If this is TRUE, spatial smoothing is performed on storms with a valid forecast. The smoothed motion INCLUDES the motion of the storm being smoothed. See also tracking_smooth_erratic_motion.");
    tt->val_offset = (char *) &tracking_spatial_smoothing - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 23'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 23");
    tt->comment_hdr = tdrpStrDup("SMOOTHING RADIUS OF INFLUENCE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'tracking_smoothing_radius'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_smoothing_radius");
    tt->descr = tdrpStrDup("Radius for motion smoothing (km).");
    tt->help = tdrpStrDup("This is the maximum radius within which the smoothing algorithm will search for candidates for smoothing data.");
    tt->val_offset = (char *) &tracking_smoothing_radius - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 1;
    tt->single_val.d = 120;
    tt++;
    
    // Parameter 'tracking_smoothing_min_nstorms'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("tracking_smoothing_min_nstorms");
    tt->descr = tdrpStrDup("Min number of other storms for smoothing.");
    tt->help = tdrpStrDup("This is the minumum number of storms to be used for smoothing. If this criteria is not met, smoothing will not be performed.");
    tt->val_offset = (char *) &tracking_smoothing_min_nstorms - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'Comment 24'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 24");
    tt->comment_hdr = tdrpStrDup("SMOOTHING WEIGHTS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'smoothing_weight_uses_inverse_distance'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("smoothing_weight_uses_inverse_distance");
    tt->descr = tdrpStrDup("Option to weight motion based on the inverse of the distacne apart.");
    tt->help = tdrpStrDup("If true, the motion of each storm is weighted by the inverse of the distance away from the storm to be smoothed.");
    tt->val_offset = (char *) &smoothing_weight_uses_inverse_distance - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'smoothing_weight_uses_mean_dbz'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("smoothing_weight_uses_mean_dbz");
    tt->descr = tdrpStrDup("Option to weight motion based on the mean DBZ value for each storm.");
    tt->help = tdrpStrDup("If true, the motion of each storm is weighted by (mean_dbz - low_dbz_threshold).");
    tt->val_offset = (char *) &smoothing_weight_uses_mean_dbz - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'smoothing_weight_uses_top'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("smoothing_weight_uses_top");
    tt->descr = tdrpStrDup("Option to weight motion based on the top for each storm.");
    tt->help = tdrpStrDup("If true, the motion of each storm is weighted by (top - base_threshold).");
    tt->val_offset = (char *) &smoothing_weight_uses_top - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 25'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 25");
    tt->comment_hdr = tdrpStrDup("SMOOTHING THRESHOLDS FOR FAST GROWTH AND DECAY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'tracking_smooth_fast_growth_decay'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_smooth_fast_growth_decay");
    tt->descr = tdrpStrDup("Option to perform spatial smoothing on storms which are growing or decaying fast.");
    tt->help = tdrpStrDup("If this is TRUE, spatial smoothing is performed on storms for which the area is growing or decaying fast. The smoothed motion does not include the motion of the storm being smoothed.");
    tt->val_offset = (char *) &tracking_smooth_fast_growth_decay - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tracking_smoothing_growth_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_smoothing_growth_threshold");
    tt->descr = tdrpStrDup("Area growth ratio threshold for smoothing motion.");
    tt->help = tdrpStrDup("See tracking_smooth_growth_decay. The area ratio is defined as (a2 - a1) / a1, where a2 is the current area and a1 is the previous area. Motion will only be smoothed if the ratio exceeds the specified value. The normal checks on smoothing will apply - search radius, min and max number of storms to be used for smoothing. If the smoothing fails the forecast will be marked as invalid.");
    tt->val_offset = (char *) &tracking_smoothing_growth_threshold - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'tracking_smoothing_decay_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("tracking_smoothing_decay_threshold");
    tt->descr = tdrpStrDup("Area decay ratio threshold for smoothing motion.");
    tt->help = tdrpStrDup("See tracking_smooth_growth_decay. The area ratio is defined as (a2 - a1) / a1, where a2 is the current area and a1 is the previous area. Motion will only be smoothed if the ratio is less than the specified value. The normal checks on smoothing will apply - search radius, min and max number of storms to be used for smoothing. If the smoothing fails the forecast will be marked as invalid.");
    tt->val_offset = (char *) &tracking_smoothing_decay_threshold - &_start_;
    tt->single_val.d = -0.5;
    tt++;
    
    // Parameter 'Comment 26'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 26");
    tt->comment_hdr = tdrpStrDup("SMOOTHING - DETECTING ERRATIC FORECASTS");
    tt->comment_text = tdrpStrDup("To determine whether a forecast is eratic, the error of the speed and direction is computed for a storm as compared with the mean motion for the storms within the radius of influence.");
    tt++;
    
    // Parameter 'tracking_smooth_erratic_only'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("tracking_smooth_erratic_only");
    tt->descr = tdrpStrDup("Option to only perform smoothing on storms which have an erratic forecast.");
    tt->help = tdrpStrDup("This is a qualifier to tracking_spatial_smoothing. If TRUE, smoothing is only performed on storms with an erratic motion forecast. The smoothed motion DOES NOT INCLUDE the motion of the storm being smoothed. A forecast is considered erratic if the speed or direction of the forecast differs significantly from the mean motion of surrounding storms. See also max_speed_error and max_dirn_error.");
    tt->val_offset = (char *) &tracking_smooth_erratic_only - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'erratic_forecast_speed_error'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("erratic_forecast_speed_error");
    tt->descr = tdrpStrDup("Speed error for erratic forecasts - percent.");
    tt->help = tdrpStrDup("The speed error is computed as:\n\t(100 * abs(speed - mean_speed)) / max(speed, mean_speed)\nIf the speed error exceeds this this value, the forecast is considered erratic.");
    tt->val_offset = (char *) &erratic_forecast_speed_error - &_start_;
    tt->single_val.d = 55;
    tt++;
    
    // Parameter 'erratic_forecast_direction_error'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("erratic_forecast_direction_error");
    tt->descr = tdrpStrDup("Direction error for erratic forecasts - degrees.");
    tt->help = tdrpStrDup("If the forecast direction speed for a storm differes from the mean direction by more than this value, the forecast is considered erratic.");
    tt->val_offset = (char *) &erratic_forecast_direction_error - &_start_;
    tt->single_val.d = 50;
    tt++;
    
    // Parameter 'Comment 27'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 27");
    tt->comment_hdr = tdrpStrDup("OVERRIDE EARLY STORM MOTION FROM FIELD TRACKER");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_early_storm_motion_using_field_tracker'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_early_storm_motion_using_field_tracker");
    tt->descr = tdrpStrDup("Option to override the early motion using results from a field tracker.");
    tt->help = tdrpStrDup("In the early stages of a storm, the motion is not well characterized by the track. This allows you to specify that in the early stages of a storm's lifetime, the motion should be determined from the results of a field tracker, such as OpticalFlow or ctrec.");
    tt->val_offset = (char *) &override_early_storm_motion_using_field_tracker - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'field_tracker_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_url");
    tt->descr = tdrpStrDup("URL for data from field tracker.");
    tt->help = tdrpStrDup("Format is 'mdvp:://hostname::dir'");
    tt->val_offset = (char *) &field_tracker_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp:://localhost::mdv/optical_flow");
    tt++;
    
    // Parameter 'field_tracker_U_motion_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_U_motion_name");
    tt->descr = tdrpStrDup("Name of U motion field in field tracker.");
    tt->help = tdrpStrDup("U is positive for flow from west to east.");
    tt->val_offset = (char *) &field_tracker_U_motion_name - &_start_;
    tt->single_val.s = tdrpStrDup("U");
    tt++;
    
    // Parameter 'field_tracker_V_motion_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_V_motion_name");
    tt->descr = tdrpStrDup("Name of V motion field in field tracker.");
    tt->help = tdrpStrDup("V is positive for flow from south to north.");
    tt->val_offset = (char *) &field_tracker_V_motion_name - &_start_;
    tt->single_val.s = tdrpStrDup("V");
    tt++;
    
    // Parameter 'field_tracker_search_margin_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_search_margin_secs");
    tt->descr = tdrpStrDup("Time margin for searching for field tracker data (secs).");
    tt->help = tdrpStrDup("We search for field tracker results that are close in time to the DBZ data we are using for Titan. The field tracker results are only used if they are within this number of seconds of the time of the primary DBZ data. If the data is not available within the time margin, the motion will not be adjusted from the field tracker results.");
    tt->val_offset = (char *) &field_tracker_search_margin_secs - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'field_tracker_realtime_wait_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_realtime_wait_secs");
    tt->descr = tdrpStrDup("Time to wait for field tracker results - (secs).");
    tt->help = tdrpStrDup("In realtime mode, the field tracker will take time to run. We therefore may need to wait for up to this number of seconds for the field tracker to complete. If the data is not available by the wait time period, the motion will not be adjusted from the field tracker.");
    tt->val_offset = (char *) &field_tracker_realtime_wait_secs - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'field_tracker_search_radius_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_search_radius_km");
    tt->descr = tdrpStrDup("Radius of influence of field tracker results (km).");
    tt->help = tdrpStrDup("In determining the storm motion from the field tracker, we search for results that are close to the storm centroid. This is the radius, from the storm centroid, that we use for computing the mean field velocity to be applied to the storm.");
    tt->val_offset = (char *) &field_tracker_search_radius_km - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'field_tracker_initial_period_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_initial_period_secs");
    tt->descr = tdrpStrDup("Time period, from the start of a storm's life, during which only the field tracker motion is used (secs).");
    tt->help = tdrpStrDup("During this period, the Titan storm motion is replaced by the field tracker motion.");
    tt->val_offset = (char *) &field_tracker_initial_period_secs - &_start_;
    tt->single_val.i = 900;
    tt++;
    
    // Parameter 'field_tracker_transition_period_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("field_tracker_transition_period_secs");
    tt->descr = tdrpStrDup("Time period, from the end of the initial period, during which a combination of the Titan motion and field tracker motion is used (secs).");
    tt->help = tdrpStrDup("During this period, the Titan storm motion is replaced by a linear combination of the Titan motion and the field tracker motion.");
    tt->val_offset = (char *) &field_tracker_transition_period_secs - &_start_;
    tt->single_val.i = 900;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
