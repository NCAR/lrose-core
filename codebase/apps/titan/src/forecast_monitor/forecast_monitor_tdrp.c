/*******************************************
 * forecast_monitor_tdrp.c
 *
 * TDRP C code file 'forecast_monitor' module.
 *
 * Code for program forecast_monitor
 *
 * This file has been automatically
 * generated by TDRP, do not modify.
 *
 *******************************************/

#include "forecast_monitor_tdrp.h"
#include <string.h>

/*
 * file scope variables
 */

static TDRPtable Table[19];
static forecast_monitor_tdrp_struct *Params;
static char *Module = "forecast_monitor";

/*************************************************************
 * forecast_monitor_tdrp_load_from_args()
 *
 * Loads up TDRP using the command line args.
 *
 * Check TDRP_usage() for command line actions associated with
 * this function.
 *
 *   argc, argv: command line args
 *
 *   forecast_monitor_tdrp_struct *params: loads up this struct
 * 
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *   char **params_path_p: if non-NULL, this is set to point to
 *                         the path of the params file used.
 *
 *  Returns 0 on success, -1 on failure.
 */

int forecast_monitor_tdrp_load_from_args(int argc, char **argv,
                         forecast_monitor_tdrp_struct *params,
                         char **override_list,
                         char **params_path_p)
{
  Params = params;
  forecast_monitor_tdrp_init(Params);
  if (tdrpLoadFromArgs(argc, argv,
                       Table, Params,
                       override_list, params_path_p)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * forecast_monitor_tdrp_load()
 *
 * Loads up TDRP for a given module.
 *
 * This version of load gives the programmer the option to load
 * up more than one module for a single application. It is a
 * lower-level routine than forecast_monitor_tdrp_load_from_args,
 * and hence more flexible, but the programmer must do more work.
 *
 *   char *param_file_path: the parameter file to be read in.
 *
 *   forecast_monitor_tdrp_struct *params: loads up this struct
 *
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *  expand_env: flag to control environment variable
 *                expansion during tokenization.
 *              If TRUE, environment expansion is set on.
 *              If FALSE, environment expansion is set off.
 *
 *  Returns 0 on success, -1 on failure.
 */

int forecast_monitor_tdrp_load(char *param_file_path,
               forecast_monitor_tdrp_struct *params,
               char **override_list,
               int expand_env, int debug)
{
  Params = params;
  forecast_monitor_tdrp_init(Params);
  if (tdrpLoad(param_file_path, Table,
               params, override_list,
               expand_env, debug)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * forecast_monitor_tdrp_load_defaults()
 *
 * Loads up defaults for a given module.
 *
 * See forecast_monitor_tdrp_load() for more details.
 *
 *  Returns 0 on success, -1 on failure.
 */

int forecast_monitor_tdrp_load_defaults(forecast_monitor_tdrp_struct *params,
                        int expand_env)
{
  Params = params;
  forecast_monitor_tdrp_init(Params);
  if (tdrpLoad(NULL, Table,
               params, NULL,
               expand_env, FALSE)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * forecast_monitor_tdrp_sync()
 *
 * Syncs the user struct data back into the parameter table,
 * in preparation for printing.
 */

void forecast_monitor_tdrp_sync(void)
{
  tdrpUser2Table(Table, Params);
}

/*************************************************************
 * forecast_monitor_tdrp_print()
 * 
 * Print params file
 *
 * The modes supported are:
 *
 *   PRINT_SHORT:   main comments only, no help or descriptions
 *                  structs and arrays on a single line
 *   PRINT_NORM:    short + descriptions and help
 *   PRINT_LONG:    norm  + arrays and structs expanded
 *   PRINT_VERBOSE: long  + private params included
 */

void forecast_monitor_tdrp_print(FILE *out, tdrp_print_mode_t mode)
{
  tdrpPrint(out, Table, Module, mode);
}

/*************************************************************
 * forecast_monitor_tdrp_check_all_set()
 *
 * Return TRUE if all set, FALSE if not.
 *
 * If out is non-NULL, prints out warning messages for those
 * parameters which are not set.
 */

int forecast_monitor_tdrp_check_all_set(FILE *out)
{
  return (tdrpCheckAllSet(out, Table, Params));
}

/*************************************************************
 * forecast_monitor_tdrp_check_is_set()
 *
 * Return TRUE if parameter is set, FALSE if not.
 *
 */

int forecast_monitor_tdrp_check_is_set(char *param_name)
{
  return (tdrpCheckIsSet(param_name, Table, Params));
}

/*************************************************************
 * forecast_monitor_tdrp_free_all()
 *
 * Frees up all TDRP dynamic memory.
 */

void forecast_monitor_tdrp_free_all(void)
{
  tdrpFreeAll(Table, Params);
}

/*************************************************************
 * forecast_monitor_tdrp_array_realloc()
 *
 * Realloc 1D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int forecast_monitor_tdrp_array_realloc(char *param_name, int new_array_n)
{
  if (tdrpArrayRealloc(Table, Params, param_name, new_array_n)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * forecast_monitor_tdrp_array2D_realloc()
 *
 * Realloc 2D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int forecast_monitor_tdrp_array2D_realloc(char *param_name,
                          int new_array_n1,
                          int new_array_n2)
{
  if (tdrpArray2DRealloc(Table, Params, param_name,
			 new_array_n1, new_array_n2)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * forecast_monitor_tdrp_table()
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *forecast_monitor_tdrp_table(void)
{
  return (Table);
}

/*************************************************************
 * forecast_monitor_tdrp_init()
 *
 * Module table initialization function.
 *
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *forecast_monitor_tdrp_init(forecast_monitor_tdrp_struct *params)

{

  TDRPtable *tt = Table;

  forecast_monitor_tdrp_struct pp; /* for computing byte_offsets */

  /* zero out struct, and store size */

  memset(params, 0, sizeof(forecast_monitor_tdrp_struct));
  params->struct_size = sizeof(forecast_monitor_tdrp_struct);

  /* Parameter 'debug' */
  /* ctype is 'forecast_monitor_debug' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("debug");
  tt->descr = tdrpStrDup("Debug option");
  tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
  tt->val_offset = (char *) &(pp.debug) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("debug");
  tt->enum_def.nfields = 4;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
    tt->enum_def.fields[0].val = DEBUG_OFF;
    tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_WARNINGS");
    tt->enum_def.fields[1].val = DEBUG_WARNINGS;
    tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_NORM");
    tt->enum_def.fields[2].val = DEBUG_NORM;
    tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
    tt->enum_def.fields[3].val = DEBUG_EXTRA;
  tt->single_val.e = DEBUG_OFF;
  tt++;
  
  /* Parameter 'malloc_debug_level' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("malloc_debug_level");
  tt->descr = tdrpStrDup("Malloc debug level");
  tt->help = tdrpStrDup("0 - none, 1 - corruption checking, 2 - records all malloc blocks and checks, 3 - printout of all mallocs etc.");
  tt->val_offset = (char *) &(pp.malloc_debug_level) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.l = 0;
  tt->max_val.l = 3;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'instance' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("instance");
  tt->descr = tdrpStrDup("Process instance");
  tt->help = tdrpStrDup("Used for registration with procmap.");
  tt->val_offset = (char *) &(pp.instance) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Test");
  tt++;
  
  /* Parameter 'mode' */
  /* ctype is 'forecast_monitor_mode' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("mode");
  tt->descr = tdrpStrDup("Operation mode");
  tt->help = tdrpStrDup("Program may be run in two modes, archive and realtime. In realtime mode, the analysis is performed for each volume scan as it becomes available. In archiv mode, all of the scans in a track file are processed");
  tt->val_offset = (char *) &(pp.mode) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("mode");
  tt->enum_def.nfields = 2;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
    tt->enum_def.fields[0].val = ARCHIVE;
    tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
    tt->enum_def.fields[1].val = REALTIME;
  tt->single_val.e = ARCHIVE;
  tt++;
  
  /* Parameter 'print_stats' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("print_stats");
  tt->descr = tdrpStrDup("Printout option");
  tt->help = tdrpStrDup("Option to print stats on tracks");
  tt->val_offset = (char *) &(pp.print_stats) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'max_realtime_valid_age' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("max_realtime_valid_age");
  tt->descr = tdrpStrDup("Max valid age of input files in realtime mode (secs)");
  tt->help = tdrpStrDup("This the max valid age for an incoming file. The program will wait for a data file more recent than this.");
  tt->val_offset = (char *) &(pp.max_realtime_valid_age) - (char *) &pp;
  tt->has_min = TRUE;
  tt->min_val.d = 1;
  tt->single_val.d = 360;
  tt++;
  
  /* Parameter 'rdata_dir' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("rdata_dir");
  tt->descr = tdrpStrDup("Radar data directory");
  tt->help = tdrpStrDup("Upper level directory for dobson cartesian radar data files");
  tt->val_offset = (char *) &(pp.rdata_dir) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("none");
  tt++;
  
  /* Parameter 'storms_dir' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("storms_dir");
  tt->descr = tdrpStrDup("Storms data directory");
  tt->help = tdrpStrDup("Directory for storm and track data files");
  tt->val_offset = (char *) &(pp.storms_dir) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("none");
  tt++;
  
  /* Parameter 'output_dir' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("output_dir");
  tt->descr = tdrpStrDup("Output directory");
  tt->help = tdrpStrDup("Directory for output data file, must have 'tmp' subdirectory");
  tt->val_offset = (char *) &(pp.output_dir) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("none");
  tt++;
  
  /* Parameter 'output_file_ext' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("output_file_ext");
  tt->descr = tdrpStrDup("Output file extension");
  tt->help = tdrpStrDup("File name extension for forecast monitor output files");
  tt->val_offset = (char *) &(pp.output_file_ext) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("fmon");
  tt++;
  
  /* Parameter 'dobson_file_ext' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("dobson_file_ext");
  tt->descr = tdrpStrDup("Dobson file extension");
  tt->help = tdrpStrDup("File name extension for dobson cartesian radar data files");
  tt->val_offset = (char *) &(pp.dobson_file_ext) - (char *) &pp;
  tt->is_private = TRUE;
  tt->single_val.s = tdrpStrDup("dob");
  tt++;
  
  /* Parameter 'dbz_field' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("dbz_field");
  tt->descr = tdrpStrDup("Reflectivity field position");
  tt->help = tdrpStrDup("Position of reflectivity (dBZ) data in the radar volumes");
  tt->val_offset = (char *) &(pp.dbz_field) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'forecast_lead_time' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("forecast_lead_time");
  tt->descr = tdrpStrDup("Forecast lead time (secs)");
  tt->help = tdrpStrDup("Lead time for which forecast stats are to be computed (secs)");
  tt->val_offset = (char *) &(pp.forecast_lead_time) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.d = 0;
  tt->max_val.d = 10800;
  tt->single_val.d = 1800;
  tt++;
  
  /* Parameter 'time_search_margin' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("time_search_margin");
  tt->descr = tdrpStrDup("Time search margin (secs)");
  tt->help = tdrpStrDup("Time margin to allow for when searching for scan times (secs)");
  tt->val_offset = (char *) &(pp.time_search_margin) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.d = 0;
  tt->max_val.d = 10800;
  tt->single_val.d = 1800;
  tt++;
  
  /* Parameter 'parabolic_growth' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("parabolic_growth");
  tt->descr = tdrpStrDup("Parabolic growth for storm trend");
  tt->help = tdrpStrDup("Apply parabolic growth to storm trend, such that the growth curve is flat after parabolic_growth_period secs");
  tt->val_offset = (char *) &(pp.parabolic_growth) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'parabolic_growth_period' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("parabolic_growth_period");
  tt->descr = tdrpStrDup("Parabolic growth period (secs)");
  tt->help = tdrpStrDup("Time at which parabolic growth curve becomes flat");
  tt->val_offset = (char *) &(pp.parabolic_growth_period) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.d = 0;
  tt->max_val.d = 10800;
  tt->single_val.d = 1800;
  tt++;
  
  /* Parameter 'forecast_min_history' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("forecast_min_history");
  tt->descr = tdrpStrDup("Min history for valid forecast(secs)");
  tt->help = tdrpStrDup("Min history for a forecast to be valid - if the storm has less history than this then the forecast is not evaluated");
  tt->val_offset = (char *) &(pp.forecast_min_history) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.d = 0;
  tt->max_val.d = 10800;
  tt->single_val.d = 900;
  tt++;
  
  /* Parameter 'verify_grid' */
  /* ctype is 'forecast_monitor_verify_grid_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRUCT_TYPE;
  tt->param_name = tdrpStrDup("verify_grid");
  tt->descr = tdrpStrDup("Grid for verification");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.verify_grid) - (char *) &pp;
  tt->struct_def.name = tdrpStrDup("verify_grid_t");
  tt->struct_def.nfields = 6;
  tt->struct_def.fields = (struct_field_t *)
      tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
    tt->struct_def.fields[0].ftype = tdrpStrDup("double");
    tt->struct_def.fields[0].fname = tdrpStrDup("min_x");
    tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[0].rel_offset = 
      (char *) &(pp.verify_grid.min_x) - (char *) &(pp.verify_grid);
    tt->struct_def.fields[1].ftype = tdrpStrDup("double");
    tt->struct_def.fields[1].fname = tdrpStrDup("min_y");
    tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[1].rel_offset = 
      (char *) &(pp.verify_grid.min_y) - (char *) &(pp.verify_grid);
    tt->struct_def.fields[2].ftype = tdrpStrDup("double");
    tt->struct_def.fields[2].fname = tdrpStrDup("dx");
    tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[2].rel_offset = 
      (char *) &(pp.verify_grid.dx) - (char *) &(pp.verify_grid);
    tt->struct_def.fields[3].ftype = tdrpStrDup("double");
    tt->struct_def.fields[3].fname = tdrpStrDup("dy");
    tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[3].rel_offset = 
      (char *) &(pp.verify_grid.dy) - (char *) &(pp.verify_grid);
    tt->struct_def.fields[4].ftype = tdrpStrDup("long");
    tt->struct_def.fields[4].fname = tdrpStrDup("nx");
    tt->struct_def.fields[4].ptype = LONG_TYPE;
    tt->struct_def.fields[4].rel_offset = 
      (char *) &(pp.verify_grid.nx) - (char *) &(pp.verify_grid);
    tt->struct_def.fields[5].ftype = tdrpStrDup("long");
    tt->struct_def.fields[5].fname = tdrpStrDup("ny");
    tt->struct_def.fields[5].ptype = LONG_TYPE;
    tt->struct_def.fields[5].rel_offset = 
      (char *) &(pp.verify_grid.ny) - (char *) &(pp.verify_grid);
  tt->n_struct_vals = 6;
  tt->struct_vals = (tdrpVal_t *)
      tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt->struct_vals[0].d = 0;
    tt->struct_vals[1].d = 0;
    tt->struct_vals[2].d = 0;
    tt->struct_vals[3].d = 0;
    tt->struct_vals[4].l = 0;
    tt->struct_vals[5].l = 0;
  tt++;
  
  /* trailing entry has param_name set to NULL */
  
  tt->param_name = NULL;
  
  return (Table);

}
