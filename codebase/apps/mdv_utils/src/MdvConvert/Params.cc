// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 1992 - 2017
// ** University Corporation for Atmospheric Research(UCAR)
// ** National Center for Atmospheric Research(NCAR)
// ** Boulder, Colorado, USA
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program MdvConvert
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Program name: MdvConvert");
    tt->comment_text = tdrpStrDup("MdvConvert reads mdv data, converts it in various ways, and writes it out. The usage is 'MdvConvert -params params_file'.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'reg_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("reg_interval");
    tt->descr = tdrpStrDup("Registration interval.");
    tt->help = tdrpStrDup("The number of seconds between expected procmap registrations.");
    tt->val_offset = (char *) &reg_interval - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("In REALTIME mode, the program waits for a new input file.  LOCAL_FILEPATH_REALTIME is a realtime mode used when data resides on the host where the application is running. This was added due to the problems that the data server layer had distinguishing data times of data written very close together. NOTE that in this mode the input_url parameter should be set to an input directory, not an input url. In ARCHIVE mode, it moves through the data between the start and end times set on the command line. In SPEC_FCAST_REALTIME mode, the program waits for a new input file that is a forecast file with the specified forecast lead time. The forecast lead time is specified in the fcast_lead_time parameter. In FILELIST mode, it moves through the list of file names specified on the command line. Paths (in FILELIST mode, at least) MUST contain a day-directory below the data file -- ./data_file.mdv will not work as a file path. In ARCHIVE_FCST mode, it moves through the data between the start and end times set on the comand line, and processes all lead times found in the forecast files. In SPEC_FCST_ARCHIVE mode, it moves through the data between the start and end times set on the comand line, and processes forecast files with the specified forecast lead time.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 8;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
      tt->enum_def.fields[2].name = tdrpStrDup("FILELIST");
      tt->enum_def.fields[2].val = FILELIST;
      tt->enum_def.fields[3].name = tdrpStrDup("SPEC_FCAST_REALTIME");
      tt->enum_def.fields[3].val = SPEC_FCAST_REALTIME;
      tt->enum_def.fields[4].name = tdrpStrDup("REALTIME_FCST_DATA");
      tt->enum_def.fields[4].val = REALTIME_FCST_DATA;
      tt->enum_def.fields[5].name = tdrpStrDup("LOCAL_FILEPATH_REALTIME");
      tt->enum_def.fields[5].val = LOCAL_FILEPATH_REALTIME;
      tt->enum_def.fields[6].name = tdrpStrDup("ARCHIVE_FCST");
      tt->enum_def.fields[6].val = ARCHIVE_FCST;
      tt->enum_def.fields[7].name = tdrpStrDup("SPEC_FCST_ARCHIVE");
      tt->enum_def.fields[7].val = SPEC_FCST_ARCHIVE;
    tt->single_val.e = ARCHIVE;
    tt++;
    
    // Parameter 'local'
    // ctype is '_local_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("local");
    tt->descr = tdrpStrDup("Setup for LOCAL_FILEPATH_REALTIME mode ONLY. Max age of input, seconds, if we use latest data info to trigger, and if we should only process the latest file.");
    tt->help = tdrpStrDup("Defaults should generally be fine.");
    tt->val_offset = (char *) &local - &_start_;
    tt->struct_def.name = tdrpStrDup("local_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("lookback");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &local.lookback - (char *) &local;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("use_ldata_info");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &local.use_ldata_info - (char *) &local;
      tt->struct_def.fields[2].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[2].fname = tdrpStrDup("latest_file_only");
      tt->struct_def.fields[2].ptype = BOOL_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &local.latest_file_only - (char *) &local;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 1200;
      tt->struct_vals[1].b = pTRUE;
      tt->struct_vals[2].b = pFALSE;
    tt++;
    
    // Parameter 'input_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_url");
    tt->descr = tdrpStrDup("URL for input data.");
    tt->help = tdrpStrDup("This is used in REALTIME and ARCHIVE modes only. In FILELIST mode, the file paths are specified on the command line. In  LOCAL_FILEPATH_REALTIME mode, set this to a directory, not a URL.");
    tt->val_offset = (char *) &input_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdv/input");
    tt++;
    
    // Parameter 'writeLdataInfo'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("writeLdataInfo");
    tt->descr = tdrpStrDup("Write _latest_data_info files for output files.");
    tt->help = tdrpStrDup("If false, will suppress writing of _latest_data_info files.");
    tt->val_offset = (char *) &writeLdataInfo - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'fcast_lead_time'
    // ctype is '_fcast_lead_time_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fcast_lead_time");
    tt->descr = tdrpStrDup("Forecast lead time information for forecast files to be processed.");
    tt->help = tdrpStrDup("Used only if mode is set to SPEC_FCAST_REALTIME or SPEC_FCST_ARCHIVE.");
    tt->val_offset = (char *) &fcast_lead_time - &_start_;
    tt->struct_def.name = tdrpStrDup("fcast_lead_time_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("lead_time_secs");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &fcast_lead_time.lead_time_secs - (char *) &fcast_lead_time;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("use_gen_time");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &fcast_lead_time.use_gen_time - (char *) &fcast_lead_time;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].b = pFALSE;
    tt++;
    
    // Parameter 'do_lead_time_subsampling'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("do_lead_time_subsampling");
    tt->descr = tdrpStrDup("Lead time subsampling flag");
    tt->help = tdrpStrDup("Set to true to enable lead time subsampling.  Used only if mode is REALTIME_FCST_DATA or ARCHIVE_FCST");
    tt->val_offset = (char *) &do_lead_time_subsampling - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'subsample_lead_time_hour'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("subsample_lead_time_hour");
    tt->descr = tdrpStrDup("The subsampled lead times to process");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_subsample_lead_time_hour - &_start_;
    tt->array_n_offset = (char *) &subsample_lead_time_hour_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 0;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'set_field_nums'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_field_nums");
    tt->descr = tdrpStrDup("Option to set field numbers");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_field_nums - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'field_nums'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("field_nums");
    tt->descr = tdrpStrDup("Field number list.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_field_nums - &_start_;
    tt->array_n_offset = (char *) &field_nums_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(int);
    tt->array_n = 1;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].i = 0;
    tt++;
    
    // Parameter 'set_field_names'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_field_names");
    tt->descr = tdrpStrDup("Option to set field names");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_field_names - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'field_names'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("field_names");
    tt->descr = tdrpStrDup("Field name list.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_field_names - &_start_;
    tt->array_n_offset = (char *) &field_names_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 1;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("0");
    tt++;
    
    // Parameter 'rename_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("rename_fields");
    tt->descr = tdrpStrDup("Option to set field names");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &rename_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'new_names'
    // ctype is '_field_names_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("new_names");
    tt->descr = tdrpStrDup("Provides a map from old field name to new field name. Note that either the filed name or the long field name must match the old_field_name specified for the renaming to take effect, and that if the renaming happens then both the field name and the long field name are renamed to the new_field_name.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_new_names - &_start_;
    tt->array_n_offset = (char *) &new_names_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(field_names_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("field_names_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("old_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_new_names->old_field_name - (char *) _new_names;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("new_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_new_names->new_field_name - (char *) _new_names;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("");
      tt->struct_vals[1].s = tdrpStrDup("");
    tt++;
    
    // Parameter 'apply_thresholds_to_field_values'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_thresholds_to_field_values");
    tt->descr = tdrpStrDup("Option to threshold field values. Points with values outside the specified limits will be set to missing.");
    tt->help = tdrpStrDup("NOTE: this works on the output field names. If rename_fields is false, then the input and output field names are the same. If rename fields is true, the field name change is performed first, before the field values are thresholded.");
    tt->val_offset = (char *) &apply_thresholds_to_field_values - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'thresholded_fields'
    // ctype is '_thresholded_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("thresholded_fields");
    tt->descr = tdrpStrDup("Limit the values in specified fields to between min_threshold and max_threshold. Values outside this range will be set to missing.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_thresholded_fields - &_start_;
    tt->array_n_offset = (char *) &thresholded_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(thresholded_field_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("thresholded_field_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("output_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_thresholded_fields->output_field_name - (char *) _thresholded_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("threshold_min");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_thresholded_fields->threshold_min - (char *) _thresholded_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("threshold_max");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_thresholded_fields->threshold_max - (char *) _thresholded_fields;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 100;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("DATA OUTPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_url");
    tt->descr = tdrpStrDup("Output URL.");
    tt->help = tdrpStrDup("Output data is written to this URL.");
    tt->val_offset = (char *) &output_url - &_start_;
    tt->single_val.s = tdrpStrDup("./output");
    tt++;
    
    // Parameter 'output_as_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_as_forecast");
    tt->descr = tdrpStrDup("Set to output the data as forecast in mdv format.");
    tt->help = tdrpStrDup("This forces a forecast-style output, whether the data is of forecast type or not.");
    tt->val_offset = (char *) &output_as_forecast - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'if_forecast_output_as_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("if_forecast_output_as_forecast");
    tt->descr = tdrpStrDup("Set to output the data as forecast, if the data is of a forecast type.");
    tt->help = tdrpStrDup("This only writes out in forecast-style output if the data_collection_type in the master header is of type FORECAST or EXTRAPOLATED.");
    tt->val_offset = (char *) &if_forecast_output_as_forecast - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_format'
    // ctype is '_output_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_format");
    tt->descr = tdrpStrDup("Specify format of file on output.");
    tt->help = tdrpStrDup("FORMAT_MDV: normal MDV formal.\n\nFORMAT_XML: XML format. XML format writes out 2 files: *.mdv.xml and *.mdv.buf. The xml file contains the meta-data. The buf file contains the binary fields.\n\nNOTE: only COMPRESSION_NONE and COMPRESSION_GZIP_VOL are supported in XML.\n\nFORMAT_NCF: write file in netCDF CF format. Extension will be .nc.\n\nFORMAT_CEDRIC: Write out in Cedric format.");
    tt->val_offset = (char *) &output_format - &_start_;
    tt->enum_def.name = tdrpStrDup("output_format_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("OUTPUT_FORMAT_MDV");
      tt->enum_def.fields[0].val = OUTPUT_FORMAT_MDV;
      tt->enum_def.fields[1].name = tdrpStrDup("OUTPUT_FORMAT_XML");
      tt->enum_def.fields[1].val = OUTPUT_FORMAT_XML;
      tt->enum_def.fields[2].name = tdrpStrDup("OUTPUT_FORMAT_NCF");
      tt->enum_def.fields[2].val = OUTPUT_FORMAT_NCF;
      tt->enum_def.fields[3].name = tdrpStrDup("OUTPUT_FORMAT_CEDRIC");
      tt->enum_def.fields[3].val = OUTPUT_FORMAT_CEDRIC;
    tt->single_val.e = OUTPUT_FORMAT_MDV;
    tt++;
    
    // Parameter 'write_to_path'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_to_path");
    tt->descr = tdrpStrDup("Write the file to a specified path.");
    tt->help = tdrpStrDup("This overrides output_url.");
    tt->val_offset = (char *) &write_to_path - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_path'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_path");
    tt->descr = tdrpStrDup("Output path.");
    tt->help = tdrpStrDup("See 'write_to_path'.");
    tt->val_offset = (char *) &output_path - &_start_;
    tt->single_val.s = tdrpStrDup("./output/test.mdv");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE ORIGIN LOCATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_origin_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_origin_location");
    tt->descr = tdrpStrDup("Option to override the origin location.");
    tt->help = tdrpStrDup("If true, the origin location in the file will be overridden with the specified values. If this option is used, remap_at_source must be set to false.");
    tt->val_offset = (char *) &override_origin_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'origin_latitude_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("origin_latitude_deg");
    tt->descr = tdrpStrDup("Origin latitude (deg).");
    tt->help = tdrpStrDup("See override_origin_location.");
    tt->val_offset = (char *) &origin_latitude_deg - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'origin_longitude_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("origin_longitude_deg");
    tt->descr = tdrpStrDup("Origin longitude (deg).");
    tt->help = tdrpStrDup("See override_origin_location.");
    tt->val_offset = (char *) &origin_longitude_deg - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'override_vlevels'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_vlevels");
    tt->descr = tdrpStrDup("Option to override the vlevels in the vlevel header.");
    tt->help = tdrpStrDup("If true, will replace the vlevels in the header with those specified in 'vlevel_array'. This does not affect the actual data in the file.");
    tt->val_offset = (char *) &override_vlevels - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vlevel_array'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("vlevel_array");
    tt->descr = tdrpStrDup("vlevel values to override what is already in the file.");
    tt->help = tdrpStrDup("See 'override_vlevels'.");
    tt->array_offset = (char *) &_vlevel_array - &_start_;
    tt->array_n_offset = (char *) &vlevel_array_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 1;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = 0;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("GEOMETRY CONVERSION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_horiz_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_horiz_limits");
    tt->descr = tdrpStrDup("Option to set horizontal limits.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_horiz_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'horiz_limits'
    // ctype is '_horiz_limits_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("horiz_limits");
    tt->descr = tdrpStrDup("Set horizontal limits.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_limits - &_start_;
    tt->struct_def.name = tdrpStrDup("horiz_limits_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("min_lat");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &horiz_limits.min_lat - (char *) &horiz_limits;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_lon");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &horiz_limits.min_lon - (char *) &horiz_limits;
      tt->struct_def.fields[2].ftype = tdrpStrDup("float");
      tt->struct_def.fields[2].fname = tdrpStrDup("max_lat");
      tt->struct_def.fields[2].ptype = FLOAT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &horiz_limits.max_lat - (char *) &horiz_limits;
      tt->struct_def.fields[3].ftype = tdrpStrDup("float");
      tt->struct_def.fields[3].fname = tdrpStrDup("max_lon");
      tt->struct_def.fields[3].ptype = FLOAT_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &horiz_limits.max_lon - (char *) &horiz_limits;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = -90;
      tt->struct_vals[1].f = -180;
      tt->struct_vals[2].f = 90;
      tt->struct_vals[3].f = 180;
    tt++;
    
    // Parameter 'set_vlevel_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_vlevel_limits");
    tt->descr = tdrpStrDup("Option to set plane vlevel limits");
    tt->help = tdrpStrDup("Mutually exclusive with set_plane_num_limits.");
    tt->val_offset = (char *) &set_vlevel_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'lower_vlevel'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("lower_vlevel");
    tt->descr = tdrpStrDup("Lower plane vlevel limit.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &lower_vlevel - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'upper_vlevel'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("upper_vlevel");
    tt->descr = tdrpStrDup("Upper plane vlevel limit.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &upper_vlevel - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'set_plane_num_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_plane_num_limits");
    tt->descr = tdrpStrDup("Option to set plane number limits");
    tt->help = tdrpStrDup("Mutually exclusive with set_vlevel_limits.");
    tt->val_offset = (char *) &set_plane_num_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'lower_plane_num'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("lower_plane_num");
    tt->descr = tdrpStrDup("Lower plane num limit.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &lower_plane_num - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'upper_plane_num'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("upper_plane_num");
    tt->descr = tdrpStrDup("Upper plane num limit.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &upper_plane_num - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'composite'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("composite");
    tt->descr = tdrpStrDup("Option for creating composite.");
    tt->help = tdrpStrDup("Composite is a plane in which each grid location contains the maximum value at any height.");
    tt->val_offset = (char *) &composite - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_z_to_constant_grid'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_z_to_constant_grid");
    tt->descr = tdrpStrDup("Option to remap the Z levels onto a grid with constant dz.");
    tt->help = tdrpStrDup("Field data will be remapped onto the specified Z levels using the nearest neighbor method. See 'remap_z_grid'. Note that this actually changes the data. Whereas 'override_vlevels' only changes the vlevels in the headers, and does not change the data.");
    tt->val_offset = (char *) &remap_z_to_constant_grid - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_z_grid'
    // ctype is '_remap_z_grid_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("remap_z_grid");
    tt->descr = tdrpStrDup("Specified Z levels for remapping.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &remap_z_grid - &_start_;
    tt->struct_def.name = tdrpStrDup("remap_z_grid_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nz");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &remap_z_grid.nz - (char *) &remap_z_grid;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("minz");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &remap_z_grid.minz - (char *) &remap_z_grid;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("dz");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &remap_z_grid.dz - (char *) &remap_z_grid;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 10;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 1;
    tt++;
    
    // Parameter 'remap_xy'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_xy");
    tt->descr = tdrpStrDup("Option to remap grid in x,y.");
    tt->help = tdrpStrDup("If true, set the remap parameters below.");
    tt->val_offset = (char *) &remap_xy - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'auto_remap_to_latlon'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_remap_to_latlon");
    tt->descr = tdrpStrDup("Option to automatically remap the grid to a lat-lon projection.");
    tt->help = tdrpStrDup("If true, the data in the file will be remapped to a latlon grid which matches the existing grid in resolution and extent. Other remap parameters will be ignored.");
    tt->val_offset = (char *) &auto_remap_to_latlon - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_at_source'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_at_source");
    tt->descr = tdrpStrDup("Flag indicating where to do the remapping.");
    tt->help = tdrpStrDup("If set to true, the remapping is done on the source machine by setting the remapping in the MDV read request. This is the default.If set to false, the remapping is done on the destination machine by doing a remap command after the read is done. This is useful if you are reading the data from a machine that is overloaded.");
    tt->val_offset = (char *) &remap_at_source - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'remap_projection'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("remap_projection");
    tt->descr = tdrpStrDup("Projection for remapping in x,y. See projection param below.");
    tt->help = tdrpStrDup("\tPROJ_LATLON: simple lat/lon grid (Equidistant Cylindrical)\n\tPROJ_FLAT: Azimuthal Equidistant (Radar)\n\tPROJ_LAMBERT_CONF: Lambert Conformal Conic\n\tPROJ_LAMBERT_AZIM: Lambert Azimuthal Equal Area\n\tPROJ_MERCATOR: Mercator - EW orientation\n\tPROJ_TRANS_MERCATOR: Tranverse Mercator - NS orientation\n\tPROJ_POLAR_STEREO: Stereographic- polar aspect\n\tPROJ_OBLIQUE_STEREO: Stereographic - oblique aspect\n\tPROJ_ALBERS: Albers Equal Area Conic\n\tPROJ_VERT_PERSP: Vertical Perspective (satellite view)\n\n");
    tt->val_offset = (char *) &remap_projection - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 10;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_LATLON");
      tt->enum_def.fields[0].val = PROJ_LATLON;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_LAMBERT_CONF");
      tt->enum_def.fields[1].val = PROJ_LAMBERT_CONF;
      tt->enum_def.fields[2].name = tdrpStrDup("PROJ_MERCATOR");
      tt->enum_def.fields[2].val = PROJ_MERCATOR;
      tt->enum_def.fields[3].name = tdrpStrDup("PROJ_POLAR_STEREO");
      tt->enum_def.fields[3].val = PROJ_POLAR_STEREO;
      tt->enum_def.fields[4].name = tdrpStrDup("PROJ_FLAT");
      tt->enum_def.fields[4].val = PROJ_FLAT;
      tt->enum_def.fields[5].name = tdrpStrDup("PROJ_OBLIQUE_STEREO");
      tt->enum_def.fields[5].val = PROJ_OBLIQUE_STEREO;
      tt->enum_def.fields[6].name = tdrpStrDup("PROJ_TRANS_MERCATOR");
      tt->enum_def.fields[6].val = PROJ_TRANS_MERCATOR;
      tt->enum_def.fields[7].name = tdrpStrDup("PROJ_ALBERS");
      tt->enum_def.fields[7].val = PROJ_ALBERS;
      tt->enum_def.fields[8].name = tdrpStrDup("PROJ_LAMBERT_AZIM");
      tt->enum_def.fields[8].val = PROJ_LAMBERT_AZIM;
      tt->enum_def.fields[9].name = tdrpStrDup("PROJ_VERT_PERSP");
      tt->enum_def.fields[9].val = PROJ_VERT_PERSP;
    tt->single_val.e = PROJ_FLAT;
    tt++;
    
    // Parameter 'remap_grid'
    // ctype is '_grid_params_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("remap_grid");
    tt->descr = tdrpStrDup("Grid parameters for remapping in x,y.");
    tt->help = tdrpStrDup("Units in km, except for LATLON, which is in degrees.");
    tt->val_offset = (char *) &remap_grid - &_start_;
    tt->struct_def.name = tdrpStrDup("grid_params_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nx");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &remap_grid.nx - (char *) &remap_grid;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("ny");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &remap_grid.ny - (char *) &remap_grid;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("minx");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &remap_grid.minx - (char *) &remap_grid;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("miny");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &remap_grid.miny - (char *) &remap_grid;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dx");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &remap_grid.dx - (char *) &remap_grid;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dy");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &remap_grid.dy - (char *) &remap_grid;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 1;
      tt->struct_vals[1].i = 1;
      tt->struct_vals[2].d = 0;
      tt->struct_vals[3].d = 0;
      tt->struct_vals[4].d = 1;
      tt->struct_vals[5].d = 1;
    tt++;
    
    // Parameter 'remap_rotation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_rotation");
    tt->descr = tdrpStrDup("Remapped grid rotation.");
    tt->help = tdrpStrDup("This applies only to PROJ_FLAT projections.");
    tt->val_offset = (char *) &remap_rotation - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_origin_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_origin_lat");
    tt->descr = tdrpStrDup("Remapped grid origin latitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.");
    tt->val_offset = (char *) &remap_origin_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_origin_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_origin_lon");
    tt->descr = tdrpStrDup("Remapped grid origin longitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.");
    tt->val_offset = (char *) &remap_origin_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_lat1'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_lat1");
    tt->descr = tdrpStrDup("Remapped grid reference latitude 1.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &remap_lat1 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_lat2'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_lat2");
    tt->descr = tdrpStrDup("Remapped grid reference latitude 2.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &remap_lat2 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_central_scale'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_central_scale");
    tt->descr = tdrpStrDup("Central scale for remapped projections.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO, OBLIQUE_STEREO and TRANSVERSE_MERCATOR projections.");
    tt->val_offset = (char *) &remap_central_scale - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'remap_tangent_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_tangent_lat");
    tt->descr = tdrpStrDup("Remapped tangent latitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO only.");
    tt->val_offset = (char *) &remap_tangent_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_tangent_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_tangent_lon");
    tt->descr = tdrpStrDup("Remapped tangent longitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO and POLAR_STEREO.");
    tt->val_offset = (char *) &remap_tangent_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_pole_is_north'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_pole_is_north");
    tt->descr = tdrpStrDup("Flag indicating stereogtraphic is over the NORTH pole.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO. If false, the projection is over the south pole.");
    tt->val_offset = (char *) &remap_pole_is_north - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'remap_persp_radius'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_persp_radius");
    tt->descr = tdrpStrDup("Radius of perspective point (km).");
    tt->help = tdrpStrDup("This applies to VERT_PERSP.");
    tt->val_offset = (char *) &remap_persp_radius - &_start_;
    tt->single_val.d = 35786;
    tt++;
    
    // Parameter 'remap_false_northing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_false_northing");
    tt->descr = tdrpStrDup("Remapped false northing correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the Y coordinate so that all coordinates are positive. Normally 0. As an alternative to false_northing and false_easting, you can set the offset_latitude and offset_longitude");
    tt->val_offset = (char *) &remap_false_northing - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_false_easting'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_false_easting");
    tt->descr = tdrpStrDup("Remapped false easting correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the X coordinate so that all coordinates are positive. Normally 0.");
    tt->val_offset = (char *) &remap_false_easting - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_set_offset_origin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_set_offset_origin");
    tt->descr = tdrpStrDup("Do you want to specify an offset origin using lat/lon instead of false_northing and false_easting?");
    tt->help = tdrpStrDup("If true, set remap_offset_origin_latitude and remap_offset_origin_longitude.");
    tt->val_offset = (char *) &remap_set_offset_origin - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_offset_origin_latitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_offset_origin_latitude");
    tt->descr = tdrpStrDup("Latitude of offset origin.");
    tt->help = tdrpStrDup("See remap_set_offset_origin.");
    tt->val_offset = (char *) &remap_offset_origin_latitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_offset_origin_longitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_offset_origin_longitude");
    tt->descr = tdrpStrDup("Longitude of offset origin.");
    tt->help = tdrpStrDup("See remap_set_offset_origin.");
    tt->val_offset = (char *) &remap_offset_origin_longitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("ENCODING AND COMPRESSION CONVERSION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'encoding_type'
    // ctype is '_encoding_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("encoding_type");
    tt->descr = tdrpStrDup("Set encoding type.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &encoding_type - &_start_;
    tt->enum_def.name = tdrpStrDup("encoding_type_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ENCODING_ASIS");
      tt->enum_def.fields[0].val = ENCODING_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("ENCODING_INT8");
      tt->enum_def.fields[1].val = ENCODING_INT8;
      tt->enum_def.fields[2].name = tdrpStrDup("ENCODING_INT16");
      tt->enum_def.fields[2].val = ENCODING_INT16;
      tt->enum_def.fields[3].name = tdrpStrDup("ENCODING_FLOAT32");
      tt->enum_def.fields[3].val = ENCODING_FLOAT32;
    tt->single_val.e = ENCODING_ASIS;
    tt++;
    
    // Parameter 'compression_type'
    // ctype is '_compression_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("compression_type");
    tt->descr = tdrpStrDup("Set compression type.");
    tt->help = tdrpStrDup("See <toolsa/compress> for details on the compression types.");
    tt->val_offset = (char *) &compression_type - &_start_;
    tt->enum_def.name = tdrpStrDup("compression_type_t");
    tt->enum_def.nfields = 9;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("COMPRESSION_ASIS");
      tt->enum_def.fields[0].val = COMPRESSION_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("COMPRESSION_NONE");
      tt->enum_def.fields[1].val = COMPRESSION_NONE;
      tt->enum_def.fields[2].name = tdrpStrDup("COMPRESSION_RLE");
      tt->enum_def.fields[2].val = COMPRESSION_RLE;
      tt->enum_def.fields[3].name = tdrpStrDup("COMPRESSION_LZO");
      tt->enum_def.fields[3].val = COMPRESSION_LZO;
      tt->enum_def.fields[4].name = tdrpStrDup("COMPRESSION_ZLIB");
      tt->enum_def.fields[4].val = COMPRESSION_ZLIB;
      tt->enum_def.fields[5].name = tdrpStrDup("COMPRESSION_BZIP");
      tt->enum_def.fields[5].val = COMPRESSION_BZIP;
      tt->enum_def.fields[6].name = tdrpStrDup("COMPRESSION_GZIP");
      tt->enum_def.fields[6].val = COMPRESSION_GZIP;
      tt->enum_def.fields[7].name = tdrpStrDup("COMPRESSION_GZIP_VOL");
      tt->enum_def.fields[7].val = COMPRESSION_GZIP_VOL;
      tt->enum_def.fields[8].name = tdrpStrDup("COMPRESSION_TYPES_N");
      tt->enum_def.fields[8].val = COMPRESSION_TYPES_N;
    tt->single_val.e = COMPRESSION_ASIS;
    tt++;
    
    // Parameter 'force_scale_change'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("force_scale_change");
    tt->descr = tdrpStrDup("Option to force a scaling change in the data");
    tt->help = tdrpStrDup("If this option is chosen, the data is read in as float data and then is converted to the chosen output encoding type using the scaling options specified below.\nNOTE: When using this option, if you set the encoding_type option to ENCODING_ASIS, the output will use FLOAT32 encoding.");
    tt->val_offset = (char *) &force_scale_change - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'scaling_type'
    // ctype is '_scaling_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("scaling_type");
    tt->descr = tdrpStrDup("Set scaling type.");
    tt->help = tdrpStrDup("This is only relevant when converting from float32 to int8 or int16 or if force_scale_change is set.");
    tt->val_offset = (char *) &scaling_type - &_start_;
    tt->enum_def.name = tdrpStrDup("scaling_type_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("SCALING_ASIS");
      tt->enum_def.fields[0].val = SCALING_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("SCALING_NONE");
      tt->enum_def.fields[1].val = SCALING_NONE;
      tt->enum_def.fields[2].name = tdrpStrDup("SCALING_ROUNDED");
      tt->enum_def.fields[2].val = SCALING_ROUNDED;
      tt->enum_def.fields[3].name = tdrpStrDup("SCALING_INTEGRAL");
      tt->enum_def.fields[3].val = SCALING_INTEGRAL;
      tt->enum_def.fields[4].name = tdrpStrDup("SCALING_DYNAMIC");
      tt->enum_def.fields[4].val = SCALING_DYNAMIC;
      tt->enum_def.fields[5].name = tdrpStrDup("SCALING_SPECIFIED");
      tt->enum_def.fields[5].val = SCALING_SPECIFIED;
    tt->single_val.e = SCALING_ROUNDED;
    tt++;
    
    // Parameter 'scale'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("scale");
    tt->descr = tdrpStrDup("Input scaling scale.");
    tt->help = tdrpStrDup("For SCALING_SPECIFIED only.");
    tt->val_offset = (char *) &scale - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'bias'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bias");
    tt->descr = tdrpStrDup("Input scaling bias.");
    tt->help = tdrpStrDup("For SCALING_SPECIFIED only.");
    tt->val_offset = (char *) &bias - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("DECIMATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'decimate'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("decimate");
    tt->descr = tdrpStrDup("Option to decimate in x,y.");
    tt->help = tdrpStrDup("If true, each plane is decimated to force the number of grid points to be less than 'decimate_max_nxy'.");
    tt->val_offset = (char *) &decimate - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'decimate_max_nxy'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("decimate_max_nxy");
    tt->descr = tdrpStrDup("Max number of xy grid points in decimation.");
    tt->help = tdrpStrDup("See 'decimate'.");
    tt->val_offset = (char *) &decimate_max_nxy - &_start_;
    tt->single_val.i = 1000000;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("INVERT PLANES IN THE VERTICAL SENSE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'invert_vertically'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("invert_vertically");
    tt->descr = tdrpStrDup("Invert the vertical levels in all fields.");
    tt->help = tdrpStrDup("This inversion is applied after the remap, forced scale change, overriding of V levels, and linear transformations.");
    tt->val_offset = (char *) &invert_vertically - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("BYTE ORDERING");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_be'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("input_be");
    tt->descr = tdrpStrDup("Are input files big-endian.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_be - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'output_be'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_be");
    tt->descr = tdrpStrDup("Are output files big-endian.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_be - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("APPLY LINEAR TRANSFORM FUNCTION TO SELECTED FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'apply_linear_transform'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_linear_transform");
    tt->descr = tdrpStrDup("Option to apply a linear transform function to the data in selected data fields.\n");
    tt->help = tdrpStrDup("Field names and transform parameters are given in linear_transforms parameter.");
    tt->val_offset = (char *) &apply_linear_transform - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'linear_transforms'
    // ctype is '_linear_transform_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("linear_transforms");
    tt->descr = tdrpStrDup("Array specifying the transform functions and the field names to which they apply.");
    tt->help = tdrpStrDup("The transform will only be applied to the specified fields. If a field which is specified does not exist, a warning will be issued.");
    tt->array_offset = (char *) &_linear_transforms - &_start_;
    tt->array_n_offset = (char *) &linear_transforms_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(linear_transform_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("linear_transform_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_linear_transforms->field_name - (char *) _linear_transforms;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("scale");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_linear_transforms->scale - (char *) _linear_transforms;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("bias");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_linear_transforms->bias - (char *) _linear_transforms;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].d = 1;
      tt->struct_vals[2].d = 0;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("WRITE USING EXTENDED PATHS");
    tt->comment_text = tdrpStrDup("This will be overridden if the environment variable MDV_WRITE_USING_EXTENDED_PATHS exists and is set to TRUE.");
    tt++;
    
    // Parameter 'write_using_extended_paths'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_using_extended_paths");
    tt->descr = tdrpStrDup("Option to write files with extended paths.");
    tt->help = tdrpStrDup("If specified, this will override that specified by the client. Default is FALSE.\n\nIf set, paths will include a separate year subdirectory, and the file name will include date and time.\n\nNon-forecast path:\n  dir/yyyy/yyyymmdd/yyyymmdd_hhmmss.mdv.\n\nForecast path:\n  dir/yyyy/yyyymmdd/yyyymmdd_g_hhmmss_f_llllllll.mdv.");
    tt->val_offset = (char *) &write_using_extended_paths - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("CONTROL OF CONVERSION TO NETCDF.");
    tt->comment_text = tdrpStrDup("The following parameters control conversion of MDV files to NetCDF CF-compliant files.");
    tt++;
    
    // Parameter 'ncf_set_global_attributes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_set_global_attributes");
    tt->descr = tdrpStrDup("Option to set specify global attributes in the NCF file.");
    tt->help = tdrpStrDup("The global attributes are 'institution', 'references' and 'comment'.");
    tt->val_offset = (char *) &ncf_set_global_attributes - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_global_attributes'
    // ctype is '_ncf_global_attributes_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ncf_global_attributes");
    tt->descr = tdrpStrDup("Global attributes for netCDF file");
    tt->help = tdrpStrDup("These strings will be included as global attributes in the NetCDF file. Other global attributes will be determined from the MDV headers.");
    tt->val_offset = (char *) &ncf_global_attributes - &_start_;
    tt->struct_def.name = tdrpStrDup("ncf_global_attributes_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("institution");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ncf_global_attributes.institution - (char *) &ncf_global_attributes;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("references");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ncf_global_attributes.references - (char *) &ncf_global_attributes;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("comment");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &ncf_global_attributes.comment - (char *) &ncf_global_attributes;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("NCAR");
      tt->struct_vals[1].s = tdrpStrDup("");
      tt->struct_vals[2].s = tdrpStrDup("Converted by MdvConvert");
    tt++;
    
    // Parameter 'ncf_transform_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_transform_fields");
    tt->descr = tdrpStrDup("Option to tranform field names, units and values when converting MDV to NCF.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_transform_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_field_transforms'
    // ctype is '_ncf_field_transform_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ncf_field_transforms");
    tt->descr = tdrpStrDup("List of transforms. If mdv_field_name is found in the MDV data, these other parameters will be used to set the field variable in the netCDF file.");
    tt->help = tdrpStrDup("See mdv2ncf_transform_fields.");
    tt->array_offset = (char *) &_ncf_field_transforms - &_start_;
    tt->array_n_offset = (char *) &ncf_field_transforms_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(ncf_field_transform_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("ncf_field_transform_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("mdv_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_ncf_field_transforms->mdv_field_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("ncf_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_field_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("ncf_standard_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_standard_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("ncf_long_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_long_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("ncf_units");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_units - (char *) _ncf_field_transforms;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("do_linear_transform");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_ncf_field_transforms->do_linear_transform - (char *) _ncf_field_transforms;
      tt->struct_def.fields[6].ftype = tdrpStrDup("float");
      tt->struct_def.fields[6].fname = tdrpStrDup("linear_multiplier");
      tt->struct_def.fields[6].ptype = FLOAT_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_ncf_field_transforms->linear_multiplier - (char *) _ncf_field_transforms;
      tt->struct_def.fields[7].ftype = tdrpStrDup("float");
      tt->struct_def.fields[7].fname = tdrpStrDup("linear_const");
      tt->struct_def.fields[7].ptype = FLOAT_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_ncf_field_transforms->linear_const - (char *) _ncf_field_transforms;
      tt->struct_def.fields[8].ftype = tdrpStrDup("data_pack_t");
      tt->struct_def.fields[8].fname = tdrpStrDup("packed_data_type");
      tt->struct_def.fields[8].ptype = ENUM_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_ncf_field_transforms->packed_data_type - (char *) _ncf_field_transforms;
        tt->struct_def.fields[8].enum_def.name = tdrpStrDup("data_pack_t");
        tt->struct_def.fields[8].enum_def.nfields = 4;
        tt->struct_def.fields[8].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[8].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[8].enum_def.fields[0].name = tdrpStrDup("DATA_PACK_FLOAT");
        tt->struct_def.fields[8].enum_def.fields[0].val = DATA_PACK_FLOAT;
        tt->struct_def.fields[8].enum_def.fields[1].name = tdrpStrDup("DATA_PACK_SHORT");
        tt->struct_def.fields[8].enum_def.fields[1].val = DATA_PACK_SHORT;
        tt->struct_def.fields[8].enum_def.fields[2].name = tdrpStrDup("DATA_PACK_BYTE");
        tt->struct_def.fields[8].enum_def.fields[2].val = DATA_PACK_BYTE;
        tt->struct_def.fields[8].enum_def.fields[3].name = tdrpStrDup("DATA_PACK_ASIS");
        tt->struct_def.fields[8].enum_def.fields[3].val = DATA_PACK_ASIS;
    tt->n_struct_vals = 9;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("mdv_field_name");
      tt->struct_vals[1].s = tdrpStrDup("ncf_field_name");
      tt->struct_vals[2].s = tdrpStrDup("ncf_standard_name");
      tt->struct_vals[3].s = tdrpStrDup("ncf_long_name");
      tt->struct_vals[4].s = tdrpStrDup("ncf_units");
      tt->struct_vals[5].b = pFALSE;
      tt->struct_vals[6].f = 1;
      tt->struct_vals[7].f = 0;
      tt->struct_vals[8].e = DATA_PACK_ASIS;
    tt++;
    
    // Parameter 'ncf_compress_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_compress_data");
    tt->descr = tdrpStrDup("Option to compress field data.");
    tt->help = tdrpStrDup("Only applies to NETCDF4 and  NETCDF4_CLASSIC files.");
    tt->val_offset = (char *) &ncf_compress_data - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_compression_level'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("ncf_compression_level");
    tt->descr = tdrpStrDup("Compression level from 1 to 9 with 9 being the greatest compression. Default is 9.");
    tt->help = tdrpStrDup("Only applies to NETCDF4 and  NETCDF4_CLASSIC files.");
    tt->val_offset = (char *) &ncf_compression_level - &_start_;
    tt->single_val.i = 9;
    tt++;
    
    // Parameter 'ncf_filename_suffix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_filename_suffix");
    tt->descr = tdrpStrDup("Suffix of netCDF files");
    tt->help = tdrpStrDup("File extension is always .nc. File name will end with mdv.suffix.nc. Set to the empty string for no suffix, in which case file name will end with .mdv.nc.");
    tt->val_offset = (char *) &ncf_filename_suffix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_file_format'
    // ctype is '_ncf_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("ncf_file_format");
    tt->descr = tdrpStrDup("NetCDF file format");
    tt->help = tdrpStrDup("netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls");
    tt->val_offset = (char *) &ncf_file_format - &_start_;
    tt->enum_def.name = tdrpStrDup("ncf_format_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLASSIC");
      tt->enum_def.fields[0].val = CLASSIC;
      tt->enum_def.fields[1].name = tdrpStrDup("NC64BIT");
      tt->enum_def.fields[1].val = NC64BIT;
      tt->enum_def.fields[2].name = tdrpStrDup("NETCDF4");
      tt->enum_def.fields[2].val = NETCDF4;
      tt->enum_def.fields[3].name = tdrpStrDup("NETCDF4_CLASSIC");
      tt->enum_def.fields[3].val = NETCDF4_CLASSIC;
    tt->single_val.e = NETCDF4;
    tt++;
    
    // Parameter 'ncf_polar_radar_file_type'
    // ctype is '_radial_file_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("ncf_polar_radar_file_type");
    tt->descr = tdrpStrDup("Output format for polar radar data.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_polar_radar_file_type - &_start_;
    tt->enum_def.name = tdrpStrDup("radial_file_type_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FILE_TYPE_CF");
      tt->enum_def.fields[0].val = FILE_TYPE_CF;
      tt->enum_def.fields[1].name = tdrpStrDup("FILE_TYPE_CF_RADIAL");
      tt->enum_def.fields[1].val = FILE_TYPE_CF_RADIAL;
      tt->enum_def.fields[2].name = tdrpStrDup("FILE_TYPE_DORADE");
      tt->enum_def.fields[2].val = FILE_TYPE_DORADE;
      tt->enum_def.fields[3].name = tdrpStrDup("FILE_TYPE_UF");
      tt->enum_def.fields[3].val = FILE_TYPE_UF;
    tt->single_val.e = FILE_TYPE_CF;
    tt++;
    
    // Parameter 'ncf_output_latlon_arrays'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_latlon_arrays");
    tt->descr = tdrpStrDup("If true latitude and longitude arrays of each grid point are output");
    tt->help = tdrpStrDup("The CF convention requires that these arrays are present in the netCDF file; however, the information is redundant since the lat and lon arrays could be constructed using the other projection and grid information required with a gridded data field");
    tt->val_offset = (char *) &ncf_output_latlon_arrays - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_output_start_end_times'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_start_end_times");
    tt->descr = tdrpStrDup("If true Mdv start_time and end_time are output");
    tt->help = tdrpStrDup("In the case in which the the information contained in the Mdv start_time and end_time may be redundant or irrelevant the user can choose not to output these variables ");
    tt->val_offset = (char *) &ncf_output_start_end_times - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_output_mdv_attributes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_mdv_attributes");
    tt->descr = tdrpStrDup("Option to output non-CF compliant MDV attributes.");
    tt->help = tdrpStrDup("If true, MDV attributes which are not CF compliant will be output. This will facilitate the translation of the data back into MDV with the minimal loss of information.");
    tt->val_offset = (char *) &ncf_output_mdv_attributes - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_output_mdv_chunks'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_mdv_chunks");
    tt->descr = tdrpStrDup("Option to output non-CF compliant MDV chunks.");
    tt->help = tdrpStrDup("If true, MDV chunks will be included as byte binary variables.");
    tt->val_offset = (char *) &ncf_output_mdv_chunks - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("DETAILS FOR CEDRIC OUTPUT CONVERSION.");
    tt->comment_text = tdrpStrDup("Parameters for writing out CEDRIC files. CEDRIC is an NCAR package for performing radar-type analyses such as dual-Doppler wind field estimation.");
    tt++;
    
    // Parameter 'cedric_volume_number'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("cedric_volume_number");
    tt->descr = tdrpStrDup("Volume number for CEDRIC conversion.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cedric_volume_number - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'cedric_volume_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("cedric_volume_name");
    tt->descr = tdrpStrDup("Volume name for CEDRIC conversion.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cedric_volume_name - &_start_;
    tt->single_val.s = tdrpStrDup("CED-VOL");
    tt++;
    
    // Parameter 'cedric_radar_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("cedric_radar_name");
    tt->descr = tdrpStrDup("Radar name for CEDRIC conversion.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cedric_radar_name - &_start_;
    tt->single_val.s = tdrpStrDup("RADAR");
    tt++;
    
    // Parameter 'cedric_project_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("cedric_project_name");
    tt->descr = tdrpStrDup("Project name for CEDRIC conversion.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cedric_project_name - &_start_;
    tt->single_val.s = tdrpStrDup("PROJECT");
    tt++;
    
    // Parameter 'cedric_program_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("cedric_program_name");
    tt->descr = tdrpStrDup("Program name for CEDRIC conversion.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cedric_program_name - &_start_;
    tt->single_val.s = tdrpStrDup("PROGRAM");
    tt++;
    
    // Parameter 'cedric_nyquist_velocity'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cedric_nyquist_velocity");
    tt->descr = tdrpStrDup("Nyquist velocity for CEDRIC conversion.");
    tt->help = tdrpStrDup("Included as metadata in CEDRIC files. CEDRIC was written for radar data, so we need to supply radar meta-data, even if this is simulated.");
    tt->val_offset = (char *) &cedric_nyquist_velocity - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'cedric_ngates_beam'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("cedric_ngates_beam");
    tt->descr = tdrpStrDup("Number of gates CEDRIC conversion.");
    tt->help = tdrpStrDup("Included as metadata in CEDRIC files. CEDRIC was written for radar data, so we need to supply radar meta-data, even if this is simulated.");
    tt->val_offset = (char *) &cedric_ngates_beam - &_start_;
    tt->single_val.i = 1000;
    tt++;
    
    // Parameter 'cedric_gate_spacing_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cedric_gate_spacing_km");
    tt->descr = tdrpStrDup("Gate spacing CEDRIC conversion (km).");
    tt->help = tdrpStrDup("Included as metadata in CEDRIC files. CEDRIC was written for radar data, so we need to supply radar meta-data, even if this is simulated.");
    tt->val_offset = (char *) &cedric_gate_spacing_km - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'cedric_elevation_angles'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cedric_elevation_angles");
    tt->descr = tdrpStrDup("Elevation angles for CEDRIC conversion (deg).");
    tt->help = tdrpStrDup("Included as metadata in CEDRIC files. CEDRIC was written for radar data, so we need to supply radar meta-data, even if this is simulated.");
    tt->array_offset = (char *) &_cedric_elevation_angles - &_start_;
    tt->array_n_offset = (char *) &cedric_elevation_angles_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 12;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = 0.5;
      tt->array_vals[1].d = 1;
      tt->array_vals[2].d = 1.5;
      tt->array_vals[3].d = 2;
      tt->array_vals[4].d = 3;
      tt->array_vals[5].d = 4;
      tt->array_vals[6].d = 5;
      tt->array_vals[7].d = 7.5;
      tt->array_vals[8].d = 10;
      tt->array_vals[9].d = 12.5;
      tt->array_vals[10].d = 15;
      tt->array_vals[11].d = 20;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
