// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 1992 - 2017
// ** University Corporation for Atmospheric Research(UCAR)
// ** National Center for Atmospheric Research(NCAR)
// ** Boulder, Colorado, USA
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program MdvPull
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'reg_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("reg_interval");
    tt->descr = tdrpStrDup("Registration interval.");
    tt->help = tdrpStrDup("The number of seconds between expected procmap registrations.");
    tt->val_offset = (char *) &reg_interval - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DATA SEARCH");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("MdvPull obtains a time list for files at the source URL. It also obtains a time list for the output URL, and compares the two lists. It then downloads missing datasets. In REALTIME mode, the search period spans 'now' - realtime_lookback_secs to 'now' + realtime_lookforward_secs. In ARCHIVE mode, the search period limits 'start_time' and 'end_time' are specified on the command line.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
    tt->single_val.e = ARCHIVE;
    tt++;
    
    // Parameter 'new_data_poll_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("new_data_poll_interval");
    tt->descr = tdrpStrDup("Interval at which to poll for new data (secs).");
    tt->help = tdrpStrDup("At this interval, MdvPull will check with the source for new data.");
    tt->val_offset = (char *) &new_data_poll_interval - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'realtime_lookback_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("realtime_lookback_secs");
    tt->descr = tdrpStrDup("REALTIME mode only - how far to look back (secs).");
    tt->help = tdrpStrDup("Applies to both observed and forecast type data.");
    tt->val_offset = (char *) &realtime_lookback_secs - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'realtime_lookforward_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("realtime_lookforward_secs");
    tt->descr = tdrpStrDup("REALTIME mode only - how far to look back (secs).");
    tt->help = tdrpStrDup("Only applicable for forecast-type data retrieved using VALID_TIME.");
    tt->val_offset = (char *) &realtime_lookforward_secs - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'search_mode'
    // ctype is '_search_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("search_mode");
    tt->descr = tdrpStrDup("Mode for searching for data sets");
    tt->help = tdrpStrDup("For observational data, always use VALID_TIME. For forecast data, you can search using VALID_TIME or GEN_TIME. If you use VALID_TIME, MdvPull will find files based on the time at which the forecast is valid. If you specifuy GEN_TIME for forecast data, you will find all data sets for which the generate (run) time lies within the search limits.");
    tt->val_offset = (char *) &search_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("search_mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("VALID_TIME");
      tt->enum_def.fields[0].val = VALID_TIME;
      tt->enum_def.fields[1].name = tdrpStrDup("GEN_TIME");
      tt->enum_def.fields[1].val = GEN_TIME;
    tt->single_val.e = VALID_TIME;
    tt++;
    
    // Parameter 'source_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("source_url");
    tt->descr = tdrpStrDup("URL for source data.");
    tt->help = tdrpStrDup("This is used in REALTIME and ARCHIVE modes only. In FILELIST mode, the file paths are specified on the command line. In  LOCAL_FILEPATH_REALTIME mode, set this to a directory, not a URL.");
    tt->val_offset = (char *) &source_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdv/source");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("READ CONSTRAINTS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_field_names'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_field_names");
    tt->descr = tdrpStrDup("Option to set field names");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_field_names - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'field_names'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("field_names");
    tt->descr = tdrpStrDup("Field name list.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_field_names - &_start_;
    tt->array_n_offset = (char *) &field_names_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 1;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("0");
    tt++;
    
    // Parameter 'set_horiz_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_horiz_limits");
    tt->descr = tdrpStrDup("Option to set horizontal limits.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_horiz_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'horiz_limits'
    // ctype is '_horiz_limits_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("horiz_limits");
    tt->descr = tdrpStrDup("Set horizontal limits.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_limits - &_start_;
    tt->struct_def.name = tdrpStrDup("horiz_limits_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("min_lat");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &horiz_limits.min_lat - (char *) &horiz_limits;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_lon");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &horiz_limits.min_lon - (char *) &horiz_limits;
      tt->struct_def.fields[2].ftype = tdrpStrDup("float");
      tt->struct_def.fields[2].fname = tdrpStrDup("max_lat");
      tt->struct_def.fields[2].ptype = FLOAT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &horiz_limits.max_lat - (char *) &horiz_limits;
      tt->struct_def.fields[3].ftype = tdrpStrDup("float");
      tt->struct_def.fields[3].fname = tdrpStrDup("max_lon");
      tt->struct_def.fields[3].ptype = FLOAT_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &horiz_limits.max_lon - (char *) &horiz_limits;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = -90;
      tt->struct_vals[1].f = -180;
      tt->struct_vals[2].f = 90;
      tt->struct_vals[3].f = 180;
    tt++;
    
    // Parameter 'set_vlevel_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_vlevel_limits");
    tt->descr = tdrpStrDup("Option to set plane vlevel limits");
    tt->help = tdrpStrDup("Mutually exclusive with set_plane_num_limits.");
    tt->val_offset = (char *) &set_vlevel_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'lower_vlevel'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("lower_vlevel");
    tt->descr = tdrpStrDup("Lower plane vlevel limit.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &lower_vlevel - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'upper_vlevel'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("upper_vlevel");
    tt->descr = tdrpStrDup("Upper plane vlevel limit.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &upper_vlevel - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'composite'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("composite");
    tt->descr = tdrpStrDup("Option for creating composite.");
    tt->help = tdrpStrDup("Composite is a plane in which each grid location contains the maximum value at any height.");
    tt->val_offset = (char *) &composite - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("RENAME FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'rename_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("rename_fields");
    tt->descr = tdrpStrDup("Option to set field names");
    tt->help = tdrpStrDup("This is done on the client side, by this application.");
    tt->val_offset = (char *) &rename_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'new_names'
    // ctype is '_field_names_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("new_names");
    tt->descr = tdrpStrDup("Provides a map from old field name to new field name. Note that either the filed name or the long field name must match the old_field_name specified for the renaming to take effect, and that if the renaming happens then both the field name and the long field name are renamed to the new_field_name.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_new_names - &_start_;
    tt->array_n_offset = (char *) &new_names_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(field_names_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("field_names_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("old_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_new_names->old_field_name - (char *) _new_names;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("new_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_new_names->new_field_name - (char *) _new_names;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("");
      tt->struct_vals[1].s = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("REMAP XY PROJECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'remap_xy'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_xy");
    tt->descr = tdrpStrDup("Option to remap grid in x,y.");
    tt->help = tdrpStrDup("If true, set the remap parameters below. This is done on the client side, by this application.");
    tt->val_offset = (char *) &remap_xy - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'auto_remap_to_latlon'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_remap_to_latlon");
    tt->descr = tdrpStrDup("Option to automatically remap the grid to a lat-lon projection.");
    tt->help = tdrpStrDup("If true, the data in the file will be remapped to a latlon grid which matches the existing grid in resolution and extent. Other remap parameters will be ignored.");
    tt->val_offset = (char *) &auto_remap_to_latlon - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_projection'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("remap_projection");
    tt->descr = tdrpStrDup("Projection for remapping in x,y. See projection param below.");
    tt->help = tdrpStrDup("\tPROJ_LATLON: simple lat/lon grid (Equidistant Cylindrical)\n\tPROJ_FLAT: Azimuthal Equidistant (Radar)\n\tPROJ_LAMBERT_CONF: Lambert Conformal Conic\n\tPROJ_LAMBERT_AZIM: Lambert Azimuthal Equal Area\n\tPROJ_MERCATOR: Mercator - EW orientation\n\tPROJ_TRANS_MERCATOR: Tranverse Mercator - NS orientation\n\tPROJ_POLAR_STEREO: Stereographic- polar aspect\n\tPROJ_OBLIQUE_STEREO: Stereographic - oblique aspect\n\tPROJ_ALBERS: Albers Equal Area Conic\n\tPROJ_VERT_PERSP: Vertical Perspective (satellite view)\n\n");
    tt->val_offset = (char *) &remap_projection - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 10;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_LATLON");
      tt->enum_def.fields[0].val = PROJ_LATLON;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_LAMBERT_CONF");
      tt->enum_def.fields[1].val = PROJ_LAMBERT_CONF;
      tt->enum_def.fields[2].name = tdrpStrDup("PROJ_MERCATOR");
      tt->enum_def.fields[2].val = PROJ_MERCATOR;
      tt->enum_def.fields[3].name = tdrpStrDup("PROJ_POLAR_STEREO");
      tt->enum_def.fields[3].val = PROJ_POLAR_STEREO;
      tt->enum_def.fields[4].name = tdrpStrDup("PROJ_FLAT");
      tt->enum_def.fields[4].val = PROJ_FLAT;
      tt->enum_def.fields[5].name = tdrpStrDup("PROJ_OBLIQUE_STEREO");
      tt->enum_def.fields[5].val = PROJ_OBLIQUE_STEREO;
      tt->enum_def.fields[6].name = tdrpStrDup("PROJ_TRANS_MERCATOR");
      tt->enum_def.fields[6].val = PROJ_TRANS_MERCATOR;
      tt->enum_def.fields[7].name = tdrpStrDup("PROJ_ALBERS");
      tt->enum_def.fields[7].val = PROJ_ALBERS;
      tt->enum_def.fields[8].name = tdrpStrDup("PROJ_LAMBERT_AZIM");
      tt->enum_def.fields[8].val = PROJ_LAMBERT_AZIM;
      tt->enum_def.fields[9].name = tdrpStrDup("PROJ_VERT_PERSP");
      tt->enum_def.fields[9].val = PROJ_VERT_PERSP;
    tt->single_val.e = PROJ_FLAT;
    tt++;
    
    // Parameter 'remap_grid'
    // ctype is '_grid_params_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("remap_grid");
    tt->descr = tdrpStrDup("Grid parameters for remapping in x,y.");
    tt->help = tdrpStrDup("Units in km, except for LATLON, which is in degrees.");
    tt->val_offset = (char *) &remap_grid - &_start_;
    tt->struct_def.name = tdrpStrDup("grid_params_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nx");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &remap_grid.nx - (char *) &remap_grid;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("ny");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &remap_grid.ny - (char *) &remap_grid;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("minx");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &remap_grid.minx - (char *) &remap_grid;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("miny");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &remap_grid.miny - (char *) &remap_grid;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dx");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &remap_grid.dx - (char *) &remap_grid;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dy");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &remap_grid.dy - (char *) &remap_grid;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 1;
      tt->struct_vals[1].i = 1;
      tt->struct_vals[2].d = 0;
      tt->struct_vals[3].d = 0;
      tt->struct_vals[4].d = 1;
      tt->struct_vals[5].d = 1;
    tt++;
    
    // Parameter 'remap_rotation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_rotation");
    tt->descr = tdrpStrDup("Remapped grid rotation.");
    tt->help = tdrpStrDup("This applies only to PROJ_FLAT projections.");
    tt->val_offset = (char *) &remap_rotation - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_origin_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_origin_lat");
    tt->descr = tdrpStrDup("Remapped grid origin latitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.");
    tt->val_offset = (char *) &remap_origin_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_origin_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_origin_lon");
    tt->descr = tdrpStrDup("Remapped grid origin longitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.");
    tt->val_offset = (char *) &remap_origin_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_lat1'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_lat1");
    tt->descr = tdrpStrDup("Remapped grid reference latitude 1.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &remap_lat1 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_lat2'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_lat2");
    tt->descr = tdrpStrDup("Remapped grid reference latitude 2.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &remap_lat2 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_central_scale'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_central_scale");
    tt->descr = tdrpStrDup("Central scale for remapped projections.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO, OBLIQUE_STEREO and TRANSVERSE_MERCATOR projections.");
    tt->val_offset = (char *) &remap_central_scale - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'remap_tangent_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_tangent_lat");
    tt->descr = tdrpStrDup("Remapped tangent latitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO only.");
    tt->val_offset = (char *) &remap_tangent_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_tangent_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_tangent_lon");
    tt->descr = tdrpStrDup("Remapped tangent longitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO and POLAR_STEREO.");
    tt->val_offset = (char *) &remap_tangent_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_pole_is_north'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_pole_is_north");
    tt->descr = tdrpStrDup("Flag indicating stereogtraphic is over the NORTH pole.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO. If false, the projection is over the south pole.");
    tt->val_offset = (char *) &remap_pole_is_north - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'remap_persp_radius'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_persp_radius");
    tt->descr = tdrpStrDup("Radius of perspective point (km).");
    tt->help = tdrpStrDup("This applies to VERT_PERSP.");
    tt->val_offset = (char *) &remap_persp_radius - &_start_;
    tt->single_val.d = 35786;
    tt++;
    
    // Parameter 'remap_false_northing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_false_northing");
    tt->descr = tdrpStrDup("Remapped false northing correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the Y coordinate so that all coordinates are positive. Normally 0. As an alternative to false_northing and false_easting, you can set the offset_latitude and offset_longitude");
    tt->val_offset = (char *) &remap_false_northing - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_false_easting'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_false_easting");
    tt->descr = tdrpStrDup("Remapped false easting correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the X coordinate so that all coordinates are positive. Normally 0.");
    tt->val_offset = (char *) &remap_false_easting - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_set_offset_origin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remap_set_offset_origin");
    tt->descr = tdrpStrDup("Do you want to specify an offset origin using lat/lon instead of false_northing and false_easting?");
    tt->help = tdrpStrDup("If true, set remap_offset_origin_latitude and remap_offset_origin_longitude.");
    tt->val_offset = (char *) &remap_set_offset_origin - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'remap_offset_origin_latitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_offset_origin_latitude");
    tt->descr = tdrpStrDup("Latitude of offset origin.");
    tt->help = tdrpStrDup("See remap_set_offset_origin.");
    tt->val_offset = (char *) &remap_offset_origin_latitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'remap_offset_origin_longitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("remap_offset_origin_longitude");
    tt->descr = tdrpStrDup("Longitude of offset origin.");
    tt->help = tdrpStrDup("See remap_set_offset_origin.");
    tt->val_offset = (char *) &remap_offset_origin_longitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("ENCODING AND COMPRESSION CONVERSION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'encoding_type'
    // ctype is '_encoding_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("encoding_type");
    tt->descr = tdrpStrDup("Set output encoding type.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &encoding_type - &_start_;
    tt->enum_def.name = tdrpStrDup("encoding_type_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ENCODING_ASIS");
      tt->enum_def.fields[0].val = ENCODING_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("ENCODING_INT8");
      tt->enum_def.fields[1].val = ENCODING_INT8;
      tt->enum_def.fields[2].name = tdrpStrDup("ENCODING_INT16");
      tt->enum_def.fields[2].val = ENCODING_INT16;
      tt->enum_def.fields[3].name = tdrpStrDup("ENCODING_FLOAT32");
      tt->enum_def.fields[3].val = ENCODING_FLOAT32;
    tt->single_val.e = ENCODING_ASIS;
    tt++;
    
    // Parameter 'compression_type'
    // ctype is '_compression_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("compression_type");
    tt->descr = tdrpStrDup("Set output compression type.");
    tt->help = tdrpStrDup("See <toolsa/compress> for details on the compression types.");
    tt->val_offset = (char *) &compression_type - &_start_;
    tt->enum_def.name = tdrpStrDup("compression_type_t");
    tt->enum_def.nfields = 9;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("COMPRESSION_ASIS");
      tt->enum_def.fields[0].val = COMPRESSION_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("COMPRESSION_NONE");
      tt->enum_def.fields[1].val = COMPRESSION_NONE;
      tt->enum_def.fields[2].name = tdrpStrDup("COMPRESSION_RLE");
      tt->enum_def.fields[2].val = COMPRESSION_RLE;
      tt->enum_def.fields[3].name = tdrpStrDup("COMPRESSION_LZO");
      tt->enum_def.fields[3].val = COMPRESSION_LZO;
      tt->enum_def.fields[4].name = tdrpStrDup("COMPRESSION_ZLIB");
      tt->enum_def.fields[4].val = COMPRESSION_ZLIB;
      tt->enum_def.fields[5].name = tdrpStrDup("COMPRESSION_BZIP");
      tt->enum_def.fields[5].val = COMPRESSION_BZIP;
      tt->enum_def.fields[6].name = tdrpStrDup("COMPRESSION_GZIP");
      tt->enum_def.fields[6].val = COMPRESSION_GZIP;
      tt->enum_def.fields[7].name = tdrpStrDup("COMPRESSION_GZIP_VOL");
      tt->enum_def.fields[7].val = COMPRESSION_GZIP_VOL;
      tt->enum_def.fields[8].name = tdrpStrDup("COMPRESSION_TYPES_N");
      tt->enum_def.fields[8].val = COMPRESSION_TYPES_N;
    tt->single_val.e = COMPRESSION_ASIS;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("DATA OUTPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_url");
    tt->descr = tdrpStrDup("Output URL.");
    tt->help = tdrpStrDup("Output data is written to this URL.");
    tt->val_offset = (char *) &output_url - &_start_;
    tt->single_val.s = tdrpStrDup("./output");
    tt++;
    
    // Parameter 'write_latest_data_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_latest_data_info");
    tt->descr = tdrpStrDup("Write _latest_data_info files for output files.");
    tt->help = tdrpStrDup("If false, will suppress writing of _latest_data_info files.");
    tt->val_offset = (char *) &write_latest_data_info - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'output_format'
    // ctype is '_output_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_format");
    tt->descr = tdrpStrDup("Specify format of file on output.");
    tt->help = tdrpStrDup("FORMAT_MDV: normal MDV formal. FORMAT_XML: XML format. XML format writes out 2 files: *.mdv.xml and *.mdv.buf. The xml file contains the meta-data. The buf file contains the binary fields.\nNOTE: only COMPRESSION_NONE and COMPRESSION_GZIP_VOL are supported in XML. FORMAT_NCF: write file in netCDF CF format. Extension will be .nc.");
    tt->val_offset = (char *) &output_format - &_start_;
    tt->enum_def.name = tdrpStrDup("output_format_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("OUTPUT_FORMAT_MDV");
      tt->enum_def.fields[0].val = OUTPUT_FORMAT_MDV;
      tt->enum_def.fields[1].name = tdrpStrDup("OUTPUT_FORMAT_XML");
      tt->enum_def.fields[1].val = OUTPUT_FORMAT_XML;
      tt->enum_def.fields[2].name = tdrpStrDup("OUTPUT_FORMAT_NCF");
      tt->enum_def.fields[2].val = OUTPUT_FORMAT_NCF;
    tt->single_val.e = OUTPUT_FORMAT_MDV;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("WRITE USING EXTENDED PATHS");
    tt->comment_text = tdrpStrDup("This will be overridden if the environment variable MDV_WRITE_USING_EXTENDED_PATHS exists and is set to TRUE.");
    tt++;
    
    // Parameter 'write_using_extended_paths'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_using_extended_paths");
    tt->descr = tdrpStrDup("Option to write files with extended paths.");
    tt->help = tdrpStrDup("If specified, this will override that specified by the client. Default is FALSE.\n\nIf set, paths will include a separate year subdirectory, and the file name will include date and time.\n\nNon-forecast path:\n  dir/yyyy/yyyymmdd/yyyymmdd_hhmmss.mdv.\n\nForecast path:\n  dir/yyyy/yyyymmdd/yyyymmdd_g_hhmmss_f_llllllll.mdv.");
    tt->val_offset = (char *) &write_using_extended_paths - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("CONTROL OF CONVERSION TO NETCDF.");
    tt->comment_text = tdrpStrDup("The following parameters control conversion of MDV files to NetCDF CF-compliant files.");
    tt++;
    
    // Parameter 'ncf_set_global_attributes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_set_global_attributes");
    tt->descr = tdrpStrDup("Option to set specify global attributes in the NCF file.");
    tt->help = tdrpStrDup("The global attributes are 'institution', 'references' and 'comment'.");
    tt->val_offset = (char *) &ncf_set_global_attributes - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_global_attributes'
    // ctype is '_ncf_global_attributes_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ncf_global_attributes");
    tt->descr = tdrpStrDup("Global attributes for netCDF file");
    tt->help = tdrpStrDup("These strings will be included as global attributes in the NetCDF file. Other global attributes will be determined from the MDV headers.");
    tt->val_offset = (char *) &ncf_global_attributes - &_start_;
    tt->struct_def.name = tdrpStrDup("ncf_global_attributes_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("institution");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ncf_global_attributes.institution - (char *) &ncf_global_attributes;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("references");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ncf_global_attributes.references - (char *) &ncf_global_attributes;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("comment");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &ncf_global_attributes.comment - (char *) &ncf_global_attributes;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("NCAR");
      tt->struct_vals[1].s = tdrpStrDup("");
      tt->struct_vals[2].s = tdrpStrDup("Converted by MdvPull");
    tt++;
    
    // Parameter 'ncf_transform_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_transform_fields");
    tt->descr = tdrpStrDup("Option to tranform field names, units and values when converting MDV to NCF.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_transform_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_field_transforms'
    // ctype is '_ncf_field_transform_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ncf_field_transforms");
    tt->descr = tdrpStrDup("List of transforms. If mdv_field_name is found in the MDV data, these other parameters will be used to set the field variable in the netCDF file.");
    tt->help = tdrpStrDup("See mdv2ncf_transform_fields.");
    tt->array_offset = (char *) &_ncf_field_transforms - &_start_;
    tt->array_n_offset = (char *) &ncf_field_transforms_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(ncf_field_transform_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("ncf_field_transform_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("mdv_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_ncf_field_transforms->mdv_field_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("ncf_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_field_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("ncf_standard_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_standard_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("ncf_long_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_long_name - (char *) _ncf_field_transforms;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("ncf_units");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_ncf_field_transforms->ncf_units - (char *) _ncf_field_transforms;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("do_linear_transform");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_ncf_field_transforms->do_linear_transform - (char *) _ncf_field_transforms;
      tt->struct_def.fields[6].ftype = tdrpStrDup("float");
      tt->struct_def.fields[6].fname = tdrpStrDup("linear_multiplier");
      tt->struct_def.fields[6].ptype = FLOAT_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_ncf_field_transforms->linear_multiplier - (char *) _ncf_field_transforms;
      tt->struct_def.fields[7].ftype = tdrpStrDup("float");
      tt->struct_def.fields[7].fname = tdrpStrDup("linear_const");
      tt->struct_def.fields[7].ptype = FLOAT_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_ncf_field_transforms->linear_const - (char *) _ncf_field_transforms;
      tt->struct_def.fields[8].ftype = tdrpStrDup("data_pack_t");
      tt->struct_def.fields[8].fname = tdrpStrDup("packed_data_type");
      tt->struct_def.fields[8].ptype = ENUM_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_ncf_field_transforms->packed_data_type - (char *) _ncf_field_transforms;
        tt->struct_def.fields[8].enum_def.name = tdrpStrDup("data_pack_t");
        tt->struct_def.fields[8].enum_def.nfields = 4;
        tt->struct_def.fields[8].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[8].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[8].enum_def.fields[0].name = tdrpStrDup("DATA_PACK_FLOAT");
        tt->struct_def.fields[8].enum_def.fields[0].val = DATA_PACK_FLOAT;
        tt->struct_def.fields[8].enum_def.fields[1].name = tdrpStrDup("DATA_PACK_SHORT");
        tt->struct_def.fields[8].enum_def.fields[1].val = DATA_PACK_SHORT;
        tt->struct_def.fields[8].enum_def.fields[2].name = tdrpStrDup("DATA_PACK_BYTE");
        tt->struct_def.fields[8].enum_def.fields[2].val = DATA_PACK_BYTE;
        tt->struct_def.fields[8].enum_def.fields[3].name = tdrpStrDup("DATA_PACK_ASIS");
        tt->struct_def.fields[8].enum_def.fields[3].val = DATA_PACK_ASIS;
    tt->n_struct_vals = 9;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("mdv_field_name");
      tt->struct_vals[1].s = tdrpStrDup("ncf_field_name");
      tt->struct_vals[2].s = tdrpStrDup("ncf_standard_name");
      tt->struct_vals[3].s = tdrpStrDup("ncf_long_name");
      tt->struct_vals[4].s = tdrpStrDup("ncf_units");
      tt->struct_vals[5].b = pFALSE;
      tt->struct_vals[6].f = 1;
      tt->struct_vals[7].f = 0;
      tt->struct_vals[8].e = DATA_PACK_ASIS;
    tt++;
    
    // Parameter 'ncf_compress_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_compress_data");
    tt->descr = tdrpStrDup("Option to compress field data.");
    tt->help = tdrpStrDup("Only applies to NETCDF4 and  NETCDF4_CLASSIC files.");
    tt->val_offset = (char *) &ncf_compress_data - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_compression_level'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("ncf_compression_level");
    tt->descr = tdrpStrDup("Compression level from 1 to 9 with 9 being the greatest compression. Default is 9.");
    tt->help = tdrpStrDup("Only applies to NETCDF4 and  NETCDF4_CLASSIC files.");
    tt->val_offset = (char *) &ncf_compression_level - &_start_;
    tt->single_val.i = 9;
    tt++;
    
    // Parameter 'ncf_base_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_base_name");
    tt->descr = tdrpStrDup("Base name for netCDF files");
    tt->help = tdrpStrDup("This will be the start of the file name.");
    tt->val_offset = (char *) &ncf_base_name - &_start_;
    tt->single_val.s = tdrpStrDup("ncf");
    tt++;
    
    // Parameter 'ncf_file_prefix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_file_prefix");
    tt->descr = tdrpStrDup("User-specified output file prefix, comes before basename");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_file_prefix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_file_suffix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_file_suffix");
    tt->descr = tdrpStrDup("Suffix of netCDF files");
    tt->help = tdrpStrDup("File extension is always .nc. File name will end with mdv.suffix.nc. Set to the empty string for no suffix, in which case file name will end with .mdv.nc.");
    tt->val_offset = (char *) &ncf_file_suffix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_file_format'
    // ctype is '_ncf_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("ncf_file_format");
    tt->descr = tdrpStrDup("NetCDF file format");
    tt->help = tdrpStrDup("netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls");
    tt->val_offset = (char *) &ncf_file_format - &_start_;
    tt->enum_def.name = tdrpStrDup("ncf_format_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLASSIC");
      tt->enum_def.fields[0].val = CLASSIC;
      tt->enum_def.fields[1].name = tdrpStrDup("NC64BIT");
      tt->enum_def.fields[1].val = NC64BIT;
      tt->enum_def.fields[2].name = tdrpStrDup("NETCDF4");
      tt->enum_def.fields[2].val = NETCDF4;
      tt->enum_def.fields[3].name = tdrpStrDup("NETCDF4_CLASSIC");
      tt->enum_def.fields[3].val = NETCDF4_CLASSIC;
    tt->single_val.e = NETCDF4;
    tt++;
    
    // Parameter 'ncf_polar_radar_file_type'
    // ctype is '_radial_file_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("ncf_polar_radar_file_type");
    tt->descr = tdrpStrDup("Output format for polar radar data.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_polar_radar_file_type - &_start_;
    tt->enum_def.name = tdrpStrDup("radial_file_type_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FILE_TYPE_CF");
      tt->enum_def.fields[0].val = FILE_TYPE_CF;
      tt->enum_def.fields[1].name = tdrpStrDup("FILE_TYPE_CF_RADIAL");
      tt->enum_def.fields[1].val = FILE_TYPE_CF_RADIAL;
      tt->enum_def.fields[2].name = tdrpStrDup("FILE_TYPE_DORADE");
      tt->enum_def.fields[2].val = FILE_TYPE_DORADE;
      tt->enum_def.fields[3].name = tdrpStrDup("FILE_TYPE_UF");
      tt->enum_def.fields[3].val = FILE_TYPE_UF;
    tt->single_val.e = FILE_TYPE_CF;
    tt++;
    
    // Parameter 'ncf_output_latlon_arrays'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_latlon_arrays");
    tt->descr = tdrpStrDup("If true latitude and longitude arrays of each grid point are output");
    tt->help = tdrpStrDup("The CF convention requires that these arrays are present in the netCDF file; however, the information is redundant since the lat and lon arrays could be constructed using the other projection and grid information required with a gridded data field");
    tt->val_offset = (char *) &ncf_output_latlon_arrays - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_output_mdv_attributes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_mdv_attributes");
    tt->descr = tdrpStrDup("Option to output non-CF compliant MDV attributes.");
    tt->help = tdrpStrDup("If true, MDV attributes which are not CF compliant will be output. This will facilitate the translation of the data back into MDV with the minimal loss of information.");
    tt->val_offset = (char *) &ncf_output_mdv_attributes - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_output_mdv_chunks'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_mdv_chunks");
    tt->descr = tdrpStrDup("Option to output non-CF compliant MDV chunks.");
    tt->help = tdrpStrDup("If true, MDV chunks will be included as byte binary variables.");
    tt->val_offset = (char *) &ncf_output_mdv_chunks - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
