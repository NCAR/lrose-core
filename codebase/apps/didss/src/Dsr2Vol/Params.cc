/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Dsr2Vol
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Dsr2Vol program");
    tt->comment_text = tdrpStrDup("Dsr2Volreads an input FMQ containing radar data, and writes it to a file in MDV format. Grid remapping and spatial interpolation are optional.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url");
    tt->descr = tdrpStrDup("Input URL for DsRadar data via FMQ");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::./fmq.dsRadar");
    tt++;
    
    // Parameter 'seek_to_end_of_input'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("seek_to_end_of_input");
    tt->descr = tdrpStrDup("Option to seek to the end of the input FMQ.");
    tt->help = tdrpStrDup("If TRUE, the program will seek to the end of the fmq and only read in new data. If FALSE, it will start reading from the beginning of the FMQ.");
    tt->val_offset = (char *) &seek_to_end_of_input - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'end_of_vol_decision'
    // ctype is '_end_of_vol_decision_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("end_of_vol_decision");
    tt->descr = tdrpStrDup("Decision type for end-of-volume.");
    tt->help = tdrpStrDup("If END_OF_VOL_FLAG, the end-of-volume flag in the data will be used to trigger the end of volume. If CHANGE_IN_VOL_NUM, and end of volume will be assumed when the volume number changes from one beam to the next. If LAST_TILT_IN_VOL, the end of the tilt number given by 'last_tilt_in_vol' will be used  to trigger the end-of-volume. If AUTOMATIC, this program will determine the end-of-volume condition by using the antenna-angle information. If END_OF_VOL_NONE, it will trigger an end of vol when max_beams_in_vol is reached. If DECREASE_IN_ELEV, it will trigger an end of volume when the elevation angle decreases by 'min_elevation_decrease'.");
    tt->val_offset = (char *) &end_of_vol_decision - &_start_;
    tt->enum_def.name = tdrpStrDup("end_of_vol_decision_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("END_OF_VOL_FLAG");
      tt->enum_def.fields[0].val = END_OF_VOL_FLAG;
      tt->enum_def.fields[1].name = tdrpStrDup("CHANGE_IN_VOL_NUM");
      tt->enum_def.fields[1].val = CHANGE_IN_VOL_NUM;
      tt->enum_def.fields[2].name = tdrpStrDup("LAST_TILT_IN_VOL");
      tt->enum_def.fields[2].val = LAST_TILT_IN_VOL;
      tt->enum_def.fields[3].name = tdrpStrDup("AUTOMATIC");
      tt->enum_def.fields[3].val = AUTOMATIC;
      tt->enum_def.fields[4].name = tdrpStrDup("END_OF_VOL_NONE");
      tt->enum_def.fields[4].val = END_OF_VOL_NONE;
      tt->enum_def.fields[5].name = tdrpStrDup("DECREASE_IN_ELEV");
      tt->enum_def.fields[5].val = DECREASE_IN_ELEV;
    tt->single_val.e = END_OF_VOL_FLAG;
    tt++;
    
    // Parameter 'last_tilt_in_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("last_tilt_in_vol");
    tt->descr = tdrpStrDup("The tilt number used to end the volume.");
    tt->help = tdrpStrDup("Only applies if 'end_of_vol_decision' is set to LAST_TILT_IN_VOL.");
    tt->val_offset = (char *) &last_tilt_in_vol - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'min_elevation_decrease'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_elevation_decrease");
    tt->descr = tdrpStrDup("The minimum decrease in the elevation angle that is  used to end the volume.");
    tt->help = tdrpStrDup("Only applies if 'end_of_vol_decision' is set to DECREASE_IN_ELEV.");
    tt->val_offset = (char *) &min_elevation_decrease - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'write_end_of_vol_when_data_stops'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_end_of_vol_when_data_stops");
    tt->descr = tdrpStrDup("Write end of vol event when data stops.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &write_end_of_vol_when_data_stops - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nsecs_no_data_for_end_of_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nsecs_no_data_for_end_of_vol");
    tt->descr = tdrpStrDup("Number of secs before writing end of vol.");
    tt->help = tdrpStrDup("See 'write_end_of_vol_when_data_stops'");
    tt->val_offset = (char *) &nsecs_no_data_for_end_of_vol - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'nbeams_overlap_per_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nbeams_overlap_per_vol");
    tt->descr = tdrpStrDup("The number of beams copied from the previous vol.");
    tt->help = tdrpStrDup("If non-zero, this number of beams is copied from the previous volume into the current one, at the start of the current volume. This is useful if the exact timing of the end-of-vol condition is in question, so that the data around the end-of-vol can be used in both volumes. If you set end_of_vol_decision to AUTOMATIC, it is recommended that you set this value to between 20 and 50, because the end-of-vol decision may be a few beams late.");
    tt->val_offset = (char *) &nbeams_overlap_per_vol - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'min_beams_in_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_beams_in_vol");
    tt->descr = tdrpStrDup("The minimum number of beams in a volume.");
    tt->help = tdrpStrDup("This filters out small unwanted bits of data between genuine volumes.");
    tt->val_offset = (char *) &min_beams_in_vol - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'max_beams_in_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_beams_in_vol");
    tt->descr = tdrpStrDup("The maximum number of beams in a volume.");
    tt->help = tdrpStrDup("This prevents memory from filling up if no end-of-volume is found.");
    tt->val_offset = (char *) &max_beams_in_vol - &_start_;
    tt->single_val.i = 20000;
    tt++;
    
    // Parameter 'use_input_scan_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_input_scan_mode");
    tt->descr = tdrpStrDup("Option to use the scan_mode in the input data.");
    tt->help = tdrpStrDup("The scan_mode indicates whether the scan is of type SURVEILLANCE/PPI RHI. The scan_mode is optionally included in the beam data. If available, it makes sense to use the scan mode to determine whether to save the data as a SURVEILLANCE/PPI or RHI. Dsr2Vol treats SURVEILLANCE and PPI data in the same manner. However, RHIs are saved in a different way. If the input scan_mode is NOT used, Dsr2Vol uses the antenna angle changes to determine whether the scan is in PPI or RHI mode.");
    tt->val_offset = (char *) &use_input_scan_mode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_input_tilt_numbers'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_input_tilt_numbers");
    tt->descr = tdrpStrDup("Option to use tilt numbers instead of the elevation histogram.");
    tt->help = tdrpStrDup("If TRUE, the tilt numbers in the beam data will be used directly to group the beams into tilts. If FALSE, the antenna angles will be analysed using a histogram technique to determine the tilt numbers.");
    tt->val_offset = (char *) &use_input_tilt_numbers - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("COMPUTING THE ELEVATION HISTOGRAM");
    tt->comment_text = tdrpStrDup("The program needs to determine the elevation angles used in the scan strategy. It does this by creating a histgram of elevation angles, and looking for peaks in this histogram.");
    tt++;
    
    // Parameter 'use_target_elev'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_target_elev");
    tt->descr = tdrpStrDup("Option to use target elevation angles instead of actual.");
    tt->help = tdrpStrDup("If TRUE, the beam elevation will be set to the target elevation angle, and the actual elevation angle will be ignored.");
    tt->val_offset = (char *) &use_target_elev - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'elev_hist_resolution'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_hist_resolution");
    tt->descr = tdrpStrDup("Resolution of elevation histogram (deg).");
    tt->help = tdrpStrDup("The elevation data is binned at this resolution. If the scan strategy has elevations very close together you may need to decrease this.");
    tt->val_offset = (char *) &elev_hist_resolution - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'elev_hist_search_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("elev_hist_search_width");
    tt->descr = tdrpStrDup("The width of the search in looking for peaks in the histogram.");
    tt->help = tdrpStrDup("When looking for peaks, the program searches by this number of bins on either side of the search bin. For example, if the elev_hist_resolution is 0.1 and the elev_hist_search_width is 3, the program will search 3 bins, or 0.3 degrees, on either side of the search bin. It looks for a peak with values equal to or below the peak in the adjacent bins and less than the peak in bins further out.");
    tt->val_offset = (char *) &elev_hist_search_width - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'elev_hist_start'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_hist_start");
    tt->descr = tdrpStrDup("Histogram start value (deg).");
    tt->help = tdrpStrDup("The elev value for the lowest bin in the histogram.");
    tt->val_offset = (char *) &elev_hist_start - &_start_;
    tt->single_val.d = -10;
    tt++;
    
    // Parameter 'elev_hist_end'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_hist_end");
    tt->descr = tdrpStrDup("Histogram end value (deg).");
    tt->help = tdrpStrDup("The elev value for the highest bin in the histogram.");
    tt->val_offset = (char *) &elev_hist_end - &_start_;
    tt->single_val.d = 90;
    tt++;
    
    // Parameter 'specify_elev_delta'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("specify_elev_delta");
    tt->descr = tdrpStrDup("Option to specify the delta elevation instead of using the elevation histogram.");
    tt->help = tdrpStrDup("This is useful if you have RHI data as input but want to store the output as PPIs. Specify the delta elevation.");
    tt->val_offset = (char *) &specify_elev_delta - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'elev_delta'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_delta");
    tt->descr = tdrpStrDup("The delta elevation to be used (deg).");
    tt->help = tdrpStrDup("See 'specify_elev_delta'.");
    tt->val_offset = (char *) &elev_delta - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("CHECKING TILT DATA");
    tt->comment_text = tdrpStrDup("Checking whether tilts should be included.");
    tt++;
    
    // Parameter 'check_min_beams_in_tilt'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_beams_in_tilt");
    tt->descr = tdrpStrDup("Option to check the number of beams in a tilt.");
    tt->help = tdrpStrDup("If TRUE, a tilt is only considered valid if the number of beams exceeds 'min_beams_in_tilt'.");
    tt->val_offset = (char *) &check_min_beams_in_tilt - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'min_beams_in_tilt'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_beams_in_tilt");
    tt->descr = tdrpStrDup("The min number of beams for a tilt to be valid.");
    tt->help = tdrpStrDup("See 'check_min_beams_in_tilt'.");
    tt->val_offset = (char *) &min_beams_in_tilt - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'check_min_fraction_in_tilt'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_fraction_in_tilt");
    tt->descr = tdrpStrDup("Option to check the fraction of beams in a tilt.");
    tt->help = tdrpStrDup("If TRUE, a tilt is only considered valid if the number of beams in the tilt, expressed as a fraction of the max number of beams in any tilt, exceeds 'min_fraction_in_tilt'.");
    tt->val_offset = (char *) &check_min_fraction_in_tilt - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'min_fraction_in_tilt'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_fraction_in_tilt");
    tt->descr = tdrpStrDup("The min fraction of max beams for a tilt to be valid.");
    tt->help = tdrpStrDup("See 'check_min_fraction_in_tilt'.");
    tt->val_offset = (char *) &min_fraction_in_tilt - &_start_;
    tt->single_val.d = 0.5;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("CENSORING USING A SPECIFIED FIELD AND/OR SIGNAL-TO-NOISE RATIO");
    tt->comment_text = tdrpStrDup("You have the option of filtering the output data based on the value of a specified field and/or the signal-to-noise ratio. If both methods are activated, then both methods must trigger at a gate for censoring to occur. For example, suppose you set thresholding on for NCP from 0.2 to 1.0, and sn_threshold of 3.0. Then, for censoring to occur, NCP must be below 0.2 and SNR must be below 3.");
    tt++;
    
    // Parameter 'filter_output_using_thresholds'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_output_using_thresholds");
    tt->descr = tdrpStrDup("Option to censor the output fields using a min and max threshold on a specified field.");
    tt->help = tdrpStrDup("If TRUE, the value of the threshold field at a gate will be examined to see if it is within the desired range. Normally NCP (normalized coherent power) will be used for this purpose. If the specified field at a gate falls outside the specified range, a censoring flag will be set. If check_sn is also set, the SNR at the gate will also be checked. If both of these tests indicate censoring, then all of the fields at the gate will be censored. If cgeck_sn is false, then only the threshold test will be used for censoring.");
    tt->val_offset = (char *) &filter_output_using_thresholds - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'threshold_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("threshold_field_name");
    tt->descr = tdrpStrDup("Name of field for thresholding.");
    tt->help = tdrpStrDup("This is the DSR (input) field name for the thresholding field. If this field is available, it is used for thresholding. If not, thresholding will not be performed.");
    tt->val_offset = (char *) &threshold_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("NCP");
    tt++;
    
    // Parameter 'threshold_min_value'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("threshold_min_value");
    tt->descr = tdrpStrDup("Minimum threshold - see 'filter_output_using_thresholds'.");
    tt->help = tdrpStrDup("If the value of the thresholding field at a gate is below this value, the gate is flagged as a candidate for censoring.");
    tt->val_offset = (char *) &threshold_min_value - &_start_;
    tt->single_val.d = 0.3;
    tt++;
    
    // Parameter 'threshold_max_value'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("threshold_max_value");
    tt->descr = tdrpStrDup("Maximum threshold - see 'filter_output_using_thresholds'.");
    tt->help = tdrpStrDup("If the value of the thresholding field at a gate is above this value, the gate is flagged as a candidate for censoring.");
    tt->val_offset = (char *) &threshold_max_value - &_start_;
    tt->single_val.d = 1.1;
    tt++;
    
    // Parameter 'check_sn'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_sn");
    tt->descr = tdrpStrDup("Option to check the signal-to-noise for censoring purposes.");
    tt->help = tdrpStrDup("If TRUE, the signal-to-noise ratio value will be checked at each gate. If the NSR value is below 'sn_threshold', it will be flagged for censoring. If filter_output_using_thresholds is also true, then both methods must trigger for censoring to occur.");
    tt->val_offset = (char *) &check_sn - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'snr_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("snr_field_name");
    tt->descr = tdrpStrDup("Specify the name of SNR field.");
    tt->help = tdrpStrDup("This is the DSR (input) field name for SNR. NOTE - you must also include this field in the output_fields array if you want to threshold on SNR. If this field is not available or is not in the output field list, DBZ will be used to estimate SNR. See 'noise_dbz_at_100km'.");
    tt->val_offset = (char *) &snr_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("SNR");
    tt++;
    
    // Parameter 'sn_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sn_threshold");
    tt->descr = tdrpStrDup("Signal-to-noise threshold for censoring.");
    tt->help = tdrpStrDup("See 'check_sn'.");
    tt->val_offset = (char *) &sn_threshold - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'noise_dbz_at_100km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("noise_dbz_at_100km");
    tt->descr = tdrpStrDup("The receiver noise power, represented as dBZ at a range of 100km.");
    tt->help = tdrpStrDup("This is used for computing the SNR value from the DBZ field. This will be used if SNR is not available. See 'snr_field_name'.");
    tt->val_offset = (char *) &noise_dbz_at_100km - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'filtering_min_valid_run'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("filtering_min_valid_run");
    tt->descr = tdrpStrDup("Minimum valid run of non-censored gates.");
    tt->help = tdrpStrDup("Only active if set to 2 or greater. A check is made to remove short runs of noise. Looking along the radial, we compute the number of contiguous gates (a 'run') with uncensored data. For the gates in this run to be accepted the length of the run must exceed censoring_min_valid_run. If the number of gates in a run is less than this, then all gates in the run are censored.");
    tt->val_offset = (char *) &filtering_min_valid_run - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("FILLING IN MISSING BEAMS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'bridge_missing_in_azimuth'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("bridge_missing_in_azimuth");
    tt->descr = tdrpStrDup("Option to bridge over missing beams in azimuth.");
    tt->help = tdrpStrDup("If true, missing beams in azimuth will be filled in by interpolating from the adjacent two beams. Only a single missing beam will be filled in. If more than one is missing, they will not be filled in. Azimuth filling is done first, before elevation filling.");
    tt->val_offset = (char *) &bridge_missing_in_azimuth - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'bridge_missing_in_elevation'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("bridge_missing_in_elevation");
    tt->descr = tdrpStrDup("Option to bridge over missing beams in elevation.");
    tt->help = tdrpStrDup("If true, missing beams in elevation will be filled in by interpolating from the adjacent two beams. Only a single missing beam will be filled in. If more than one is missing, they will not be filled in. The elevation interpolation is done after the asimuth interpolation is complete.");
    tt->val_offset = (char *) &bridge_missing_in_elevation - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("CHECK FOR MOVING ANTENNA");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'check_antenna_moving'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_antenna_moving");
    tt->descr = tdrpStrDup("Option to check that the antenna is moving.");
    tt->help = tdrpStrDup("If true, beams will only be stored if the antenna is moving. If the antenna stops, beams will be ignored.");
    tt->val_offset = (char *) &check_antenna_moving - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_angle_change'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_angle_change");
    tt->descr = tdrpStrDup("Minimun angle change beam-to-beam (deg).");
    tt->help = tdrpStrDup("For the antenna to be considered moving. the antenna much move by this amount from one beam to the next. The angle check is made in both azimuth and elevation.");
    tt->val_offset = (char *) &min_angle_change - &_start_;
    tt->single_val.d = 0.05;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("REMOVING TEST PULSE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'remove_test_pulse'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_test_pulse");
    tt->descr = tdrpStrDup("Option to remove the test pulse data.");
    tt->help = tdrpStrDup("If true, the test pulse data will be removed from the end of the beam. The test pulse data generally lies in the last few gates in the beam. If true, the number of gates will be reduced by 'ngates_test_pulse'.");
    tt->val_offset = (char *) &remove_test_pulse - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ngates_test_pulse'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("ngates_test_pulse");
    tt->descr = tdrpStrDup("Number of gates to remove to get rid of test pulse.");
    tt->help = tdrpStrDup("See 'remove_test_pulse'.");
    tt->val_offset = (char *) &ngates_test_pulse - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("RADAR PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'delta_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("delta_az");
    tt->descr = tdrpStrDup("Target delta azimuth (deg).");
    tt->help = tdrpStrDup("The target spacing of the data beams in azimuth. NOTE: the lookup table is computed assuming that there is an exact number of beams per 45-degree sector. If delta_az does not satisfy this requirement, it will be adjusted upwards to the next suitable value.\n\tIMPORTANT NOTE: if the beams are indexed in azimuith, the indexed resolution will override this parameter.");
    tt->val_offset = (char *) &delta_az - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'az_correction'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("az_correction");
    tt->descr = tdrpStrDup("Correction to angular azimuth values (deg).");
    tt->help = tdrpStrDup("This correction is applied to the azimuth angles before computing the azimuth position.");
    tt->val_offset = (char *) &az_correction - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'override_radar_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_location");
    tt->descr = tdrpStrDup("Option to override radar location.");
    tt->help = tdrpStrDup("If TRUE, the program will use location specified in the 'radar_location' parameter.");
    tt->val_offset = (char *) &override_radar_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_location'
    // ctype is '_radar_location_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("radar_location");
    tt->descr = tdrpStrDup("Radar location if override is set true.");
    tt->help = tdrpStrDup("The radar_location is only used if 'override_radar_location' is set true. Otherwise the information in the input data stream is used. Note that the altitude is in kilometers, not meters.");
    tt->val_offset = (char *) &radar_location - &_start_;
    tt->struct_def.name = tdrpStrDup("radar_location_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("latitude");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &radar_location.latitude - (char *) &radar_location;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("longitude");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &radar_location.longitude - (char *) &radar_location;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("altitude");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &radar_location.altitude - (char *) &radar_location;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0;
    tt++;
    
    // Parameter 'override_beam_width'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_beam_width");
    tt->descr = tdrpStrDup("Option to override radar beam width.");
    tt->help = tdrpStrDup("If TRUE, the program will use beam width specified in the 'beam_width' parameter.");
    tt->val_offset = (char *) &override_beam_width - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'beam_width'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("beam_width");
    tt->descr = tdrpStrDup("Radar beam width if override is set true.");
    tt->help = tdrpStrDup("The beam width is only used if 'override_beam_width' is set true. Otherwise the information in the input data stream is used.");
    tt->val_offset = (char *) &beam_width - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'radar_description'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_description");
    tt->descr = tdrpStrDup("General description of radar.");
    tt->help = tdrpStrDup("Used for data_set_info in MDV file.");
    tt->val_offset = (char *) &radar_description - &_start_;
    tt->single_val.s = tdrpStrDup("not-set");
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("FILTER DATA BASED ON GEOMETRY or PRF");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'filter_gate_spacing'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_gate_spacing");
    tt->descr = tdrpStrDup("Option to filter data based on gate spacing.");
    tt->help = tdrpStrDup("If TRUE, the program will use only beam data which matches the 'keep_gate_spacing' parameter.");
    tt->val_offset = (char *) &filter_gate_spacing - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'keep_gate_spacing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("keep_gate_spacing");
    tt->descr = tdrpStrDup("Desired radar gate spacing (km).");
    tt->help = tdrpStrDup("The specified gate spacing is only used if 'filter_gate_spacing' is set true. Otherwise all gate spacings in the input data stream are used.");
    tt->val_offset = (char *) &keep_gate_spacing - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'filter_start_range'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_start_range");
    tt->descr = tdrpStrDup("Option to filter data based on start range.");
    tt->help = tdrpStrDup("If TRUE, the program will use only beam data which matches the 'keep _start_range' parameter.");
    tt->val_offset = (char *) &filter_start_range - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'keep_start_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("keep_start_range");
    tt->descr = tdrpStrDup("Desired radar start range (km).");
    tt->help = tdrpStrDup("The specified start range is only used if 'filter_start_range' is set true. Otherwise all start ranges in the input data stream are used.");
    tt->val_offset = (char *) &keep_start_range - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'filter_prf'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_prf");
    tt->descr = tdrpStrDup("Option to filter data based on PRF.");
    tt->help = tdrpStrDup("If TRUE, the program will use only beam data with PRFs between the given limits.");
    tt->val_offset = (char *) &filter_prf - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_prf'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_prf");
    tt->descr = tdrpStrDup("Minimum acceptable PRF (/s).");
    tt->help = tdrpStrDup("See 'filter_prf'.");
    tt->val_offset = (char *) &min_prf - &_start_;
    tt->single_val.d = 100;
    tt++;
    
    // Parameter 'max_prf'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_prf");
    tt->descr = tdrpStrDup("Maximum acceptable PRF (/s).");
    tt->help = tdrpStrDup("See 'filter_prf'.");
    tt->val_offset = (char *) &max_prf - &_start_;
    tt->single_val.d = 2000;
    tt++;
    
    // Parameter 'filter_elev'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_elev");
    tt->descr = tdrpStrDup("Option to filter data based on elevation angle.");
    tt->help = tdrpStrDup("If TRUE, the program will use only beam data with elevations between the given limits.");
    tt->val_offset = (char *) &filter_elev - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_elev'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_elev");
    tt->descr = tdrpStrDup("Minimum valid elevation for beams (deg).");
    tt->help = tdrpStrDup("If the elevation is below this value, the beam is ignored.");
    tt->val_offset = (char *) &min_elev - &_start_;
    tt->single_val.d = -10;
    tt++;
    
    // Parameter 'max_elev'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_elev");
    tt->descr = tdrpStrDup("Maximum valid elevation for beams (deg).");
    tt->help = tdrpStrDup("If the elevation is above this value, the beam is ignored.");
    tt->val_offset = (char *) &max_elev - &_start_;
    tt->single_val.d = 90;
    tt++;
    
    // Parameter 'filter_antenna_transitions'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_antenna_transitions");
    tt->descr = tdrpStrDup("Option to filter data when the transition flag is set.");
    tt->help = tdrpStrDup("If TRUE, the program will filter out beams which are computed when the antenna is moving from one tilt to the next, or one volume to the next.");
    tt->val_offset = (char *) &filter_antenna_transitions - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("INTERPOLATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'min_nvalid_for_interp'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_nvalid_for_interp");
    tt->descr = tdrpStrDup("Minimum number of valid data points for theinterpolation.");
    tt->help = tdrpStrDup("The program performs an 8-point linear interpolation. This is the number of valid data points, out of the possible 8, which must be present for interpolation to proceed. A high number will exclude marginal points. A low number will include marginal points.");
    tt->val_offset = (char *) &min_nvalid_for_interp - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 1;
    tt->max_val.i = 8;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("OUTPUT FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_compression'
    // ctype is '_compression_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_compression");
    tt->descr = tdrpStrDup("Output compression options.");
    tt->help = tdrpStrDup("The data may be optionally compressed for output. BZIP is generally the slowest but most compact. ZLIB uses the gzip compression algorithm, which is faster than BZIP, and for some data more compact as well. LZO is faster than BZIP and ZLIB, but not as compact. RLE is simple run-length encoding compression, which is the fastest and least compact.");
    tt->val_offset = (char *) &output_compression - &_start_;
    tt->enum_def.name = tdrpStrDup("compression_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("NO_COMPRESSION");
      tt->enum_def.fields[0].val = NO_COMPRESSION;
      tt->enum_def.fields[1].name = tdrpStrDup("RLE_COMPRESSION");
      tt->enum_def.fields[1].val = RLE_COMPRESSION;
      tt->enum_def.fields[2].name = tdrpStrDup("LZO_COMPRESSION");
      tt->enum_def.fields[2].val = LZO_COMPRESSION;
      tt->enum_def.fields[3].name = tdrpStrDup("ZLIB_COMPRESSION");
      tt->enum_def.fields[3].val = ZLIB_COMPRESSION;
      tt->enum_def.fields[4].name = tdrpStrDup("BZIP_COMPRESSION");
      tt->enum_def.fields[4].val = BZIP_COMPRESSION;
      tt->enum_def.fields[5].name = tdrpStrDup("GZIP_COMPRESSION");
      tt->enum_def.fields[5].val = GZIP_COMPRESSION;
    tt->single_val.e = ZLIB_COMPRESSION;
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_output_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("Array of output fields.");
    tt->help = tdrpStrDup("The program will only output these fields. The dsr_name is the field name in the dsr data. If the output_name is an empty string, the output name will be set to the dsr_name. If output_name is non-empty, this will be used. Likewise for the units. Set the transform to dB, dBZ or none. Indicate the dBZ field by setting is_dbz to true. Set interp_db_as_power if you want to compute power from db before interpolating. Set is_vel for velocity field so that interpolation can take nyquist folding into account. If allow_interp is set to false, interpolation is not permitted on this field, and nearest-neighbor will be used instead. Set the output encoding type to select the resolution of the output data.");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(output_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("output_field_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("dsr_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_fields->dsr_name - (char *) _output_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("output_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_fields->output_name - (char *) _output_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("output_units");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_output_fields->output_units - (char *) _output_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("transform");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_output_fields->transform - (char *) _output_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[4].fname = tdrpStrDup("is_dbz");
      tt->struct_def.fields[4].ptype = BOOL_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_output_fields->is_dbz - (char *) _output_fields;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("interp_db_as_power");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_output_fields->interp_db_as_power - (char *) _output_fields;
      tt->struct_def.fields[6].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[6].fname = tdrpStrDup("is_vel");
      tt->struct_def.fields[6].ptype = BOOL_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_output_fields->is_vel - (char *) _output_fields;
      tt->struct_def.fields[7].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[7].fname = tdrpStrDup("allow_interp");
      tt->struct_def.fields[7].ptype = BOOL_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_output_fields->allow_interp - (char *) _output_fields;
      tt->struct_def.fields[8].ftype = tdrpStrDup("encoding_t");
      tt->struct_def.fields[8].fname = tdrpStrDup("encoding");
      tt->struct_def.fields[8].ptype = ENUM_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_output_fields->encoding - (char *) _output_fields;
        tt->struct_def.fields[8].enum_def.name = tdrpStrDup("encoding_t");
        tt->struct_def.fields[8].enum_def.nfields = 3;
        tt->struct_def.fields[8].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[8].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[8].enum_def.fields[0].name = tdrpStrDup("ENCODING_INT8");
        tt->struct_def.fields[8].enum_def.fields[0].val = ENCODING_INT8;
        tt->struct_def.fields[8].enum_def.fields[1].name = tdrpStrDup("ENCODING_INT16");
        tt->struct_def.fields[8].enum_def.fields[1].val = ENCODING_INT16;
        tt->struct_def.fields[8].enum_def.fields[2].name = tdrpStrDup("ENCODING_FLOAT32");
        tt->struct_def.fields[8].enum_def.fields[2].val = ENCODING_FLOAT32;
    tt->n_struct_vals = 18;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].s = tdrpStrDup("DBZ");
      tt->struct_vals[2].s = tdrpStrDup("dBZ");
      tt->struct_vals[3].s = tdrpStrDup("none");
      tt->struct_vals[4].b = pTRUE;
      tt->struct_vals[5].b = pFALSE;
      tt->struct_vals[6].b = pFALSE;
      tt->struct_vals[7].b = pTRUE;
      tt->struct_vals[8].e = ENCODING_INT8;
      tt->struct_vals[9].s = tdrpStrDup("VEL");
      tt->struct_vals[10].s = tdrpStrDup("VEL");
      tt->struct_vals[11].s = tdrpStrDup("m/s");
      tt->struct_vals[12].s = tdrpStrDup("none");
      tt->struct_vals[13].b = pFALSE;
      tt->struct_vals[14].b = pFALSE;
      tt->struct_vals[15].b = pTRUE;
      tt->struct_vals[16].b = pTRUE;
      tt->struct_vals[17].e = ENCODING_INT8;
    tt++;
    
    // Parameter 'output_coverage_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_coverage_field");
    tt->descr = tdrpStrDup("Option to output a field depicting radar coverage.");
    tt->help = tdrpStrDup("If true, and extra field, with the name 'Coverage', is included in the output. This is a simple flag field, with a 1 indicating that the radar covers that pixel, and a 0 indicating that is does not.");
    tt->val_offset = (char *) &output_coverage_field - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'override_missing_dbz_for_interp'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_missing_dbz_for_interp");
    tt->descr = tdrpStrDup("Option to set dBZ values if they are missing.");
    tt->help = tdrpStrDup("If true, missing dBZ values will be replaced by a low dbz value before interpolation takes place. If this is not done, non-missing dBZ values tend to be propagated into the missing areas, patricularly in the vertical dimension at long range where the vertical spacing between the beams is large. This leads to a ballooning of reflectivity from low heights.");
    tt->val_offset = (char *) &override_missing_dbz_for_interp - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'override_nyquist'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_nyquist");
    tt->descr = tdrpStrDup("Option to override nyquist velocity in incoming data.");
    tt->help = tdrpStrDup("If true, the nyquist_velocity parameter is used to specify the nyquist. If false, the nyquist is computed from the incoming radar data stream. The nyquist is used for velocity interpolation, to ensure that folded values are treated correctlty.");
    tt->val_offset = (char *) &override_nyquist - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nyquist_velocity'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("nyquist_velocity");
    tt->descr = tdrpStrDup("Specify nyquist velocity (m/s).");
    tt->help = tdrpStrDup("See 'override_nyquist'.");
    tt->val_offset = (char *) &nyquist_velocity - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("OUTPUT FILES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_cart_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_cart_files");
    tt->descr = tdrpStrDup("Option to output files with Cartesian geometry.");
    tt->help = tdrpStrDup("If true, the parameters in the cart_files array are used. The grid origin is at the radar. nxy is the number of grid points in x and y. dxy is the grid resolution in x and y. Therefore the grid is a square in x,y. nz is the number of CAPPI heights. minz is the height of the lowest CAPPI and dz is the height between successive CAPPIs. If interpolate is true, an 8-point linear interpolation grid transformation is performed. If interpolate is false, a nearest-neighbor transformation is performed. The MDV files are stored at mdv_url. The max_range parameter (km) can be used to limit the useful data range. Input data beyond this range is ignored. Set to a negative value to disable it, in which case no limit is placed on range.");
    tt->val_offset = (char *) &output_cart_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'cart_files'
    // ctype is '_cart_file_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("cart_files");
    tt->descr = tdrpStrDup("Details for files in cart geometry.");
    tt->help = tdrpStrDup("Only active if 'output_cart_files' is true.");
    tt->array_offset = (char *) &_cart_files - &_start_;
    tt->array_n_offset = (char *) &cart_files_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(cart_file_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("cart_file_t");
    tt->struct_def.nfields = 8;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nxy");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_cart_files->nxy - (char *) _cart_files;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("dxy");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_cart_files->dxy - (char *) _cart_files;
      tt->struct_def.fields[2].ftype = tdrpStrDup("int");
      tt->struct_def.fields[2].fname = tdrpStrDup("nz");
      tt->struct_def.fields[2].ptype = INT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_cart_files->nz - (char *) _cart_files;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("minz");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_cart_files->minz - (char *) _cart_files;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dz");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_cart_files->dz - (char *) _cart_files;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("interpolate");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_cart_files->interpolate - (char *) _cart_files;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("mdv_url");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_cart_files->mdv_url - (char *) _cart_files;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("max_range");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_cart_files->max_range - (char *) _cart_files;
    tt->n_struct_vals = 8;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 400;
      tt->struct_vals[1].d = 1;
      tt->struct_vals[2].i = 20;
      tt->struct_vals[3].d = 0.5;
      tt->struct_vals[4].d = 1;
      tt->struct_vals[5].b = pTRUE;
      tt->struct_vals[6].s = tdrpStrDup("./data/mdv/radarCart");
      tt->struct_vals[7].d = -1;
    tt++;
    
    // Parameter 'output_ppi_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_ppi_files");
    tt->descr = tdrpStrDup("Option to output files with PPI geometry.");
    tt->help = tdrpStrDup("If true, the parameters in the ppi_files array are used. The grid origin is at the radar. nxy is the number of grid points in x and y. dxy is the grid resolution in x and y. Therefore the grid is a square in x,y. min_elev is the lowest elevation angle to be stored, in degrees. Similarly for for max_elev. If interpolate is true, an 8-point linear interpolation grid transformation is performed. If interpolate is false, a nearest-neighbor transformation is performed. The MDV files are stored at mdv_url. All gates with heights below min_ht or above max_ht (in km) will be set to missing. The max_range parameter (km) can be used to limit the useful data range. Input data beyond this range is ignored. Set to a negative value to disable it, in which case no limit is placed on range.");
    tt->val_offset = (char *) &output_ppi_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ppi_files'
    // ctype is '_ppi_file_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ppi_files");
    tt->descr = tdrpStrDup("Details for files in ppi geometry.");
    tt->help = tdrpStrDup("Only active if 'output_ppi_files' is true.");
    tt->array_offset = (char *) &_ppi_files - &_start_;
    tt->array_n_offset = (char *) &ppi_files_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(ppi_file_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("ppi_file_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nxy");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_ppi_files->nxy - (char *) _ppi_files;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("dxy");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_ppi_files->dxy - (char *) _ppi_files;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("min_elev");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_ppi_files->min_elev - (char *) _ppi_files;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("max_elev");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_ppi_files->max_elev - (char *) _ppi_files;
      tt->struct_def.fields[4].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[4].fname = tdrpStrDup("interpolate");
      tt->struct_def.fields[4].ptype = BOOL_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_ppi_files->interpolate - (char *) _ppi_files;
      tt->struct_def.fields[5].ftype = tdrpStrDup("string");
      tt->struct_def.fields[5].fname = tdrpStrDup("mdv_url");
      tt->struct_def.fields[5].ptype = STRING_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_ppi_files->mdv_url - (char *) _ppi_files;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("min_ht");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_ppi_files->min_ht - (char *) _ppi_files;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("max_ht");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_ppi_files->max_ht - (char *) _ppi_files;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("max_range");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_ppi_files->max_range - (char *) _ppi_files;
    tt->n_struct_vals = 9;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 400;
      tt->struct_vals[1].d = 1;
      tt->struct_vals[2].d = 0;
      tt->struct_vals[3].d = 90;
      tt->struct_vals[4].b = pFALSE;
      tt->struct_vals[5].s = tdrpStrDup("./data/mdv/radarPpi");
      tt->struct_vals[6].d = 0;
      tt->struct_vals[7].d = 50;
      tt->struct_vals[8].d = -1;
    tt++;
    
    // Parameter 'output_polar_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_polar_files");
    tt->descr = tdrpStrDup("Option to output files with Polar radar geometry.");
    tt->help = tdrpStrDup("If true, the parameters in the polar_files array are used. max_range is the maximum range to be stored, in km. min_elev is the lowest elevation angle to be stored, in degrees. Similarly for for max_elev. If interpolate is true, an 8-point linear interpolation grid transformation is performed. If interpolate is false, a nearest-neighbor transformation is performed. The MDV files are stored at mdv_url.");
    tt->val_offset = (char *) &output_polar_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'polar_files'
    // ctype is '_polar_file_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("polar_files");
    tt->descr = tdrpStrDup("Details for files in polar geometry.");
    tt->help = tdrpStrDup("Only active if 'output_polar_files' is true.");
    tt->array_offset = (char *) &_polar_files - &_start_;
    tt->array_n_offset = (char *) &polar_files_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(polar_file_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("polar_file_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("max_range");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_polar_files->max_range - (char *) _polar_files;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_elev");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_polar_files->min_elev - (char *) _polar_files;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("max_elev");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_polar_files->max_elev - (char *) _polar_files;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("mdv_url");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_polar_files->mdv_url - (char *) _polar_files;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 300;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 90;
      tt->struct_vals[3].s = tdrpStrDup("./data/mdv/radarPolar");
    tt++;
    
    // Parameter 'trim_polar_sectors'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("trim_polar_sectors");
    tt->descr = tdrpStrDup("Option to store only the sector in which there is data.");
    tt->help = tdrpStrDup("This only applies to polar files. In the MDV file a sector may be stored as a full 360 or with only the beams in which there is data - the rest of the azimuths will be filled with missing values. If this is set TRUE, only the sector in which data is present will be stored.");
    tt->val_offset = (char *) &trim_polar_sectors - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("SEPARATING SECTOR VOLUMES FROM SURVEILLANCE VOLUMES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'separate_sector_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("separate_sector_files");
    tt->descr = tdrpStrDup("Option to separate the sector files from surveillance files.");
    tt->help = tdrpStrDup("\nSometimes a scan strategy will switch between sector scans and surveillance scans. In these cases, it can be useful to separate the sectors by storing them in different directories.\n\nIf you set this option to true, the directory path for sectors will be determined by appending the 'sector_subdirectory' parameter to the paths of cart, ppi or polar files. Similarly, for surveillance scans, the parameter 'surveillance_subdirectory' will be appended to the paths.\n\nIf the parameter 'use_input_scan_mode' is true, the scan mode will be used to determine which scans are sectors. If use_input_scan_mode is false, the number of beams will be computed as a fraction of the maximum number possible. If this fraction is greater than the parameter 'min_fraction_for_surveillance', the scan will be assumed to be a surveillance scan. Otherwise it will be assumed to be a sector scan.");
    tt->val_offset = (char *) &separate_sector_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'sector_subdirectory'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("sector_subdirectory");
    tt->descr = tdrpStrDup("The directory name for sector scan files.");
    tt->help = tdrpStrDup("See 'separate_sector_files'. If a volume is a sector, this will be appended to the path for cart, ppi and polar files.");
    tt->val_offset = (char *) &sector_subdirectory - &_start_;
    tt->single_val.s = tdrpStrDup("sector");
    tt++;
    
    // Parameter 'surveillance_subdirectory'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("surveillance_subdirectory");
    tt->descr = tdrpStrDup("The directory name for surveillance scan files.");
    tt->help = tdrpStrDup("See 'separate_sector_files'. If a volume is a surveillance scan, this will be appended to the path for cart, ppi and polar files.");
    tt->val_offset = (char *) &surveillance_subdirectory - &_start_;
    tt->single_val.s = tdrpStrDup("full");
    tt++;
    
    // Parameter 'min_fraction_for_surveillance'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_fraction_for_surveillance");
    tt->descr = tdrpStrDup("The min fraction of max beams for a surveillance scan.");
    tt->help = tdrpStrDup("See 'separate_sector_files'. If the fraction of beams in the volume exceeds this min value, the volume will be considered a full revolution. Otherwise it will be considered a sector scan. Only active if 'use_input_scan_mode' is false.");
    tt->val_offset = (char *) &min_fraction_for_surveillance - &_start_;
    tt->single_val.d = 0.8;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("SEPARATE VERTICALLY-SCANNED VOLUMES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'separate_vert_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("separate_vert_files");
    tt->descr = tdrpStrDup("Option to write vertically-pointing data files to a separate directory.");
    tt->help = tdrpStrDup("This allows you to separate volumes of vertically-pointing data and save them to a separate directory. If the elevation angles in a volume are consistently above a specified value, the volume will be written to the specified directory. This only applies to polar data. If is ignored for cart and ppi output.");
    tt->val_offset = (char *) &separate_vert_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vert_subdirectory'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_subdirectory");
    tt->descr = tdrpStrDup("The directory name for vertically-pointing volumes.");
    tt->help = tdrpStrDup("See 'separate_vert_files'.");
    tt->val_offset = (char *) &vert_subdirectory - &_start_;
    tt->single_val.s = tdrpStrDup("vert");
    tt++;
    
    // Parameter 'min_elevation_for_vert_files'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_elevation_for_vert_files");
    tt->descr = tdrpStrDup("The min elevation angle for vertically-pointing operations (deg).");
    tt->help = tdrpStrDup("This is the elevation threshold for vertically-pointing operations. If the specified fraction of the data has an elevation angle in excess of this angle, the volume will be considered to be from vertically-pointing operations.");
    tt->val_offset = (char *) &min_elevation_for_vert_files - &_start_;
    tt->single_val.d = 85;
    tt++;
    
    // Parameter 'min_vert_fraction_for_vert_files'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_vert_fraction_for_vert_files");
    tt->descr = tdrpStrDup("The min fraction of data with elevations in excess of the min elevation.");
    tt->help = tdrpStrDup("If the fraction of the data with elevation angles above the specified min_elevation exceeds this fraction,  the volume will be considered to be from vertically-pointing operations.");
    tt->val_offset = (char *) &min_vert_fraction_for_vert_files - &_start_;
    tt->single_val.d = 0.9;
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("RHI MODE - OPTION TO SAVE RHI DATA");
    tt->comment_text = tdrpStrDup("If the program finds RHI data, it performs a histogram analysis to decide which radials are active and stores out the data in the MDV files as RHIs.");
    tt++;
    
    // Parameter 'output_rhi_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_rhi_files");
    tt->descr = tdrpStrDup("Option to save RHIs if available.");
    tt->help = tdrpStrDup("When creating RHI files, the elevation angles are stored in a regular grid while the azimuths are stored in the vlevels array.\n\nIf the beams are indexed in elevation (i.e. are computed on a regular grid), the RHIs are saved out on that regular grid.\n\nIf the beams are not indexed, the actual RHI elevation angles are resampled onto the regular grid. The oversampling ratio is computed as the number of elevation angles stored divided by the number of elevations measured. The higher the number the more accurate the elevation values. This step is necessary because the measured angles vary from one RHI to another, but all RHIs must be stored with the same elevation angles. Oversampling allows the program to interpolate the measured values onto the stored angles.\n\nThe interpolation flag governs whether the RHI data is interpolated when it is put onto the regular elevation grid. If false, nearest neighbor is used.\n");
    tt->val_offset = (char *) &output_rhi_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'rhi_files'
    // ctype is '_rhi_file_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("rhi_files");
    tt->descr = tdrpStrDup("Details for files in RHI geometry.");
    tt->help = tdrpStrDup("Only active if 'output_rhi_files' is true.");
    tt->array_offset = (char *) &_rhi_files - &_start_;
    tt->array_n_offset = (char *) &rhi_files_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(rhi_file_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("rhi_file_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("oversampling_ratio");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_rhi_files->oversampling_ratio - (char *) _rhi_files;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("interp_in_elevation");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_rhi_files->interp_in_elevation - (char *) _rhi_files;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("mdv_url");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_rhi_files->mdv_url - (char *) _rhi_files;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 4;
      tt->struct_vals[1].b = pFALSE;
      tt->struct_vals[2].s = tdrpStrDup("./data/mdv/radarRhi");
    tt++;
    
    // Parameter 'rhi_az_hist_resolution'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("rhi_az_hist_resolution");
    tt->descr = tdrpStrDup("Resolution of azimuth histogram (deg).");
    tt->help = tdrpStrDup("For determining RHI azimuths. The azimuth data is binned at this resolution.");
    tt->val_offset = (char *) &rhi_az_hist_resolution - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'rhi_az_hist_search_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("rhi_az_hist_search_width");
    tt->descr = tdrpStrDup("The width of the search in looking for peaks in the azimuth histogram.");
    tt->help = tdrpStrDup("When looking for peaks in azimuth histogram, the program searches by this number of bins on either side of the search bin. For example, if the az_hist_resolution is 0.1 and the az_hist_search_width is 3, the program will search 3 bins, or 0.3 degrees, on either side of the search bin. It looks for a peak with values equal to or below the peak in the adjacent bins and less than the peak in bins further out.");
    tt->val_offset = (char *) &rhi_az_hist_search_width - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'check_min_beams_in_rhi'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_beams_in_rhi");
    tt->descr = tdrpStrDup("Option to check the number of beams in an rhi.");
    tt->help = tdrpStrDup("If TRUE, an rhi is only considered valid if the number of beams exceeds 'min_beams_in_rhi'.");
    tt->val_offset = (char *) &check_min_beams_in_rhi - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_beams_in_rhi'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_beams_in_rhi");
    tt->descr = tdrpStrDup("The min number of beams for an rhi to be valid.");
    tt->help = tdrpStrDup("See 'check_min_beams_in_rhi'.");
    tt->val_offset = (char *) &min_beams_in_rhi - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'check_min_fraction_in_rhi'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_fraction_in_rhi");
    tt->descr = tdrpStrDup("Option to check the fraction of beams in an rhi.");
    tt->help = tdrpStrDup("If TRUE, an rhi is only considered valid if the number of beams in the rhi, expressed as a fraction of the max number of beams in any rhi, exceeds 'min_fraction_in_rhi'.");
    tt->val_offset = (char *) &check_min_fraction_in_rhi - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_fraction_in_rhi'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_fraction_in_rhi");
    tt->descr = tdrpStrDup("The min fraction of max beams for an rhi to be valid.");
    tt->help = tdrpStrDup("See 'check_min_fraction_in_rhi'.");
    tt->val_offset = (char *) &min_fraction_in_rhi - &_start_;
    tt->single_val.d = 0.3;
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("CARTESIAN RHI MODE - OPTION TO SAVE RHI DATA AS CARTESIAN");
    tt->comment_text = tdrpStrDup("If the program finds RHI data, it treats the data as a normal volume and converts it into Cartessian space.");
    tt++;
    
    // Parameter 'output_rhi_cart_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_rhi_cart_files");
    tt->descr = tdrpStrDup("Option to convert RHI volumes to cartesian.");
    tt->help = tdrpStrDup("For RHI scans, the data will be converted to a Cartesian volume, using the same gridding method as for CART output.");
    tt->val_offset = (char *) &output_rhi_cart_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'rhi_cart_files'
    // ctype is '_cart_file_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("rhi_cart_files");
    tt->descr = tdrpStrDup("Details for rhi files in cartesian geometry.");
    tt->help = tdrpStrDup("Only active if 'output_rhi_cart_files' is true.");
    tt->array_offset = (char *) &_rhi_cart_files - &_start_;
    tt->array_n_offset = (char *) &rhi_cart_files_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(cart_file_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("cart_file_t");
    tt->struct_def.nfields = 8;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nxy");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_rhi_cart_files->nxy - (char *) _rhi_cart_files;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("dxy");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_rhi_cart_files->dxy - (char *) _rhi_cart_files;
      tt->struct_def.fields[2].ftype = tdrpStrDup("int");
      tt->struct_def.fields[2].fname = tdrpStrDup("nz");
      tt->struct_def.fields[2].ptype = INT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_rhi_cart_files->nz - (char *) _rhi_cart_files;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("minz");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_rhi_cart_files->minz - (char *) _rhi_cart_files;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dz");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_rhi_cart_files->dz - (char *) _rhi_cart_files;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("interpolate");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_rhi_cart_files->interpolate - (char *) _rhi_cart_files;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("mdv_url");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_rhi_cart_files->mdv_url - (char *) _rhi_cart_files;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("max_range");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_rhi_cart_files->max_range - (char *) _rhi_cart_files;
    tt->n_struct_vals = 8;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 400;
      tt->struct_vals[1].d = 1;
      tt->struct_vals[2].i = 20;
      tt->struct_vals[3].d = 0.5;
      tt->struct_vals[4].d = 1;
      tt->struct_vals[5].b = pTRUE;
      tt->struct_vals[6].s = tdrpStrDup("./data/mdv/radarCart/rhi");
      tt->struct_vals[7].d = -1;
    tt++;
    
    // Parameter 'rhi_cart_delta_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("rhi_cart_delta_az");
    tt->descr = tdrpStrDup("Target delta azimuth (deg) for Cartesian RHIs.");
    tt->help = tdrpStrDup("The target spacing of the data beams in azimuth. NOTE: the lookup table is computed assuming that there is an exact number of beams per 45-degree sector. If delta_az does not satisfy this requirement, it will be adjusted upwards to the next suitable value.\n\tSee also 'delta_az'.");
    tt->val_offset = (char *) &rhi_cart_delta_az - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("REGISTERING MASTER LATEST_DATA_INFO FOR SEPARATED SCAN TYPES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_master_ldata_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_master_ldata_info");
    tt->descr = tdrpStrDup("Option to write a master latest_data_info for separated scan types.");
    tt->help = tdrpStrDup("If the files for different scan types (surveillance, sector, rhi, vert etc.) are written to separate subdirectories, you have the option of registering the latest_data_info to a master location. This allows the system monitor to stay current, no matter which scan type is active.");
    tt->val_offset = (char *) &write_master_ldata_info - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'master_ldata_info_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("master_ldata_info_url");
    tt->descr = tdrpStrDup("The URL for the master latest_data_info.");
    tt->help = tdrpStrDup("See 'write_master_ldata_info'.");
    tt->val_offset = (char *) &master_ldata_info_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp:://localhost::/tmp");
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("OUTPUT FILE TIME-STAMP");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'auto_mid_time'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_mid_time");
    tt->descr = tdrpStrDup("Option to automatically compute the volume mid time.");
    tt->help = tdrpStrDup("If TRUE, the mid_time is the mean of the start and end times of the data in the volume. If FALSE, the mid time is computed as the end time minus 'age_at_end_of_volume'.");
    tt->val_offset = (char *) &auto_mid_time - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'age_at_end_of_volume'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("age_at_end_of_volume");
    tt->descr = tdrpStrDup("Specified age (secs) of the data relative to the data time at the end of the volume.");
    tt->help = tdrpStrDup("Used if 'auto_mid_time' is FALSE.");
    tt->val_offset = (char *) &age_at_end_of_volume - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'max_vol_duration'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_vol_duration");
    tt->descr = tdrpStrDup("Maximum volume duration (secs).");
    tt->help = tdrpStrDup("If a volume exceeds this duration it is not saved. This takes care of cases in which the radar data stops in the middle of a volume for some reason. Then the early data in the volume will not match the late data.");
    tt->val_offset = (char *) &max_vol_duration - &_start_;
    tt->single_val.i = 900;
    tt++;
    
    // Parameter 'Comment 20'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 20");
    tt->comment_hdr = tdrpStrDup("OUTPUT DATA SET INFORMATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'data_set_info'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_info");
    tt->descr = tdrpStrDup("Data set info.");
    tt->help = tdrpStrDup("This is placed in the MDV master header for documentation purposes.");
    tt->val_offset = (char *) &data_set_info - &_start_;
    tt->single_val.s = tdrpStrDup("This MDV radar volume file was created by Dsr2Vol.");
    tt++;
    
    // Parameter 'data_set_source'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_source");
    tt->descr = tdrpStrDup("Data set source details.");
    tt->help = tdrpStrDup("This is placed in the MDV master header for documentation purposes.");
    tt->val_offset = (char *) &data_set_source - &_start_;
    tt->single_val.s = tdrpStrDup("Radar data, RAP, NCAR.");
    tt++;
    
    // Parameter 'Comment 21'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 21");
    tt->comment_hdr = tdrpStrDup("AUTOMATIC END-OF-VOLUME DETECTION");
    tt->comment_text = tdrpStrDup("These parameters are used if end_of_volume_decision is set to AUTOMATIC. This assumes a simple bottom-up or top-down scan strategy. No attempt will be made to search for RHIs, or other complicattions in the SCAN strategy.");
    tt++;
    
    // Parameter 'set_end_of_vol_from_elev_change'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_end_of_vol_from_elev_change");
    tt->descr = tdrpStrDup("Option to set the end of vol flag based on change in elevation angle.");
    tt->help = tdrpStrDup("If true, the program will look for changes in elevation angle to compute the end of volume. Only this test, and the test for prf change, will be used to identify the end of volume condition.");
    tt->val_offset = (char *) &set_end_of_vol_from_elev_change - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vol_starts_at_bottom'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vol_starts_at_bottom");
    tt->descr = tdrpStrDup("Flag to indicate that elevation angles increase in the volume.");
    tt->help = tdrpStrDup("If the volume starts at the top, i.e. elevations decrease during the volume, set this to FALSE.");
    tt->val_offset = (char *) &vol_starts_at_bottom - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'elev_change_for_end_of_vol'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_change_for_end_of_vol");
    tt->descr = tdrpStrDup("Change in elevation which triggers and end of volume.");
    tt->help = tdrpStrDup("If the elevation angle changes by this amount, and end of volume flag will be set.");
    tt->val_offset = (char *) &elev_change_for_end_of_vol - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0.1;
    tt->single_val.d = 1.5;
    tt++;
    
    // Parameter 'set_end_of_vol_on_prf_change'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_end_of_vol_on_prf_change");
    tt->descr = tdrpStrDup("Option to set the end-of-vol flag when the PRF changes.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_end_of_vol_on_prf_change - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nbeams_history'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nbeams_history");
    tt->descr = tdrpStrDup("Number of beams in history list.");
    tt->help = tdrpStrDup("This is the number of beams stored in the history list. The list is used for determining the status of the antenna. The antenna algorithm checks o see if either the elevation angle is stable (PPI mode) or the azimuth angle is stable (RHI mode). The el_accuracy and az_accuracy parameters are used to detect whether el or az are stable.");
    tt->val_offset = (char *) &nbeams_history - &_start_;
    tt->single_val.i = 16;
    tt++;
    
    // Parameter 'el_accuracy'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("el_accuracy");
    tt->descr = tdrpStrDup("Accuracy of antenna controller in elevation (deg).");
    tt->help = tdrpStrDup("Used to determine if antenna is stationary in elevation, i.e. is it in PPI mode? If the cumulative elevation change during the history period is less than this value, the antenna is assumed to be in PPI mode.");
    tt->val_offset = (char *) &el_accuracy - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'az_accuracy'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("az_accuracy");
    tt->descr = tdrpStrDup("Accuracy of antenna controller in azimuth (deg).");
    tt->help = tdrpStrDup("Used to determine if antenna is stationary in azimuth, i.e. is it in RHI mode? If the cumulative azimuth change during the history period is less than this value, the antenna is assumed to be in RHI mode.");
    tt->val_offset = (char *) &az_accuracy - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'min_az_change_ppi'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_az_change_ppi");
    tt->descr = tdrpStrDup("Min azimuth change for PPI (deg).");
    tt->help = tdrpStrDup("For a valid PPI, the azimuth must change by at least this amount during nbeams_history, while the elevation is not changing.");
    tt->val_offset = (char *) &min_az_change_ppi - &_start_;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'min_el_change_rhi'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_el_change_rhi");
    tt->descr = tdrpStrDup("Min elevation change for RHI (deg).");
    tt->help = tdrpStrDup("For a valid RHI, the elevation must change by at least this amount during nbeams_history, while the azimuth is not changing.");
    tt->val_offset = (char *) &min_el_change_rhi - &_start_;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'max_az_change_per_tilt'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_az_change_per_tilt");
    tt->descr = tdrpStrDup("Maximum azimuth change per tilt (deg).");
    tt->help = tdrpStrDup("If the tilt elevation has not changed by the time the azimuth has changed by this number of degrees, an end-of-volume condition is triggered. This is used to handle the single-elevation surveillance case in which the antenna scans in PPI at a single elevation angle.");
    tt->val_offset = (char *) &max_az_change_per_tilt - &_start_;
    tt->single_val.i = 540;
    tt++;
    
    // Parameter 'min_beams_per_ppi_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_beams_per_ppi_vol");
    tt->descr = tdrpStrDup("Min number of beams per PPI volume.");
    tt->help = tdrpStrDup("Used to prevent end-of-volume conditions being determined during antenna transition to the start of the next volume.");
    tt->val_offset = (char *) &min_beams_per_ppi_vol - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'min_beams_per_rhi_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_beams_per_rhi_vol");
    tt->descr = tdrpStrDup("Min number of beams per RHI volume.");
    tt->help = tdrpStrDup("Used to prevent end-of-volume conditions being determined during antenna transition to the start of the next volume.");
    tt->val_offset = (char *) &min_beams_per_rhi_vol - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'debug_auto_detection'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug_auto_detection");
    tt->descr = tdrpStrDup("Flag for debugging auto end-of-vol detection.");
    tt->help = tdrpStrDup("If set, messages will be printed to stderr on how the auto-detection algorithm is making decisions.");
    tt->val_offset = (char *) &debug_auto_detection - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
