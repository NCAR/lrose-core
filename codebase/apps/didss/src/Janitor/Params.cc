/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Janitor
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("The Janitor is a program that does maintenance on data files.\n");
    tt->comment_text = tdrpStrDup("It is used to : \n\n\t* Delete files that have not been modified for a certain time\n\t* Compress files that have not been accessed for a certain time\n\t* Leave data alone if it is listed in an eventlist as pertaining to\n\t  an interesting case.\n\nSo there are three different times involved :\n\t * The time since file modification, for deletion\n\t * The time since file access, for compression, and\n\t * The time the data pertains to, which is parsed from\n\t   the filename according to the RAP file naming convention.\n\nThe Janitor operates by recursing under a top directory (usually\ndefined by the RAP_DATA_DIR environment variable). As the Janitor\nrecurses into a directory it looks for a file named _janitor and\nreads its parameters from it, if it exists. If it does not,\nthen the parameters the janitor entered the directory with\nare used.\n\nTypically a user will specify a very complete _janitor file in the\ntop directory. Directories lower in the tree typically\ncontain _janitor files that only overwrite a few\nvariables - the rest retain the values\nthat were specified in the top level directory.\n\nAt the time of writing, users may consult\nhttp://www.rap.ucar.edu/staff/oien/janitor.html\nfor more information.\n\nNiles Oien, RAP, NCAR, August 1999 (oien@rap.ucar.edu)");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debugging messages will be printed.");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("primary");
    tt++;
    
    // Parameter 'top_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("top_dir");
    tt->descr = tdrpStrDup("Top level directory - defaults to DATA_DIR or RAP_DATA_DIR if not set.");
    tt->help = tdrpStrDup("The Janitor traverses recursively from this directory downwards.");
    tt->val_offset = (char *) &top_dir - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'once_only'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("once_only");
    tt->descr = tdrpStrDup("Option to traverse the directories once and then exit.");
    tt->help = tdrpStrDup("If false, the Janitor will repeatedly traverse the directory tree, with a delay of 'SleepBetweenPasses' between the passes. If true, the Janitor will make a single pass and then exit.");
    tt->val_offset = (char *) &once_only - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'SleepBetweenPasses'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("SleepBetweenPasses");
    tt->descr = tdrpStrDup("Sleep time between passes - secs");
    tt->help = tdrpStrDup("Janitor sleeps for this time between traversal passes of the directory structure. This is intended to prevent the Janitor from causing an excessive CPU load.");
    tt->val_offset = (char *) &SleepBetweenPasses - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 900;
    tt++;
    
    // Parameter 'SleepBetweenDirs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("SleepBetweenDirs");
    tt->descr = tdrpStrDup("Sleep time between directories - secs");
    tt->help = tdrpStrDup("Janitor sleeps for this time as it moves between between directories. It is intended to prevent the Janitor from causing an excessive CPU load.");
    tt->val_offset = (char *) &SleepBetweenDirs - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("TRAVERSING THE DIRECTORY TREE");
    tt->comment_text = tdrpStrDup("Controlling the way the Janitor searches the directory tree for files to delete or compress.");
    tt++;
    
    // Parameter 'recurse'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("recurse");
    tt->descr = tdrpStrDup("Recurse to lower directories.");
    tt->help = tdrpStrDup("Set to false to leave directories below the current directory alone.");
    tt->val_offset = (char *) &recurse - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'FollowDangerousLinks'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("FollowDangerousLinks");
    tt->descr = tdrpStrDup("Follow path relative soft links ./ and ../");
    tt->help = tdrpStrDup("Setting this to true is dangerous if recurse is true. Beware of circular links.");
    tt->val_offset = (char *) &FollowDangerousLinks - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'process'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("process");
    tt->descr = tdrpStrDup("Process files in this directory.");
    tt->help = tdrpStrDup("Set to false to leave the current directory alone. However, subdirs are processed unless the recurse parameter is set to false.");
    tt->val_offset = (char *) &process - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'report'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("report");
    tt->descr = tdrpStrDup("Option to place a report file in each directory visisted.");
    tt->help = tdrpStrDup("If set, a file named _janitor_Report is written in the directory\nwhere the -janitor file was found. Note that this parameter\ndoes NOT recurse, that is, setting report=TRUE in the top directory\nwill cause a _janitor_Report to be written to the top\ndirectory but not subdirectories.\n\nThe _janitor_Report file is an ASCII report of the state of\nthe janitor when it got to that directory.");
    tt->val_offset = (char *) &report - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("FILE IDENTIFICATION");
    tt->comment_text = tdrpStrDup("Controlling the way the Janitor finds files to delete or compress.");
    tt++;
    
    // Parameter 'check_ext'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_ext");
    tt->descr = tdrpStrDup("Option to check for file extension.");
    tt->help = tdrpStrDup("If set, only files with the 'ext' extension are processed.");
    tt->val_offset = (char *) &check_ext - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ext");
    tt->descr = tdrpStrDup("Specified file extension. See 'check_ext'.");
    tt->help = tdrpStrDup("The specified extension may optionally include the leading period.");
    tt->val_offset = (char *) &ext - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'date_format'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("date_format");
    tt->descr = tdrpStrDup("Option to check for RAP date-time naming convention.");
    tt->help = tdrpStrDup("If set, the files must follow the RAP file naming\nconvention (which means that the filename is based\non the date that the data in the file pertains to).");
    tt->val_offset = (char *) &date_format - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'file_ages_in_days'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("file_ages_in_days");
    tt->descr = tdrpStrDup("Option to specify file ages in days, instead of secs.");
    tt->help = tdrpStrDup("If TRUE, 'MaxNoModDays' and 'MaxNoAccessDays' are used. If FALSE, 'MaxModificationAgeBeforeDelete' and 'MaxAccessAgeBeforeCompress' are used.");
    tt->val_offset = (char *) &file_ages_in_days - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("FILE DELETION");
    tt->comment_text = tdrpStrDup("Option to delete files.");
    tt++;
    
    // Parameter 'delete_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("delete_files");
    tt->descr = tdrpStrDup("Option to delete files.");
    tt->help = tdrpStrDup("If set, files are deleted if their modification age exceeds MaxNoModDays, if set, or MaxModificationAgeBeforeDelete.");
    tt->val_offset = (char *) &delete_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'MaxNoModDays'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("MaxNoModDays");
    tt->descr = tdrpStrDup("Max file age before deletion - days. Used if 'file_ages_in_days' is TRUE.");
    tt->help = tdrpStrDup("If delete_files is TRUE, a file will be deleted if it has not been modified in this amount of time.");
    tt->val_offset = (char *) &MaxNoModDays - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'MaxModificationAgeBeforeDelete'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("MaxModificationAgeBeforeDelete");
    tt->descr = tdrpStrDup("Max file age before deletion - secs. Used if 'file_ages_in_days' is FALSE.");
    tt->help = tdrpStrDup("If delete_files is TRUE, a file will be deleted if it has not been modified in this amount of time.");
    tt->val_offset = (char *) &MaxModificationAgeBeforeDelete - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 1728000;
    tt++;
    
    // Parameter 'disk_use_threshold'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("disk_use_threshold");
    tt->descr = tdrpStrDup("Percentage full disk threshold");
    tt->help = tdrpStrDup("If this is exceeded, then the Janitor will start deleting the oldest files in the data repository until the disk usage percentage is below disk_delete_threshold.\n\nNOTE : This facility is only supported under LINUX. For other UNIX OS's the disk is assumed to be 0% full.");
    tt->val_offset = (char *) &disk_use_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 0;
    tt->max_val.i = 100;
    tt->single_val.i = 100;
    tt++;
    
    // Parameter 'disk_delete_threshold'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("disk_delete_threshold");
    tt->descr = tdrpStrDup("Percentage full disk threshold for deletions");
    tt->help = tdrpStrDup("If the disk is considered too full based on the disk_use_threshold parameter, the oldest files in the data repository will be deleted until the disk usage falls below this value. Note that files will only be deleted if they are not in an event list and are not in a directory with a disk_use_threshold of 100. Note that this value must be less than the disk_use_threshold value or your disk could fill up.");
    tt->val_offset = (char *) &disk_delete_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 0;
    tt->max_val.i = 100;
    tt->single_val.i = 100;
    tt++;
    
    // Parameter 'MaxNumFilesInDir'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("MaxNumFilesInDir");
    tt->descr = tdrpStrDup("Maximum number of files allowed in a directory");
    tt->help = tdrpStrDup("If the number of files in a directory (after other deletion processes have completed) exceeds this number, then the oldest files (based upon modification time) will be deleted until the number of files left is equal to this value. When MaxNumFilesInDir is less than zero (the default) it will not be applied.  Setting MaxNumFilesInDir to zero will cause it to delete all files in a directory.  Files that begin with a '.' or '_' will not be included in the count. The value  of 'delete_files' does not influence the behavior wrt.  MaxNumFilesInDir");
    tt->val_offset = (char *) &MaxNumFilesInDir - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = -1;
    tt->single_val.i = -1;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("DIRECTORY DELETION");
    tt->comment_text = tdrpStrDup("Option to delete directories.");
    tt++;
    
    // Parameter 'RemoveEmptyDirs'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("RemoveEmptyDirs");
    tt->descr = tdrpStrDup("Option to remove empty directories.");
    tt->help = tdrpStrDup("If set, directories are removed if file deletion leaves them empty.");
    tt->val_offset = (char *) &RemoveEmptyDirs - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'MaxDirAgeDays'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("MaxDirAgeDays");
    tt->descr = tdrpStrDup("Max dir age before deletion - days. Used if 'file_ages_in_days' is TRUE.");
    tt->help = tdrpStrDup("If RemoveEmptyDirs is TRUE, a dir will be deleted if it has not been modified in this amount of time.");
    tt->val_offset = (char *) &MaxDirAgeDays - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'MaxDirAgeSecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("MaxDirAgeSecs");
    tt->descr = tdrpStrDup("Max dir age before deletion - secs. Used if 'file_ages_in_days' is FALSE.");
    tt->help = tdrpStrDup("If RemoveEmptyDirs is TRUE, a dir will be deleted if it has not been modified in this amount of time.");
    tt->val_offset = (char *) &MaxDirAgeSecs - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("FILE COMPRESSION");
    tt->comment_text = tdrpStrDup("Option to compress files.");
    tt++;
    
    // Parameter 'compress'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compress");
    tt->descr = tdrpStrDup("Should we compress files?");
    tt->help = tdrpStrDup("If set, files are compressed if their age indicates\nthat they should be. Systems that do not decompress\non the fly should avoid compression.");
    tt->val_offset = (char *) &compress - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'CompressBasedOnAccessTime'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("CompressBasedOnAccessTime");
    tt->descr = tdrpStrDup("Make compression decision based on access time");
    tt->help = tdrpStrDup("If TRUE, the compression decision will be made based on\nthe latest ACCESS time of the file.\nSee MaxNoAccessDays or MaxAccessAgeBeforeCompress.\nIf FALSE, the compression decision will be made based on\n the latest MODIFICATION time of the file.\nSee MaxNoModDaysBeforeCompress or MaxNoModSecsBeforeCompress.\n");
    tt->val_offset = (char *) &CompressBasedOnAccessTime - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'MaxNoAccessDays'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("MaxNoAccessDays");
    tt->descr = tdrpStrDup("Max quiescent age before compression - days. Used if 'file_ages_in_days' is TRUE");
    tt->help = tdrpStrDup("If compress is TRUE, a file will be compressed if it has not been accessed within this time.");
    tt->val_offset = (char *) &MaxNoAccessDays - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'MaxAccessAgeBeforeCompress'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("MaxAccessAgeBeforeCompress");
    tt->descr = tdrpStrDup("Max quiescent age before compression - secs. Used if 'file_ages_in_days' is FALSE.");
    tt->help = tdrpStrDup("If compress is TRUE, a file will be compressed if it has not been accessed within this time.");
    tt->val_offset = (char *) &MaxAccessAgeBeforeCompress - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 86400;
    tt++;
    
    // Parameter 'MaxNoModDaysCompress'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("MaxNoModDaysCompress");
    tt->descr = tdrpStrDup("Max file mod age before compression - days.");
    tt->help = tdrpStrDup(" Used if 'file_ages_in_days' is TRUE. If compress is TRUE, a file will be compressed if it has not been modified in this amount of time.");
    tt->val_offset = (char *) &MaxNoModDaysCompress - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'MaxNoModSecsCompress'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("MaxNoModSecsCompress");
    tt->descr = tdrpStrDup("Max file mod age before compression - secs.");
    tt->help = tdrpStrDup(" Used if 'file_ages_in_days' is FALSE. If compress is TRUE, a file will be compressed if it has not been modified in this amount of time.");
    tt->val_offset = (char *) &MaxNoModSecsCompress - &_start_;
    tt->single_val.i = 1728000;
    tt++;
    
    // Parameter 'com_str'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("com_str");
    tt->descr = tdrpStrDup("Compress command to be executed on files, with carat (^) for filename");
    tt->help = tdrpStrDup("Compress command to execute on files.");
    tt->val_offset = (char *) &com_str - &_start_;
    tt->single_val.s = tdrpStrDup("gzip -f ^");
    tt++;
    
    // Parameter 'compressed_ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("compressed_ext");
    tt->descr = tdrpStrDup("Extension for compressed files.");
    tt->help = tdrpStrDup("Extension for compressed files. The Janitor needs this to determine\nif a file has already been compressed. If a compression technique\nother than gzip is used, this may have to be changed (for instance\nif the compress command was used the extension should be .Z).");
    tt->val_offset = (char *) &compressed_ext - &_start_;
    tt->single_val.s = tdrpStrDup(".gz");
    tt++;
    
    // Parameter 'sleep_factor'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sleep_factor");
    tt->descr = tdrpStrDup("Single int value");
    tt->help = tdrpStrDup("Sleep for sleep_factor*compression_time after compressing a file.");
    tt->val_offset = (char *) &sleep_factor - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("EVENT LISTS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'ProcessIfNoMaster'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ProcessIfNoMaster");
    tt->descr = tdrpStrDup("Single bool value");
    tt->help = tdrpStrDup("The Janitor will look for two eventlists. One is\nin the directory with the data it pertains to\nand is named _janitor_Eventlist, the other (master)\neventlist is specified by the MasterEventsFile parameter\nand this may be on a disk that is remotely mounted.\n\nIf for some reason the master eventlist file is not\nfound, the user can specify that the Janitor is to\ndo nothing by specifying ProcessIfNoMaster=FALSE.");
    tt->val_offset = (char *) &ProcessIfNoMaster - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ignoreEventlists'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ignoreEventlists");
    tt->descr = tdrpStrDup("If this is set, ignore event lists.");
    tt->help = tdrpStrDup("This parameter intended to be used to delete MM5 raw\ndata, even if it is on an eventlist.");
    tt->val_offset = (char *) &ignoreEventlists - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'MasterEventsFile'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("MasterEventsFile");
    tt->descr = tdrpStrDup("Single string value");
    tt->help = tdrpStrDup("Event list file.");
    tt->val_offset = (char *) &MasterEventsFile - &_start_;
    tt->single_val.s = tdrpStrDup("$(HOME)/data/_janitor_Master_Eventlist");
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("CROSS MOUNT ISSUES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'HostnameMustMatch'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("HostnameMustMatch");
    tt->descr = tdrpStrDup("Set this to TRUE to force the host name to match the one\nspecified by the Hostname parameter. The intent is to give some\ncontrol over the processing of cross mounted directories. If\na directory physically attached to a machine named Grasshopper is\ncross mounted on a machine named Monkey via nfs, and in that directory\nthe _janitor file specifies that the hostname must be Grasshopper,\nthen only the janitor from Grasshopper will be able to recurse\ninto that directory. The janitor on Monkey will be denied access.");
    tt->help = tdrpStrDup("The default is to set this to FALSE.");
    tt->val_offset = (char *) &HostnameMustMatch - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Hostname'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("Hostname");
    tt->descr = tdrpStrDup("The host name.");
    tt->help = tdrpStrDup("See comments for HostnameMustMatch above.");
    tt->val_offset = (char *) &Hostname - &_start_;
    tt->single_val.s = tdrpStrDup("MachineName");
    tt++;
    
    // Parameter 'UseLockfiles'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("UseLockfiles");
    tt->descr = tdrpStrDup("If this is set, use lock files to lock a directory.");
    tt->help = tdrpStrDup("Default is not to do this.");
    tt->val_offset = (char *) &UseLockfiles - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("CALL SCRIPT WHEN FILES ARE DELETED");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'call_script_on_file_deletion'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("call_script_on_file_deletion");
    tt->descr = tdrpStrDup("Option to spawn a script when a file is deleted.");
    tt->help = tdrpStrDup("If TRUE, the script 'script_to_call' will be called each time a file is deleted.");
    tt->val_offset = (char *) &call_script_on_file_deletion - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'script_to_call_on_file_deletion'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("script_to_call_on_file_deletion");
    tt->descr = tdrpStrDup("Name of script to call if call_script_on_file_deletion is true");
    tt->help = tdrpStrDup("The script will be called with the args specified in script_arg_list[] and supplementary_args[] - see below.");
    tt->val_offset = (char *) &script_to_call_on_file_deletion - &_start_;
    tt->single_val.s = tdrpStrDup("delete_script_example.py");
    tt++;
    
    // Parameter 'delete_script_arg_list'
    // ctype is '_delete_script_arg_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("delete_script_arg_list");
    tt->descr = tdrpStrDup("List of arguments to be passed to the delete script.");
    tt->help = tdrpStrDup("The arg string is followed by the respective value, for example file_path. So on the command line, you could see '-file /tmp/data/filename.ext -dir /tmp/data -name filename.ext'. DATA_TIME is the time of the data in the file, if that can be deduced from the file name, and -1 if not. MOD_TIME is the latest mod time of the file.");
    tt->array_offset = (char *) &_delete_script_arg_list - &_start_;
    tt->array_n_offset = (char *) &delete_script_arg_list_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(delete_script_arg_t);
    tt->array_n = 6;
    tt->struct_def.name = tdrpStrDup("delete_script_arg_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("delete_script_id_t");
      tt->struct_def.fields[0].fname = tdrpStrDup("id");
      tt->struct_def.fields[0].ptype = ENUM_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_delete_script_arg_list->id - (char *) _delete_script_arg_list;
        tt->struct_def.fields[0].enum_def.name = tdrpStrDup("delete_script_id_t");
        tt->struct_def.fields[0].enum_def.nfields = 6;
        tt->struct_def.fields[0].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[0].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[0].enum_def.fields[0].name = tdrpStrDup("DELETE_DATA_TIME");
        tt->struct_def.fields[0].enum_def.fields[0].val = DELETE_DATA_TIME;
        tt->struct_def.fields[0].enum_def.fields[1].name = tdrpStrDup("DELETE_MOD_TIME");
        tt->struct_def.fields[0].enum_def.fields[1].val = DELETE_MOD_TIME;
        tt->struct_def.fields[0].enum_def.fields[2].name = tdrpStrDup("DELETE_DIR_PATH");
        tt->struct_def.fields[0].enum_def.fields[2].val = DELETE_DIR_PATH;
        tt->struct_def.fields[0].enum_def.fields[3].name = tdrpStrDup("DELETE_FILE_PATH");
        tt->struct_def.fields[0].enum_def.fields[3].val = DELETE_FILE_PATH;
        tt->struct_def.fields[0].enum_def.fields[4].name = tdrpStrDup("DELETE_FILE_NAME");
        tt->struct_def.fields[0].enum_def.fields[4].val = DELETE_FILE_NAME;
        tt->struct_def.fields[0].enum_def.fields[5].name = tdrpStrDup("DELETE_FILE_EXT");
        tt->struct_def.fields[0].enum_def.fields[5].val = DELETE_FILE_EXT;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("str");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_delete_script_arg_list->str - (char *) _delete_script_arg_list;
    tt->n_struct_vals = 12;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].e = DELETE_DATA_TIME;
      tt->struct_vals[1].s = tdrpStrDup("--data_time");
      tt->struct_vals[2].e = DELETE_MOD_TIME;
      tt->struct_vals[3].s = tdrpStrDup("--mod_time");
      tt->struct_vals[4].e = DELETE_DIR_PATH;
      tt->struct_vals[5].s = tdrpStrDup("--dir");
      tt->struct_vals[6].e = DELETE_FILE_PATH;
      tt->struct_vals[7].s = tdrpStrDup("--path");
      tt->struct_vals[8].e = DELETE_FILE_NAME;
      tt->struct_vals[9].s = tdrpStrDup("--name");
      tt->struct_vals[10].e = DELETE_FILE_EXT;
      tt->struct_vals[11].s = tdrpStrDup("--ext");
    tt++;
    
    // Parameter 'delete_supplementary_args'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("delete_supplementary_args");
    tt->descr = tdrpStrDup("Supplementary arguments to be added to end of delete argument list.");
    tt->help = tdrpStrDup("This allows you to add arbitrary command line arguments at the END of the list. So for example if you want to add a debug arg to your script, you could specify '-debug' as a supplementary arg. The supplementary args will appear on the command line in the order specified, wth spaces between them.");
    tt->array_offset = (char *) &_delete_supplementary_args - &_start_;
    tt->array_n_offset = (char *) &delete_supplementary_args_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 1;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("--debug");
    tt++;
    
    // Parameter 'run_delete_script_in_background'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("run_delete_script_in_background");
    tt->descr = tdrpStrDup("Option to run delete script in background.");
    tt->help = tdrpStrDup("If TRUE, the script will be run in the background. Therefore, the system call will return immediately. If FALSE, the Janitor will wait until the script completes before continuing execution.");
    tt->val_offset = (char *) &run_delete_script_in_background - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'terminate_delete_script_if_hung'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("terminate_delete_script_if_hung");
    tt->descr = tdrpStrDup("Option to terminate delete script if it hangs.");
    tt->help = tdrpStrDup("If TRUE, the script will be killed if it does not return within 'delete_script_max_run_secs'.");
    tt->val_offset = (char *) &terminate_delete_script_if_hung - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'delete_script_max_run_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("delete_script_max_run_secs");
    tt->descr = tdrpStrDup("Max time allowed for script - secs.");
    tt->help = tdrpStrDup("If 'terminate_delete_script_if_hung' is TRUE, the script will be killed if it does not complete withing this number of secs.");
    tt->val_offset = (char *) &delete_script_max_run_secs - &_start_;
    tt->single_val.i = 300;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
