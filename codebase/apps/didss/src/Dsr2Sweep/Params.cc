/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Dsr2Sweep
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Dsr2Sweep program");
    tt->comment_text = tdrpStrDup("Dsr2Sweep reads an input FMQ containing radar data, and writes it to a file in Sweep format. Currently, DORADE and netCDF sweep file formats are supported.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url");
    tt->descr = tdrpStrDup("Input URL for DsRadar data via FMQ");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::fmq/dsRadar");
    tt++;
    
    // Parameter 'seek_to_end_of_input'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("seek_to_end_of_input");
    tt->descr = tdrpStrDup("Option to seek to the end of the input FMQ.");
    tt->help = tdrpStrDup("If TRUE, the program will seek to the end of the fmq and only read in new data. If FALSE, it will start reading from the beginning of the FMQ.");
    tt->val_offset = (char *) &seek_to_end_of_input - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'end_of_sweep_detection'
    // ctype is '_end_of_sweep_detection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("end_of_sweep_detection");
    tt->descr = tdrpStrDup("Method used for detecting end-of-sweep");
    tt->help = tdrpStrDup("\tSWEEP_NUM_EOS_DETECT - An end-of-sweep is detected if the sweep number in the DsRadar queue changes. This can only be used if the sweep number value is set correctly by the radar software.\n\tSCAN_STRATEGY_EOS_DETECT - End-of-sweep is determined based on the scan strategy specified in the scan_strategy parameter.\n");
    tt->val_offset = (char *) &end_of_sweep_detection - &_start_;
    tt->enum_def.name = tdrpStrDup("end_of_sweep_detection_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("SWEEP_NUM_EOS_DETECT");
      tt->enum_def.fields[0].val = SWEEP_NUM_EOS_DETECT;
      tt->enum_def.fields[1].name = tdrpStrDup("SCAN_STRATEGY_EOS_DETECT");
      tt->enum_def.fields[1].val = SCAN_STRATEGY_EOS_DETECT;
    tt->single_val.e = SWEEP_NUM_EOS_DETECT;
    tt++;
    
    // Parameter 'scan_strategy'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("scan_strategy");
    tt->descr = tdrpStrDup("List of expected elevation angles for the radar data.");
    tt->help = tdrpStrDup("Used only if end_of_sweep_detection is set to SCAN_STRATEGY_EOS_DETECT.\nNote that there must be more than one elevation angle for this to work.\n");
    tt->array_offset = (char *) &_scan_strategy - &_start_;
    tt->array_n_offset = (char *) &scan_strategy_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 8;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = 0.5;
      tt->array_vals[1].d = 1.5;
      tt->array_vals[2].d = 2.5;
      tt->array_vals[3].d = 3.5;
      tt->array_vals[4].d = 6;
      tt->array_vals[5].d = 8;
      tt->array_vals[6].d = 10;
      tt->array_vals[7].d = 15;
    tt++;
    
    // Parameter 'scan_strategy_epsilon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("scan_strategy_epsilon");
    tt->descr = tdrpStrDup("Allowable error in the elevation angle when matching it to a target elevation in the scan strategy.");
    tt->help = tdrpStrDup("Used only if end_of_sweep_detection is set to SCAN_STRATEGY_EOS_DETECT.\n");
    tt->val_offset = (char *) &scan_strategy_epsilon - &_start_;
    tt->single_val.d = 0.3;
    tt++;
    
    // Parameter 'min_beams_in_sweep'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("min_beams_in_sweep");
    tt->descr = tdrpStrDup("Minimum number of beams allowed in a sweep");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &min_beams_in_sweep - &_start_;
    tt->has_min = TRUE;
    tt->min_val.l = 0;
    tt->single_val.l = 0;
    tt++;
    
    // Parameter 'constrain_elevation'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("constrain_elevation");
    tt->descr = tdrpStrDup("Option to only write sweeps with selected range of elevation angles.");
    tt->help = tdrpStrDup("If TRUE, only sweeps with elevation angles between min_elevation and max_elevation will be written.");
    tt->val_offset = (char *) &constrain_elevation - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_elevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_elevation");
    tt->descr = tdrpStrDup("Min elevation angle (deg).");
    tt->help = tdrpStrDup("See 'contrain_elevation' parameter.");
    tt->val_offset = (char *) &min_elevation - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'max_elevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_elevation");
    tt->descr = tdrpStrDup("Max elevation angle (deg).");
    tt->help = tdrpStrDup("See 'contrain_elevation' parameter.");
    tt->val_offset = (char *) &max_elevation - &_start_;
    tt->single_val.d = 90;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("CHECK FOR MOVING ANTENNA");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'check_antenna_moving'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_antenna_moving");
    tt->descr = tdrpStrDup("Option to check that the antenna is moving.");
    tt->help = tdrpStrDup("If true, beams will only be stored if the antenna is moving. If the antenna stops, beams will be ignored.");
    tt->val_offset = (char *) &check_antenna_moving - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_angle_change'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_angle_change");
    tt->descr = tdrpStrDup("Minimun angle change beam-to-beam (deg).");
    tt->help = tdrpStrDup("For the antenna to be considered moving. the antenna much move by this amount from one beam to the next. The angle check is made in both azimuth and elevation.");
    tt->val_offset = (char *) &min_angle_change - &_start_;
    tt->single_val.d = 0.05;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("TEST PULSE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'test_pulse_present'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("test_pulse_present");
    tt->descr = tdrpStrDup("is there a test pulse in the data?");
    tt->help = tdrpStrDup("Normally the test pulse would appear towards the maximum range.");
    tt->val_offset = (char *) &test_pulse_present - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'test_pulse_power'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("test_pulse_power");
    tt->descr = tdrpStrDup("Test pulse power (dBm).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &test_pulse_power - &_start_;
    tt->single_val.d = -9999;
    tt++;
    
    // Parameter 'test_pulse_start_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("test_pulse_start_range");
    tt->descr = tdrpStrDup("Test pulse start range (km).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &test_pulse_start_range - &_start_;
    tt->single_val.d = -9999;
    tt++;
    
    // Parameter 'test_pulse_end_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("test_pulse_end_range");
    tt->descr = tdrpStrDup("Test pulse end range (km).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &test_pulse_end_range - &_start_;
    tt->single_val.d = -9999;
    tt++;
    
    // Parameter 'remove_test_pulse'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_test_pulse");
    tt->descr = tdrpStrDup("Option to remove the test pulse data.");
    tt->help = tdrpStrDup("If true, the test pulse data will be removed from the end of the beam. The test pulse data generally lies in the last few gates in the beam. If true, the number of gates will be reduced by 'ngates_test_pulse'.");
    tt->val_offset = (char *) &remove_test_pulse - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ngates_test_pulse'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("ngates_test_pulse");
    tt->descr = tdrpStrDup("Number of gates to remove to get rid of test pulse.");
    tt->help = tdrpStrDup("See 'remove_test_pulse'.");
    tt->val_offset = (char *) &ngates_test_pulse - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("OUTPUT FILES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_dir");
    tt->descr = tdrpStrDup("Output directory");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_dir - &_start_;
    tt->single_val.s = tdrpStrDup("data/nc_sweep");
    tt++;
    
    // Parameter 'output_format'
    // ctype is '_output_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_format");
    tt->descr = tdrpStrDup("Type of output files to create");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_format - &_start_;
    tt->enum_def.name = tdrpStrDup("output_format_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DORADE_OUTPUT");
      tt->enum_def.fields[0].val = DORADE_OUTPUT;
      tt->enum_def.fields[1].name = tdrpStrDup("NC_RADAR_OUTPUT");
      tt->enum_def.fields[1].val = NC_RADAR_OUTPUT;
    tt->single_val.e = NC_RADAR_OUTPUT;
    tt++;
    
    // Parameter 'write_to_dated_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_to_dated_dir");
    tt->descr = tdrpStrDup("Option to write to a directory named after the date.");
    tt->help = tdrpStrDup("If FALSE, files will be written to output_dir/.If TRUE, files will be written to output_dir/yyyymmdd/.");
    tt->val_offset = (char *) &write_to_dated_dir - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_latest_data_info_file'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_latest_data_info_file");
    tt->descr = tdrpStrDup("Option to write latest data info file to output dir.");
    tt->help = tdrpStrDup("If TRUE, latest_data_info files will be written after the file itself.");
    tt->val_offset = (char *) &write_latest_data_info_file - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_nbeams_in_file'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_nbeams_in_file");
    tt->descr = tdrpStrDup("Max number of beams in a file");
    tt->help = tdrpStrDup("Set to -1 to impose no maximum");
    tt->val_offset = (char *) &max_nbeams_in_file - &_start_;
    tt->single_val.i = 1024;
    tt++;
    
    // Parameter 'use_fixed_angle_for_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_fixed_angle_for_filename");
    tt->descr = tdrpStrDup("Option to use the fixed (target) angle in file name.");
    tt->help = tdrpStrDup("If TRUE, the fixed angle in the center of the sweep will be used to name the file. If FALSE, the mean of the angles in the sweep will be used to name the file.");
    tt->val_offset = (char *) &use_fixed_angle_for_filename - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'filter_antenna_transitions'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_antenna_transitions");
    tt->descr = tdrpStrDup("Option to filter data when the transition flag is set.");
    tt->help = tdrpStrDup("If TRUE, the program will filter out beams which are computed when the antenna is moving from one tilt to the next, or one volume to the next.");
    tt->val_offset = (char *) &filter_antenna_transitions - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("RADAR PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'project_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("project_name");
    tt->descr = tdrpStrDup("Name of project");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &project_name - &_start_;
    tt->single_val.s = tdrpStrDup("REFRACTT");
    tt++;
    
    // Parameter 'platform_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("platform_name");
    tt->descr = tdrpStrDup("Name of instrument platform");
    tt->help = tdrpStrDup("This is normally the radar name, and is used in the sweep file name.");
    tt->val_offset = (char *) &platform_name - &_start_;
    tt->single_val.s = tdrpStrDup("SPOL");
    tt++;
    
    // Parameter 'producer_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("producer_name");
    tt->descr = tdrpStrDup("Name of producer");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &producer_name - &_start_;
    tt->single_val.s = tdrpStrDup("NCAR RAL");
    tt++;
    
    // Parameter 'use_target_elev'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_target_elev");
    tt->descr = tdrpStrDup("Flag indicating whether to use the target elevation");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &use_target_elev - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'override_radar_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_location");
    tt->descr = tdrpStrDup("Option to override radar location.");
    tt->help = tdrpStrDup("If TRUE, the program will use location specified in the 'radar_location' parameter.");
    tt->val_offset = (char *) &override_radar_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_location'
    // ctype is '_radar_location_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("radar_location");
    tt->descr = tdrpStrDup("Radar location if override is set true.");
    tt->help = tdrpStrDup("The radar_location is only used if 'override_radar_location' is set true. Otherwise the information in the input data stream is used. Note that the altitude is in kilometers, not meters.");
    tt->val_offset = (char *) &radar_location - &_start_;
    tt->struct_def.name = tdrpStrDup("radar_location_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("latitude");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &radar_location.latitude - (char *) &radar_location;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("longitude");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &radar_location.longitude - (char *) &radar_location;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("altitude");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &radar_location.altitude - (char *) &radar_location;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0;
    tt++;
    
    // Parameter 'override_beam_width'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_beam_width");
    tt->descr = tdrpStrDup("Option to override radar beam width.");
    tt->help = tdrpStrDup("If TRUE, the program will use beam width specified in the 'beam_width' parameter.");
    tt->val_offset = (char *) &override_beam_width - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'beam_width'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("beam_width");
    tt->descr = tdrpStrDup("Radar beam width if override is set true.");
    tt->help = tdrpStrDup("The beam width is only used if 'override_beam_width' is set true. Otherwise the information in the input data stream is used.");
    tt->val_offset = (char *) &beam_width - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'set_calib_power_to_measured_power'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_calib_power_to_measured_power");
    tt->descr = tdrpStrDup("Option to set the calibrated power as the measured power.");
    tt->help = tdrpStrDup("If TRUE, the measured power will be stored as calibrated power.");
    tt->val_offset = (char *) &set_calib_power_to_measured_power - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("OUTPUT FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_output_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("Array of output fields.");
    tt->help = tdrpStrDup("The program will only output these fields\n\tdsr_name - the field name in the dsr data.\n\toutput_name - the field name in the output file. If the output_name is an empty string, the output name will be set to the dsr_name.\n\toutput_units - The units to use in the output file. This has to be an enumerated list because that's all that's allowed by the library that creates the output file.\n\toutput_encoding - The encoding to use in the output file.\n\t  SI16: signed 16-bit integer, with scale and bias\n\t        si16 = (float - bias) / scale\n\t  FL32: 32-bit floating point\n\toutput_scale - the scaling to be used for ENCODING_SI16\n\t    set scale to -9999 to use the scaling from the input data\n\toutput_bias - the bias to be used for ENCODING_SI16\n\t    bias should normally be set to 0.0\n\n");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(output_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("output_field_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("dsr_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_fields->dsr_name - (char *) _output_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("output_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_fields->output_name - (char *) _output_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("field_units_t");
      tt->struct_def.fields[2].fname = tdrpStrDup("output_units");
      tt->struct_def.fields[2].ptype = ENUM_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_output_fields->output_units - (char *) _output_fields;
        tt->struct_def.fields[2].enum_def.name = tdrpStrDup("field_units_t");
        tt->struct_def.fields[2].enum_def.nfields = 4;
        tt->struct_def.fields[2].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[2].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[2].enum_def.fields[0].name = tdrpStrDup("UNITS_NONE");
        tt->struct_def.fields[2].enum_def.fields[0].val = UNITS_NONE;
        tt->struct_def.fields[2].enum_def.fields[1].name = tdrpStrDup("UNITS_REFL");
        tt->struct_def.fields[2].enum_def.fields[1].val = UNITS_REFL;
        tt->struct_def.fields[2].enum_def.fields[2].name = tdrpStrDup("UNITS_POWER");
        tt->struct_def.fields[2].enum_def.fields[2].val = UNITS_POWER;
        tt->struct_def.fields[2].enum_def.fields[3].name = tdrpStrDup("UNITS_VEL");
        tt->struct_def.fields[2].enum_def.fields[3].val = UNITS_VEL;
      tt->struct_def.fields[3].ftype = tdrpStrDup("field_encoding_t");
      tt->struct_def.fields[3].fname = tdrpStrDup("output_encoding");
      tt->struct_def.fields[3].ptype = ENUM_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_output_fields->output_encoding - (char *) _output_fields;
        tt->struct_def.fields[3].enum_def.name = tdrpStrDup("field_encoding_t");
        tt->struct_def.fields[3].enum_def.nfields = 2;
        tt->struct_def.fields[3].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[3].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[3].enum_def.fields[0].name = tdrpStrDup("ENCODING_SI16");
        tt->struct_def.fields[3].enum_def.fields[0].val = ENCODING_SI16;
        tt->struct_def.fields[3].enum_def.fields[1].name = tdrpStrDup("ENCODING_FL32");
        tt->struct_def.fields[3].enum_def.fields[1].val = ENCODING_FL32;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("output_scale");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_output_fields->output_scale - (char *) _output_fields;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("output_bias");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_output_fields->output_bias - (char *) _output_fields;
    tt->n_struct_vals = 12;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].s = tdrpStrDup("DBZ");
      tt->struct_vals[2].e = UNITS_REFL;
      tt->struct_vals[3].e = ENCODING_FL32;
      tt->struct_vals[4].d = -9999;
      tt->struct_vals[5].d = 0;
      tt->struct_vals[6].s = tdrpStrDup("VEL");
      tt->struct_vals[7].s = tdrpStrDup("VEL");
      tt->struct_vals[8].e = UNITS_VEL;
      tt->struct_vals[9].e = ENCODING_FL32;
      tt->struct_vals[10].d = -9999;
      tt->struct_vals[11].d = 0;
    tt++;
    
    // Parameter 'override_nyquist'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_nyquist");
    tt->descr = tdrpStrDup("Option to override nyquist velocity in incoming data.");
    tt->help = tdrpStrDup("If true, the nyquist_velocity parameter is used to specify the nyquist. If false, the nyquist is computed from the incoming radar data stream. The nyquist is used for velocity interpolation, to ensure that folded values are treated correctlty.");
    tt->val_offset = (char *) &override_nyquist - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nyquist_velocity'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("nyquist_velocity");
    tt->descr = tdrpStrDup("Specify nyquist velocity (m/s).");
    tt->help = tdrpStrDup("See 'override_nyquist'.");
    tt->val_offset = (char *) &nyquist_velocity - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'scale_by_100_bias_0'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("scale_by_100_bias_0");
    tt->descr = tdrpStrDup("Option to use scale of 100, bias of 0.");
    tt->help = tdrpStrDup("If TRUE, the program will scale output parameterswith scale of 100, bias of 0 - needed for S-Pol legacy.  Rain and Particle ID derived products If FALSE, it will use 'standard' product scaling.");
    tt->val_offset = (char *) &scale_by_100_bias_0 - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
