/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program VerifyGrid
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Computes verification statistics for gridded forecasts. The forecast and truth grids are read in from MDV files. Output is printed to stdout.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed with the appropriate level of detail.");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_WARNINGS");
      tt->enum_def.fields[1].val = DEBUG_WARNINGS;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[2].val = DEBUG_NORM;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[3].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operation mode");
    tt->help = tdrpStrDup("Program may be run in two modes, archive and realtime. In realtime mode, the analysis is performed for each volume scan as it becomes available. In archiv mode, the file list is obtained from the command line.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
    tt->single_val.e = ARCHIVE;
    tt++;
    
    // Parameter 'max_realtime_valid_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_realtime_valid_age");
    tt->descr = tdrpStrDup("Max age of input data");
    tt->help = tdrpStrDup("For realtime only - max age of input data for it to be valid");
    tt->val_offset = (char *) &max_realtime_valid_age - &_start_;
    tt->single_val.i = 300;
    tt++;
    
    // Parameter 'method'
    // ctype is '_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("method");
    tt->descr = tdrpStrDup("Method of operation.");
    tt->help = tdrpStrDup("Methods are (1) CONT - contingency table analysis for a grid, with text output. (2) REGION method, in which contingency data for a series of circular areas is computed and printed to stdout. (3) STATS analysis, printing stats to stdout and an xgraph output option. (4) REGRESSION method - data pairs for plotting with ascii_to_xgraph, output to stdout. (5) MAP - Added by Niles - use a set of map files.");
    tt->val_offset = (char *) &method - &_start_;
    tt->enum_def.name = tdrpStrDup("method_t");
    tt->enum_def.nfields = 5;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("GRID_CONT_METHOD");
      tt->enum_def.fields[0].val = GRID_CONT_METHOD;
      tt->enum_def.fields[1].name = tdrpStrDup("REGION_CONT_METHOD");
      tt->enum_def.fields[1].val = REGION_CONT_METHOD;
      tt->enum_def.fields[2].name = tdrpStrDup("STATS_METHOD");
      tt->enum_def.fields[2].val = STATS_METHOD;
      tt->enum_def.fields[3].name = tdrpStrDup("REGRESSION_METHOD");
      tt->enum_def.fields[3].val = REGRESSION_METHOD;
      tt->enum_def.fields[4].name = tdrpStrDup("MAP_CONT_METHOD");
      tt->enum_def.fields[4].val = MAP_CONT_METHOD;
    tt->single_val.e = GRID_CONT_METHOD;
    tt++;
    
    // Parameter 'forecast_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("forecast_dir");
    tt->descr = tdrpStrDup("ARCHIVE mode only. Directory for forecast grid files");
    tt->help = tdrpStrDup("The files in this directory are sampled to get the data for this program.");
    tt->val_offset = (char *) &forecast_dir - &_start_;
    tt->single_val.s = tdrpStrDup(".");
    tt++;
    
    // Parameter 'forecast_lead_time'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("forecast_lead_time");
    tt->descr = tdrpStrDup("Forecast lead time (secs)");
    tt->help = tdrpStrDup("Number of seconds by which the forecast lies in the future.");
    tt->val_offset = (char *) &forecast_lead_time - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'forecast_field'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("forecast_field");
    tt->descr = tdrpStrDup("Forecast field number");
    tt->help = tdrpStrDup("Field number of forecast data in cartesian grid (0-based)");
    tt->val_offset = (char *) &forecast_field - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'forecast_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("forecast_ht");
    tt->descr = tdrpStrDup("Forecast plane height (km).");
    tt->help = tdrpStrDup("This is the height of the forecast data to be used. The closest available plane will be selected. Set to -1 to select composite (column-max) data.");
    tt->val_offset = (char *) &forecast_ht - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'forecast_level_lower'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("forecast_level_lower");
    tt->descr = tdrpStrDup("Lower value for forecast level");
    tt->help = tdrpStrDup("Only include forecast data above this value in the contingency table analysis");
    tt->val_offset = (char *) &forecast_level_lower - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'forecast_level_upper'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("forecast_level_upper");
    tt->descr = tdrpStrDup("Upper value for forecast level");
    tt->help = tdrpStrDup("Only include forecast data below this value in the contingency table analysis.");
    tt->val_offset = (char *) &forecast_level_upper - &_start_;
    tt->single_val.d = 100;
    tt++;
    
    // Parameter 'truth_data_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("truth_data_dir");
    tt->descr = tdrpStrDup("Truth data directory");
    tt->help = tdrpStrDup("Directory for dobson cartesian radar data files - truth");
    tt->val_offset = (char *) &truth_data_dir - &_start_;
    tt->single_val.s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'truth_field'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("truth_field");
    tt->descr = tdrpStrDup("Truth field number");
    tt->help = tdrpStrDup("Field number of truth data in cartesian grid (0-based)");
    tt->val_offset = (char *) &truth_field - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'truth_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("truth_ht");
    tt->descr = tdrpStrDup("Truth plane height (km).");
    tt->help = tdrpStrDup("This is the height of the truth data to be used. The closest available plane will be selected. Set to -1 to select composite (column-max) data.");
    tt->val_offset = (char *) &truth_ht - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'truth_level_lower'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("truth_level_lower");
    tt->descr = tdrpStrDup("Lower value for truth level");
    tt->help = tdrpStrDup("Only include truth data above this value in the contingecy table analysis");
    tt->val_offset = (char *) &truth_level_lower - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'truth_level_upper'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("truth_level_upper");
    tt->descr = tdrpStrDup("Upper value for truth level");
    tt->help = tdrpStrDup("Only include truth data below this value in the contingecy table analysis");
    tt->val_offset = (char *) &truth_level_upper - &_start_;
    tt->single_val.d = 100;
    tt++;
    
    // Parameter 'file_time_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("file_time_margin");
    tt->descr = tdrpStrDup("Time margin (secs)");
    tt->help = tdrpStrDup("Margin around actual file time used when determining time match");
    tt->val_offset = (char *) &file_time_margin - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'output_region_spdb'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_region_spdb");
    tt->descr = tdrpStrDup("Option to output SPDB data for REGION_CONT_METHOD.");
    tt->help = tdrpStrDup("If set, the region contingency data is stored in an SPDB database. See 'region_spdb_dir'.");
    tt->val_offset = (char *) &output_region_spdb - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'region_spdb_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("region_spdb_dir");
    tt->descr = tdrpStrDup("REGION_CONT_METHOD only. Output directory for SPDB data.");
    tt->help = tdrpStrDup("The region contingency data is optionally stored as SPDB data. See 'output_region_spdb'.");
    tt->val_offset = (char *) &region_spdb_dir - &_start_;
    tt->single_val.s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'spdb_valid_period'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("spdb_valid_period");
    tt->descr = tdrpStrDup("Period for which the SPBD products remain valid (secs).");
    tt->help = tdrpStrDup("This is used by the displays to decide when to age off products which are no longer valid.");
    tt->val_offset = (char *) &spdb_valid_period - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'check_grid_geom'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_grid_geom");
    tt->descr = tdrpStrDup("REGRESSION_METHOD only. Check grid geometry.");
    tt->help = tdrpStrDup("If set to FALSE, the program will assume that the grids which are being used are effectively the same, and no checking will be done.");
    tt->val_offset = (char *) &check_grid_geom - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'use_specified_grid'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_specified_grid");
    tt->descr = tdrpStrDup("Option to use the specified grid for the analysis.");
    tt->help = tdrpStrDup("If set, the grid specified by the 'specified_grid' param is used for evaluation. Otherwise the native data grid is used.");
    tt->val_offset = (char *) &use_specified_grid - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specified_grid'
    // ctype is '_grid_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("specified_grid");
    tt->descr = tdrpStrDup("Grid parameters");
    tt->help = tdrpStrDup("The grid params for the regression method");
    tt->val_offset = (char *) &specified_grid - &_start_;
    tt->struct_def.name = tdrpStrDup("grid_t");
    tt->struct_def.nfields = 8;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("origin_lat");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &specified_grid.origin_lat - (char *) &specified_grid;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("origin_lon");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &specified_grid.origin_lon - (char *) &specified_grid;
      tt->struct_def.fields[2].ftype = tdrpStrDup("int");
      tt->struct_def.fields[2].fname = tdrpStrDup("nx");
      tt->struct_def.fields[2].ptype = INT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &specified_grid.nx - (char *) &specified_grid;
      tt->struct_def.fields[3].ftype = tdrpStrDup("int");
      tt->struct_def.fields[3].fname = tdrpStrDup("ny");
      tt->struct_def.fields[3].ptype = INT_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &specified_grid.ny - (char *) &specified_grid;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("minx");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &specified_grid.minx - (char *) &specified_grid;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("miny");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &specified_grid.miny - (char *) &specified_grid;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("dx");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &specified_grid.dx - (char *) &specified_grid;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("dy");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &specified_grid.dy - (char *) &specified_grid;
    tt->n_struct_vals = 8;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].i = 0;
      tt->struct_vals[3].i = 0;
      tt->struct_vals[4].d = 0;
      tt->struct_vals[5].d = 0;
      tt->struct_vals[6].d = 0;
      tt->struct_vals[7].d = 0;
    tt++;
    
    // Parameter 'load_means_in_specified_grid'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("load_means_in_specified_grid");
    tt->descr = tdrpStrDup("Option to load up the specified grid with means instead of nearest neighbor values.");
    tt->help = tdrpStrDup("If set, the value stored at each grid location is the mean of the native points which fall within that grid block. Otherwise the nearest neighbor is used to load the grid.");
    tt->val_offset = (char *) &load_means_in_specified_grid - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'check_range'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_range");
    tt->descr = tdrpStrDup("Option to check range from radar");
    tt->help = tdrpStrDup("If set, the range from the radar is checked. Only points at less than the maximum range are used");
    tt->val_offset = (char *) &check_range - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_range");
    tt->descr = tdrpStrDup("Max range (km)");
    tt->help = tdrpStrDup("Max. range (km) for analysis - data beyond this is ignored");
    tt->val_offset = (char *) &max_range - &_start_;
    tt->single_val.d = 150;
    tt++;
    
    // Parameter 'relaxed_contingency'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("relaxed_contingency");
    tt->descr = tdrpStrDup("GRID_CONT_METHOD only. Option to use a relaxed algorithm to compute the contingencies");
    tt->help = tdrpStrDup("If set, a relaxed algorithm is used. This means that surrounding points are used in determining the contingency values. The contingency_search_margin governs the search limits. See the code for details");
    tt->val_offset = (char *) &relaxed_contingency - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'relax_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("relax_forecast");
    tt->descr = tdrpStrDup("GRID_CONT_METHOD with relaxed_contingency only. Option to relax the forecast grid.");
    tt->help = tdrpStrDup("If set, a relaxed algorithm is used for both forecast and truth gids, else thruth only.");
    tt->val_offset = (char *) &relax_forecast - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'relaxed_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("relaxed_margin");
    tt->descr = tdrpStrDup("GRID_CONT_METHOD only. Search margin (grid units)");
    tt->help = tdrpStrDup("Number of adjacent grids searched for contingency match. See relaxed_contingency");
    tt->val_offset = (char *) &relaxed_margin - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'truth_must_fill_relaxed'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("truth_must_fill_relaxed");
    tt->descr = tdrpStrDup("Option to only regard truth as filled relaxed grid.");
    tt->help = tdrpStrDup("If set, a truth point is only considered as active if ALL of the points within the relaxed grid are set. If not set, a truth point is active if any point in the relaxed grid is set.");
    tt->val_offset = (char *) &truth_must_fill_relaxed - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_scan_cont'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_scan_cont");
    tt->descr = tdrpStrDup("GRID_CONT_METHOD only. Option to output scan-by-scan contingency data to named dir");
    tt->help = tdrpStrDup("If set, the contingency table data computed for each scan will be output to a file in the named directory. The file name will comprise the date and the specified file extension");
    tt->val_offset = (char *) &output_scan_cont - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'scan_cont_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("scan_cont_dir");
    tt->descr = tdrpStrDup("Dir path for scan-by-scan contingency data");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &scan_cont_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'scan_cont_ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("scan_cont_ext");
    tt->descr = tdrpStrDup("Extension for scan-by-scan contingency data");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &scan_cont_ext - &_start_;
    tt->single_val.s = tdrpStrDup("cont");
    tt++;
    
    // Parameter 'projection'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("projection");
    tt->descr = tdrpStrDup("GRID_CONT_METHOD only. Projection type for intermediate grid file");
    tt->help = tdrpStrDup("Projection type to put in intermediate grid file so it can be displayed.  See output_intermediate_grids parameter.");
    tt->val_offset = (char *) &projection - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_FLAT");
      tt->enum_def.fields[0].val = PROJ_FLAT;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_LATLON");
      tt->enum_def.fields[1].val = PROJ_LATLON;
    tt->single_val.e = PROJ_FLAT;
    tt++;
    
    // Parameter 'output_intermediate_grids'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_intermediate_grids");
    tt->descr = tdrpStrDup("GRID_CONT_METHOD only. Option to output intermediate grids to an MDV file");
    tt->help = tdrpStrDup("If set, the intermediate grids are output in an MDV file.  The intermediate grids are the truth and forecast grids mapped onto the specified contingency grid and set to 1 if the input grid is between the specified limits, 0 otherwise.  The intermediate grids will only be output if this is set and use_native_grid and relaxed_contingency are both FALSE and you are in CONT method.");
    tt->val_offset = (char *) &output_intermediate_grids - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'intermediate_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("intermediate_dir");
    tt->descr = tdrpStrDup("Intermediate grid output directory");
    tt->help = tdrpStrDup("The directory to be used for intermediate grids.  Only used if output_intermediate_grids is TRUE.  The files in this directory are named YYYYMMDD/hhmmss.mdv using the centroid time of the truth file as the time used in naming the file.");
    tt->val_offset = (char *) &intermediate_dir - &_start_;
    tt->single_val.s = tdrpStrDup(".");
    tt++;
    
    // Parameter 'regions'
    // ctype is '_regions_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("regions");
    tt->descr = tdrpStrDup("REGION_CONT_METHOD only. Details of circular regions.");
    tt->help = tdrpStrDup("In REGION_CONT_METHOD, statistics are computed for a series of circular regions. The region is centered on the given lat and lon point, with the radius as given in km. The percent coverage for an event is also given per region.");
    tt->array_offset = (char *) &_regions - &_start_;
    tt->array_n_offset = (char *) &regions_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(regions_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("regions_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_regions->name - (char *) _regions;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("lat");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_regions->lat - (char *) _regions;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("lon");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_regions->lon - (char *) _regions;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("radius");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_regions->radius - (char *) _regions;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("percent_covered");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_regions->percent_covered - (char *) _regions;
    tt->n_struct_vals = 5;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("not_set");
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0;
      tt->struct_vals[3].d = 0;
      tt->struct_vals[4].d = 0;
    tt++;
    
    // Parameter 'MapList'
    // ctype is '_map_list_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("MapList");
    tt->descr = tdrpStrDup("MAP_CONT_METHOD only. List of map files.");
    tt->help = tdrpStrDup("In MAP_CONT_METHOD, statistics are computed for a series of user-defined regions. The regions are defined by map files. The percent coverage must be specified along with the file names.");
    tt->array_offset = (char *) &_MapList - &_start_;
    tt->array_n_offset = (char *) &MapList_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(map_list_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("map_list_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("filename");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_MapList->filename - (char *) _MapList;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("percent_covered");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_MapList->percent_covered - (char *) _MapList;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("not_set");
      tt->struct_vals[1].d = 0;
    tt++;
    
    // Parameter 'min_regression_val'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_regression_val");
    tt->descr = tdrpStrDup("REGRESSION_METHOD only. Min regression data value");
    tt->help = tdrpStrDup("Only points with data above this value are included in the regresion analysis");
    tt->val_offset = (char *) &min_regression_val - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = -1000;
    tt->max_val.d = 1000;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'regression_include_missing'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("regression_include_missing");
    tt->descr = tdrpStrDup("REGRESSION_METHOD only. Option to include missing data values in the output.");
    tt->help = tdrpStrDup("If set, missing values are included in the output. Missing values appear as -9999.999.");
    tt->val_offset = (char *) &regression_include_missing - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'hist'
    // ctype is '_hist_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("hist");
    tt->descr = tdrpStrDup("STATS_METHOD only. Histogram parameters");
    tt->help = tdrpStrDup("The params for the histogram in stats method. This is a histogram of all of the truth data values for which the corresponding forecast data value falls between the forecast_level_lower and forecast_level_upper parameters.");
    tt->val_offset = (char *) &hist - &_start_;
    tt->struct_def.name = tdrpStrDup("hist_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("n_intervals");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &hist.n_intervals - (char *) &hist;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("low_limit");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &hist.low_limit - (char *) &hist;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("interval_size");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &hist.interval_size - (char *) &hist;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
