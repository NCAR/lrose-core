/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/***************************************************************
 * write_c++_mode.c
 *
 * Routines to write to the C++ mode output files
 *
 * Mike Dixon, RAP, NCAR, Boulder, CO, USA
 *
 * April 1998
 *
 ****************************************************************/

#include "tdrp_gen.h"
#include <time.h>
#include <limits.h>
#include <float.h>

#define BOOL_STR(a) ((a)? "TRUE" : "FALSE")

static char *EscapedStr = NULL;
static char *escape_quotes(const char *str);
static void free_escaped_str();
static char *print_val(int ptype, const enum_def_t *enum_def, const tdrpVal_t *val);
static void write_comments_default_constructor(FILE *out);
static void write_comments_copy_constructor(FILE *out);
static void write_comments_destructor(FILE *out);
static void write_comments_assignment(FILE *out);
static void write_comments_load_from_args(FILE *out);
static void write_comments_load_apply_args(FILE *out);
static void write_comments_is_arg_valid(FILE *out);
static void write_comments_is_arg_validN(FILE *out);
static void write_comments_load(FILE *out);
static void write_comments_load_from_buf(FILE *out);
static void write_comments_load_defaults(FILE *out);
static void write_comments_sync(FILE *out);
static void write_comments_print(FILE *out);
static void write_comments_check_all_set(FILE *out);
static void write_comments_check_is_set(FILE *out);
static void write_comments_free_all(FILE *out);
static void write_comments_array_realloc(FILE *out);
static void write_comments_array2D_realloc(FILE *out);
static void write_comments_usage(FILE *out);
static void write_comments_init(FILE *out);
static void write_copyright(FILE *out);

/***********************************************
 * write_hh_file()
 *
 * Write the header file
 *
 * Returns 0 on success, -1 on failure.
 */

int write_hh_file(const char *class_name, 
                  const TDRPtable *t_entries,
		  int n_defs,
                  const char *prog_name,
                  const char *lib_name,
                  const char *output_dir,
                  int singleton)
  
{

  char hname[4192];
  FILE *hfile;
  int i, j;
  const TDRPtable *tt;

  /*
   * open file
   */
  
  if (strcmp(output_dir, ".")) {
    sprintf(hname,"%s/%s.hh", output_dir, class_name);
  } else {
    sprintf(hname,"%s.hh", class_name);
  }

  if ((hfile = fopen(hname, "w")) == NULL) {
    fprintf(stderr, "ERROR: tdrp_gen:write_hh_file, opening file\n");
    perror(hname);
    return (-1);
  }

  /*
   * copyright
   */

  write_copyright(hfile);

  /*
   * preamble
   */

  fprintf(hfile, "////////////////////////////////////////////\n");
  fprintf(hfile, "// %s\n", hname);
  fprintf(hfile, "//\n");
  fprintf(hfile, "// TDRP header file for '%s' class.\n", class_name);
  fprintf(hfile, "//\n");
  if (prog_name != NULL) {
    fprintf(hfile, "// Code for program %s\n", prog_name);
    fprintf(hfile, "//\n");
  }
  fprintf(hfile, "// This header file has been automatically\n");
  fprintf(hfile, "// generated by TDRP, do not modify.\n");
  fprintf(hfile, "//\n");
  fprintf(hfile, "/////////////////////////////////////////////\n");
  fprintf(hfile, "\n");

  fprintf(hfile, "/**\n");
  fprintf(hfile, " *\n");
  fprintf(hfile, " * @file %s.hh\n", class_name);
  fprintf(hfile, " *\n");
  fprintf(hfile, " * This class is automatically generated by the Table\n");
  fprintf(hfile, " * Driven Runtime Parameters (TDRP) system\n");
  fprintf(hfile, " *\n");
  if (singleton) {
    fprintf(hfile, " * @class %s - singleton\n", class_name);
  } else {
    fprintf(hfile, " * @class %s\n", class_name);
  }
  fprintf(hfile, " *\n");
  fprintf(hfile, " * @author automatically generated\n");
  fprintf(hfile, " *\n");
  fprintf(hfile, " */\n");
  fprintf(hfile, "\n");

  fprintf(hfile, "#ifndef %s_hh\n", class_name);
  fprintf(hfile, "#define %s_hh\n", class_name);
  fprintf(hfile, "\n");
  fprintf(hfile, "#include <tdrp/tdrp.h>\n");
  fprintf(hfile, "#include <iostream>\n");
  fprintf(hfile, "#include <cstdio>\n");
  fprintf(hfile, "#include <cstdlib>\n");
  fprintf(hfile, "#include <cstring>\n");
  fprintf(hfile, "#include <climits>\n");
  fprintf(hfile, "#include <cfloat>\n");
  fprintf(hfile, "\n");
  fprintf(hfile, "using namespace std;\n");
  fprintf(hfile, "\n");

  /*
   * start of class definition
   */

  fprintf(hfile, "// Class definition\n\n");

  fprintf(hfile, "class %s {\n\n", class_name);

  /*
   * public members
   */

  fprintf(hfile, "public:\n\n");

  /*
   * enum typedefs
   */

  if (n_enum_defs() > 0) {
    fprintf(hfile, "  // enum typedefs\n\n");
  }

  for (i = 0; i < n_enum_defs(); i++) {
    enum_def_t *enm = enum_def_by_index(i);
    fprintf(hfile, "  typedef enum {\n");
    for (j = 0; j < enm->nfields; j++) {
      fprintf(hfile, "    %s = %d",
	      enm->fields[j].name, enm->fields[j].val);
      if (j < enm->nfields - 1) {
	fprintf(hfile, ",\n");
      } else {
	fprintf(hfile, "\n");
      }
    } /* j */
    fprintf(hfile, "  } %s;\n", enm->name);
    fprintf(hfile, "\n");
  } /* i */

  /*
   * struct typedefs
   */
  
  if (n_struct_defs() > 0) {
    fprintf(hfile, "  // struct typedefs\n\n");
  }

  for (i = 0; i < n_struct_defs(); i++) {
    struct_def_t *strct = struct_def_by_index(i);
    fprintf(hfile, "  typedef struct {\n");
    for (j = 0; j < strct->nfields; j++) {
      if (strct->fields[j].ptype == ENUM_TYPE) {
	fprintf(hfile, "    %s %s;\n",
		strct->fields[j].ftype,
		strct->fields[j].fname);
      } else {
	fprintf(hfile, "    %s %s;\n",
		ctype_cname_by_iname(strct->fields[j].ftype),
		strct->fields[j].fname);
      }
    } /* j */
    fprintf(hfile, "  } %s;\n", strct->name);
    fprintf(hfile, "\n");
  } /* i */

  /*
   * function prototypes
   */

  fprintf(hfile,
	  "  ///////////////////////////\n"
	  "  // Member functions\n"
	  "  //\n\n");

  /*
   * Constructor
   */

  if (singleton) {
    
    fprintf(hfile, "  // Get singleton instance pointer\n\n");
    fprintf(hfile, "  static %s *Inst();\n\n", class_name);
    fprintf(hfile, "private:\n\n");
    fprintf(hfile, "    // Singleton instance pointer is private\n");
    fprintf(hfile, "    static %s *_instance;\n\n", class_name);
    fprintf(hfile, "    // Constructor is private\n");
    fprintf(hfile, "    %s ();\n\n", class_name);
    fprintf(hfile, "public:\n\n");

  } else {

    write_comments_default_constructor(hfile);
    fprintf(hfile,
            "  %s ();\n\n", class_name);

  }
  
  /*
   * copy constructor
   */

  write_comments_copy_constructor(hfile);
  
  fprintf(hfile,
	  "  %s (const %s&);\n\n", class_name, class_name);
  
  /*
   * destructor
   */

  write_comments_destructor(hfile);
  
  fprintf(hfile, "  ~%s ();\n\n", class_name);

  /*
   * assignment
   */

  write_comments_assignment(hfile);
  
  fprintf(hfile,
	  "  void operator=(const %s&);\n\n", class_name);
  
  /*
   * load from args
   */

  write_comments_load_from_args(hfile);

  fprintf(hfile,
	  "  int loadFromArgs(int argc, char **argv,\n"
	  "                   char **override_list,\n"
	  "                   char **params_path_p,\n"
	  "                   bool defer_exit = false);\n\n");

  fprintf(hfile,
	  "  bool exitDeferred() { return (_exitDeferred); }\n\n");

  /*
   * load apply args
   */

  write_comments_load_apply_args(hfile);

  fprintf(hfile,
	  "  int loadApplyArgs(const char *params_path,\n"
	  "                    int argc, char **argv,\n"
	  "                    char **override_list,\n"
	  "                    bool defer_exit = false);\n\n");

  /*
   * is arg valid?
   */

  write_comments_is_arg_valid(hfile);

  fprintf(hfile,
	  "  static bool isArgValid(const char *arg);\n\n");
  
  write_comments_is_arg_validN(hfile);

  fprintf(hfile,
	  "  static int isArgValidN(const char *arg);\n\n");
  


  /*
   * low-level load for multiple classes per program
   */

  write_comments_load(hfile);

  fprintf(hfile,
	  "  int load(const char *param_file_path,\n"
	  "           char **override_list,\n"
	  "           int expand_env, int debug);\n\n");

  /*
   * load from buf
   */

  write_comments_load_from_buf(hfile);

  fprintf(hfile,
	  "  int loadFromBuf(const char *param_source_str,\n"
	  "                  char **override_list,\n"
	  "                  const char *inbuf, int inlen,\n"
	  "                  int start_line_num,\n"
	  "                  int expand_env, int debug);\n\n");

  /*
   * default load for multiple classes per program
   */

  write_comments_load_defaults(hfile);

  fprintf(hfile,
	  "  int loadDefaults(int expand_env);\n\n");

  /*
   * sync()
   */

  write_comments_sync(hfile);

  fprintf(hfile, "  void sync() const;\n\n");

  /*
   * print()
   */

  write_comments_print(hfile);

  fprintf(hfile,
	  "  void print(FILE *out, tdrp_print_mode_t mode = PRINT_NORM);\n\n");
     
  /*
   * check_all_set()
   */

  write_comments_check_all_set(hfile);

  fprintf(hfile, "  int checkAllSet(FILE *out);\n\n");

  /*
   * check_is_set()
   */

  write_comments_check_is_set(hfile);

  fprintf(hfile, "  int checkIsSet(const char *param_name);\n\n");


  /*
   * array_realloc()
   */

  write_comments_array_realloc(hfile);

  fprintf(hfile,
	  "  int arrayRealloc(const char *param_name,\n"
	  "                   int new_array_n);\n\n");

  /*
   * array2D_realloc()
   */

  write_comments_array2D_realloc(hfile);

  fprintf(hfile,
	  "  int array2DRealloc(const char *param_name,\n"
	  "                     int new_array_n1,\n"
	  "                     int new_array_n2);\n\n");

  /*
   * freeAll()
   */

  write_comments_free_all(hfile);

  fprintf(hfile, "  void freeAll(void);\n\n");

  /*
   * usage()
   */

  write_comments_usage(hfile);
  
  fprintf(hfile, "  static void usage(ostream &out);\n\n");

  /*
   * data members - these are the parameters
   */

  fprintf(hfile,
	  "  ///////////////////////////\n"
	  "  // Data Members\n"
	  "  //\n\n");

  fprintf(hfile,
	  "  char _start_; // start of data region\n"
	  "                // needed for zeroing out data\n"
	  "                // and computing offsets\n\n");

  tt = t_entries;
  for (i = 0; i < n_defs; i++, tt++) {
    if (tt->ptype != COMMENT_TYPE) {
      if (tt->is_array) {
	fprintf(hfile, "  %s *_%s;\n",
		tdrpType2Str(tt), tt->param_name);
	fprintf(hfile, "  int %s_n;\n", tt->param_name);
	if (tt->is_array2D) {
	  fprintf(hfile, "  %s **__%s;\n",
		  tdrpType2Str(tt), tt->param_name);
	  fprintf(hfile, "  int %s_n1;\n", tt->param_name);
	  fprintf(hfile, "  int %s_n2;\n", tt->param_name);
	}
      } else {
	fprintf(hfile, "  %s %s;\n",
		tdrpType2Str(tt), tt->param_name);
      }
      fprintf(hfile, "\n");
    } /* if (tt->ptype != COMMENT_TYPE) */
  } /* i */

  fprintf(hfile,
	  "  char _end_; // end of data region\n"
	  "              // needed for zeroing out data\n\n");

  /*
   * private members
   */

  fprintf(hfile, "private:\n\n");
  fprintf(hfile, "  void _init();\n\n");
  fprintf(hfile, "  mutable TDRPtable _table[%d];\n\n", n_defs + 1);
  fprintf(hfile, "  const char *_className;\n\n");
  fprintf(hfile, "  bool _exitDeferred;\n\n");

  /*
   * end of class
   */

  fprintf(hfile, "};\n\n");

  /*
   * ending
   */

  fprintf(hfile, "#endif\n");
  fprintf(hfile, "\n");

  fclose(hfile);
  return (0);

}

/***********************************************
 * write_cc_file()
 *
 * Write the C++ code file
 *
 * Returns 0 on success, -1 on failure.
 */

int write_cc_file(const char *class_name,
                  const TDRPtable *t_entries,
		  int n_defs,
                  const char *prog_name,
                  const char *lib_name,
                  const char *output_dir,
                  int singleton)
  
{

  char cname[4192];
  FILE *cfile;
  int idef;
  const TDRPtable *tt;

  /*
   * open file
   */

  if (strcmp(output_dir, ".")) {
    sprintf(cname,"%s/%s.cc", output_dir, class_name);
  } else {
    sprintf(cname,"%s.cc", class_name);
  }

  if ((cfile = fopen(cname, "w")) == NULL) {
    fprintf(stderr, "ERROR: tdrp_gen:write_cc_file, opening file\n");
    perror(cname);
    return (-1);
  }

  /*
   * copyright
   */

  write_copyright(cfile);

  /*
   * preamble
   */

  fprintf(cfile,
	  "////////////////////////////////////////////\n"
	  "// %s\n"
	  "//\n", cname);

  fprintf(cfile, "// TDRP C++ code file for class '%s'.\n", class_name);
  fprintf(cfile, "//\n");
  
  if (prog_name != NULL) {
    fprintf(cfile, "// Code for program %s\n", prog_name);
    fprintf(cfile, "//\n");
  }

  fprintf(cfile,
	  "// This file has been automatically\n"
	  "// generated by TDRP, do not modify.\n"
	  "//\n"
	  "/////////////////////////////////////////////\n"
	  "\n"
	  "/**\n"
	  " *\n"
	  " * @file %s.cc\n"
	  " *\n"
	  " * @class %s\n"
	  " *\n"
	  " * This class is automatically generated by the Table\n"
	  " * Driven Runtime Parameters (TDRP) system\n"
	  " *\n"
	  " * @note Source is automatically generated from\n"
	  " *       paramdef file at compile time, do not modify\n"
	  " *       since modifications will be overwritten.\n"
	  " *\n"
	  " *\n"
	  " * @author Automatically generated\n"
	  " *\n"
	  " */\n", class_name, class_name);

  if (singleton) {
    fprintf(cfile,
            "\n/* This class is a singleton */\n");
  }

  if (lib_name == NULL) {
    fprintf(cfile,
            "#include \"%s.hh\"\n",
            class_name);
  } else {
    fprintf(cfile,
            "#include <%s/%s.hh>\n",
            lib_name,
            class_name);
  }
  fprintf(cfile, "#include <cstring>\n");
  fprintf(cfile, "\n");

  if (singleton) {
    fprintf(cfile, "// singleton instance is global\n");
    fprintf(cfile, "%s *%s::_instance = (%s *) NULL;\n\n",
            class_name, class_name, class_name);
  }
  
  /*
   * member functions
   */

  /*
   * default constructor
   */

  write_comments_default_constructor(cfile);
  
  fprintf(cfile, "  %s::%s()\n\n", class_name, class_name);
  
  fprintf(cfile,
          "  {\n\n"
          "    // zero out table\n\n"
          "    memset(_table, 0, sizeof(_table));\n\n"
          "    // zero out members\n\n"
          "    memset(&_start_, 0, &_end_ - &_start_);\n\n");
  
  fprintf(cfile,
          "    // class name\n\n"
          "    _className = \"%s\";\n\n", class_name);
  
  fprintf(cfile,
          "    // initialize table\n\n"
          "    _init();\n\n");
  
  fprintf(cfile,
          "    // set members\n\n"
          "    tdrpTable2User(_table, &_start_);\n\n"
          "    _exitDeferred = false;\n\n");
  
  fprintf(cfile, "  }\n\n");
  
  /*
   * copy constructor
   */

  write_comments_copy_constructor(cfile);
  
  fprintf(cfile,
	  "  %s::%s(const %s& source)\n\n",
	  class_name, class_name, class_name);
  
  fprintf(cfile, "  {\n\n");


  fprintf(cfile,
	  "    // sync the source object\n\n"
	  "    source.sync();\n\n");
  
  fprintf(cfile,
	  "    // zero out table\n\n"
	  "    memset(_table, 0, sizeof(_table));\n\n"
	  "    // zero out members\n\n"
	  "    memset(&_start_, 0, &_end_ - &_start_);\n\n");
  
  fprintf(cfile,
	  "    // class name\n\n"
	  "    _className = \"%s\";\n\n", class_name);
  
  fprintf(cfile,
	  "    // copy table\n\n"
	  "    tdrpCopyTable((TDRPtable *) source._table, _table);\n\n");
  
  fprintf(cfile,
	  "    // set members\n\n"
	  "    tdrpTable2User(_table, &_start_);\n\n"
	  "    _exitDeferred = false;\n\n");
  
  fprintf(cfile, "  }\n\n");

  /*
   * destructor
   */

  write_comments_destructor(cfile);
  
  fprintf(cfile, "  %s::~%s()\n\n", class_name, class_name);
  
  fprintf(cfile,
	  "  {\n\n"
	  "    // free up\n\n"
	  "    freeAll();\n\n");

  if (singleton) {
    fprintf(cfile, "    if (_instance) {\n");
    fprintf(cfile, "      delete _instance;\n");
    fprintf(cfile, "      _instance = NULL;\n");
    fprintf(cfile, "    }\n");
  }

  fprintf(cfile, "  }\n\n");
  
  /*
   * retrieve singleton instance
   */
  
  if (singleton) {

    fprintf(cfile,
            "  ////////////////////////////////////////////\n"
            "  // Inst(): retrieve singleton instance\n"
            "  //\n");

    fprintf(cfile, "  %s *%s::Inst()\n", class_name, class_name);
    fprintf(cfile, "  {\n");
    fprintf(cfile, "    if (_instance == (%s *) NULL) {\n", class_name);
    fprintf(cfile, "      _instance = new %s;\n", class_name);
    fprintf(cfile, "    }\n");
    fprintf(cfile, "    return _instance;\n");
    fprintf(cfile, "  }\n");
    fprintf(cfile, "\n");

  }

  /*
   * assignment
   */

  write_comments_assignment(cfile);
  
  fprintf(cfile,
	  "  void %s::operator=(const %s& other)\n\n",
	  class_name, class_name);
  
  fprintf(cfile, "  {\n\n");

  fprintf(cfile,
	  "    // sync the other object\n\n"
	  "    other.sync();\n\n");
  
  fprintf(cfile,
	  "    // free up any existing memory\n\n"
	  "    freeAll();\n\n");
  
  fprintf(cfile,
	  "    // zero out table\n\n"
	  "    memset(_table, 0, sizeof(_table));\n\n"
	  "    // zero out members\n\n"
	  "    memset(&_start_, 0, &_end_ - &_start_);\n\n");
  
  fprintf(cfile,
	  "    // copy table\n\n"
	  "    tdrpCopyTable((TDRPtable *) other._table, _table);\n\n");
  
  fprintf(cfile,
	  "    // set members\n\n"
	  "    tdrpTable2User(_table, &_start_);\n\n");
  
  fprintf(cfile,
	  "    _exitDeferred = other._exitDeferred;\n\n");
  
  fprintf(cfile, "  }\n\n");

  /*
   * load_from_args()
   */

  write_comments_load_from_args(cfile);
  
  fprintf(cfile ,
	  "  int %s::loadFromArgs(int argc, char **argv,\n"
	  "                           char **override_list,\n"
	  "                           char **params_path_p,\n"
	  "                           bool defer_exit)\n"
	  "  {\n"
	  "    int exit_deferred;\n"
	  "    if (_tdrpLoadFromArgs(argc, argv,\n"
	  "                          _table, &_start_,\n"
	  "                          override_list, params_path_p,\n"
	  "                          _className,\n"
	  "                          defer_exit, &exit_deferred)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      if (exit_deferred) {\n"
	  "        _exitDeferred = true;\n"
	  "      }\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * load_from_args()
   */

  write_comments_load_apply_args(cfile);
  
  fprintf(cfile ,
	  "  int %s::loadApplyArgs(const char *params_path,\n"
	  "                            int argc, char **argv,\n"
	  "                            char **override_list,\n"
	  "                            bool defer_exit)\n"
	  "  {\n"
	  "    int exit_deferred;\n"
	  "    if (tdrpLoadApplyArgs(params_path, argc, argv,\n"
	  "                          _table, &_start_,\n"
	  "                          override_list,\n"
	  "                          _className,\n"
	  "                          defer_exit, &exit_deferred)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      if (exit_deferred) {\n"
	  "        _exitDeferred = true;\n"
	  "      }\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * is arg valid?
   */

  write_comments_is_arg_valid(cfile);

  fprintf(cfile,
	  "  bool %s::isArgValid(const char *arg)\n"
	  "  {\n"
	  "    return (tdrpIsArgValid(arg));\n"
	  "  }\n\n",
	  class_name);
  
  write_comments_is_arg_validN(cfile);

  fprintf(cfile,
	  "  int %s::isArgValidN(const char *arg)\n"
	  "  {\n"
	  "    return (tdrpIsArgValidN(arg));\n"
	  "  }\n\n",
	  class_name);
  
  /*
   * load()
   */
  
  write_comments_load(cfile);
  
  fprintf(cfile,
	  "  int %s::load(const char *param_file_path,\n"
	  "                   char **override_list,\n"
	  "                   int expand_env, int debug)\n"
	  "  {\n"
	  "    if (tdrpLoad(param_file_path,\n"
	  "                 _table, &_start_,\n"
	  "                 override_list,\n"
	  "                 expand_env, debug)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * load_from_buf()
   */
  
  write_comments_load_from_buf(cfile);
  
  fprintf(cfile,
	  "  int %s::loadFromBuf(const char *param_source_str,\n"
	  "                          char **override_list,\n"
	  "                          const char *inbuf, int inlen,\n"
	  "                          int start_line_num,\n"
	  "                          int expand_env, int debug)\n"
	  "  {\n"
	  "    if (tdrpLoadFromBuf(param_source_str,\n"
	  "                        _table, &_start_,\n"
	  "                        override_list,\n"
	  "                        inbuf, inlen, start_line_num,\n"
	  "                        expand_env, debug)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * loadDefaults()
   */

  write_comments_load_defaults(cfile);

  fprintf(cfile,
	  "  int %s::loadDefaults(int expand_env)\n"
	  "  {\n"
	  "    if (tdrpLoad(NULL,\n"
	  "                 _table, &_start_,\n"
	  "                 NULL, expand_env, FALSE)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * sync()
   */
  
  write_comments_sync(cfile);

  fprintf(cfile,
	  "  void %s::sync(void) const\n"
	  "  {\n"
	  "    tdrpUser2Table(_table, (char *) &_start_);\n"
	  "  }\n\n",
	  class_name);

  /*
   * print()
   */

  write_comments_print(cfile);
  
  fprintf(cfile,
	  "  void %s::print(FILE *out, tdrp_print_mode_t mode)\n"
	  "  {\n"
	  "    tdrpPrint(out, _table, _className, mode);\n"
	  "  }\n\n",
	  class_name);
     
  /*
   * check_all_set()
   */

  write_comments_check_all_set(cfile);

  fprintf(cfile,
	  "  int %s::checkAllSet(FILE *out)\n"
	  "  {\n"
	  "    return (tdrpCheckAllSet(out, _table, &_start_));\n"
	  "  }\n\n",
	  class_name);

  /*
   * check_is_set()
   */

  write_comments_check_is_set(cfile);

  fprintf(cfile,
          "  int %s::checkIsSet(const char *paramName)\n"
          "  {\n"
          "    return (tdrpCheckIsSet(paramName, _table, &_start_));\n"
          "  }\n\n",
          class_name);

  /*
   * free_all()
   */

  write_comments_free_all(cfile);

  fprintf(cfile,
	  "  void %s::freeAll(void)\n"
	  "  {\n"
	  "    tdrpFreeAll(_table, &_start_);\n"
	  "  }\n\n",
	  class_name);

  /*
   * usage()
   */

  write_comments_usage(cfile);
  
  fprintf(cfile,
	  "  void %s::usage(ostream &out)\n"
	  "  {\n"
	  "    out << \"TDRP args: [options as below]\\n\"\n"
	  "        << \"   [ -params/--params path ] specify params file path\\n\"\n"
	  "        << \"   [ -check_params/--check_params] check which params are not set\\n\"\n"
	  "        << \"   [ -print_params/--print_params [mode]] print parameters\\n\"\n"
	  "        << \"     using following modes, default mode is 'norm'\\n\"\n"
	  "        << \"       short:   main comments only, no help or descr\\n\"\n"
	  "        << \"                structs and arrays on a single line\\n\"\n"
	  "        << \"       norm:    short + descriptions and help\\n\"\n"
	  "        << \"       long:    norm  + arrays and structs expanded\\n\"\n"
	  "        << \"       verbose: long  + private params included\\n\"\n"
	  "        << \"       short_expand:   short with env vars expanded\\n\"\n"
	  "        << \"       norm_expand:    norm with env vars expanded\\n\"\n"
	  "        << \"       long_expand:    long with env vars expanded\\n\"\n"
	  "        << \"       verbose_expand: verbose with env vars expanded\\n\"\n"
	  "        << \"   [ -tdrp_debug] debugging prints for tdrp\\n\"\n"
	  "        << \"   [ -tdrp_usage] print this usage\\n\";\n"
	  "  }\n\n",
	  class_name);

  /*
   * array_realloc()
   */

  write_comments_array_realloc(cfile);

  fprintf(cfile,
	  "  int %s::arrayRealloc(const char *param_name, int new_array_n)\n"
	  "  {\n"
	  "    if (tdrpArrayRealloc(_table, &_start_,\n"
	  "                         param_name, new_array_n)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * array2D_realloc()
   */

  write_comments_array2D_realloc(cfile);

  fprintf(cfile,
	  "  int %s::array2DRealloc(const char *param_name,\n"
	  "                             int new_array_n1,\n"
	  "                             int new_array_n2)\n"
	  "  {\n"
	  "    if (tdrpArray2DRealloc(_table, &_start_, param_name,\n"
	  "                           new_array_n1, new_array_n2)) {\n"
	  "      return (-1);\n"
	  "    } else {\n"
	  "      return (0);\n"
	  "    }\n"
	  "  }\n\n",
	  class_name);

  /*
   * _init()
   */

  write_comments_init(cfile);

  fprintf(cfile,
	  "  void %s::_init()\n\n",
	  class_name);
  
  fprintf(cfile,
	  "  {\n\n"
	  "    TDRPtable *tt = _table;\n\n");

  /*
   * members of main struct
   */

  tt = t_entries;
  for (idef = 0; idef < n_defs; idef++, tt++) {

    fprintf(cfile, "    // Parameter '%s'\n", tt->param_name);
    if (tt->ptype != COMMENT_TYPE) {
      fprintf(cfile, "    // ctype is '%s'\n",
	      ctype_cname_by_index(tt->ctype));
    }
    fprintf(cfile, "    \n");
    fprintf(cfile, "    memset(tt, 0, sizeof(TDRPtable));\n");
    fprintf(cfile, "    tt->ptype = %s;\n", tdrpTableEntry2Str(tt->ptype));
    fprintf(cfile, "    tt->param_name = tdrpStrDup(\"%s\");\n",
	    tt->param_name);
    
    if (tt->ptype == COMMENT_TYPE) {
      fprintf(cfile, "    tt->comment_hdr = tdrpStrDup(\"%s\");\n",
	      escape_quotes(tt->comment_hdr));
      fprintf(cfile, "    tt->comment_text = tdrpStrDup(\"%s\");\n",
	      escape_quotes(tt->comment_text));
      fprintf(cfile, "    tt++;\n");
      fprintf(cfile, "    \n");
      continue;
    }

    fprintf(cfile, "    tt->descr = tdrpStrDup(\"%s\");\n",
	    escape_quotes(tt->descr));
    fprintf(cfile, "    tt->help = tdrpStrDup(\"%s\");\n",
	    escape_quotes(tt->help));
    
    if (tt->is_array) {

      fprintf(cfile,
	      "    tt->array_offset = (char *) &_%s - &_start_;\n",
	      tt->param_name);
      fprintf(cfile,
	      "    tt->array_n_offset = (char *) &%s_n - &_start_;\n",
	      tt->param_name);

      if (tt->is_array2D) {
	fprintf(cfile,
		"    tt->array2D_offset = (char *) &__%s - &_start_;\n",
		tt->param_name);
	fprintf(cfile,
		"    tt->array_n1_offset = (char *) &%s_n1 - &_start_;\n",
		tt->param_name);
	fprintf(cfile,
		"    tt->array_n2_offset = (char *) &%s_n2 - &_start_;\n",
		tt->param_name);
      }

    } else {

      fprintf(cfile,
	      "    tt->val_offset = (char *) &%s - &_start_;\n",
	      tt->param_name);

    } /* if (tt->is_array) */

    if (tt->is_private) {
      fprintf(cfile, "    tt->is_private = %s;\n", BOOL_STR(tt->is_private));
    }

    if (tt->ptype == INT_TYPE || tt->ptype == LONG_TYPE ||
	tt->ptype == FLOAT_TYPE || tt->ptype == DOUBLE_TYPE) {
      if (tt->has_min) {
	fprintf(cfile, "    tt->has_min = %s;\n", BOOL_STR(tt->has_min));
      }
      if (tt->has_max) {
	fprintf(cfile, "    tt->has_max = %s;\n", BOOL_STR(tt->has_max));
      }
    }

    if (tt->is_array) {
      fprintf(cfile, "    tt->is_array = %s;\n", BOOL_STR(tt->is_array));
    }
    if (tt->is_array2D) {
      fprintf(cfile, "    tt->is_array2D = %s;\n", BOOL_STR(tt->is_array2D));
    }
    
    if (tt->is_array) { /* if (tt->is_array2D) */
      fprintf(cfile, "    tt->array_len_fixed = %s;\n",
	      BOOL_STR(tt->array_len_fixed));
      fprintf(cfile, "    tt->array_elem_size = sizeof(%s);\n",
	      tdrpType2Str(tt));
      fprintf(cfile, "    tt->array_n = %d;\n", tt->array_n);
    } /* if (tt->is_array2D) */
    
    if (tt->is_array2D) {
      fprintf(cfile, "    tt->array_n1 = %d;\n", tt->array_n1);
      fprintf(cfile, "    tt->array_n2 = %d;\n", tt->array_n2);
    }
    
    /*
     * print out min and max values
     */
    
    if (tt->has_min) {
      fprintf(cfile, "    tt->min_val.%s;\n",
	      print_val(tt->ptype, &tt->enum_def, &tt->min_val));
    }
    if (tt->has_max) {
      fprintf(cfile, "    tt->max_val.%s;\n",
	      print_val(tt->ptype, &tt->enum_def, &tt->max_val));
    }

    /*
     * enum def
     */

    if (tt->ptype == ENUM_TYPE) {

      int i;

      fprintf(cfile, "    tt->enum_def.name = tdrpStrDup(\"%s\");\n",
	      tt->enum_def.name);
      fprintf(cfile, "    tt->enum_def.nfields = %d;\n",
	      tt->enum_def.nfields);
      fprintf(cfile,
	      "    tt->enum_def.fields = (enum_field_t *)\n"
	      "        tdrpMalloc(tt->enum_def.nfields * "
	      "sizeof(enum_field_t));\n");
      
      for (i = 0; i < tt->enum_def.nfields; i++) {
	fprintf(cfile,
		"      tt->enum_def.fields[%d].name = tdrpStrDup(\"%s\");\n",
		i, tt->enum_def.fields[i].name);
	fprintf(cfile,
		"      tt->enum_def.fields[%d].val = %s;\n",
		i, tt->enum_def.fields[i].name);
      } /* i */

    } else if (tt->ptype == STRUCT_TYPE) {

      int i;
      
      fprintf(cfile, "    tt->struct_def.name = tdrpStrDup(\"%s\");\n",
	      tt->struct_def.name);
      fprintf(cfile, "    tt->struct_def.nfields = %d;\n",
	      tt->struct_def.nfields);
      fprintf(cfile,
	      "    tt->struct_def.fields = (struct_field_t *)\n"
	      "        tdrpMalloc(tt->struct_def.nfields * "
	      "sizeof(struct_field_t));\n");

      /*
       * struct fields
       */
      
      for (i = 0; i < tt->struct_def.nfields; i++) {

	fprintf(cfile,
		"      tt->struct_def.fields[%d].ftype = tdrpStrDup(\"%s\");\n",
		i, tt->struct_def.fields[i].ftype);
	fprintf(cfile,
		"      tt->struct_def.fields[%d].fname = tdrpStrDup(\"%s\");\n",
		i, tt->struct_def.fields[i].fname);
	fprintf(cfile,
		"      tt->struct_def.fields[%d].ptype = %s;\n",
		i, tdrpTableEntry2Str(tt->struct_def.fields[i].ptype));
	if (tt->is_array) {
	  fprintf(cfile,
		  "      tt->struct_def.fields[%d].rel_offset = \n"
		  "        (char *) &_%s->%s - (char *) _%s;\n",
		  i, tt->param_name,
		  tt->struct_def.fields[i].fname, tt->param_name);
	} else {
	  fprintf(cfile,
		  "      tt->struct_def.fields[%d].rel_offset = \n"
		  "        (char *) &%s.%s - (char *) &%s;\n",
		  i, tt->param_name,
		  tt->struct_def.fields[i].fname, tt->param_name);
	}

	/*
	 * extra output for enum-type struct fields
	 */

	if (tt->struct_def.fields[i].ptype == ENUM_TYPE) {

	  int j;

	  fprintf(cfile, "        tt->struct_def.fields[%d].enum_def.name "
		  "= tdrpStrDup(\"%s\");\n", i,
		  tt->struct_def.fields[i].enum_def.name);
	  fprintf(cfile, "        tt->struct_def.fields[%d].enum_def.nfields "
		  "= %d;\n", i,
		  tt->struct_def.fields[i].enum_def.nfields);
	  fprintf(cfile,
		  "        tt->struct_def.fields[%d].enum_def.fields = "
		  "(enum_field_t *) tdrpMalloc\n"
		  "          (tt->struct_def.fields[%d].enum_def.nfields * "
		  "sizeof(enum_field_t));\n", i, i);
	  for (j = 0; j < tt->struct_def.fields[i].enum_def.nfields; j++) {
	    fprintf(cfile,
		    "        tt->struct_def.fields[%d].enum_def.fields[%d].name"
		    " = tdrpStrDup(\"%s\");\n", i, j,
		    tt->struct_def.fields[i].enum_def.fields[j].name);
	    fprintf(cfile,
		    "        tt->struct_def.fields[%d].enum_def.fields[%d].val"
		    " = %s;\n", i, j,
		    tt->struct_def.fields[i].enum_def.fields[j].name);
	  } /* j */
	  
	} /* if (tt->struct_def.fields[i].ptype == ENUM_TYPE) */

      } /* i */

    } /* if (tt->ptype == ENUM_TYPE) */

    /*
     * default values
     */

    if (tt->ptype == STRUCT_TYPE) {

      int j;
      
      fprintf(cfile,
	      "    tt->n_struct_vals = %d;\n", tt->n_struct_vals);
      fprintf(cfile,
	      "    tt->struct_vals = (tdrpVal_t *)\n"
	      "        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));\n");
      for (j = 0; j < tt->n_struct_vals; j++) {
	int ifield = j % tt->struct_def.nfields;
	fprintf(cfile, "      tt->struct_vals[%d].%s;\n", j,
		print_val(tt->struct_def.fields[ifield].ptype,
			    &tt->struct_def.fields[ifield].enum_def,
			    tt->struct_vals + j));
      }


    } else if (tt->is_array2D) {

      int nvals = tt->array_n1 * tt->array_n2;
      int j;

      fprintf(cfile,
	      "    tt->array_vals = (tdrpVal_t *)\n"
	      "        tdrpMalloc(tt->array_n1 * tt->array_n2 *\n"
	      "          sizeof(tdrpVal_t));\n");
      for (j = 0; j < nvals; j++) {
	fprintf(cfile, "      tt->array_vals[%d].%s;\n", j,
		print_val(tt->ptype, &tt->enum_def, tt->array_vals + j));
      }

    } else if (tt->is_array) {

      int j;

      fprintf(cfile,
	      "    tt->array_vals = (tdrpVal_t *)\n"
	      "        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));\n");
      for (j = 0; j < tt->array_n; j++) {
	fprintf(cfile, "      tt->array_vals[%d].%s;\n", j,
		print_val(tt->ptype, &tt->enum_def, tt->array_vals + j));
      }

    } else {

      /*
       * print out single values
       */
    
      fprintf(cfile, "    tt->single_val.%s;\n",
	      print_val(tt->ptype, &tt->enum_def, &tt->single_val));

    }
    
    /*
     * increment to next table entry
     */

    fprintf(cfile, "    tt++;\n");
    fprintf(cfile, "    \n");

  } /* idef */
  
  /*
   * trailing entry has param_name of NULL
   */

  fprintf(cfile, "    // trailing entry has param_name set to NULL\n");
  fprintf(cfile, "    \n");
  fprintf(cfile, "    tt->param_name = NULL;\n");
  fprintf(cfile, "    \n");

  /*
   * _init() ending
   */

  fprintf(cfile, "    return;\n");
  fprintf(cfile, "  \n");
  fprintf(cfile, "  }\n");

  /*
   * free up etc.
   */

  free_escaped_str();
  fclose(cfile);
  return (0);

}

/******************************************
 * escape_quotes()
 *
 * Returns a string with the quotes escaped
 */

static char *escape_quotes(const char *str)

{

  const char *ss;
  char *es;

  if (str == NULL) {
    return ("");
  }

  if (EscapedStr == NULL) {
    EscapedStr = (char *) tdrpMalloc(strlen(str) * 2 + 2);
  } else {
    EscapedStr = (char *) tdrpRealloc(EscapedStr, strlen(str) * 2 + 2);
  }

  ss = str;
  es = EscapedStr;

  while (*ss != '\0') {
    if (*ss == '\"') {
      *es = '\\';
      es++;
      *es = '\"';
    } else {
      *es = *ss;
    }
    es++;
    ss++;
  }
  *es = '\0';

  return (EscapedStr);

}

/******************************************
 * free_escaped_str()
 *
 * Frees the memory for the escaped string.
 */

static void free_escaped_str()

{
  tdrpFree(EscapedStr);
  EscapedStr = NULL;
}

/************************************************************
 * print_val
 *
 * sprintfs a value to a string.
 *
 * NOTE: the string is static, so use it before calling this
 * function again.
 */

static char *print_val(int ptype, const enum_def_t *enum_def, const tdrpVal_t *val)
     
{

  static char str[65536];
  int i;
  
  switch (ptype) {
    
  case BOOL_TYPE:
    sprintf(str, "b = %s", tdrpBool2Str(val->b));
    break;
    
  case ENUM_TYPE:
    sprintf(str, "e = UNKNOWN");
    for (i = 0; i < enum_def->nfields; i++) {
      if (val->e == enum_def->fields[i].val) {
	sprintf(str, "e = %s", enum_def->fields[i].name);
	break;
      }
    }
    break;
    
  case STRING_TYPE:
    sprintf(str, "s = tdrpStrDup(\"%s\")", val->s);
    break;
    
  case INT_TYPE:
    if ( val->i == INT_MIN )
      sprintf(str, "i = INT_MIN");
    else if ( val->i == INT_MAX )
      sprintf(str, "i = INT_MAX");
    else
      sprintf(str, "i = %d", val->i);
    break;
    
  case LONG_TYPE:
    if ( val->l == LONG_MIN )
      sprintf(str, "l = LONG_MIN");
    else if ( val->l == LONG_MAX )
      sprintf(str, "l = LONG_MAX");
    else
      sprintf(str, "l = %ld", val->l);
    break;
    
  case FLOAT_TYPE:
    if ( val->f == FLT_MIN )
      sprintf(str, "f = FLT_MIN");
    else if ( val->f == FLT_MAX )
      sprintf(str, "f = FLT_MAX");
    else
      sprintf(str, "f = %g", val->f);
    break;
    
  case DOUBLE_TYPE:
    if ( val->d == DBL_MIN )
      sprintf(str, "d = DBL_MIN");
    else if ( val->d == DBL_MAX )
      sprintf(str, "d = DBL_MAX");
    else
      sprintf(str, "d = %g", val->d);
    break;
    
  default:
    break;
    
  } /* switch */

  return (str);

}  

/**************************************
 * write_comments_default_constructor()
 */

static void write_comments_default_constructor(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // Default constructor\n"
	  "  //\n\n");

}

/***********************************
 * write_comments_copy_constructor()
 */

static void write_comments_copy_constructor(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // Copy constructor\n"
	  "  //\n\n");

}

/***********************************
 * write_comments_destructor()
 */

static void write_comments_destructor(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // Destructor\n"
	  "  //\n\n");

}

/*****************************
 * write_comments_assignment()
 */

static void write_comments_assignment(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // Assignment\n"
	  "  //\n\n");

}

/*********************************
 * write_comments_load_from_args()
 */

static void write_comments_load_from_args(FILE *out)

{

  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // loadFromArgs()\n"
	  "  //\n"
	  "  // Loads up TDRP using the command line args.\n"
	  "  //\n"
	  "  // Check usage() for command line actions associated with\n"
	  "  // this function.\n"
	  "  //\n"
	  "  //   argc, argv: command line args\n"
	  "  //\n"
	  "  //   char **override_list: A null-terminated list of overrides\n"
	  "  //     to the parameter file.\n"
	  "  //     An override string has exactly the format of an entry\n"
	  "  //     in the parameter file itself.\n"
	  "  //\n"
	  "  //   char **params_path_p:\n"
	  "  //     If this is non-NULL, it is set to point to the path\n"
	  "  //     of the params file used.\n"
	  "  //\n"
	  "  //   bool defer_exit: normally, if the command args contain a \n"
	  "  //      print or check request, this function will call exit().\n"
	  "  //      If defer_exit is set, such an exit is deferred and the\n"
	  "  //      private member _exitDeferred is set.\n"
	  "  //      Use exidDeferred() to test this flag.\n"
	  "  //\n"
	  "  //  Returns 0 on success, -1 on failure.\n"
	  "  //\n\n");

}

/*********************************
 * write_comments_load_apply_args()
 */

static void write_comments_load_apply_args(FILE *out)

{

  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // loadApplyArgs()\n"
	  "  //\n"
	  "  // Loads up TDRP using the params path passed in, and applies\n"
	  "  // the command line args for printing and checking.\n"
	  "  //\n"
	  "  // Check usage() for command line actions associated with\n"
	  "  // this function.\n"
	  "  //\n"
	  "  //   const char *param_file_path: the parameter file to be read in\n"
	  "  //\n"
	  "  //   argc, argv: command line args\n"
	  "  //\n"
	  "  //   char **override_list: A null-terminated list of overrides\n"
	  "  //     to the parameter file.\n"
	  "  //     An override string has exactly the format of an entry\n"
	  "  //     in the parameter file itself.\n"
	  "  //\n"
	  "  //   bool defer_exit: normally, if the command args contain a \n"
	  "  //      print or check request, this function will call exit().\n"
	  "  //      If defer_exit is set, such an exit is deferred and the\n"
	  "  //      private member _exitDeferred is set.\n"
	  "  //      Use exidDeferred() to test this flag.\n"
	  "  //\n"
	  "  //  Returns 0 on success, -1 on failure.\n"
	  "  //\n\n");

}

/*******************************
 * write_comments_is_arg_valid()
 */

static void write_comments_is_arg_valid(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // isArgValid()\n"
	  "  // \n"
	  "  // Check if a command line arg is a valid TDRP arg.\n"
	  "  //\n\n");

}

static void write_comments_is_arg_validN(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // isArgValid()\n"
	  "  // \n"
	  "  // Check if a command line arg is a valid TDRP arg.\n"
	  "  // return number of args consumed.\n"
	  "  //\n\n");

}
     

/***********************
 * write_comments_load()
 */

static void write_comments_load(FILE *out)

{

  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // load()\n"
	  "  //\n"
	  "  // Loads up TDRP for a given class.\n"
	  "  //\n"
	  "  // This version of load gives the programmer the option to load\n"
	  "  // up more than one class for a single application. It is a\n"
	  "  // lower-level routine than loadFromArgs, and hence more\n"
	  "  // flexible, but the programmer must do more work.\n"
	  "  //\n"
	  "  //   const char *param_file_path: the parameter file to be read in.\n"
	  "  //\n"
	  "  //   char **override_list: A null-terminated list of overrides\n"
	  "  //     to the parameter file.\n"
	  "  //     An override string has exactly the format of an entry\n"
	  "  //     in the parameter file itself.\n"
	  "  //\n"
	  "  //   expand_env: flag to control environment variable\n"
	  "  //               expansion during tokenization.\n"
	  "  //               If TRUE, environment expansion is set on.\n"
	  "  //               If FALSE, environment expansion is set off.\n"
	  "  //\n"
	  "  //  Returns 0 on success, -1 on failure.\n"
	  "  //\n\n");

}

/********************************
 * write_comments_load_from_buf()
 */

static void write_comments_load_from_buf(FILE *out)

{

  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // loadFromBuf()\n"
	  "  //\n"
	  "  // Loads up TDRP for a given class.\n"
	  "  //\n"
	  "  // This version of load gives the programmer the option to\n"
	  "  // load up more than one module for a single application,\n"
	  "  // using buffers which have been read from a specified source.\n"
	  "  //\n"
	  "  //   const char *param_source_str: a string which describes the\n"
	  "  //     source of the parameter information. It is used for\n"
	  "  //     error reporting only.\n"
	  "  //\n"
	  "  //   char **override_list: A null-terminated list of overrides\n"
	  "  //     to the parameter file.\n"
	  "  //     An override string has exactly the format of an entry\n"
	  "  //     in the parameter file itself.\n"
	  "  //\n"
	  "  //   const char *inbuf: the input buffer\n"
	  "  //\n"
	  "  //   int inlen: length of the input buffer\n"
	  "  //\n"
	  "  //   int start_line_num: the line number in the source which\n"
	  "  //     corresponds to the start of the buffer.\n"
	  "  //\n"
	  "  //   expand_env: flag to control environment variable\n"
	  "  //               expansion during tokenization.\n"
	  "  //               If TRUE, environment expansion is set on.\n"
	  "  //               If FALSE, environment expansion is set off.\n"
	  "  //\n"
	  "  //  Returns 0 on success, -1 on failure.\n"
	  "  //\n\n");

}

/********************************
 * write_comments_load_defaults()
 */

static void write_comments_load_defaults(FILE *out)

{

  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // loadDefaults()\n"
	  "  //\n"
	  "  // Loads up default params for a given class.\n"
	  "  //\n"
	  "  // See load() for more detailed info.\n"
	  "  //\n"
	  "  //  Returns 0 on success, -1 on failure.\n"
	  "  //\n\n");

}

/***********************
 * write_comments_sync()
 */

static void write_comments_sync(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // sync()\n"
	  "  //\n"
	  "  // Syncs the user struct data back into the parameter table,\n"
	  "  // in preparation for printing.\n"
	  "  //\n"
	  "  // This function alters the table in a consistent manner.\n"
	  "  // Therefore it can be regarded as const.\n"
	  "  //\n\n");

}

/************************
 * write_comments_print()
 */

static void write_comments_print(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // print()\n"
	  "  // \n"
	  "  // Print params file\n"
	  "  //\n"
	  "  // The modes supported are:\n"
	  "  //\n"
	  "  //   PRINT_SHORT:   main comments only, no help or descriptions\n"
	  "  //                  structs and arrays on a single line\n"
	  "  //   PRINT_NORM:    short + descriptions and help\n"
	  "  //   PRINT_LONG:    norm  + arrays and structs expanded\n"
	  "  //   PRINT_VERBOSE: long  + private params included\n"
	  "  //\n\n");

}
     
/********************************
 * write_comments_check_all_set()
 */

static void write_comments_check_all_set(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // checkAllSet()\n"
	  "  //\n"
	  "  // Return TRUE if all set, FALSE if not.\n"
	  "  //\n"
	  "  // If out is non-NULL, prints out warning messages for those\n"
	  "  // parameters which are not set.\n"
	  "  //\n\n");

}

/********************************
 * write_comments_check_is_set()
 */

static void write_comments_check_is_set(FILE *out)

{
 
  fprintf(out,
          "  //////////////////////////////////////////////////////////////\n"
          "  // checkIsSet()\n"
          "  //\n"
          "  // Return TRUE if parameter is set, FALSE if not.\n"
          "  //\n"
          "  //\n\n");

}

/***************************
 * write_comments_free_all()
 */

static void write_comments_free_all(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // freeAll()\n"
	  "  //\n"
	  "  // Frees up all TDRP dynamic memory.\n"
	  "  //\n\n");

}

/********************************
 * write_comments_array_realloc()
 */

static void write_comments_array_realloc(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // arrayRealloc()\n"
	  "  //\n"
	  "  // Realloc 1D array.\n"
	  "  //\n"
	  "  // If size is increased, the values from the last array \n"
	  "  // entry is copied into the new space.\n"
	  "  //\n"
	  "  // Returns 0 on success, -1 on error.\n"
	  "  //\n\n");

}

/**********************************
 * write_comments_array2D_realloc()
 */

static void write_comments_array2D_realloc(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // array2DRealloc()\n"
	  "  //\n"
	  "  // Realloc 2D array.\n"
	  "  //\n"
	  "  // If size is increased, the values from the last array \n"
	  "  // entry is copied into the new space.\n"
	  "  //\n"
	  "  // Returns 0 on success, -1 on error.\n"
	  "  //\n\n");

}

/*************************
 * write_comments_usage()
 */

static void write_comments_usage(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // usage()\n"
	  "  //\n"
	  "  // Prints out usage message for TDRP args as passed\n"
	  "  // in to loadFromArgs().\n"
	  "  //\n\n");

}

/***********************
 * write_comments_init()
 */

static void write_comments_init(FILE *out)
     
{
  
  fprintf(out,
	  "  ////////////////////////////////////////////\n"
	  "  // _init()\n"
	  "  //\n"
	  "  // Class table initialization function.\n"
	  "  //\n"
	  "  //\n\n");

}

/***********************
 * write_copyright()
 */

static void write_copyright(FILE *out)
     
{

  fprintf(out,
          "/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */\n"
          "/* ** Copyright UCAR                                                         */\n"
          "/* ** University Corporation for Atmospheric Research (UCAR)                 */\n"
          "/* ** National Center for Atmospheric Research (NCAR)                        */\n"
          "/* ** Boulder, Colorado, USA                                                 */\n"
          "/* ** BSD licence applies - redistribution and use in source and binary      */\n"
          "/* ** forms, with or without modification, are permitted provided that       */\n"
          "/* ** the following conditions are met:                                      */\n"
          "/* ** 1) If the software is modified to produce derivative works,            */\n"
          "/* ** such modified software should be clearly marked, so as not             */\n"
          "/* ** to confuse it with the version available from UCAR.                    */\n"
          "/* ** 2) Redistributions of source code must retain the above copyright      */\n"
          "/* ** notice, this list of conditions and the following disclaimer.          */\n"
          "/* ** 3) Redistributions in binary form must reproduce the above copyright   */\n"
          "/* ** notice, this list of conditions and the following disclaimer in the    */\n"
          "/* ** documentation and/or other materials provided with the distribution.   */\n"
          "/* ** 4) Neither the name of UCAR nor the names of its contributors,         */\n"
          "/* ** if any, may be used to endorse or promote products derived from        */\n"
          "/* ** this software without specific prior written permission.               */\n"
          "/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */\n"
          "/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */\n"
          "/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */\n"
          "/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */\n");

}

