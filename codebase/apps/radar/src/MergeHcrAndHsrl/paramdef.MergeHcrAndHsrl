/*********************************************************
 * parameter definitions for MergeHcrAndHsrl
 *
 * Mike Dixon, RAP, NCAR, Boulder, CO, USA, 80307-3000
 *
 * Sept 2018
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "Merges field data from HCR and HSRL instruments.";
}

commentdef {
  p_header = "DEBUGGING";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef string {
  p_default = "test";
  p_descr = "Program instance for process registration.";
  p_help = "This application registers with procmap. This is the instance used for registration.";
} instance;

commentdef {
  p_header = "DATA INPUT";
}

typedef enum {
  REALTIME, ARCHIVE, FILELIST
} mode_t;

paramdef enum mode_t {
  p_default = REALTIME;
  p_descr = "Operating mode";
  p_help = "In REALTIME mode, the program waits for a new input file.  "
           "In ARCHIVE mode, it moves through the data between the start "
           "and end times set on the command line. "
           "In FILELIST mode, it moves through the list of file names "
           "specified on the command line. "
           "Paths (in FILELIST mode, at least) MUST contain a "
           "day-directory below the data file -- ./data_file.ext will not "
           "work as a file path";
} mode;

paramdef int {
  p_default = 300;
  p_descr = "Maximum age of realtime data (secs)";
  p_help =  "Only data less old than this will be used.";
} max_realtime_data_age_secs;

commentdef {
  p_header = "DATA LOCATIONS";
  p_text = "HCR is the primary data set, and the HCR data files are read in first. Then the associate HSRL data is found, and merged into the HCR data set.";
}

paramdef string {
  p_default = "/scr/rain1/rsfdata/projects/socrates/hcr/qc/cfradial/velcorr/2hz";
  p_descr = "Directory for HCR data files.";
  p_help = "These are in CfRadial format.";
} hcr_data_dir;

paramdef string {
  p_default = "/scr/rain1/rsfdata/projects/socrates/hsrl/qc/cfradial/qc_moments";
  p_descr = "Directory for HSRL data files.";
  p_help = "These are in CfRadial format.";
} hsrl_data_dir;

paramdef double {
  p_default = 0.25;
  p_descr = "Time tolerance for matching the HSRL rays to the HCR rays (secs).";
  p_help = "Only rays within this tolerance are used.";
} ray_match_time_tolerance_sec;

commentdef {
  p_header = "SPECIFYING FIELDS TO COPY FROM EACH SOURCE";
}

typedef enum {
  ENCODING_FLOAT32,
  ENCODING_INT32,
  ENCODING_INT16,
  ENCODING_INT08
} output_encoding_t;

typedef struct {
  string input_field_name;
  string output_field_name;
  output_encoding_t output_encoding;
} field_t;

paramdef struct field_t {
  p_default = {
    { "DBZ", "HCR_DBZ", ENCODING_INT16 },
    { "VEL_CORR", "HCR_VEL", ENCODING_INT16 },
    { "WIDTH", "HCR_WIDTH", ENCODING_INT16 },
    { "LDR", "HCR_LDR", ENCODING_INT16 },
    { "NCP", "HCR_NCP", ENCODING_INT16 },
    { "SNR", "HCR_SNR", ENCODING_INT16 },
    { "DBMVC", "HCR_DBM", ENCODING_INT16 }
  };
  p_descr = "Specs of HCR fields to be included.";
  p_help = "input_field_name: name of field in input file.\noutput_field_name: name of field in output file.\nencoding: output encoding for the field.";
} hcr_fields[];

paramdef struct field_t {
  p_default = {
    { "DBZ", "HCR_DBZ", ENCODING_INT16 },
    { "VEL_CORR", "HCR_VEL", ENCODING_INT16 },
    { "WIDTH", "HCR_WIDTH", ENCODING_INT16 },
    { "LDR", "HCR_LDR", ENCODING_INT16 },
    { "NCP", "HCR_NCP", ENCODING_INT16 },
    { "SNR", "HCR_SNR", ENCODING_INT16 },
    { "DBMVC", "HCR_DBM", ENCODING_INT16 }
  };
  p_descr = "Specs of HSRL fields to be included.";
  p_help = "input_field_name: name of field in input file.\noutput_field_name: name of field in output file.\nencoding: output encoding for the field.";
} hsrl_fields[];

commentdef {
  p_header = "SPECIFYING FIELDS TO BE COMBINED";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to combine some fields to produce derived fields";
  p_help = "We can combine pairs of fields using simple algorithms. This created derived fields. The fields to be combined must already have been specified as 'output_fields' above.";
} add_combined_fields;

typedef enum {
  COMBINE_MEAN,
  COMBINE_UNBIASED_MEAN,
  COMBINE_GEOM_MEAN,
  COMBINE_MAX,
  COMBINE_MIN,  
  COMBINE_SUM,
  COMBINE_DIFF
} combine_method_t;

typedef struct {
  string field_name_1;
  string field_name_2;
  string combined_name;
  string long_name;
  combine_method_t combine_method;
  boolean require_both;
  output_encoding_t output_encoding;
} combined_field_t;

paramdef struct combined_field_t {
  p_default = {
    {
      field_name_1 = "DBZ1",
      field_name_2 = "DBZ2",
      combined_name = "DBZ_MEAN",
      long_name = "mean_of_DBZ1_and_DBZ2",
      combine_method = COMBINE_MEAN,
      require_both = TRUE,
      output_encoding = ENCODING_INT16
    }
    ,
    {
      field_name_1 = "DBZ1",
      field_name_2 = "DBZ2",
      combined_name = "DBZ_MAX",
      long_name = "max_of_DBZ1_and_DBZ2",
      combine_method = COMBINE_MAX,
      require_both = FALSE,
      output_encoding = ENCODING_INT16
    }
    ,
    {
      field_name_1 = "DBZ1",
      field_name_2 = "DBZ2",
      combined_name = "DBZ_MIN",
      long_name = "min_of_DBZ1_and_DBZ2",
      combine_method = COMBINE_MIN,
      require_both = FALSE,
      output_encoding = ENCODING_INT16
    }
  };
  p_descr = "Specs of fields to be combined.";
  p_help = "field_name_1 and field_name_2 must be in the output_fields list. If 'require_both' is TRUE, both fields needs to be non-missing to produce an output field. output_encoding - see 'output_fields' above. MEAN: arimthmetic mean. UNBIASED_MEAN: first remove any consistent bias between field1 and field2, by adjusting field2 to field 1. Then compute the arithmetic mean. This reduces noise in the fields without changing the value of field1. GEOM_MEAN: geometric mean. MAX: maximum of the two fields. MIN: minimum of the two fields.";
} combined_fields[];

paramdef boolean {
  p_default = false;
  p_descr = "Option to print mean value for each combined field in each volume";
  p_help = "If true, we compute the mean value of each combined field, and write it to stdout.";
} print_mean_of_combined_fields;

commentdef {
  p_header = "OPTIONAL FIXED ANGLE OR SWEEP NUMBER LIMITS";
  p_text = "Fixed angles are elevation in PPI mode and azimuth in RHI mode.";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to set fixed angle limits";
  p_help = "Only use sweeps within the specified fixed angle limits.";
} set_fixed_angle_limits;

paramdef double {
  p_default = 0;
  p_descr = "Lower fixed angle limit - degrees.";
} lower_fixed_angle_limit;

paramdef double {
  p_default = 90;
  p_descr = "Upper fixed angle limit - degrees.";
} upper_fixed_angle_limit;

paramdef boolean {
  p_default = false;
  p_descr = "Option to set sweep number limits";
  p_help = "Only read sweeps within the specified sweep number limits.";
} set_sweep_num_limits;

paramdef int {
  p_default = 0;
  p_descr = "Lower sweep number limit.";
} lower_sweep_num;

paramdef int {
  p_default = 0;
  p_descr = "Upper sweep number limit.";
} upper_sweep_num;

commentdef {
  p_header = "OPTION TO CHECK FOR CONSTANT GEOMETRY";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to check that the ray geometry does not change.";
  p_help = "If true, will only merge rays with the same geometry as the primary volume. If false, secondary rays will be remapped to the primary ray geometry.";
} check_constant_geometry;

commentdef {
  p_header = "SWEEP FILE AGGREGATION";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to aggregate sweep files into a volume on read.";
  p_help = "If false, and the input data is in sweeps rather than volumes (e.g. DORADE), the sweep files from a volume will be aggregated into a volume.";
} aggregate_sweep_files_on_read;

commentdef {
  p_header = "OUTPUT FORMAT";
}

typedef enum {
  OUTPUT_FORMAT_CFRADIAL,
  OUTPUT_FORMAT_DORADE,
  OUTPUT_FORMAT_FORAY,
  OUTPUT_FORMAT_NEXRAD,
  OUTPUT_FORMAT_UF,
  OUTPUT_FORMAT_MDV_RADIAL
} output_format_t;

paramdef enum output_format_t {
  p_default = OUTPUT_FORMAT_CFRADIAL;
  p_descr = "Format for the output files.";
} output_format;

typedef enum {
  CLASSIC, NC64BIT, NETCDF4, NETCDF4_CLASSIC
} netcdf_style_t;

paramdef enum netcdf_style_t {
  p_default = "CLASSIC";
  p_descr = "NetCDF style - if output_format is CFRADIAL";
  p_help = "netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls";
} netcdf_style;

commentdef {
  p_header = "OUTPUT BYTE-SWAPPING and COMPRESSION";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to leave data in native byte order.";
  p_help = "If false, data will be byte-swapped as appropriate on output.";
} output_native_byte_order;

paramdef boolean {
  p_default = true;
  p_descr = "Option to compress data fields on output.";
  p_help = "Applies to netCDF and Dorade. UF does not support compression.";
} output_compressed;

commentdef {
  p_header = "OUTPUT OPTIONS FOR CfRadial FILES";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to force the use of ragged arrays for CfRadial files.";
  p_help = "Only applies to CfRadial. If true, forces the use of ragged arrays even if the number of gates for all rays is constant.";
} output_force_ngates_vary;

paramdef int {
  p_default = 4;
  p_descr = "Compression level for output, if compressed.";
  p_help = "Applies to netCDF only. Dorade compression is run-length encoding, and has not options..";
} compression_level;

commentdef {
  p_header = "OUTPUT DIRECTORY AND FILE NAME";
}

paramdef string {
  p_default = "./output";
  p_descr = "Output directory path.";
  p_help = "Files will be written to this directory.";
} output_dir;

typedef enum {
  START_AND_END_TIMES,
  START_TIME_ONLY,
  END_TIME_ONLY,
  SPECIFY_FILE_NAME
} filename_mode_t;

paramdef enum filename_mode_t {
  p_default = START_AND_END_TIMES;
  p_descr = "Mode for computing output file name.";
  p_help = "START_AND_END_TIMES: include both start and end times in file name. START_TIME_ONLY: include only start time in file name. END_TIME_ONLY: include only end time in file name.";
} output_filename_mode;

paramdef string {
  p_default = "cfradial.test.nc";
  p_descr = "Name of output file.";
  p_help = "Applies only if output_filename_mode is SPECIFY_FILE_NAME. File of this name will be written to output_dir.";
} output_filename;

paramdef boolean {
  p_default = true;
  p_descr = "Add the day directory to the output directory.";
  p_help = "Path will be output_dir/yyyymmdd/filename.";
} append_day_dir_to_output_dir;

paramdef boolean {
  p_default = false;
  p_descr = "Add the year directory to the output directory.";
  p_help = "Path will be output_dir/yyyy/yyyymmdd/filename.";
} append_year_dir_to_output_dir;

commentdef {
  p_header = "OPTION TO OVERRIDE MISSING VALUES";
  p_text = "Missing values are applicable to both metadata and field data. The default values should be satisfactory for most purposes. However, you can choose to override these if you are careful with the selected values.\n\nThe default values for metadata are:\n\tmissingMetaDouble = -9999.0\n\tmissingMetaFloat = -9999.0\n\tmissingMetaInt = -9999\n\tmissingMetaChar = -128\n\nThe default values for field data are:\n\tmissingFl64 = -9.0e33\n\tmissingFl32 = -9.0e33\n\tmissingSi32 = -2147483647\n\tmissingSi16 = -32768\n\tmissingSi08 = -128\n\n";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the missing values for meta-data";
  p_help = "See following parameter options.";
} override_missing_metadata_values;

paramdef double {
  p_default = -9999.0;
  p_descr = "Missing value for metadata of type double.";
  p_help = "Only applies if override_missing_metadata_values is TRUE";
} missing_metadata_double;

paramdef float {
  p_default = -9999.0;
  p_descr = "Missing value for metadata of type float.";
  p_help = "Only applies if override_missing_metadata_values is TRUE";
} missing_metadata_float;

paramdef int {
  p_default = -9999;
  p_descr = "Missing value for metadata of type int.";
  p_help = "Only applies if override_missing_metadata_values is TRUE";
} missing_metadata_int;

paramdef int {
  p_default = -128;
  p_descr = "Missing value for metadata of type char.";
  p_help = "Only applies if override_missing_metadata_values is TRUE";
} missing_metadata_char;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the missing values for field data";
  p_help = "See following parameter options.";
} override_missing_field_values;

paramdef double {
  p_default = -9.0e33;
  p_descr = "Missing value for field data of type 64-bit float.";
  p_help = "Only applies if override_missing_field_values is TRUE";
} missing_field_fl64;

paramdef double {
  p_default = -9.0e33;
  p_descr = "Missing value for field data of type 32-bit float.";
  p_help = "Only applies if override_missing_field_values is TRUE";
} missing_field_fl32;

paramdef int {
  p_default = -2147483647;
  p_descr = "Missing value for field data of type 32-bit integer.";
  p_help = "Only applies if override_missing_field_values is TRUE";
} missing_field_si32;

paramdef int {
  p_default = -232768;
  p_descr = "Missing value for field data of type 16-bit integer.";
  p_help = "Only applies if override_missing_field_values is TRUE";
} missing_field_si16;

paramdef int {
  p_default = -128;
  p_descr = "Missing value for field data of type 8-bit integer.";
  p_help = "Only applies if override_missing_field_values is TRUE";
} missing_field_si08;

