// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
////////////////////////////////////////////////////////////
// LegacyParams.hh
//
// Read legacy params, write out tdrp-compatible param file
//
// Mike Dixon, EOL, NCAR, Boulder, CO, USA
// Dec 2023
//
/////////////////////////////////////////////////////////////

#include "Constants.hh"
#include "LegacyParams.hh"
#include "Cimages_P.hh"
#include "Croutes_P.hh"
#include "Csyprod_P.hh"
#include "Cterrain_P.hh"
#include "Cdraw_P.hh"
#include <cerrno>
#include <iostream>
#include <cstdio>
#include <toolsa/DateTime.hh>
#include <toolsa/umisc.h>
#include <toolsa/str.h>
#include <toolsa/TaStr.hh>
#include <toolsa/utim.h>
#include <toolsa/http.h>

// constructor

LegacyParams::LegacyParams()
{
  _printParamdef = false;
  _paramsBuf = NULL;
  _paramsBufLen = 0;
  _tdrpFile = NULL;
}

// destructor

LegacyParams::~LegacyParams()
{
  clear();
  if (_tdrpFile != NULL) {
    fclose(_tdrpFile);
  }
}

// Clear the data base

void LegacyParams::clear()
{
  _plist.clear();
  _paramsBuf = NULL;
  _paramsBufLen = 0;
}

///////////////////////////////////////////////////////////////
// read in the legacy params
// write out tdrp params file
///////////////////////////////////////////////////////////////

int LegacyParams::translateToTdrp(const string &legacyParamsPath,
                                  const string &tdrpParamsPath)
  
{

  // load up the params buffer from file or http
  
  if (_loadKeyValPairs(legacyParamsPath)) {
    fprintf(stderr,"LegacyParams::translateToTdrp()\n");
    fprintf(stderr,"  Could not load params from file\n");
    return -1;
  }
  
  // Retrieve the parameters from text file
  // read params in from buffer
  
  if (_readFromBuf(_paramsBuf, _paramsBufLen, "cidd")) {
    fprintf(stderr,"LegacyParams::translateToTdrp()\n");
    fprintf(stderr,"  Could not read params buffer\n");
    return -1;
  }

  // open the output tdrp params file

  _tdrpFile = fopen(tdrpParamsPath.c_str(), "w");
  if (_tdrpFile == NULL) {
    fprintf(stderr,"ERROR - LegacyParams::translateToTdrp\n");
    fprintf(stderr,"  Cannot open tdrp file for writing\n");
    perror(tdrpParamsPath.c_str());
    return -1;
  }

  // tdrp header
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "//\n");
  fprintf(_tdrpFile, "// TDRP params file, generated by Lucid\n");
  fprintf(_tdrpFile, "// Legacy params path: %s\n", legacyParamsPath.c_str());
  fprintf(_tdrpFile, "// %s\n", DateTime::strm(time(NULL)).c_str());
  fprintf(_tdrpFile, "//\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  // read in the main parameters

  if (_readMainParams()) {
    return -1;
  }

  // read in GUI config
  
  if (_readGuiConfigTdrp() == 0) {
    // _guiConfig.print(stdout);
  }
  
  // read in gridded fields
  
  if (_readGrids()) {
    return -1;
  }

  // read in winds
  
  if (_readWinds()) {
    return -1;
  }
    
  // read in maps
  
  if (_readMaps()) {
    return -1;
  }
    
  // read in symprods params from old tdrp section, write to main params
  
  if (_readSymprodsTdrp()) {
    return -1;
  }
    
  // read in terrain from old tdrp section, write to main params
  
  if (_readTerrainTdrp()) {
    return -1;
  }
    
  // read in route winds from old tdrp section, write to main params
  
  if (_readRouteWindsTdrp()) {
    return -1;
  }
    
  // read in draw export from old tdrp section, write to main params
  
  if (_readDrawExportTdrp()) {
    return -1;
  }
    
  // read in image generation from old tdrp section, write to main params
  
  if (_readImageGenTdrp()) {
    return -1;
  }
    
  // setPrintTdrp(false);

  return 0;

}


////////////////////////////////////////
// read in from param file
//
// returns 0 on success, -1 on failure

int LegacyParams::_readFromPath(const char *file_path,
                                const char *prog_name)

{

  // open file

  FILE *params_file;
  if ((params_file = fopen(file_path, "r")) == NULL) {
    int errNum = errno;
    cerr << "ERROR - LegacyParams::read" << endl;
    cerr << "  Cannot read params from file: " << file_path << endl;
    cerr << "  " << strerror(errNum) << endl;
    return -1;
  }

  // loop through file
  
  char line[BUFSIZ];

  while (!feof(params_file)) {
    
    // read a line
    
    if (fgets(line, BUFSIZ, params_file) == NULL) {
      break;
    }
    
    if (feof(params_file))
      break;

    // substitute in any environment variables
    
    usubstitute_env(line, BUFSIZ);

    // delete past any hash-bang

    char *sptr;
    if ((sptr = strstr(line, "#!")) != NULL) {
      *sptr = '\0';
    }
    
    // process only if the line has the program name followed by a period.
    
    char *name = line;
    if (strlen(name) < strlen(prog_name + 1)) {
      continue;
    }
    if (strncmp(prog_name, name, strlen(prog_name)) ||
	name[strlen(prog_name)] != '.') {
      continue;
    }

    // check that there is a colon

    char *colon = strchr(name, ':');
    if (!colon) {
      continue;
    }
    
    // back up past any white space
    
    char *end_of_name = colon - 1;
    while (*end_of_name == ' ' || *end_of_name == '\t') {
      end_of_name--;
    }

    // place null at end of name

    *(end_of_name + 1) = '\0';

    // get entry string

    char *entry = colon + 1;

    // advance past white space
    
    while (*entry == ' ' || *entry == '\t') {
      entry++;
    }

    // back up past white space
    
    char *end_of_entry = entry + strlen(entry);
    while (*end_of_entry == ' ' || *end_of_entry == '\t' ||
	   *end_of_entry == '\r' || *end_of_entry == '\n' ||
	   *end_of_entry == '\0') {
      end_of_entry--;
    }

    // place null at end of entry
    
    *(end_of_entry + 1) = '\0';

    // check that we do not already have this param
    
    bool previous_entry_found = false;
    for (size_t ii = 0; ii < _plist.size(); ii++) {
      if (_plist[ii].name == name) {
	_plist[ii].entry = entry;
	previous_entry_found = true;
	break;
      }
    } // ii

    // if previous entry was not found,
    // store name and entry pointers in params list

    if (!previous_entry_found) {
      param_list_t ll;
      ll.name = name;
      ll.entry = entry;
      _plist.push_back(ll);
    }
      
  } /* while (!feof(params_file)) */

  // close file

  fclose(params_file);

  // debug print

  // for (size_t ii = 0; ii < _plist.size(); ii++) {
  //   cerr << "name, val: " << _plist[ii].name << ", " << _plist[ii].entry << endl;
  // } // ii
  // cerr << "Param list size: " << _plist.size() << endl;

  return 0;

}

////////////////////////////////////////
// read from a param buffer
//
// returns 0 on success, -1 on failure

int LegacyParams::_readFromBuf(const char *buf,
                               int buf_len,
                               const char *prog_name)

{

  // loop through lines in buffer
  
  char line[BUFSIZ];
  const char *ptr = buf;
  
  while (ptr < buf + buf_len) {
  
    // find a line

    const char *eol = strchr(ptr, '\n');
    if (eol == NULL) {
      break;
    }
    
    int lineLen = eol - ptr + 1;
    int copyLen;
    if (lineLen > BUFSIZ) {
      copyLen = BUFSIZ;
    } else {
      copyLen = lineLen;
    }
    STRncopy(line, ptr, copyLen);
    ptr += lineLen;

    // substitute in any environment variables
    
    usubstitute_env(line, BUFSIZ);
    
    // delete past any hash-bang

    char *sptr;
    if ((sptr = strstr(line, "#!")) != NULL) {
      *sptr = '\0';
    }
    
    // process only if the line has the program name followed by a period.
    
    char *name = line;
    if (strlen(name) < strlen(prog_name + 1)) {
      continue;
    }
    if (strncmp(prog_name, name, strlen(prog_name)) ||
	name[strlen(prog_name)] != '.') {
      continue;
    }

    // check that there is a colon

    char *colon = strchr(name, ':');
    if (!colon) {
      continue;
    }
    
    // back up past any white space
    
    char *end_of_name = colon - 1;
    while (*end_of_name == ' ' || *end_of_name == '\t') {
      end_of_name--;
    }

    // place null at end of name

    *(end_of_name + 1) = '\0';

    // get entry string

    char *entry = colon + 1;

    // advance past white space
    
    while (*entry == ' ' || *entry == '\t') {
      entry++;
    }

    // back up past white space
    
    char *end_of_entry = entry + strlen(entry);
    while (*end_of_entry == ' ' || *end_of_entry == '\t' ||
	   *end_of_entry == '\r' || *end_of_entry == '\n' ||
	   *end_of_entry == '\0') {
      end_of_entry--;
    }

    // place null at end of entry
    
    *(end_of_entry + 1) = '\0';

    // check that we do not already have this param
    
    bool previous_entry_found = false;
    for (size_t ii = 0; ii < _plist.size(); ii++) {
      if (_plist[ii].name == name) {
	_plist[ii].entry = entry;
	previous_entry_found = true;
	break;
      }
    } // ii

    // if previous entry was not found,
    // store name and entry pointers in params list

    if (!previous_entry_found) {
      param_list_t ll;
      ll.name = name;
      ll.entry = entry;
      _plist.push_back(ll);
    }
      
  } /* while (!feof(params_file)) */

  // debug print

  // for (size_t ii = 0; ii < _plist.size(); ii++) {
  //   cerr << "name, val: " << _plist[ii].name << ", " << _plist[ii].entry << endl;
  // } // ii
  // cerr << "Param list size: " << _plist.size() << endl;

  return 0;

}

///////////////////////////////////////////////////////////////
// gets an entry from the param list
// returns NULL if this fails
///////////////////////////////////////////////////////////////

const char *LegacyParams::_get(const char *search_name) const

{
  
  for (size_t ii =  0; ii < _plist.size(); ii++) {
    if (_plist[ii].name == search_name) {
      return (_plist[ii].entry.c_str());
    }
  }

  return NULL;

}

///////////////////////////////////////////////////////////////
// returns the value of a double parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

double LegacyParams::_getDouble(const char *name,
                                double default_val,
                                bool writeToTdrpFile,
                                string nameOverride)
{
  
  if (_printParamdef) {
    cout << endl;
    cout << "paramdef double {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  double dval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    double val;
    if (sscanf(entryStr, "%lg", &val) == 1) {
      dval = val;
    }
  }

  if (writeToTdrpFile) {
    if (nameOverride.size() > 0) {
      fprintf(_tdrpFile, "%s = %lg;\n", nameOverride.c_str(), dval);
    } else {
      fprintf(_tdrpFile, "%s = %lg;\n", _removeCiddStr(name), dval);
    }
  }

  return dval;

}

///////////////////////////////////////////////////////////////
// returns the value of a float parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

float LegacyParams::_getFloat(const char *name,
                              float default_val,
                              bool writeToTdrpFile,
                              string nameOverride)
{

  if (_printParamdef) {
    cout << endl;
    cout << "paramdef double {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  float fval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    float val;
    if (sscanf(entryStr, "%g", &val) == 1) {
      fval = val;
    }
  }
  
  if (writeToTdrpFile) {
    if (nameOverride.size() > 0) {
      fprintf(_tdrpFile, "%s = %g;\n", nameOverride.c_str(), fval);
    } else {
      fprintf(_tdrpFile, "%s = %g;\n", _removeCiddStr(name), fval);
    }
  }

  return fval;

}

///////////////////////////////////////////////////////////////
// returns the value of a boolean parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

bool LegacyParams::_getBoolean(const char *name,
                               int default_val,
                               bool writeToTdrpFile,
                               string nameOverride)

{

  if (_printParamdef) {
    cout << endl;
    cout << "paramdef boolean {" << endl;
    if (default_val == 0) {
      cout << "  p_default = FALSE;" << endl;
    } else {
      cout << "  p_default = TRUE;" << endl;
    }
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  bool bval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    int val;
    if (sscanf(entryStr, "%d", &val) == 1) {
      bval = val;
    }
  }

  if (writeToTdrpFile) {
    if (nameOverride.size() > 0) {
      fprintf(_tdrpFile, "%s = %s;\n", nameOverride.c_str(), (bval?"TRUE":"FALSE"));
    } else {
      fprintf(_tdrpFile, "%s = %s;\n", _removeCiddStr(name), (bval?"TRUE":"FALSE"));
    }
  }

  return bval;

}

///////////////////////////////////////////////////////////////
// returns the value of a int parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

int LegacyParams::_getInt(const char *name,
                          int default_val,
                          bool writeToTdrpFile,
                          string nameOverride)

{

  if (_printParamdef) {
    cout << endl;
    cout << "paramdef int {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  int ival = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    int val;
    if (sscanf(entryStr, "%d", &val) == 1) {
      ival = val;
    }
  }
  
  if (writeToTdrpFile) {
    if (nameOverride.size() > 0) {
      fprintf(_tdrpFile, "%s = %d;\n", nameOverride.c_str(), ival);
    } else {
      fprintf(_tdrpFile, "%s = %d;\n", _removeCiddStr(name), ival);
    }
  }

  return ival;

}

///////////////////////////////////////////////////////////////
// returns the value of a long parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

long LegacyParams::_getLong(const char *name,
                            long default_val,
                            bool writeToTdrpFile,
                            string nameOverride)

{

  if (_printParamdef) {
    cout << endl;
    cout << "paramdef int {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }
  
  long lval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    long val;
    if (sscanf(entryStr, "%ld", &val) == 1) {
      lval = val;
    }
  }
  
  if (writeToTdrpFile) {
    if (nameOverride.size() > 0) {
      fprintf(_tdrpFile, "%s = %ld;\n", nameOverride.c_str(), lval);
    } else {
      fprintf(_tdrpFile, "%s = %ld;\n", _removeCiddStr(name), lval);
    }
  }

  return lval;

}

///////////////////////////////////////////////////////////////
// returns the value of a string parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

const string LegacyParams::_getString(const char *name,
                                      const char *default_val,
                                      bool writeToTdrpFile,
                                      string nameOverride)
  
{

  if (_printParamdef) {
    cout << endl;
    cout << "paramdef string {" << endl;
    cout << "  p_default = \"" << default_val << "\";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }
  
  string sval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    sval = entryStr;
  }

  if (writeToTdrpFile) {
    if (nameOverride.size() > 0) {
      fprintf(_tdrpFile, "%s = \"%s\";\n", nameOverride.c_str(), sval.c_str());
    } else {
      fprintf(_tdrpFile, "%s = \"%s\";\n", _removeCiddStr(name), sval.c_str());
    }
  }

  return sval;
  
}

/////////////////////////////////////////////////////////////////////////////
// FIND_TAG_TEXT Search a null terminated string for the text between tags
//
// Searches through input_buf for text between tags of the form <TAG>...Text...</TAG>
// Returns a pointer to the beginning of the text and its length if found.
// text_line_no is used on input to begin counting and is set on output to the starting
// line number of the tagged text

const char *LegacyParams::_findTagText(const char *input_buf,
                                       const char * tag,
                                       long *text_len,
                                       long *text_line_no)
{
  int start_line_no;
  const char *start_ptr;
  const char *end_ptr;
  const char *ptr;
  char end_tag[TAG_BUF_LEN];
  char start_tag[TAG_BUF_LEN];
  
  // Reasonable tag check - Give up
  if(strlen(tag) > TAG_BUF_LEN - 5) {
    fprintf(stderr,"Unreasonable tag: %s - TOO long!\n",tag);
    *text_len = 0;
    return NULL;
  }
  
  // Clear the string buffers
  memset(start_tag,0,TAG_BUF_LEN);
  memset(end_tag,0,TAG_BUF_LEN);
  
  start_line_no = *text_line_no;
  
  snprintf(start_tag, TAG_BUF_LEN - 1, "<%s>", tag);
  snprintf(end_tag, TAG_BUF_LEN - 1, "</%s>", tag);
  
  // Search for Start tag
  if((start_ptr = strstr(input_buf,start_tag)) == NULL) {
    *text_len = 0;
    *text_line_no = start_line_no;
    return NULL;
  }
  start_ptr +=  strlen(start_tag); // Skip ofer tag to get to the text
  
  // Search for end tag after the start tag
  if((end_ptr = strstr(start_ptr,end_tag)) == NULL) {
    *text_len = 0;
    *text_line_no = start_line_no;
    return NULL;
  }
  end_ptr--;  // Skip back one character to last text character
  
  // Compute the length of the text_tag
  *text_len = (long) (end_ptr - start_ptr);
  
  // Count the lines before the starting tag
  ptr = input_buf;
  while(((ptr = strchr(ptr,'\n')) != NULL) && (ptr < start_ptr)) {
    ptr++; // Move past the found NL
    start_line_no++;
  }
  
  *text_line_no = start_line_no;
  return start_ptr;
}

//////////////////////////////////////////////////////////////
// remove cidd. from start of parameter name

const char *LegacyParams::_removeCiddStr(const char *name) const

{

  if (strncmp(name, "cidd.", 5) == 0) {
    return (name + 5);
  } else {
    return name;
  }
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA_DEFAULT : Allocate and load the parameter data base using the
//                        default parameter settings and set Global Struct
//                        members
// 

int LegacyParams::_loadKeyValPairsDefault(char* &db_buf, int &db_len)
{

  // Generate the full params string.  The non-TDRP portions are kept in
  // static strings while the TDRP portions are loaded from the default
  // parameters

  Cgui_P gui_P;
  Csyprod_P syprod_P;
  Cdraw_P draw_P;
  Cimages_P images_P;
  Cterrain_P terrain_P;
  Croutes_P routes_P;
  
  string params_text = ParamsTextMasterHeader;
  params_text += _getDefaultTdrpParams("GUI_CONFIG", &gui_P);
  params_text += ParamsTextGrids;
  params_text += ParamsTextWinds;
  params_text += ParamsTextMaps;
  params_text += ParamsTextMainParams;
  params_text += _getDefaultTdrpParams("DRAW_EXPORT", &draw_P);
  params_text += _getDefaultTdrpParams("IMAGE_GENERATION", &images_P);
  params_text += _getDefaultTdrpParams("SYMPRODS", &syprod_P);
  params_text += _getDefaultTdrpParams("TERRAIN", &terrain_P);
  params_text += _getDefaultTdrpParams("ROUTE_WINDS", &routes_P);
  
  // Allocate space for the buffer copy
  
  db_len = params_text.size() + 1;
  
  if ((db_buf = (char *)calloc(db_len, 1)) == NULL) {
    fprintf(stderr,"Problems allocating %ld bytes for parameter file\n",
	    (long)db_len);
    return -1;
  }
  
  // Copy the parameters into the buffer
  
  memcpy(db_buf, params_text.c_str(), db_len - 1);
  db_buf[db_len-1] = '\0';

  return 0;
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA_FILE : Allocate and load the parameter data base from a file
//                     and set Global Struct members
// 

int LegacyParams::_loadKeyValPairsFile(const string &fname,
                                       char* &db_buf,
                                       int &db_len)
{

  FILE *infile;
  
  // create temp buffer
  
  int tmpLen = 1000000;
  char *tmpBuf = new char[tmpLen];
  
  // Open DB file
  
  if((infile = fopen(fname.c_str(),"r")) == NULL) {
    perror(fname.c_str());
    fprintf(stderr,"Problems Opening %s\n",fname.c_str());
    return -1;
  }
  
  // Read into tmp buf
  db_len = fread(tmpBuf, 1, tmpLen, infile);
  if(db_len <= 0) {
    perror(fname.c_str());
    fprintf(stderr,"ERROR - LegacyParams::_loadKeyValsPairsFile\n");
    fprintf(stderr,"  Params file name: %s\n", fname.c_str());
    return -1;
  }
  
  // Allocate space for the whole file plus a null
  if((db_buf = (char *)  calloc(db_len + 1, 1)) == NULL) {
    fprintf(stderr,"Problems allocating %d bytes for parameter file\n",
            db_len);
    return -1;
  }
  
  // copy in
  
  memcpy(db_buf, tmpBuf, db_len);
  db_buf[db_len] = '\0'; // Make sure to null terminate
  delete[] tmpBuf;
  
  // Close DB file
  if(fclose(infile) != 0 )  {
    fprintf(stderr,"Problems Closing %s\n",fname.c_str());
    return -1;
  }

  return 0;
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA_HTTP : Allocate and load the parameter data base from a Web
//                     server and set Global Struct members
// 

int LegacyParams::_loadKeyValPairsHttp(const string &fname,
                                       char* &db_buf,
                                       int &db_len)
{

  int ret_stat;
  
  // Allow 5 seconds to retrieve the data 
  
  if(_httpProxyUrl.size() > Constants::URL_MIN_SIZE) {
    ret_stat = HTTPgetURL_via_proxy(_httpProxyUrl.c_str(), fname.c_str(), 5000,
				    &db_buf, &db_len);
  } else {
    ret_stat = HTTPgetURL(fname.c_str(), 5000, &db_buf, &db_len);
  }
  
  if(ret_stat <= 0 || db_len <= 0) {
    fprintf(stderr,"Could'nt Load Parameter Database from URL: %s,  %d\n",
	    fname.c_str(), ret_stat);
    if(ret_stat < 0) {
      fprintf(stderr,"Failed to successfully trasnact with the http server\n");
    } else {
      fprintf(stderr,
	      "HTTP server couldn't retreive the file - Returned  Stat: %d\n",
	      ret_stat);
    }
    fprintf(stderr,
	    "Make sure URL looks like: http://host.domain/dir/filename\n");
    fprintf(stderr,
	    "The most common problem is usually missing  the :// part \n");
    fprintf(stderr,"or a misspelled/incorrect host, directory or filename\n");
    if(_httpProxyUrl.size() > Constants::URL_MIN_SIZE)
      fprintf(stderr,"Also Check Proxy URL:%s\n", _httpProxyUrl.c_str());
    return -1;
  }

  return 0;
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA : Allocate and load the data base file - Set Global
// Struct members
// 

int LegacyParams::_loadKeyValPairs(const string &fname)
{
  
  char *db_buf = NULL;
  int db_len = 0;
  int iret = 0;
  
  if (fname == "") {
    // Default parameters
    iret = _loadKeyValPairsDefault(db_buf, db_len);
  } else if(strncasecmp(fname.c_str(), "http:", 5) == 0) {
    // HTTP Based retrieve 
    iret = _loadKeyValPairsHttp(fname, db_buf, db_len);
  } else {
    // FILE based retrieve
    iret = _loadKeyValPairsFile(fname, db_buf, db_len);
  }

  if (iret == 0) {
    _paramsBuf = db_buf;
    _paramsBufLen = db_len;
    return 0;
  } else {
    return -1;
  }
  
}

/************************************************************************
 * Read in main params
 */

int LegacyParams::_readMainParams()
  
{

  // Load the Main parameters
  
  long param_text_len = 0;
  long param_text_line_no = 0;
  const char *param_text = _findTagText(_paramsBuf,
                                        "MAIN_PARAMS",
                                        &param_text_len,
                                        &param_text_line_no);
    
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr, "ERROR - LegacyParams::_readMainParams\n");
    fprintf(stderr, "  Could not find MAIN_PARAMS SECTION\n");
    return -1;
  }
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <MAIN_PARAMS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  _debug = _getBoolean("cidd.debug_flag", 0);
  _debug1 = _getBoolean("cidd.debug1_flag", 0);
  _debug2 = _getBoolean("cidd.debug2_flag", 0);

  if (_debug2) {
    fprintf(_tdrpFile, "debug = DEBUG_EXTRA;\n");
  } else if (_debug1) {
    fprintf(_tdrpFile, "debug = DEBUG_VERBOSE;\n");
  } else if (_debug) {
    fprintf(_tdrpFile, "debug = DEBUG_NORM;\n");
  } else {
    fprintf(_tdrpFile, "debug = DEBUG_OFF;\n");
  }
  
  // IF demo_time is set in the params, set to start in archive mode
  
  string demoTimeStr = _getString("cidd.demo_time", "", false);
  if (demoTimeStr.size() >= 12) {
    DateTime dtime;
    _parseStringIntoTime(demoTimeStr, dtime);
    fprintf(_tdrpFile, "start_mode = MODE_ARCHIVE;\n");
    fprintf(_tdrpFile, "archive_start_time = \"%.4d %.2d %.2d %.2d %.2d %.2d\";\n",
            dtime.getYear(), dtime.getMonth(), dtime.getDay(),
            dtime.getHour(), dtime.getMin(), dtime.getSec());
  } else {
    fprintf(_tdrpFile, "start_mode = MODE_REALTIME;\n");
  }
  _getLong("cidd.starting_movie_frames", 12, true, "n_movie_frames");

  double frameIntervalMins = _getDouble("cidd.time_interval", 10.0, false);
  fprintf(_tdrpFile, "frame_interval_secs = %g;\n", frameIntervalMins * 60.0);
  
  _getLong("cidd.temporal_rounding", 300);
  string climoStr = _getString("cidd.climo_mode", "regular", false);
  if (climoStr.find("regular") != string::npos) {
    fprintf(_tdrpFile, "climo_mode = CLIMO_REGULAR_INTERVAL;\n");
  } else if (climoStr.find("daily") != string::npos) {
    fprintf(_tdrpFile, "climo_mode = CLIMO_DAILY_INTERVAL;\n");
  } else if (climoStr.find("yearly") != string::npos) {
    fprintf(_tdrpFile, "climo_mode = CLIMO_YEARLY_INTERVAL;\n");
  }
  _getBoolean("cidd.use_local_timestamps", 0);

  /* movies */
  _getLong("cidd.max_time_list_span", 365, true, "climo_max_time_span_days");
  _getDouble("cidd.frame_span", 10.0, true, "climo_frame_span_mins");

  // movies
  _getDouble("cidd.forecast_interval", 2.0, true, "forecast_interval_hours");
  _getDouble("cidd.past_interval", 0.0, true, "past_interval_hours");
  _getDouble("cidd.movie_magnify_factor",1.0);
  _getBoolean("cidd.check_data_times", 0);
  _getString("cidd.movieframe_time_format", "%H%M");
  _getLong("cidd.movieframe_time_mode", 0);

  // clipping for rendering
  _getBoolean("cidd.check_clipping", 0);
  
  // data retrieval
  _getDouble("cidd.stretch_factor", 1.5, true, "time_search_stretch_factor");
  int dmode = _getLong("cidd.gather_data_mode", 0, false);
  if (dmode == 1) {
    fprintf(_tdrpFile, "gather_data_mode = FIRST_BEFORE_END_OF_FRAME;\n");
  } else if (dmode == 2) {
    fprintf(_tdrpFile, "gather_data_mode = FIRST_AFTER_START_OF_FRAME;\n");
  } else {
    fprintf(_tdrpFile, "gather_data_mode = CLOSEST_TO_FRAME_CENTER;\n");
  }
  
  _getLong("cidd.redraw_interval", Constants::REDRAW_INTERVAL);
  _getLong("cidd.update_interval", Constants::UPDATE_INTERVAL);
  _getString("cidd.datamap_host", "");
  _getLong("cidd.data_timeout_secs", 10);
  _getLong("cidd.simple_command_timeout_secs",30);
  _getLong("cidd.complex_command_timeout_secs",180);

  // movies
  _getBoolean("cidd.movie_on", 0);
  _getLong("cidd.movie_delay", 3000, true, "loop_delay_msecs");
  _getLong("cidd.movie_speed_msec", 75, true, "movie_dwell_msecs");
  _getBoolean("cidd.reset_frames", 0);

  // model data
  _getLong("cidd.model_run_list_hours",24);

  // How many idle seconds can elapse before resetting the display
  _getLong("cidd.idle_reset_seconds",0);

  // image generation in html mode
  _getBoolean("cidd.html_mode", 0);
  _runOnceAndExit = _getBoolean("cidd.run_once_and_exit",0);
  _getBoolean("cidd.transparent_images", 0);
  _getString("cidd.image_dir", "/tmp/image_dir");
  _getBoolean("cidd.save_images_to_day_subdir", 0);
  _getString("cidd.image_ext", "png");
  _getString("cidd.image_horiz_prefix", "CP");
  _getString("cidd.image_vert_prefix", "CV");
  _getString("cidd.image_name_separator", "_");

  // output image file names
  
  _getBoolean("cidd.add_height_to_filename",0);
  _getBoolean("cidd.add_frame_time_to_filename",1);
  _getBoolean("cidd.add_button_name_to_filename",0);
  _getBoolean("cidd.add_frame_num_to_filename",1);
  _getBoolean("cidd.add_gen_time_to_filename",0);
  _getBoolean("cidd.add_valid_time_to_filename",0);
  _getString("cidd.horiz_image_dir", "/tmp/cidd_horiz_image_dir");
  _getString("cidd.horiz_image_fname", "cidd_horiz_view.png");
  _getString("cidd.horiz_image_command", "");
  _getString("cidd.vert_image_dir", "/tmp/cidd_vert_image_dir");
  _getString("cidd.vert_image_fname", "cidd_vert_view.png");
  _getString("cidd.vert_image_command", "");
  _getBoolean("cidd.output_geo_xml", 0);
  _getBoolean("cidd.use_latlon_in_geo_xml", 0);

  // script to run after generating image
  
  _getString("cidd.image_convert_script", "convert_image.csh");
  _getString("cidd.print_script", "");
  _getString("cidd.series_convert_script", "make_anim.csh");

  // data compression from server
  
  _getBoolean("cidd.request_compressed_data",0);
  _getBoolean("cidd.request_gzip_vol_compression",0);

  // projections
  string projTypeStr =
    _getString("cidd.projection_type", "CARTESIAN", false, "proj_type_str");
  if (projTypeStr == "CARTESIAN") {
    fprintf(_tdrpFile, "proj_type = PROJ_FLAT;\n");
  } else if (projTypeStr == "LAT_LON") {
    fprintf(_tdrpFile, "proj_type = PROJ_LATLON;\n");
  } else if (projTypeStr == "LAMBERT") {
    fprintf(_tdrpFile, "proj_type = PROJ_LAMBERT_CONF;\n");
  } else if (projTypeStr == "STEREOGRAPHIC") {
    fprintf(_tdrpFile, "proj_type = PROJ_OBLIQUE_STEREO;\n");
  } else if (projTypeStr == "POLAR_STEREO") {
    fprintf(_tdrpFile, "proj_type = PROJ_POLAR_STEREO;\n");
  } else if (projTypeStr == "MERCATOR") {
    fprintf(_tdrpFile, "proj_type = PROJ_MERCATOR;\n");
  }
    
  _getDouble("cidd.lambert_lat1", 20.0, true, "proj_lat1");
  _getDouble("cidd.lambert_lat2", 60.0, true, "proj_lat2");
  _getDouble("cidd.tangent_lat", 90.0, true, "proj_tangent_lat");
  _getDouble("cidd.tangent_lon", 0.0, true, "proj_tangent_lon");
  _getDouble("cidd.central_scale", 1.0, true, "proj_central_scale");
  _getDouble("cidd.north_angle", 0.0, true, "proj_rotation");
  _getBoolean("cidd.use_cosine", 1, true, "use_cosine_correction"); // legacy
  _getBoolean("cidd.use_cosine_correction", 1);
  _getDouble("cidd.scale_units_per_km", 1.0);
  _getString("cidd.scale_units_label", "km");

  // data retrieval
  _getBoolean("cidd.always_get_full_domain", 0);
  _getBoolean("cidd.do_not_clip_on_mdv_request", 0);
  _getBoolean("cidd.do_not_decimate_on_mdv_request", 0);
     
  /* Toggle for enabling a status report window */
  _getBoolean("cidd.enable_status_window", 0);
  _getBoolean("cidd.report_clicks_in_status_window", 0);
  _getBoolean("cidd.report_clicks_in_degM_and_nm", 0);
  _getDouble("cidd.magnetic_variation_deg", 0);
  
  /* Toggle for enabling a Save Image Panel */
  _getBoolean("cidd.enable_save_image_panel", 0);

  // domain limits
  _getDouble("cidd.domain_limit_min_x",-10000);
  _getDouble("cidd.domain_limit_max_x",10000);
  _getDouble("cidd.domain_limit_min_y",-10000);
  _getDouble("cidd.domain_limit_max_y",10000);
  
  // origin latitude and longitude
  _originLatitude = _getDouble("cidd.origin_latitude", 0.0, false);
  _originLongitude = _getDouble("cidd.origin_longitude", 0.0, false);

  fprintf(_tdrpFile, "proj_origin_lat = %g;\n", _originLatitude);
  fprintf(_tdrpFile, "proj_origin_lon = %g;\n", _originLongitude);

  // click location on reset
  _getDouble("cidd.reset_click_latitude", _originLatitude, false);
  _getDouble("cidd.reset_click_longitude", _originLongitude, false);

  
  // startup pages
  // _getLong("cidd.planview_start_page", 1); // subtract 1
  // _getLong("cidd.xsect_start_page", 1); // subtract 1

  // zooms

  fprintf(_tdrpFile, "// <ZOOMS>\n");

  int startZoomLevel = _getLong("cidd.start_zoom_level", 1, false);
  _getBoolean("cidd.zoom_limits_in_latlon",0);
  _getLong("cidd.num_cache_zooms",1);
  _getDouble("cidd.min_zoom_threshold", 5.0);
  int numZoomLevels = _getLong("cidd.num_zoom_levels", 1, false);
  
  vector<ZoomLevel> zooms;
  string startZoomLabel;
  
  for(int ii = 0; ii < numZoomLevels; ii++) {
    
    ZoomLevel zoom;

    char str_buf[1024];
    char defaultLabel[1024];
    int defaultSize = 100 * (ii + 1);
    
    snprintf(str_buf, 1023, "cidd.level%d_label", ii + 1);
    snprintf(defaultLabel, 1023, "%dkm", defaultSize);
    zoom.label = _getString(str_buf, defaultLabel, false);
    if (ii == 0 || startZoomLevel == (ii + 1)) {
      startZoomLabel = zoom.label;
    }
    
    snprintf(str_buf, 1023, "cidd.level%d_min_xkm", ii + 1);
    zoom.min_x = _getDouble(str_buf, defaultSize * -1.0, false);
    
    snprintf(str_buf, 1023, "cidd.level%d_min_ykm", ii + 1);
    zoom.min_y = _getDouble(str_buf, defaultSize * -1.0, false);
    
    snprintf(str_buf, 1023, "cidd.level%d_max_xkm", ii + 1);
    zoom.max_x = _getDouble(str_buf, defaultSize * -1.0, false);
    
    snprintf(str_buf, 1023, "cidd.level%d_max_ykm", ii + 1);
    zoom.max_y = _getDouble(str_buf, defaultSize * -1.0, false);

    zooms.push_back(zoom);
    
  } // i
  
  fprintf(_tdrpFile, "start_zoom_label = %s;\n", startZoomLabel.c_str());
  
  fprintf(_tdrpFile, "zoom_levels = {\n");
  for(size_t izoom = 0; izoom < zooms.size(); izoom++) {
    ZoomLevel &zoom = zooms[izoom];
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    label = \"%s\",\n", zoom.label.c_str());
    fprintf(_tdrpFile, "    min_x = %lg,\n", zoom.min_x);
    fprintf(_tdrpFile, "    min_y = %lg,\n", zoom.min_y);
    fprintf(_tdrpFile, "    max_x = %lg,\n", zoom.max_x);
    fprintf(_tdrpFile, "    max_y = %lg\n", zoom.max_y);
    fprintf(_tdrpFile, "  }\n");
    if (izoom < zooms.size() - 1) {
      fprintf(_tdrpFile, "  ,\n");
    }
  } // izoom
  fprintf(_tdrpFile, "};\n");
  fprintf(_tdrpFile, "// </ZOOMS>\n");
  
  // vert axis
  _getDouble("cidd.min_ht", 0.0);
  _getDouble("cidd.max_ht", 30.0);
  _getDouble("cidd.start_ht", 0.0);

  // maps

  _getString("cidd.map_file_subdir", "$(HOME)/git/lrose-displays/maps",
             true, "map_urls");
  _getDouble("cidd.locator_margin_km", 50.0);
  _getString("cidd.station_loc_url", "");

  int maps_font_mode = _getLong("cidd.font_display_mode", 1, false);
  if (maps_font_mode == 0) {
    fprintf(_tdrpFile, "map_font_background = MAP_FONT_BACKGROUND_TRANSPARENT\n;");
  } else {
    fprintf(_tdrpFile, "map_font_background = MAP_FONT_BACKGROUND_OPAQUE\n;");
  }

  // server access

  _getString("cidd.remote_ui_url", "");
  _getString("cidd.http_tunnel_url", "");
  _httpProxyUrl = _getString("cidd.http_proxy_url", "");

  // colors
  
  _getString("cidd.color_file_subdir", "$(HOME)/git/lrose-displays/color_scales",
             true, "color_scale_urls");
  _getString("cidd.foreground_color", "White");
  _getString("cidd.background_color", "Black");
  _getString("cidd.margin_color", "Black");
  _getString("cidd.out_of_range_color", "transparent");
  _getString("cidd.route_path_color", "yellow");
  _getString("cidd.time_axis_color", "cyan");
  _getString("cidd.time_frame_color", "yellow");
  _getString("cidd.height_axis_color", "cyan");
  _getString("cidd.height_indicator_color", "red");
  _getString("cidd.range_ring_color", "grey");
  _getString("cidd.missing_data_color","transparent");
  _getString("cidd.bad_data_color","transparent");

  _getString("cidd.latest_click_mark_color", "red");
  _getString("cidd.latest_client_mark_color", "yellow");

  // time control GUI - colors
  
  fprintf(_tdrpFile, "// <TIME_CONTROL_GUI>\n");
  
  _getString("cidd.epoch_indicator_color", "yellow");
  _getString("cidd.now_time_color", "red");
  _getString("cidd.time_tick_color", "yellow");
  
  vector<string> time_tick_colors;
  for(int ii = 0; ii < 9; ii++) {
    char str_buf[1024];
    snprintf(str_buf, 1023, "cidd.time_tick_color%d", ii + 1);
    string color = _getString(str_buf, "none", false);
    if (color.find("none") == string::npos) {
      time_tick_colors.push_back(color);
    }
  } // ii
  
  fprintf(_tdrpFile, "time_tick_colors = {\n");
  for(size_t ii = 0; ii < time_tick_colors.size(); ii++) {
    string &color = time_tick_colors[ii];
    fprintf(_tdrpFile, "  \"%s\"", color.c_str());
    if (ii < time_tick_colors.size() - 1) {
      fprintf(_tdrpFile, ",\n");
    } else {
      fprintf(_tdrpFile, "\n");
    }
  } // itime_tick_color
  fprintf(_tdrpFile, "};\n");

  fprintf(_tdrpFile, "// </TIME_CONTROL_GUI>\n");
  
  /* Toggle for displaying the height Selector in Right Margin */
  // _getBoolean("cidd.show_height_sel", 1);

  /* Toggle for displaying data access and rendering messages */
  // _getBoolean("cidd.show_data_messages", 1);

  // mode for writing latlon values
  // _getLong("cidd.latlon_mode",0);

  // time labels
  _getString("cidd.label_time_format", "%m/%d/%y %H:%M:%S");
  _getString("cidd.moviestart_time_format", "%H:%M %m/%d/%Y");
  _getString("cidd.frame_range_time_format", "%H:%M");

  // Get the on/off state of the extra legend plotting - Force to either 0 or 1
  _getBoolean("cidd.layer_legends_on", 1);
  _getBoolean("cidd.cont_legends_on", 1);
  _getBoolean("cidd.wind_legends_on", 1);

  /* Toggle for displaying data labels */
  _getBoolean("cidd.display_labels", 1);

  /* Toggle for displaying the analog clock */
  _getBoolean("cidd.display_ref_lines", 1);

  // margins
  // _getLong("cidd.top_margin_render_style", 1);
  // _getLong("cidd.bot_margin_render_style", 1);
  
  // main window (horiz view)

  int horizXpos = _getLong("cidd.horiz_default_x_pos", 0, false);
  fprintf(_tdrpFile, "horiz_window_x_pos = %d;\n", horizXpos);
  
  int horizYpos = _getLong("cidd.horiz_default_y_pos", 0, false);
  fprintf(_tdrpFile, "horiz_window_y_pos = %d;\n", horizYpos);
  
  int horizMinWidth = _getLong("cidd.horiz_min_width", 400, false);
  fprintf(_tdrpFile, "horiz_window_min_width = %d;\n", horizMinWidth);
  
  int horizMinHeight = _getLong("cidd.horiz_min_height", 400, false);
  fprintf(_tdrpFile, "horiz_window_min_height = %d;\n", horizMinHeight);
  
  int horizHeight = _getLong("cidd.horiz_default_height", 800, false);
  double aspectRatio = _getDouble("cidd.aspect_ratio", 1.0, false);
  if (aspectRatio <= 0.0) {
    aspectRatio = 1.0;
  }
  int horizWidth = (int) (horizHeight * aspectRatio + 0.5);
  
  fprintf(_tdrpFile, "horiz_plot_width = %d;\n", horizWidth);
  fprintf(_tdrpFile, "horiz_plot_height = %d;\n", horizHeight);
  
  // int rightMargin = _getLong("cidd.horiz_right_margin", 60, false);
  // fprintf(_tdrpFile, "horiz_color_scale_width = %d;\n", rightMargin);
  
  _getLong("cidd.horiz_top_margin", 20);
  _getLong("cidd.horiz_bot_margin", 20);
  _getLong("cidd.horiz_left_margin", 20);
  // int rightMargin = _getLong("cidd.horiz_right_margin", 80.0, false);
  fprintf(_tdrpFile, "horiz_right_margin = %d;\n", 6);

  // _getLong("cidd.horiz_legends_start_x", 0);
  // _getLong("cidd.horiz_legends_start_y", 0);
  // _getLong("cidd.horiz_legends_delta_y", 0);

  // vertical section
  
  int vertXpos = _getLong("cidd.vert_default_x_pos", -1, false);
  fprintf(_tdrpFile, "vert_window_x_pos = %d;\n", vertXpos);
  
  int vertYpos = _getLong("cidd.vert_default_y_pos", -1, false);
  fprintf(_tdrpFile, "vert_window_y_pos = %d;\n", vertYpos);
  
  int vertWidth = _getLong("cidd.vert_default_width", 400, false);
  fprintf(_tdrpFile, "vert_plot_width = %d;\n", vertWidth);

  int vertHeight = _getLong("cidd.vert_default_height", 400, false);
  fprintf(_tdrpFile, "vert_plot_height = %d;\n", vertHeight);

  int vertMinWidth = _getLong("cidd.vert_min_width", 400, false);
  fprintf(_tdrpFile, "vert_window_min_width = %d;\n", vertMinWidth);
  
  int vertMinHeight = _getLong("cidd.vert_min_height", 400, false);
  fprintf(_tdrpFile, "vert_window_min_height = %d;\n", vertMinHeight);
  
  _getLong("cidd.vert_top_margin", 20);
  _getLong("cidd.vert_bot_margin", 20);
  _getLong("cidd.vert_left_margin", 20);
  _getLong("cidd.vert_right_margin", 80);

  // _getLong("cidd.vert_legends_start_x", 0);
  // _getLong("cidd.vert_legends_start_y", 0);
  // _getLong("cidd.vert_legends_delta_y", 0);

  // range rings
  _getBoolean("cidd.range_rings", 0);
  _getLong("cidd.range_ring_x_space", 50);
  _getLong("cidd.range_ring_y_space", 15);
  _getBoolean("cidd.range_ring_labels", 1);
  _getDouble("cidd.range_ring_spacing", -1.0);
  _getDouble("cidd.max_ring_range", 1000.0);
  _getBoolean("cidd.range_ring_follows_data", 0);
  _getBoolean("cidd.range_ring_for_radar_only", 0);

  // Toggle for shifting the display origin - Useful for mobile units.
  _getBoolean("cidd.domain_follows_data", 0);

  // azimuth lines
  _getDouble("cidd.azmith_interval", 30.0, true, "azimuth_interval");
  _getDouble("cidd.azmith_radius", 200.0, true, "azimuth_radius");
  _getBoolean("cidd.azmith_lines", 0, true, "azimuth_lines");

  // winds
  // _getBoolean("cidd.wind_mode", 0);
  bool windsOn = _getBoolean("cidd.all_winds_on", 1, false);
  if (windsOn) {
    fprintf(_tdrpFile, "winds_on_at_startup = TRUE;\n");
  } else {
    fprintf(_tdrpFile, "winds_on_at_startup = FALSE;\n");
  }
  
  int shaftLen = _getLong("cidd.barb_shaft_len", 33, false);
  fprintf(_tdrpFile, "wind_barb_shaft_len = %d;\n", shaftLen);
  
  int idealXVec = _getLong("cidd.ideal_x_vectors", 20, false);
  fprintf(_tdrpFile, "wind_ideal_x_vectors = %d;\n", idealXVec);
  
  int idealYVec = _getLong("cidd.ideal_y_vectors", 20, false);
  fprintf(_tdrpFile, "wind_ideal_y_vectors = %d;\n", idealYVec);
  
  _getLong("cidd.wind_head_size", 5);
  _getDouble("cidd.wind_head_angle", 45.0);
  _getLong("cidd.wind_scaler", 3);
  _getDouble("cidd.wind_time_scale_interval", 10.0);

  _windMarkerType = _getString("cidd.wind_marker_type", "arrow", false);
  if (_windMarkerType == "arrow") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_ARROW;\n");
  } else if (_windMarkerType == "vector") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_VECTOR;\n");
  } else if (_windMarkerType == "barb") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_BARB;\n");
  } else if (_windMarkerType == "labeledbarb") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_LABELEDBARB;\n");
  } else if (_windMarkerType == "tuft") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_TUFT;\n");
  } else if (_windMarkerType == "tickvector") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_TICKVECTOR;\n");
  } else if (_windMarkerType == "metbarb") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_METBARB;\n");
  } else if (_windMarkerType == "barb_sh") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_BARB_SH;\n");
  } else if (_windMarkerType == "labeledbarb_sh") {
    fprintf(_tdrpFile, "wind_marker_type = WIND_LABELEDBARB_SH;\n");
  } else {
    fprintf(_tdrpFile, "wind_marker_type = WIND_ARROW;\n");
  }
    
  _getDouble("cidd.wind_w_scale_factor", 10.0);
  _getDouble("cidd.wind_units_scale_factor", 1.0);
  _getDouble("cidd.wind_reference_speed", 10.0);
  _getString("cidd.wind_units_label", "m/sec");

  // bad and missing values
  _getBoolean("cidd.map_bad_to_min_value", 0);
  _getBoolean("cidd.map_missing_to_min_value", 0);

  ////////////////////////////////////////////////////////
  // fields to be contoured
  
  fprintf(_tdrpFile, "// <CONTOURS>\n");

  vector<ContourField> contours;
  
  for(int ii = 0; ii < 20; ii++) {
    
    // get entry
    
    char str_buf[1024];
    snprintf(str_buf, 1023, "cidd.contour%d_field", ii + 1);
    string val = _getString(str_buf, "not_found", false);
    if (val.find("not_found") == 0) {
      continue;
    }
    
    // tokenize based on spaces, min of 2 tokens
    
    vector<string> toks;
    TaStr::tokenize(val, " ", toks);
    if (toks.size() < 2) {
      continue;
    }
    
    ContourField contour;
    contour.field_name = toks[0];
    contour.color = toks[1];
    contour.on_at_startup = true;

    // check third token for "off"
    
    if (toks.size() > 2) {
      if (toks[2].find("off") != string::npos) {
        contour.on_at_startup = false;
      }
    }
    
    contours.push_back(contour);
    
  } // i

  // write to TDRP
  
  fprintf(_tdrpFile, "contour_fields = {\n");
  for(size_t ii = 0; ii < contours.size(); ii++) {
    ContourField &contour = contours[ii];
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    field_name = \"%s\",\n", contour.field_name.c_str());
    fprintf(_tdrpFile, "    color = \"%s\",\n", contour.color.c_str());
    fprintf(_tdrpFile, "    on_at_startup = %s\n", (contour.on_at_startup?"true":"false"));
    fprintf(_tdrpFile, "  }\n");
    if (ii < contours.size() - 1) {
      fprintf(_tdrpFile, "  ,\n");
    }
  } // izoom
  fprintf(_tdrpFile, "};\n");

  // contours
  _getBoolean("cidd.label_contours",1);
  _getLong("cidd.contour_line_width", 1);
  _getLong("cidd.smooth_contours", 0);
  _getBoolean("cidd.use_alt_contours", 0);
  _getBoolean("cidd.add_noise", 0);
  _getDouble("cidd.special_contour_value", 0.0);

  fprintf(_tdrpFile, "// </CONTOURS>\n");
  
  ////////////////////////////////////////////////////////
  // layer overlay fields
  
  fprintf(_tdrpFile, "// <LAYERS>\n");

  vector<LayerField> layers;
  
  for(int ii = 0; ii < 20; ii++) {

    // get entry
    
    char str_buf[1024];
    snprintf(str_buf, 1023, "cidd.layer%d_field", ii + 1);
    string val = _getString(str_buf, "not_found", false);
    if (val.find("not_found") == 0) {
      continue;
    }

    // tokenize on spaces, should be at least 1 token (the field name)
    
    vector<string> toks;
    TaStr::tokenize(val, " ", toks);
    if (toks.size() < 1) {
      continue;
    }
    
    LayerField layer;
    layer.field_name = toks[0];
    layer.on_at_startup = true;

    // check for "off" indicating that it is not on at startup
    
    if (toks.size() > 1) {
      if (toks[1].find("off") != string::npos) {
        layer.on_at_startup = false;
      }
    }
    
    layers.push_back(layer);
    
  } // i

  // write to TDRP
  
  fprintf(_tdrpFile, "layer_fields = {\n");
  for(size_t ilayer = 0; ilayer < layers.size(); ilayer++) {
    LayerField &layer = layers[ilayer];
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    field_name = \"%s\",\n", layer.field_name.c_str());
    fprintf(_tdrpFile, "    on_at_startup = %s\n", (layer.on_at_startup?"true":"false"));
    fprintf(_tdrpFile, "  }\n");
    if (ilayer < layers.size() - 1) {
      fprintf(_tdrpFile, "  ,\n");
    }
  } // izoom
  fprintf(_tdrpFile, "};\n");
  fprintf(_tdrpFile, "// </LAYERS>\n");
  
  // main field on top?
  _getBoolean("cidd.draw_main_on_top", 0);

  // latest click location
  _getBoolean("cidd.mark_latest_click_location", 0);
  _getLong("cidd.latest_click_mark_size", 11);
  _getBoolean("cidd.click_posn_rel_to_origin", 0);

  // fonts

  // fprintf(_tdrpFile, "// <FONTS>\n");

  // _numFonts = _getLong("cidd.num_fonts", 1, false);
  // _getLong("cidd.font_display_mode",1);
  
  // vector<string> fonts;
  // for(int ii = 0; ii < _numFonts; ii++) {
  //   char str_buf[1024];
  //   snprintf(str_buf, 1023, "cidd.font%d", ii + 1);
  //   string font = _getString(str_buf, "none", false);
  //   if (font.find("none") == string::npos) {
  //     fonts.push_back(font);
  //   }
  // } // ii

  // fprintf(_tdrpFile, "fonts = {\n");
  // for(size_t ifont = 0; ifont < fonts.size(); ifont++) {
  //   string &font = fonts[ifont];
  //   fprintf(_tdrpFile, "  \"%s\"", font.c_str());
  //   if (ifont < fonts.size() - 1) {
  //     fprintf(_tdrpFile, ",\n");
  //   } else {
  //     fprintf(_tdrpFile, "\n");
  //   }
  // } // ifont
  // fprintf(_tdrpFile, "};\n");
  // fprintf(_tdrpFile, "// </FONTS>\n");
  
  /* Toggle for displaying the analog clock */
  _getBoolean("cidd.show_clock", 0);

  /* Set the time to display on the analog clock */
  _getBoolean("cidd.draw_clock_local", 0);
  
  // field menu - number of columns
  _numMenuCols = _getLong("cidd.num_field_menu_cols", 1);
  
  // display modes
  _getBoolean("cidd.one_click_rhi", 0);

  // canvas events
  _getDouble("cidd.rotate_coarse_adjust",6.0);
  _getDouble("cidd.rotate_medium_adjust",2.0);
  _getDouble("cidd.rotate_fine_adjust", 0.5);
  _getBoolean("cidd.disable_pick_mode", 1);
  _replaceUnderscores = _getBoolean("cidd.replace_underscores", 1);
  _getBoolean("cidd.close_popups", 0);
  _getBoolean("cidd.clip_overlay_fields", 0);

  // labels
  _getString("cidd.horiz_frame_label", "Lucid");
  _getString("cidd.no_data_message", "NO DATA FOUND (in this area at the selected time)");
  _getString("cidd.status_info_file", "");
  _getString("cidd.help_command", "");

  // ////////////////////////////////////////////////////////
  // // Bookmarks for a menu of URLS - Index starts at 1
  
  // fprintf(_tdrpFile, "// <BOOKMARKS>\n");
  
  // _getString("cidd.bookmark_command", "");
  // _numBookmarks = _getLong("cidd.num_bookmarks", 0, false);

  // // read bookmark labels and urls
  
  // vector<Bookmark> bookmarks;
  // for(int ii = 0; ii < _numBookmarks; ii++) {
  //   Bookmark bookmark;
  //   char str_buf[1024];
  //   snprintf(str_buf, 1023, "cidd.bookmark_label%d", ii + 1);
  //   bookmark.label = _getString(str_buf, "not_found", false);
  //   if (bookmark.label.find("not_found") == 0) {
  //     continue;
  //   }
  //   snprintf(str_buf, 1023, "cidd.bookmark%d", ii + 1);
  //   bookmark.url = _getString(str_buf, "not_found", false);
  //   if (bookmark.url.find("not_found") == 0) {
  //     continue;
  //   }
  //   bookmarks.push_back(bookmark);
  // } // i

  // // write to TDRP
  
  // fprintf(_tdrpFile, "bookmarks = {\n");
  // for(size_t ii = 0; ii < bookmarks.size(); ii++) {
  //   Bookmark &bookmark = bookmarks[ii];
  //   fprintf(_tdrpFile, "  {\n");
  //   fprintf(_tdrpFile, "    label = \"%s\",\n", bookmark.label.c_str());
  //   fprintf(_tdrpFile, "    url = \"%s\"\n", bookmark.url.c_str());
  //   fprintf(_tdrpFile, "  }\n");
  //   if (ii < bookmarks.size() - 1) {
  //     fprintf(_tdrpFile, "  ,\n");
  //   }
  // } // izoom
  // fprintf(_tdrpFile, "};\n");
  
  // fprintf(_tdrpFile, "// </BOOKMARKS>\n");
  
  // image intensity
  _getDouble("cidd.image_inten", 0.8);
  _getLong("cidd.inten_levels", 32);
  _getDouble("cidd.data_inten", 1.0);

  // fill and contour thresholds
  _getLong("cidd.image_fill_threshold", 120000);
  _getLong("cidd.dynamic_contour_threshold", 160000);
  
  // shmem
  _getLong("cidd.coord_key", 63500);

  ///////////////////////////////////////////////////////
  // products
  
  fprintf(_tdrpFile, "// <PRODUCTS>\n");

  _getBoolean("cidd.products_on", 1);
  _getLong("cidd.product_line_width", 1);
  _getLong("cidd.product_font_size", 1);
  _getDouble("cidd.scale_constant", 300.0);
  
  vector<ProdAdjustment> adjs;
  for(int ii = 0; ii < 20; ii++) {
    char str_buf[1024];
    snprintf(str_buf, 1023, "cidd.product_detail_threshold%d", ii + 1);
    double thresh = _getDouble(str_buf, -9999, false);
    if (thresh < -9998) {
      continue;
    }
    snprintf(str_buf, 1023, "cidd.product_detail_adjustment%d", ii + 1);
    int indexAdj = _getInt(str_buf, -9999, false);
    if (indexAdj < -9998) {
      continue;
    }
    ProdAdjustment adj;
    adj.threshold = thresh;
    adj.font_index_adj = indexAdj;
    adjs.push_back(adj);
  } // i

  // write to TDRP
  
  fprintf(_tdrpFile, "product_adjustments = {\n");
  for(size_t ii = 0; ii < adjs.size(); ii++) {
    ProdAdjustment &adj = adjs[ii];
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    threshold = %lg,\n", adj.threshold);
    fprintf(_tdrpFile, "    font_index_adj = %d\n", adj.font_index_adj);
    fprintf(_tdrpFile, "  }\n");
    if (ii < adjs.size() - 1) {
      fprintf(_tdrpFile, "  ,\n");
    }
  } // izoom
  fprintf(_tdrpFile, "};\n");
  
  fprintf(_tdrpFile, "// </PRODUCTS>\n");

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </MAIN_PARAMS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  return 0;

}

/////////////////////////////////////////////////////////////////////////////
// initialize the group names

int LegacyParams::_readGuiConfigTdrp()
{
  
  // read the GUI_CONFIG parameters

  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"GUI_CONFIG",
                 &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    return -1;
  }
  
  // read into TDRP from buffer
  
  if (_guiConfig.loadFromBuf("GUI_CONFIG TDRP Section",
                             NULL, param_text,
                             param_text_len,
                             param_text_line_no,
                             TRUE, _debug2)  < 0) { 
    return -1;
  }

  return 0;

}

/////////////////////////////////////////////////////////////////////////////
// initialize data field structs

int LegacyParams::_readGrids()
{
  
  // read in gridded fields
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <GRIDS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  // read the GRIDS params buffer
  
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"GRIDS",
                 &param_text_len, &param_text_line_no);
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr, "ERROR - LegacyParams::_readGrids\n");
    fprintf(stderr, "  No GRIDS section in param file\n");
    return -1;
  }
  string paramText(param_text, param_text_len);
  
  // read all the lines in the data information buffer
  
  vector<Field> flds;
  int total_len = 0;
  const char *start_ptr = paramText.c_str();
  const char *end_ptr;
  while((end_ptr = strchr(start_ptr,'\n')) != NULL &&
        (total_len < param_text_len)) {
    
    // Skip over blank, short or commented lines
    int len = (end_ptr - start_ptr)+1;
    if( (len < 20)  || (*start_ptr == '#')) {
      total_len += len + 1;
      start_ptr = end_ptr + 1; // Skip past the newline
      param_text_line_no++;
      continue;
    }

    if(flds.size() < Constants::MAX_DATA_FIELDS - 1) {
      
      Field fld;
      
      // create space for text line

      fld.text_line.resize(len + 10000);
      STRcopy((char *) fld.text_line.c_str(), start_ptr, len);
      
      /* Do Environment variable substitution */
      usubstitute_env((char *) fld.text_line.c_str(), len + 10000);
      
      flds.push_back(fld);

    } else {

      fprintf(stderr,
              "Cidd: Warning. Too many Data Fields. Data field not processed\n");
      fprintf(stderr,"Line %ld \n",param_text_line_no);
	 
    }

    total_len += len + 1;   // Count characters processed 
    start_ptr = end_ptr +1; // Skip past the newline
    param_text_line_no++;

  }
  
  if (flds.size() < 1) {
    fprintf(stderr, "ERROR - LegacyParams::_readGrids\n");
    fprintf(stderr, "At least one valid gridded data field required\n");
    return -1;
  }

  /* get temp space for substrings */
  char *cfield[MAX_PARSE_FIELDS];
  for(int ii = 0; ii < MAX_PARSE_FIELDS; ii++) {
    cfield[ii] = (char *)  calloc(MAX_PARSE_SIZE, 1);
  }

  /* scan through each of the data information lines */

  for(size_t ifield = 0; ifield < flds.size(); ifield++) {
    
    Field &fld = flds[ifield];
    
    // tokenize and check we have at least 11 fields
    vector<string> ltoks;
    TaStr::tokenize(fld.text_line, " ", ltoks);
    if (ltoks.size() < 11) {
      fld.is_valid = false;
      continue;
    }
    
    /* separate into substrings */

    STRparse(fld.text_line.c_str(), cfield,
             INPUT_LINE_LEN, MAX_PARSE_FIELDS, MAX_PARSE_SIZE);
    fld.legend_label = cfield[0];
    fld.button_label = cfield[1];

    /* Replace spaces with underscores in labels */
    for(int jj = (int) fld.button_label.size() - 1 ; jj >= 0; jj--) {
      if (fld.button_label[jj] == ' ') {
        fld.button_label[jj] = '_';
      }
    }
    for(int jj = (int) fld.legend_label.size() - 1 ; jj >= 0; jj--) {
      if (fld.legend_label[jj] == ' ') {
        fld.legend_label[jj] = '_';
      }
    }

    // split the URL into url and field name - the delimiter is '&'
    
    vector<string> toks;
    TaStr::tokenize(cfield[2], "&", toks);
    if (toks.size() != 2) {
      cerr << "WARNING - bad data field line, no field name" << endl;
      cerr << fld.text_line << endl;
      fld.is_valid = false;
      continue;
    }
    fld.url = toks[0];
    fld.field_name = toks[1];

    // other members
    
    fld.color_map = cfield[3];
    
    // if units are "" or --, set to zero-length string
    if (!strcmp(cfield[4], "\"\"") || !strcmp(cfield[4], "--")) {
      fld.field_units.clear();
    } else {
      fld.field_units = cfield[4];
    }

    fld.contour_low = atof(cfield[5]);
    fld.contour_high = atof(cfield[6]);
    fld.contour_interval = atof(cfield[7]);

    if (strncasecmp(cfield[8],"rad",3) == 0) {
      fld.render_mode = POLYGONS;
    } else {
      fld.render_mode = POLYGONS;
    }

    if (strncasecmp(cfield[8],"cont",4) == 0) {
      fld.render_mode = FILLED_CONTOURS;
    }

    if (strncasecmp(cfield[8],"lcont",4) == 0) {
      fld.render_mode = LINE_CONTOURS;
    }

    if (strncasecmp(cfield[8],"dcont",4) == 0) {
      fld.render_mode = DYNAMIC_CONTOURS;
    }

    if (strstr(cfield[8],"comp") != NULL) {
      fld.composite_mode = TRUE;
    }

    if (strstr(cfield[8],"autoscale") != NULL) {
      fld.auto_scale = TRUE;
    }

    fld.display_in_menu = atoi(cfield[9]);
    
    if(_runOnceAndExit) {
      fld.auto_render = 1;
    } else {
      fld.auto_render = atoi(cfield[10]);
    }

    fld.is_valid = true;
    
  } // ifield
  
  /* free up temp storage for substrings */
  for(int i = 0; i < MAX_PARSE_FIELDS; i++) {
    free(cfield[i]);
  }

  // set group name from gui config as appropriate

  vector<Field> validFlds;

  for(size_t ifield = 0; ifield < flds.size(); ifield++) {
    Field &fld = flds[ifield];
    if (!fld.is_valid) {
      continue;
    }
    
    // is this a filler line?
    if (fld.button_label.find("====") != string::npos ||
        fld.legend_label.find("====") != string::npos ||
        fld.field_name.find("None") != string::npos ||
        fld.color_map.find("none.") != string::npos) {
      fld.group_name = "";
      validFlds.push_back(fld);
      continue;
    }
    
    for (int ii = 0; ii < _guiConfig.field_list_n; ii++) {
      string groupName = _guiConfig._field_list[ii].id_label;
      for (size_t ii = 0; ii < groupName.size(); ii++) {
        if (groupName[ii] == ' ') {
          groupName[ii] = '_';
        }
      }
      string tag = _guiConfig._field_list[ii].grid_list;
      if (fld.button_label.find(tag) == 0) {
        fld.group_name = groupName;
      } else if (fld.legend_label.find(tag) == 0) {
        fld.group_name = groupName;
      }
    }
    validFlds.push_back(fld);
  }
  
  // delet menu lines with no valid fields

  vector<Field> finalFlds;
  int nMenuRows = (int) ((validFlds.size() - 1) / _numMenuCols) + 1;
  for (int irow = 0; irow < nMenuRows; irow++) {
    // get fields for this row
    vector<Field> goodFlds, emptyFlds;
    for (int icol = 0; icol < _numMenuCols; icol++) {
      int fieldNum = irow * _numMenuCols + icol;
      if (fieldNum < (int) validFlds.size()) {
        if (validFlds[fieldNum].group_name.size() != 0) {
          goodFlds.push_back(validFlds[fieldNum]);
        } else {
          emptyFlds.push_back(validFlds[fieldNum]);
        }
      }
    } // icol
    if (goodFlds.size() > 0) {
      for (size_t ii = 0; ii < goodFlds.size(); ii++) {
        finalFlds.push_back(goodFlds[ii]);
      }
      for (size_t ii = 0; ii < emptyFlds.size(); ii++) {
        finalFlds.push_back(emptyFlds[ii]);
      }
    }
  } // irow

  
  /* write to tdrp params file */
  
  fprintf(_tdrpFile, "fields = {\n");
  int count = 0;
  for(size_t ifield = 0; ifield < finalFlds.size(); ifield++) {
    Field &fld = finalFlds[ifield];
    if (count > 0) {
      fprintf(_tdrpFile, "  ,\n");
    }
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    group_name = \"%s\",\n", fld.group_name.c_str());
    fprintf(_tdrpFile, "    button_label = \"%s\",\n", fld.button_label.c_str());
    fprintf(_tdrpFile, "    legend_label = \"%s\",\n", fld.legend_label.c_str());
    fprintf(_tdrpFile, "    url = \"%s\",\n", fld.url.c_str());
    fprintf(_tdrpFile, "    field_name = \"%s\",\n", fld.field_name.c_str());
    fprintf(_tdrpFile, "    color_map = \"%s\",\n", fld.color_map.c_str());
    fprintf(_tdrpFile, "    field_units = \"%s\",\n", fld.field_units.c_str());
    fprintf(_tdrpFile, "    contour_low = %lg,\n", fld.contour_low);
    fprintf(_tdrpFile, "    contour_high = %lg,\n", fld.contour_high);
    fprintf(_tdrpFile, "    contour_interval = %lg,\n", fld.contour_interval);
    switch (fld.render_mode) {
      case POLYGONS:
        fprintf(_tdrpFile, "    render_mode = POLYGONS,\n");
        break;
      case FILLED_CONTOURS:
        fprintf(_tdrpFile, "    render_mode = FILLED_CONTOURS,\n");
        break;
      case DYNAMIC_CONTOURS:
        fprintf(_tdrpFile, "    render_mode = DYNAMIC_CONTOURS,\n");
        break;
      case LINE_CONTOURS:
        fprintf(_tdrpFile, "    render_mode = LINE_CONTOURS,\n");
        break;
    }
    fprintf(_tdrpFile, "    display_in_menu = %s,\n",
            (fld.display_in_menu?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "    background_render = %s,\n",
            (fld.background_render?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "    composite_mode = %s,\n",
            (fld.composite_mode?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "    auto_scale = %s,\n",
            (fld.auto_scale?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "    auto_render = %s\n",
            (fld.auto_render?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  }\n");
    count++;
  } // ifield
  fprintf(_tdrpFile, "};\n");

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </GRIDS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  return 0;

}

/************************************************************************
 * Read in wind fields
 */

int LegacyParams::_readWinds()
  
{

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <WINDS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  // read the WINDS params buffer
  
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"WINDS",
                 &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr, "WARNING - LegacyParams::_readWinds\n");
    fprintf(stderr, "  No WINDS section in param file\n");
    return -1;
  }
  string paramText(param_text, param_text_len);
  
  // alloc cfield array
  
  char *cfield[MAX_PARSE_FIELDS];
  for(int i = 0; i < MAX_PARSE_FIELDS; i++) {
    cfield[i] =(char *) calloc(MAX_PARSE_SIZE, 1);
  }
  
  // set default marker type
  
  _defaultWindRenderMode = _getWindRenderMode(_windMarkerType.c_str());

  // read the params lines, create winds vector
  
  int total_len = 0;
  const char *start_ptr = paramText.c_str();
  const char *end_ptr;
  vector<Wind> winds;
  
  while((end_ptr = strchr(start_ptr,'\n')) != NULL && 
        (total_len < param_text_len)) {
  
    // Skip over blank, short or commented lines
    int len = (end_ptr - start_ptr) + 1; 
    
    if( len > 15 && *start_ptr != '#') {
    
      int num_fields =
        STRparse(start_ptr, cfield, len, MAX_PARSE_FIELDS, MAX_PARSE_SIZE); 
      
      if(*start_ptr != '#' && num_fields >= 7) {
        Wind wind;
        // create space for text line
        wind.text_line.resize(len + 10000);
        STRcopy((char *) wind.text_line.c_str(), start_ptr, len);
        /* Do Environment variable substitution */
        usubstitute_env((char *) wind.text_line.c_str(), len + 10000);
        winds.push_back(wind);
      }

    }

    start_ptr = end_ptr +1; // Skip past the newline
    total_len += len  +1;
      
  } // while

  // parse the winds params from the text lines
  
  for(size_t ii = 0; ii < winds.size(); ii++) {

    Wind &wind = winds[ii];
    int num_fields = STRparse(wind.text_line.c_str(), cfield,
                              INPUT_LINE_LEN,
                              MAX_PARSE_FIELDS, MAX_PARSE_SIZE);
    if(num_fields < 7) {
      fprintf(stderr,
              "Error in wind field line. Wrong number of parameters: %s",
              wind.text_line.c_str());
    }

    // labels
    
    wind.button_label = cfield[0];
    wind.legend_label = cfield[0];

    // url - strip off trailing &
    
    wind.url = cfield[1];
    if (wind.url.size() > 3 && wind.url[wind.url.size() - 1] == '&') {
      wind.url = wind.url.substr(0, wind.url.size() - 1);
    }

    wind.u_field_name = cfield[2];
    wind.v_field_name = cfield[3];
    wind.w_field_name = cfield[4];
    wind.units = cfield[5];

    // split the line width field, using the delimiter ','
    // if there is a second token this indicated the render mode
    
    vector<string> toks;
    TaStr::tokenize(cfield[6], ",", toks);
    if (toks.size() < 1) {
      cerr << "WARNING - bad wind params: " << wind.text_line << endl;
      wind.is_valid = false;
    } else {
      wind.line_width = atoi(toks[0].c_str());
      if (wind.line_width < 0) {
        // negative line width, inactive
        wind.on_at_startup = false;
        wind.line_width *= -1;
      }
      if (wind.line_width > 10) {
        // sanity check
        wind.line_width = 1;
      }
      if (toks.size() > 1) {
        wind.render_mode = _getWindRenderMode(toks[1].c_str());
      }
    }
    
    if(num_fields > 7) {
      wind.color = cfield[7];
    } else {
      wind.color = "white";
    }
    
    /* Replace spaces with underscores in labels */
    for(int jj = (int) wind.button_label.size() - 1 ; jj >= 0; jj--) {
      if (wind.button_label[jj] == ' ') {
        wind.button_label[jj] = '_';
      }
    }
    for(int jj = (int) wind.legend_label.size() - 1 ; jj >= 0; jj--) {
      if(wind.legend_label[jj] == ' ') {
        wind.legend_label[jj] = '_';
      }
    }

    wind.is_valid = true;
    
  } // ii
  
  /* free temp space */
  for(size_t i = 0; i < MAX_PARSE_FIELDS; i++) {
    if (cfield[i] != NULL) {
      free(cfield[i]);
    }
  }
  
  /* write to tdrp params file */

  fprintf(_tdrpFile, "winds = {\n");
  for(size_t ifield = 0; ifield < winds.size(); ifield++) {
    Wind &wind = winds[ifield];
    if (!wind.is_valid) {
      continue;
    }
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    button_label = \"%s\",\n", wind.button_label.c_str());
    fprintf(_tdrpFile, "    legend_label = \"%s\",\n", wind.legend_label.c_str());
    fprintf(_tdrpFile, "    url = \"%s\",\n", wind.url.c_str());
    fprintf(_tdrpFile, "    u_field_name = \"%s\",\n", wind.u_field_name.c_str());
    fprintf(_tdrpFile, "    v_field_name = \"%s\",\n", wind.v_field_name.c_str());
    fprintf(_tdrpFile, "    w_field_name = \"%s\",\n", wind.w_field_name.c_str());
    fprintf(_tdrpFile, "    units = \"%s\",\n", wind.units.c_str());
    fprintf(_tdrpFile, "    line_width = %d,\n", wind.line_width);
    switch (wind.render_mode) {
      case ARROW:
        fprintf(_tdrpFile, "    marker_type = WIND_ARROW,\n");
        break;
      case VECTOR:
        fprintf(_tdrpFile, "    marker_type = WIND_VECTOR,\n");
        break;
      case BARB:
        fprintf(_tdrpFile, "    marker_type = WIND_BARB,\n");
        break;
      case LABELEDBARB:
        fprintf(_tdrpFile, "    marker_type = WIND_LABELEDBARB,\n");
        break;
      case TUFT:
        fprintf(_tdrpFile, "    marker_type = WIND_TUFT,\n");
        break;
      case TICKVECTOR:
        fprintf(_tdrpFile, "    marker_type = WIND_TICKVECTOR,\n");
        break;
      case METBARB:
        fprintf(_tdrpFile, "    marker_type = WIND_METBARB,\n");
        break;
      case BARB_SH:
        fprintf(_tdrpFile, "    marker_type = WIND_BARB_SH,\n");
        break;
      case LABELEDBARB_SH:
        fprintf(_tdrpFile, "    marker_type = WIND_LABELEDBARB_SH,\n");
        break;
    }
    fprintf(_tdrpFile, "    color = \"%s\",\n", wind.color.c_str());
    fprintf(_tdrpFile, "    on_at_startup = %s\n",
            (wind.on_at_startup?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  }\n");
    if (ifield < winds.size() - 1) {
      fprintf(_tdrpFile, "  ,\n");
    }
  } // ifield
  fprintf(_tdrpFile, "};\n");

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </WINDS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  return 0;
  
}

//////////////////////////////////////////////
// decode the winder render mode from string

LegacyParams::WindRenderMode
  LegacyParams::_getWindRenderMode(const char* markerStr)
{
  if(strncasecmp(markerStr, "arrow", 5) == 0) {
    return LegacyParams::ARROW;
  }
  if(strncasecmp(markerStr, "tuft", 4) == 0) {
    return LegacyParams::TUFT;
  }
  if(strncasecmp(markerStr, "barb", 4) == 0) {
    return LegacyParams::BARB;
  }
  if(strncasecmp(markerStr, "vector", 6) == 0) {
    return LegacyParams::VECTOR;
  }
  if(strncasecmp(markerStr, "tickvector", 10) == 0) {
    return LegacyParams::TICKVECTOR;
  }
  if(strncasecmp(markerStr, "labeledbarb", 11) == 0) {
    return LegacyParams::LABELEDBARB;
  }
  if(strncasecmp(markerStr, "metbarb", 7) == 0) {
    return LegacyParams::METBARB;
  }
  if(strncasecmp(markerStr, "barb_sh", 7) == 0) {
    return LegacyParams::BARB_SH;
  }
  if(strncasecmp(markerStr, "labeledbarb_sh", 14) == 0) {
    return LegacyParams::LABELEDBARB_SH;
  }
  return LegacyParams::ARROW;
}
  
/************************************************************************
 * Read in map fields
 */

int LegacyParams::_readMaps()
  
{

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <MAPS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  // read the MAPS params buffer

  bool maps_active = true;
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"MAPS",
                 &param_text_len, &param_text_line_no);
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr, "WARNING - LegacyParams::_readMaps\n");
    fprintf(stderr, "  No MAPS section in param file\n");
    maps_active = false;
  }
  string paramText(param_text, param_text_len);

  if (maps_active) {
    
    // alloc cfield array
    
    char *cfield[MAX_PARSE_FIELDS];
    for(int i = 0; i < MAX_PARSE_FIELDS; i++) {
      cfield[i] =(char *) calloc(MAX_PARSE_SIZE, 1);
    }
    
    // read the params lines, create maps vector
    
    int total_len = 0;
    const char *start_ptr = paramText.c_str();
    const char *end_ptr;
    vector<MapOverlay> overlays;
    
    while((end_ptr = strchr(start_ptr,'\n')) != NULL && 
          (total_len < param_text_len)) {
      
      // Skip over blank, short or commented lines
      int len = (end_ptr - start_ptr) + 1; 
      
      if(len > 20 && *start_ptr != '#') {
        
        int num_fields =
          STRparse(start_ptr, cfield, len, MAX_PARSE_FIELDS, MAX_PARSE_SIZE); 
        
        if(*start_ptr != '#' && num_fields >= 7) {
          MapOverlay overlay;
          // create space for text line
          overlay.text_line.resize(len + 10000);
          STRcopy((char *) overlay.text_line.c_str(), start_ptr, len);
          /* Do Environment variable substitution */
          usubstitute_env((char *) overlay.text_line.c_str(), len + 10000);
          overlays.push_back(overlay);
        }
        
      }
      
      start_ptr = end_ptr +1; // Skip past the newline
      total_len += len  +1;
      
    } // while
    
    // parse the maps params from the text lines
    
    for(size_t ii = 0; ii < overlays.size(); ii++) {
      
      MapOverlay &overlay = overlays[ii];
      int num_fields = STRparse(overlay.text_line.c_str(), cfield,
                                INPUT_LINE_LEN,
                                MAX_PARSE_FIELDS, MAX_PARSE_SIZE);
      if(num_fields < 7) {
        fprintf(stderr,
                "Error in map field line. Too few parameters: %s",
                overlay.text_line.c_str());
      }
      
      // labels
      
      overlay.map_code = cfield[0];
      overlay.control_label = cfield[1];
      
      // file name
      
      overlay.map_file_name = cfield[2];
      
      // line width
      
      overlay.line_width = atoi(cfield[3]);
      if (overlay.line_width == 0) {
        overlay.on_at_startup = false;
        overlay.line_width = 1;
      } else if (overlay.line_width < 0) {
        // negative line width, inactive
        overlay.on_at_startup = false;
        overlay.line_width *= -1;
      }
      if (overlay.line_width > 10) {
        // sanity check
        overlay.line_width = 1;
      }
      
      // detail thresholds
      
      overlay.detail_thresh_min = atof(cfield[4]);
      overlay.detail_thresh_max = atof(cfield[5]);
      
      // color - can be space delimited, so add all remaining tokens
      
      overlay.color = cfield[6];
      for(int jj = 7; jj < num_fields; jj++) {
        overlay.color = overlay.color + " ";
        overlay.color = cfield[jj];
      }
      
      overlay.is_valid = true;
      
    } // ii
    
    /* free temp space */
    for(size_t i = 0; i < MAX_PARSE_FIELDS; i++) {
      if (cfield[i] != NULL) {
        free(cfield[i]);
      }
    }
    
    /* write to tdrp params file */
    
    fprintf(_tdrpFile, "maps = {\n");
    for(size_t ifield = 0; ifield < overlays.size(); ifield++) {
      MapOverlay &overlay = overlays[ifield];
      if (!overlay.is_valid) {
        continue;
      }
      fprintf(_tdrpFile, "  {\n");
      fprintf(_tdrpFile, "    map_code = \"%s\",\n", overlay.map_code.c_str());
      fprintf(_tdrpFile, "    control_label = \"%s\",\n", overlay.control_label.c_str());
      fprintf(_tdrpFile, "    map_file_name = \"%s\",\n", overlay.map_file_name.c_str());
      fprintf(_tdrpFile, "    line_width = %d,\n", overlay.line_width);
      fprintf(_tdrpFile, "    detail_thresh_min = %lg,\n", overlay.detail_thresh_min);
      fprintf(_tdrpFile, "    detail_thresh_max = %lg,\n", overlay.detail_thresh_max);
      fprintf(_tdrpFile, "    color = \"%s\",\n", overlay.color.c_str());
      fprintf(_tdrpFile, "    on_at_startup = %s\n",
              (overlay.on_at_startup?"TRUE":"FALSE"));
      fprintf(_tdrpFile, "  }\n");
      if (ifield < overlays.size() - 1) {
        fprintf(_tdrpFile, "  ,\n");
      }
    } // ifield
    fprintf(_tdrpFile, "};\n");

  } else {

    // no maps

    fprintf(_tdrpFile, "maps = {};\n");
    
  }

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </MAPS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  return 0;
  
}

/************************************************************************
 * Read in symprods
 */

int LegacyParams::_readSymprodsTdrp()
  
{

  // Instantiate the symprods params object, which will load the defaults
  
  Csyprod_P symprod;

  // read in SYMPRODS buffer
  
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"SYMPRODS",
                 &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Warning: No SYMPRODS Section in params\n");
    fprintf(stderr,"  will use the defaults\n");
  } else {
    // Set the symprod object from the buffer
    if(symprod.loadFromBuf("SYMPRODS TDRP Section",
                           NULL,param_text,
                           param_text_len,
                           param_text_line_no,
                           TRUE, FALSE) < 0) {
      fprintf(stderr,"Problems with <SYMPRODS> params in legacy params file.\n");
      fprintf(stderr,"Please fix.\n");
      return -1;
    }
  }

  // write it out to tdrp file, changing param names as appropriate
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <SYMPRODS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  switch (symprod.debug) {
    case Csyprod_P::DEBUG_OFF:
      fprintf(_tdrpFile, "symprod_debug = SYMPROD_DEBUG_OFF;\n");
      break;
    case Csyprod_P::DEBUG_NORM:
      fprintf(_tdrpFile, "symprod_debug = SYMPROD_DEBUG_NORM;\n");
      break;
    case Csyprod_P::DEBUG_VERBOSE:
      fprintf(_tdrpFile, "symprod_debug = SYMPROD_DEBUG_VERBOSE;\n");
      break;
  }

  fprintf(_tdrpFile, "symprod_short_requests = %s;\n",
          (symprod.short_requests?"TRUE":"FALSE"));
    
  fprintf(_tdrpFile, "symprod_gzip_requests = %s;\n",
          (symprod.gzip_requests?"TRUE":"FALSE"));

  fprintf(_tdrpFile, "symprod_prod_info = {\n");
  
  for (int ii = 0; ii < symprod.prod_info_n; ii++) {
    
    Csyprod_P::prod_info_t &info = symprod._prod_info[ii];
    
    fprintf(_tdrpFile, "  {\n");
    fprintf(_tdrpFile, "    menu_label = \"%s\",\n", info.menu_label);
    fprintf(_tdrpFile, "    url = \"%s\",\n", info.url);
    fprintf(_tdrpFile, "    data_type = %d,\n", info.data_type);
    switch (info.render_type) {
      case Csyprod_P::RENDER_ALL:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_ALL,\n");
        break;
      case Csyprod_P::RENDER_ALL_VALID:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_ALL_VALID,\n");
        break;
      case Csyprod_P::RENDER_VALID_IN_LAST_FRAME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_VALID_IN_LAST_FRAME,\n");
        break;
      case Csyprod_P::RENDER_LATEST_IN_FRAME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_LATEST_IN_FRAME,\n");
        break;
      case Csyprod_P::RENDER_LATEST_IN_LOOP:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_LATEST_IN_LOOP,\n");
        break;
      case Csyprod_P::RENDER_FIRST_BEFORE_FRAME_TIME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_FIRST_BEFORE_FRAME_TIME,\n");
        break;
      case Csyprod_P::RENDER_FIRST_BEFORE_DATA_TIME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_FIRST_BEFORE_DATA_TIME,\n");
        break;
      case Csyprod_P::RENDER_FIRST_AFTER_DATA_TIME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_FIRST_AFTER_DATA_TIME,\n");
        break;
      case Csyprod_P::RENDER_ALL_BEFORE_DATA_TIME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_ALL_BEFORE_DATA_TIME,\n");
        break;
      case Csyprod_P::RENDER_ALL_AFTER_DATA_TIME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_ALL_AFTER_DATA_TIME,\n");
        break;
      case Csyprod_P::RENDER_GET_VALID:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_GET_VALID,\n");
        break;
      case Csyprod_P::RENDER_GET_VALID_AT_FRAME_TIME:
        fprintf(_tdrpFile, "    render_type = SYMPROD_RENDER_GET_VALID_AT_FRAME_TIME,\n");
        break;
    }
    fprintf(_tdrpFile, "    on_by_default = %s,\n",
            (info.on_by_default?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "    minutes_allow_before = %lg,\n",
            info.minutes_allow_before);
    fprintf(_tdrpFile, "    minutes_allow_after = %lg,\n",
            info.minutes_allow_after);
    fprintf(_tdrpFile, "    text_off_threshold = %lg,\n",
            info.text_off_threshold);
    fprintf(_tdrpFile, "    request_data_on_zoom = %s,\n",
            (info.request_data_on_zoom?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "    request_data_on_vert_change = %s\n",
            (info.request_data_on_vert_change?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  }\n");
    if (ii < symprod.prod_info_n - 1) {
      fprintf(_tdrpFile, "  ,\n");
    }
  } // ii
  fprintf(_tdrpFile, "};\n");

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </SYMPRODS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  return 0;
  
}

/************************************************************************
 * Read in terrain params
 */

int LegacyParams::_readTerrainTdrp()
  
{

  // Instantiate the terrain params object, which will load the defaults
  
  Cterrain_P terrain;
  
  // read in SYMPRODS buffer
  
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf, "TERRAIN",
                 &param_text_len, &param_text_line_no);

  bool terrain_active = true;
  if(param_text == NULL || param_text_len <=0 ) {
    terrain_active = false;
  } else {
    // Set the terrain object from the buffer
    if(terrain.loadFromBuf("TERRAIN TDRP Section",
                           NULL,param_text,
                           param_text_len,
                           param_text_line_no,
                           TRUE, FALSE) < 0) {
      fprintf(stderr, "Problems with <TERRAIN> params in legacy params file.\n");
      fprintf(stderr, "Ignoring terrain params.\n");
      terrain_active = false;
    }
  }
  
  // write it out to tdrp file, changing param names as appropriate
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <TERRAIN>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  if (terrain_active) {
    
    fprintf(_tdrpFile, "terrain_active = TRUE;\n");
    fprintf(_tdrpFile, "terrain_id_label = \"%s\";\n", terrain.id_label);
    fprintf(_tdrpFile, "terrain_url = \"%s\";\n", terrain.terrain_url);
    fprintf(_tdrpFile, "terrain_height_scaler = %lg;\n", terrain.height_scaler);
    fprintf(_tdrpFile, "landuse_url = \"%s\";\n", terrain.landuse_url);
    fprintf(_tdrpFile, "landuse_colorscale = \"%s\";\n", terrain.landuse_colorscale);
    if (strlen(terrain.landuse_url) > 0) {
      fprintf(_tdrpFile, "landuse_active = TRUE;\n");
    } else {
      fprintf(_tdrpFile, "landuse_active = FALSE;\n");
    }
    
    switch (terrain.land_use_render_method) {
      case Cterrain_P::RENDER_FILLED_CONT:
        fprintf(_tdrpFile,
                "landuse_render_method = TERRAIN_RENDER_FILLED_CONT;\n");
        break;
      case Cterrain_P::RENDER_RECTANGLES:
        fprintf(_tdrpFile,
                "landuse_render_method = TERRAIN_RENDER_RECTANGLES;\n");
        break;
      case Cterrain_P::RENDER_DYNAMIC_CONTOURS:
        fprintf(_tdrpFile,
                "landuse_render_method = TERRAIN_RENDER_DYNAMIC_CONTOURS;\n");
        break;
    }
    
    fprintf(_tdrpFile, "terrain_earth_color1 = \"%s\";\n", terrain.earth_color1);
    fprintf(_tdrpFile, "terrain_earth_color2 = \"%s\";\n", terrain.earth_color2);

  } else {

    fprintf(_tdrpFile, "terrain_active = FALSE;\n");

  }
  
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </TERRAIN>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  return 0;
  
}

/************************************************************************
 * Read in route winds params
 */

int LegacyParams::_readRouteWindsTdrp()
  
{

  // Instantiate the route winds params object
  
  Croutes_P routes;
  
  // read in buffer
  
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf, "ROUTE_WINDS",
                 &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Warning: No ROUTE_WINDS Section in params\n");
    fprintf(_tdrpFile, "route_winds_active = FALSE;\n");
  } else {
    // Set the routes object from the buffer
    if(routes.loadFromBuf("ROUTE WINDS TDRP Section",
                          NULL,param_text,
                          param_text_len,
                          param_text_line_no,
                          TRUE, FALSE) < 0) {
      fprintf(stderr,
              "Problems with <ROUTE_WINDS> params in legacy params file.\n");
      fprintf(stderr,"Please fix.\n");
      return -1;
    }
  }
  
  // write it out to tdrp file, changing param names as appropriate
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <ROUTE_VSECTIONS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  fprintf(_tdrpFile, "route_winds_active = TRUE;\n");
  
  switch (routes.debug) {
    case Croutes_P::DEBUG_OFF:
      fprintf(_tdrpFile, "route_debug = ROUTE_DEBUG_OFF;\n");
      break;
    case Croutes_P::DEBUG_NORM:
      fprintf(_tdrpFile, "route_debug = ROUTE_DEBUG_NORM;\n");
      break;
    case Croutes_P::DEBUG_VERBOSE:
      fprintf(_tdrpFile, "route_debug = ROUTE_DEBUG_VERBOSE;\n");
      break;
  }
  
  fprintf(_tdrpFile, "route_font_height = %d;\n",
          routes.font_height);
  fprintf(_tdrpFile, "route_add_waypoints_labels = %d;\n",
          routes.add_waypoints_labels);
  fprintf(_tdrpFile, "route_add_wind_text = %d;\n",
          routes.add_wind_text);
  
  switch (routes.label_style) {
    case Croutes_P::REGULAR_INTERVALS:
      fprintf(_tdrpFile,
              "route_label_style = ROUTE_REGULAR_INTERVALS;\n");
      break;
    case Croutes_P::EQUAL_DIVISIONS:
      fprintf(_tdrpFile,
              "route_label_style = ROUTE_EQUAL_DIVISIONS;\n");
      break;
  }
  
  fprintf(_tdrpFile, "route_label_interval = %lg;\n",
          routes.label_interval);
  fprintf(_tdrpFile, "route_num_labels = %d;\n",
          routes.num_route_labels);
  fprintf(_tdrpFile, "route_track_line_width = %d;\n",
          routes.route_track_line_width);

  fprintf(_tdrpFile, "route_u_url = \"%s\";\n", routes.u_url);
  fprintf(_tdrpFile, "route_v_url = \"%s\";\n", routes.v_url);

  // fprintf(_tdrpFile, "route_turb_url = \"%s\";\n", routes.turb_url);
  // fprintf(_tdrpFile, "route_turb_low_thresh = %lg;\n",
  //         routes.turb_low_thresh);
  // fprintf(_tdrpFile, "route_turb_mod_thresh = %lg;\n",
  //         routes.turb_mod_thresh);
  // fprintf(_tdrpFile, "route_turb_high_thresh = %lg;\n",
  //         routes.turb_hi_thresh);

  // fprintf(_tdrpFile, "route_icing_url = \"%s\";\n", routes.icing_url);
  // fprintf(_tdrpFile, "route_icing_low_thresh = %lg;\n",
  //         routes.icing_low_thresh);
  // fprintf(_tdrpFile, "route_icing_mod_thresh = %lg;\n",
  //         routes.icing_mod_thresh);
  // fprintf(_tdrpFile, "route_icing_high_thresh = %lg;\n",
  //         routes.icing_hi_thresh);
  
  fprintf(_tdrpFile, "route_paths = {\n");
  for (int ii = 0; ii < routes.route_paths_n; ii++) {
    fprintf(_tdrpFile, "  \"%s\"", routes._route_paths[ii]);
    if (ii == routes.route_paths_n - 1) {
      fprintf(_tdrpFile, "\n");
    } else {
      fprintf(_tdrpFile, ",\n");
    }
  }
  fprintf(_tdrpFile, "};\n");

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </ROUTE_VSECTIONS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  return 0;
  
}

/************************************************************************
 * Read in draw export params
 */

int LegacyParams::_readDrawExportTdrp()
  
{

  // Instantiate the draw params object, which will load the defaults
  
  Cdraw_P draw;

  // read in DRAW buffer

  bool draw_export_active = true;
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"DRAW_EXPORT",
                 &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Warning: No DRAW_EXPORT Section in params\n");
    fprintf(stderr,"Will be disabled\n");
    draw_export_active = false;
  } else {
    // Set the symprod object from the buffer
    if(draw.loadFromBuf("DRAW_EXPORT TDRP Section",
                        NULL,param_text,
                        param_text_len,
                        param_text_line_no,
                        TRUE, FALSE) < 0) {
      fprintf(stderr,"Problems with <DRAW_EXPORT> params in legacy params file.\n");
      fprintf(stderr,"Please fix.\n");
      fprintf(stderr,"Will be disabled\n");
      draw_export_active = false;
    }
  }

  // write it out to tdrp file, changing param names as appropriate
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <DRAW_EXPORT>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  if (draw_export_active) {
    
    fprintf(_tdrpFile, "draw_export_active = TRUE;\n");

    fprintf(_tdrpFile, "draw_export_info = {\n");
    
    for (int ii = 0; ii < draw.dexport_info_n; ii++) {
      
      Cdraw_P::dexport_t &info = draw._dexport_info[ii];
      
      fprintf(_tdrpFile, "  {\n");
      fprintf(_tdrpFile, "    id_label = \"%s\",\n", info.id_label);
      fprintf(_tdrpFile, "    url = \"%s\",\n", info.url);
      fprintf(_tdrpFile, "    valid_minutes = %lg,\n", info.valid_minutes);
      fprintf(_tdrpFile, "    default_id_no = %d,\n",
              info.default_id_no);
      fprintf(_tdrpFile, "    default_label = \"%s\"\n", info.default_label);
      fprintf(_tdrpFile, "  }\n");
      if (ii < draw.dexport_info_n - 1) {
        fprintf(_tdrpFile, "  ,\n");
      }
    } // ii
    fprintf(_tdrpFile, "};\n");

  } else {

    fprintf(_tdrpFile, "draw_export_active = FALSE;\n");

  }
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </DRAW_EXPORT>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  return 0;
  
}

/************************************************************************
 * Read in image generation params
 */

int LegacyParams::_readImageGenTdrp()
  
{

  // Instantiate the image gen object, which will load the defaults
  
  Cimages_P images;
  
  // read in image gen buffer

  bool image_gen_active = true;
  long param_text_len = 0, param_text_line_no = 0;
  const char *param_text =
    _findTagText(_paramsBuf,"IMAGE_GENERATION",
                 &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Warning: No IMAGE_GENERATION Section in params\n");
    fprintf(stderr,"  will be ignored\n");
    image_gen_active = false;
  } else {
    // Set the symprod object from the buffer
    if(images.loadFromBuf("IMAGE_GENERATION TDRP Section",
                          NULL,param_text,
                          param_text_len,
                          param_text_line_no,
                          TRUE, FALSE) < 0) {
      fprintf(stderr,
              "Problems with <IMAGE_GENERATION> params in legacy params file.\n");
      image_gen_active = false;
    }
  }
  
  // write it out to tdrp file, changing param names as appropriate

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <IMAGE_GENERATION>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
    
  if (image_gen_active) {
    
    fprintf(_tdrpFile, "terrain_active = TRUE;\n");
    switch (images.debug) {
      case Cimages_P::DEBUG_OFF:
        fprintf(_tdrpFile, "image_debug = IMAGE_DEBUG_OFF;\n");
        break;
      case Cimages_P::DEBUG_NORM:
        fprintf(_tdrpFile, "image_debug = IMAGE_DEBUG_NORM;\n");
        break;
      case Cimages_P::DEBUG_VERBOSE:
        fprintf(_tdrpFile, "image_debug = IMAGE_DEBUG_VERBOSE;\n");
        break;
    }
    
    fprintf(_tdrpFile, "image_generate_vsection = %s;\n",
            (images.generate_vsection_images?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "image_vsection_waypts_in_latlon = %s;\n",
            (images.vsection_waypts_in_latlon?"TRUE":"FALSE"));
    
    fprintf(_tdrpFile, "image_vsection_spec = {\n");
    
    for (int ii = 0; ii < images.vsection_spec_n; ii++) {
      
      Cimages_P::vsection_spec_t &spec = images._vsection_spec[ii];
      
      fprintf(_tdrpFile, "  {\n");
      fprintf(_tdrpFile, "    vsection_label = \"%s\",\n", spec.vsection_label);
      fprintf(_tdrpFile, "    n_waypts = %d,\n", spec.n_waypts);
      fprintf(_tdrpFile, "    waypt_locs = \"%s\",\n", spec.waypt_locs);
      fprintf(_tdrpFile, "  }\n");
      if (ii < images.vsection_spec_n - 1) {
        fprintf(_tdrpFile, "  ,\n");
      }
    } // ii
    fprintf(_tdrpFile, "};\n");

  } else {

    fprintf(_tdrpFile, "terrain_active = FALSE;\n");

  }
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </IMAGE_GENERATION>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  return 0;
  
}

/////////////////////////////////////////////////////////////////////////////
// print the legacy params default

void LegacyParams::printLegacyDefaults(ostream &out)
{

  // Generate the full params string.  The non-TDRP portions are kept in
  // static strings while the TDRP portions are loaded from the default
  // parameters

  Cgui_P gui_P;
  Csyprod_P syprod_P;
  Cdraw_P draw_P;
  Cimages_P images_P;
  Cterrain_P terrain_P;
  Croutes_P routes_P;
  
  string params_text = ParamsTextMasterHeader;
  params_text += _getDefaultTdrpParams("GUI_CONFIG", &gui_P);
  params_text += ParamsTextGrids;
  params_text += ParamsTextWinds;
  params_text += ParamsTextMaps;
  params_text += ParamsTextMainParams;
  params_text += _getDefaultTdrpParams("DRAW_EXPORT", &draw_P);
  params_text += _getDefaultTdrpParams("IMAGE_GENERATION", &images_P);
  params_text += _getDefaultTdrpParams("SYMPRODS", &syprod_P);
  params_text += _getDefaultTdrpParams("TERRAIN", &terrain_P);
  params_text += _getDefaultTdrpParams("ROUTE_WINDS", &routes_P);

  out << params_text << endl;

}

/*************************************************************************
 * PARSE_STRING_INTO_TIME:   Parse string to and time structure
 *
 */
void LegacyParams::_parseStringIntoTime(const string &timeStr, DateTime &dtime)
{

  double field[16];
  int num_fields = STRparse_double(timeStr.c_str(), field, 40, 16);
  int year = 0, month = 0, day= 0, hour = 0, min = 0, sec = 0;
  
  switch(num_fields) {
    
    case 6:     /* hour:min:sec month/day/Year */
      
      hour = (int)(field[0]) % 24;
      min = (int)(field[1]) % 60;
      sec = (int)(field[2]) % 60;
      month = (int)(field[3]) % 13;
      day = (int)(field[4]) % 32;
      
      if(field[5] < 50 ) field[5] += 2000;
      if(field[5] < 1900) field[5] += 1900;
      year = (int)(field[5]);
      break;
      
    case 5:     /* hour:min month/day/year */
      
      hour = (int)(field[0]) % 24;
      min = (int)(field[1]) % 60;
      sec = 0;
      
      month = (int)(field[2]) % 13;
      day = (int)(field[3]) % 32;
      if(field[4] < 50 ) field[4] += 2000;
      if(field[4] < 1900) field[4] += 1900;
      year = (int)(field[4]);
      break;
      
    case 4:     /* hour:min month day */
      
      hour = (int)(field[0]) % 24;
      min = (int)(field[1]) % 60;
      month = (int)(field[2]) % 13;
      day = (int)(field[3]) % 32;
      break;
      
    case 2:     /* min:sec */
      min = (int)(field[0]) % 60;
      sec = (int)(field[1]) % 60;
      break;
      
    case 1:     /* min */
      min = (int)(field[0]) % 60;
      break;
  }

  dtime.set(year, month, day, hour, min, sec);

}
