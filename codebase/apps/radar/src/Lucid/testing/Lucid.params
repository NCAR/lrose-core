/**********************************************************************
 * TDRP params for ./Lucid
 **********************************************************************/

//======================================================================
//
// Lucid is an app for integrating multiple weather data products into a 
//   single display.
//
// Lucid is a C++ application using the QT GUI toolkit. It is based on 
//   the legacy CIDD app.
//
//======================================================================
 
//======================================================================
//
// Parameter sections in this file:.
//
// 	<DEBUGGING> - set debug levels
// 	<PROCESS_CONTROL> - and interprocess communication
// 	<FIELDS> - fields to be displayed
// 	<DATA_RETRIEVAL> - how to read the data
// 	<MAPS> - map overlays
// 	<PROJECTION> - world coordinate projection for main window
// 	<MOVIE_LOOPS> - animations
// 	<ZOOM_DOMAINS> - pre-defined zooms
// 	<GUI> - User interface
// 	<WINDOWS> - window size and placement
// 	<HORIZ_VIEW> - horizontal plan-view display
// 	<VERT_VIEW> - vertical cross-section display
// 	<COLORS> - colors for display elements
// 	<OVERLAYS> - geometric overlays and legends
// 	<RENDERING> - details on rendering
// 	<SYMBOLIC_PRODUCTS> - rendering products as overlays
// 	<TERRAIN> - getting and rendering terrain data
// 	<WINDS> - getting and rendering gridded winds
// 	<IMAGE_GENERATION> - image generation
// 	<AUTO_VERT> - predefined vertical sections for image generation
// 	<PLUGINS> - Communicating with other applications
// 	<HELP> - user help.
//
//======================================================================
 
//======================================================================
//
// <DEBUGGING>.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
//
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_NORM
//     DEBUG_VERBOSE
//     DEBUG_EXTRA

debug = DEBUG_OFF;

///////////// debug_flag //////////////////////////////
//
// Basic debug flag.
//
// General informational messages - Initialization messages.
//
// Type: boolean

debug_flag = FALSE;

///////////// debug1_flag /////////////////////////////
//
// More verbose debug flag.
//
// Data flow related messages.
//
// Type: boolean

debug1_flag = FALSE;

///////////// debug2_flag /////////////////////////////
//
// Verbose diagnostics.
//
// Developer debugging information.
//
// Type: boolean

debug2_flag = FALSE;

//======================================================================
//
// </DEBUGGING>.
//
//======================================================================
 
//======================================================================
//
// <PROCESS_CONTROL>.
//
//======================================================================
 
///////////// register_with_procmap ///////////////////
//
// Option to register this process with the process mapper (procmap).
//
// If TRUE, every minute this process will register a heartbeat with 
//   procmap. If the process hangs, it will be restared by the 
//   auto_restarter.
//
// Type: boolean

register_with_procmap = FALSE;

///////////// instance ////////////////////////////////
//
// Process instance.
//
// Used for registration with procmap.
//
// Type: string

instance = "test";

///////////// top_level_cache_dir /////////////////////
//
// Directory for storing temporary files as a cache.
//
// The temporary files we cache are for the maps and color scales. Below 
//   this top level directory Lucid will create subdirectories as follows:
// 	(maps) 'top_level_cache_dir/Lucid/params_file_name/maps'
// 	(color_scales) 
//   'top_level_cache_dir/Lucid/params_file_name/color_scales'.
//
// Type: string

top_level_cache_dir = "/tmp/cache";

///////////// clear_cache /////////////////////////////
//
// Clear the cached maps and color_scales files.
//
// If true, the cached files will be cleared to ensure a new download.
//
// Type: boolean

clear_cache = FALSE;

///////////// use_curl_for_downloads //////////////////
//
// Option to use 'curl' do download remote map and color_scale files.
//
// If true, we use the curl app for the downloads. If false, we use http 
//   requests generated natively within Lucid.
//
// Type: boolean

use_curl_for_downloads = FALSE;

///////////// idle_reset_seconds //////////////////////
//
// After this period of inactivity, the display will reset itself to a 
//   known starting point.
//
// Set this <= 0 to essentially turn off.
//
// Type: int

idle_reset_seconds = 0;

///////////// coord_key ///////////////////////////////
//
// Key for coordinate in shared memory.
//
// Store clicked locations in shmem. Other apps can watch for those 
//   clicks, and respond approppriately.
//
// Type: int

coord_key = 61500;

///////////// titan_key ///////////////////////////////
//
// Key for titan clicks in shared memory.
//
// Store clicked locations in shmem. Rview and TimeHist can watch for 
//   those clicks, and respond approppriately.
//
// Type: int

titan_key = 61600;

//======================================================================
//
// STARTUP MODE and TIME parameters.
//
// Start up in REALTIME or ARCHIVE mode.
//
//======================================================================
 
///////////// start_mode //////////////////////////////
//
// Operating mode at start.
//
// In ARCHIVE mode, the movie start time will be set to 
//   archive_start_time. In REALTIME mode the movie end time will be set 
//   to NOW, and the movie start time will be computed relative to the end 
//   time.
//
// Type: enum
// Options:
//     MODE_ARCHIVE
//     MODE_REALTIME

start_mode = MODE_ARCHIVE;

///////////// archive_start_time //////////////////////
//
// Start time for archive mode.
//
// This is the start of the movie time interval.
//
// Type: string

archive_start_time = "2022 05 26 01 00 00";

//======================================================================
//
// </PROCESS_CONTROL>.
//
//======================================================================
 
//======================================================================
//
// <FIELDS>.
//
//======================================================================
 
///////////// color_scale_urls ////////////////////////
//
// URLs for color scales. Use a comma-delimited list to seach in 
//   multiple locations.
//
// This can be either (a) a local directory in the file system, or (b) a 
//   remote URL using http or https.
//
// Type: string

color_scale_urls = "$(HOME)/git/lrose-displays/color_scales,http://front.eol.ucar.edu/color_scales";

///////////// fields //////////////////////////////////
//
// Fields to be displayed.
//
// /ngroup_name: we organize the fields into groups. If all are the same 
//   we use a single group. Set the group name to empty if this is just a 
//   filler field to organize the field list in the gui./nbutton_label: 
//   appears on the GUI. /nlegend_label: appears in the plot. /nurl: 
//   location of data or data server. /nfield_name: name in the file. 
//   /ncolor_map: name of color map in color_scale_dir. /nunits: units to 
//   appear on the display. /ncontour_low: contour rendering lower limit. 
//   /ncontour_high: contour rendering upper limit. /ncontour_interval: 
//   contour rendering interval. /nrender_mode:/n  POLYGONS: 
//   Rectangle/polygon fills of gridded data./n  FILLED_CONTOURS: false 
//   color filled contours./n  LINE_CONTOURS: line contours./n  
//   DYNAMIC_CONTOURS: auto switching between cart and cont./n         
//   uses dynamic_contour_treshold./ndisplay_in_menu: display this field 
//   in the menu./nbackground_render: render this field automatically in 
//   the background./ncomposite_mode: display max over 
//   height./nauto_scale: scale automatically./nauto_render: render 
//   automatically./n.
//
// Type: struct
//   typedef struct {
//      string group_name;
//      string button_label;
//      string legend_label;
//      string url;
//      string field_name;
//      string color_map;
//      string field_units;
//      double contour_low;
//      double contour_high;
//      double contour_interval;
//      grid_render_mode_t render_mode;
//        Options:
//          POLYGONS
//          FILLED_CONTOURS
//          DYNAMIC_CONTOURS
//          LINE_CONTOURS
//      boolean display_in_menu;
//      boolean background_render;
//      boolean composite_mode;
//      boolean auto_scale;
//      boolean auto_render;
//   }
//
// 1D array - variable length.

fields = {
  {
    group_name = "main",
    button_label = "DBZ_F",
    legend_label = "DBZ_F",
    url = "mdvp:://front.eol.ucar.edu:8080:dynamo/cfradial/orig/moments/sband/sur",
    field_name = "DBZ_F",
    color_map = "dbz.colors",
    field_units = "dBZ",
    contour_low = -5,
    contour_high = 80,
    contour_interval = 5,
    render_mode = POLYGONS,
    display_in_menu = TRUE,
    background_render = FALSE,
    composite_mode = FALSE,
    auto_scale = FALSE,
    auto_render = FALSE
  }
  ,
  {
    group_name = "main",
    button_label = "VEL_F",
    legend_label = "VEL_F",
    url = "mdvp:://front.eol.ucar.edu:8080:dynamo/cfradial/orig/moments/sband/sur",
    field_name = "VEL_F",
    color_map = "vel.colors",
    field_units = "m/s",
    contour_low = -5,
    contour_high = 80,
    contour_interval = 5,
    render_mode = POLYGONS,
    display_in_menu = TRUE,
    background_render = FALSE,
    composite_mode = FALSE,
    auto_scale = FALSE,
    auto_render = FALSE
  }
};

///////////// replace_underscores /////////////////////
//
// Underscores in field names and legends are replaced by spaces.
//
// Type: boolean

replace_underscores = TRUE;

//======================================================================
//
// </FIELDS>.
//
//======================================================================
 
//======================================================================
//
// <DATA_RETRIEVAL>.
//
//======================================================================
 
///////////// check_data_times ////////////////////////
//
// Used to reject 'out of date' data.
//
// Set this param to TRUE to check and reject for rendering any data 
//   that falls outside the movie frame interval + the 
//   slop/stretch_factor.
//
// Type: boolean

check_data_times = FALSE;

///////////// time_search_stretch_factor //////////////
//
// Sets the allowable time error for data to appear in movie frames.
//
// (times the time_interval) (6 min * 6 = 36 minutes before or after the 
//   beginning or end of the movie frame times.
//
// Type: double

time_search_stretch_factor = 6;

///////////// gather_data_mode ////////////////////////
//
// Sets whether we request data closest to the start, midpoint or end of 
//   a movie frame.
//
// CLOSEST_TO_FRAME_CENTER: closest to frame midpoint; 
//   FIRST_BEFORE_END_OF_FRAME: closest to frame end time; 
//   FIRST_AFTER_START_OF_FRAME: closest to the start time of the frame. 
//   Typically, real-time operation should operate as closest to end of 
//   frame. Choose CENTER if you want to enter a time and have data the 
//   data at that time appear, regardless of how wide the movie frame 
//   interval is.
//
// Type: enum
// Options:
//     CLOSEST_TO_FRAME_CENTER
//     FIRST_BEFORE_END_OF_FRAME
//     FIRST_AFTER_START_OF_FRAME

gather_data_mode = CLOSEST_TO_FRAME_CENTER;

///////////// update_interval /////////////////////////
//
// Number of seconds between data update requests.
//
// The display will check the Data Mapper for new data every interval in 
//   real-time mode. At every interval we will check for updates to each 
//   grid and product. If no datamap_host is set, the data is assumed to 
//   be old and will be reloaded every interval. Set this wisely. Values 
//   of 10-900 are typical. Default=120 Setting this below 3 seconds is 
//   not advised.  interacts with the Data Mapper Host parameter: 
//   cidd.datamap_host:.
//
// Type: int

update_interval = 120;

///////////// datamap_host ////////////////////////////
//
// DataMapper Host.
//
// Host on which the DataMapper app is running.
//
// Type: string

datamap_host = "localhost";

///////////// data_timeout_secs ///////////////////////
//
// Number of seconds to wait for data to come in before giving up.
//
// On very slow networks this may need to go as high as 180 seconds.
//
// Type: int

data_timeout_secs = 30;

///////////// request_compressed_data /////////////////
//
// Request data from MDV servers be compressed.
//
// When a remote URL is used, the server can compress the data for 
//   transmission. This makes sense for slow remote connections.
//
// Type: boolean

request_compressed_data = FALSE;

///////////// request_gzip_vol_compression ////////////
//
// Use gzip-style compression for remote data access.
//
// See 'request_compressed_data'.
//
// Type: boolean

request_gzip_vol_compression = FALSE;

///////////// model_run_list_hours ////////////////////
//
// Gather model run times within these number of hours from the end of 
//   the movie loop.
//
// More hours means more Model runs will appear in the menu.
//
// Type: int

model_run_list_hours = 24;

///////////// forecast_interval_hours /////////////////
//
// This parameter sets the maximum number of hours in the future a user 
//   can select from the quick forecast menu.
//
// See SHOW_FORECAST_MENU menu bar button.
//
// Type: double

forecast_interval_hours = 24;

///////////// past_interval_hours /////////////////////
//
// The maximum number of hours in the PAST a user can selectfrom the 
//   quick forecast menu.
//
// See SHOW_PAST_MENU menu bar button.
//
// Type: double

past_interval_hours = 0;

///////////// always_get_full_domain //////////////////
//
// Request the outer domain established by domain_limit params.
//
// i.e. do not clip the data on request.
//
// Type: boolean

always_get_full_domain = FALSE;

///////////// do_not_clip_on_mdv_request //////////////
//
// Request the whole earth or Hemisphere, centered on the origin.
//
// Type: boolean

do_not_clip_on_mdv_request = FALSE;

///////////// do_not_decimate_on_mdv_request //////////
//
// Do not decimate on MDV request, get all points from MDV server.
//
// Type: boolean

do_not_decimate_on_mdv_request = FALSE;

///////////// check_clipping //////////////////////////
//
// Set this parameter to TRUE when displaying data on dissimilar grid 
//   projection and stripes or other artifacts are rendered.
//
// Each polygon will be checked to make sure it will render correctly. 
//   This slows down the rendering a bit so it is FALSE by default.
//
// Type: boolean

check_clipping = FALSE;

///////////// http_tunnel_url /////////////////////////
//
// Tunnel for all DsServer (mdvp,spdbp,etc) Protocols.
//
// USE THIS TO CROSS A FIREWALL ON THE SERVER END OF THE CHAI. Set this 
//   to the special http tunnel that resides in the same local network as 
//   the  data server hosts. This allows 'tunneling' the MDV and Spdb data 
//   protocols through a host, running apache:httpd that is visible from 
//   the Internet or intranet. Note: a special  'Apache::Mod_perl' 
//   extension (The tunnel - it's similar to a cgi mechanism) must be 
//   installed on the http server for this to work.
//
// Type: string

http_tunnel_url = "http://www.rap.ucar.edu/DsServerTunnel.";

///////////// http_proxy_url //////////////////////////
//
// USE THIS TO CROSS A FIREWALL AT THE Client/CIDD End of the Chain.
//
// # Set this to the url of a http forwarding proxy to pass http 
//   requests through the proxy. This is usually the same as the HTTP 
//   proxy URL in your browser. Note. If you need the data to flow through 
//   the proxy the http_tunnel_url must be enabled.
//
// Type: string

http_proxy_url = "http://webcache.ucar.edu:3128/";

//======================================================================
//
// Another view of the possible Service Topologies.
//
// All Local - No Firewalls - Standard Setup
// --------- Local Lan --------------
// CIDD<--- MDVP --->DsMdvServer
//
// Data Services Behind a firewall
// ----- Internet ----|Firewall|------ Local Lan ----------------
// CIDD<---HTTP--->DsServer Tunnel<---MDVP--->DsMdvServer
//
// Both Client and Data Services behind Firewalls
// ---Local Lan ---|Firewall|--Internet----|Firewall|--------Local Lan 
//   ----------
// CIDD<---HTTP--->Http Proxy<---HTTP--->DsServer 
//   Tunnel<---MDVP--->DsMdvServer.
//
//======================================================================
 
///////////// locator_margin_km ///////////////////////
//
// Station locator features.
//
// Maximum allowed  Distance in km between request point and station.
//
// Type: double

locator_margin_km = 50;

///////////// station_loc_url /////////////////////////
//
// Full Path File name or http URL to a station data file.
//
// The format of each line is:  ID, LAT, LON, ALT(m), TYPE.
//
// Type: string

station_loc_url = "http://www.rap.ucar.edu/maps/Taiwan_stations.dat";

//======================================================================
//
// </DATA_RETRIEVAL>.
//
//======================================================================
 
//======================================================================
//
// <MAPS>.
//
//======================================================================
 
///////////// map_urls ////////////////////////////////
//
// URLs for maps. Use a comma-delimited list to seach in multiple 
//   locations.
//
// This can be either (a) a local directory in the file system, or (b) a 
//   remote URL using http or https.
//
// Type: string

map_urls = "$(HOME)/git/lrose-displays/maps,http://front.eol.ucar.edu/maps";

///////////// maps_enabled_at_startup /////////////////
//
// Enable maps at start.
//
// If FALSE, maps will not be emabled at startup. You will have to turn 
//   them on via the maps menu.
//
// Type: boolean

maps_enabled_at_startup = TRUE;

///////////// maps ////////////////////////////////////
//
// Map overlays to be displayed.
//
// map_code: name of the map, appears on the GUI. 
// control_label: appears in the plot. 
// map_file_name: name of map file in maps directory
// line_width: line width to be used for map vectors. 
// detail_thresh_min: min detail threshold for displaying map. Detail 
//   thresholds are computed as units of km across the image. 
// detail_thresh_max: max detail threshold for displaying map. Detail 
//   thresholds are computed as units of km across the image. 
// color: X color name.
// on_at_startup: display overlay when app starts up.
//
// Type: struct
//   typedef struct {
//      string map_code;
//      string control_label;
//      string map_file_name;
//      int line_width;
//      double detail_thresh_min;
//      double detail_thresh_max;
//      string color;
//      boolean on_at_startup;
//   }
//
// 1D array - variable length.

maps = {
  {
    map_code = "US_Highways",
    control_label = "US_Highways",
    map_file_name = "conus_ushwys.map",
    line_width = 1,
    detail_thresh_min = 0,
    detail_thresh_max = 1000,
    color = "grey",
    on_at_startup = TRUE
  }
  ,
  {
    map_code = "Interstates",
    control_label = "Interstates",
    map_file_name = "conus_interstates.map",
    line_width = 1,
    detail_thresh_min = 0,
    detail_thresh_max = 10000,
    color = "white",
    on_at_startup = TRUE
  }
};

///////////// maps_font_size //////////////////////////
//
// Font size for labels on maps.
//
// Type: int

maps_font_size = 8;

///////////// map_font_background /////////////////////
//
// Font rendering mode for maps.
//
// MAP_FONT_BACKGROUND_OPAQUE: Clears background behind label text. 
//   MAP_FONT_BACKGROUND_TRANSPARENT: does not clear background.
//
// Type: enum
// Options:
//     MAP_FONT_BACKGROUND_TRANSPARENT
//     MAP_FONT_BACKGROUND_OPAQUE

map_font_background = MAP_FONT_BACKGROUND_TRANSPARENT;

//======================================================================
//
// </MAPS>.
//
//======================================================================
 
//======================================================================
//
// <PROJECTION>.
//
// Geographic projection for horizontal view.
//
//======================================================================
 
///////////// proj_type ///////////////////////////////
//
// Projection for mapping in x,y. See projection param below.
//
// 	PROJ_LATLON: simple lat/lon grid (Equidistant Cylindrical)
// 	PROJ_FLAT: Azimuthal Equidistant (Radar)
// 	PROJ_LAMBERT_CONF: Lambert Conformal Conic
// 	PROJ_LAMBERT_AZIM: Lambert Azimuthal Equal Area
// 	PROJ_MERCATOR: Mercator - EW orientation
// 	PROJ_TRANS_MERCATOR: Tranverse Mercator - NS orientation
// 	PROJ_POLAR_STEREO: Stereographic- polar aspect
// 	PROJ_OBLIQUE_STEREO: Stereographic - oblique aspect
// 	PROJ_ALBERS: Albers Equal Area Conic.
//
// Type: enum
// Options:
//     PROJ_LATLON
//     PROJ_LAMBERT_CONF
//     PROJ_MERCATOR
//     PROJ_POLAR_STEREO
//     PROJ_FLAT
//     PROJ_OBLIQUE_STEREO
//     PROJ_TRANS_MERCATOR
//     PROJ_ALBERS
//     PROJ_LAMBERT_AZIM

proj_type = PROJ_FLAT;

///////////// proj_origin_lat /////////////////////////
//
// Projection grid origin latitude.
//
// This applies to all projections except LATLON.
//
// Type: double

proj_origin_lat = 0;

///////////// proj_origin_lon /////////////////////////
//
// Projection grid origin longitude.
//
// This applies to all projections except LATLON.
//
// Type: double

proj_origin_lon = 0;

///////////// proj_rotation ///////////////////////////
//
// Amount grids are rotated clockwise to true north.
//
// This applies to only to PROJ_FLAT projection.
//
// Type: double

proj_rotation = 0;

///////////// proj_lat1 ///////////////////////////////
//
// Projection grid reference latitude 1.
//
// This applies to LAMBERT_CONF and ALBERS projections.
//
// Type: double

proj_lat1 = 0;

///////////// proj_lat2 ///////////////////////////////
//
// Projection grid reference latitude 2.
//
// This applies to LAMBERT_CONF and ALBERS projections.
//
// Type: double

proj_lat2 = 0;

///////////// proj_central_scale //////////////////////
//
// Central scale for projection.
//
// This applies to POLAR_STEREO, OBLIQUE_STEREO and TRANSVERSE_MERCATOR 
//   projections.
//
// Type: double

proj_central_scale = 1;

///////////// proj_tangent_lat ////////////////////////
//
// Projection tangent latitude (deg).
//
// This applies to OBLIQUE_STEREO only.
//
// Type: double

proj_tangent_lat = 0;

///////////// proj_tangent_lon ////////////////////////
//
// Projection tangent longitude (deg).
//
// This applies to OBLIQUE_STEREO and POLAR_STEREO.
//
// Type: double

proj_tangent_lon = 0;

///////////// proj_pole_is_north //////////////////////
//
// Flag indicating stereogtraphic is over the NORTH pole.
//
// This applies to POLAR_STEREO. If false, the projection is over the 
//   south pole.
//
// Type: boolean

proj_pole_is_north = TRUE;

///////////// proj_persp_radius ///////////////////////
//
// Radius of perspective point (km).
//
// This applies to VERT_PERSP.
//
// Type: double

proj_persp_radius = 35786;

///////////// proj_false_northing /////////////////////
//
// Projection false northing correction.
//
// Occasionally, this is added to the Y coordinate so that all 
//   coordinates are positive. Normally 0. As an alternative to 
//   false_northing and false_easting, you can set the offset_latitude and 
//   offset_longitude.
//
// Type: double

proj_false_northing = 0;

///////////// proj_false_easting //////////////////////
//
// Projection false easting correction.
//
// Occasionally, this is added to the X coordinate so that all 
//   coordinates are positive. Normally 0.
//
// Type: double

proj_false_easting = 0;

///////////// proj_set_offset_origin //////////////////
//
// Do you want to specify an offset origin using lat/lon instead of 
//   false_northing and false_easting?.
//
// If true, set proj_offset_origin_latitude and 
//   proj_offset_origin_longitude.
//
// Type: boolean

proj_set_offset_origin = FALSE;

///////////// proj_offset_origin_latitude /////////////
//
// Latitude of offset origin.
//
// See proj_set_offset_origin.
//
// Type: double

proj_offset_origin_latitude = 0;

///////////// proj_offset_origin_longitude ////////////
//
// Longitude of offset origin.
//
// See proj_set_offset_origin.
//
// Type: double

proj_offset_origin_longitude = 0;

///////////// use_cosine_correction ///////////////////
//
// Diagnostic mode used to ignore the Elevation angle on polar data 
//   (radars, etc).
//
// Set to FALSE to display all polar grids as if the elevation were 
//   always 0.0 degrees. This allows one to view radial data near 90 
//   degrees elevation.
//
// Type: boolean

use_cosine_correction = TRUE;

///////////// report_clicks_in_degM_and_nm ////////////
//
// Report click position in degrees magnetic and nautical miles.
//
// By default distance are in km and bearings in deg T.
//
// Type: boolean

report_clicks_in_degM_and_nm = FALSE;

///////////// magnetic_variation_deg //////////////////
//
// Set the magnetic variation for the display location.
//
// Variation is true minus magnetic.
//
// Type: double

magnetic_variation_deg = 0;

//======================================================================
//
// </PROJECTION>.
//
//======================================================================
 
//======================================================================
//
// <MOVIE_LOOPS>.
//
//======================================================================
 
///////////// n_movie_frames //////////////////////////
//
// The number of frames in the movie at startup.
//
// The movie duration is the number of frames multiplied by the frame 
//   duration.
//
// Type: int

n_movie_frames = 12;

///////////// frame_interval_secs /////////////////////
//
// Interval between movie time frames (secs).
//
// The data for each frame is requested for the center of the frame.
//
// Type: double

frame_interval_secs = 300;

///////////// max_frame_interval_secs /////////////////
//
// Max interval between movie time frames (secs).
//
// Type: double

max_frame_interval_secs = 3600;

///////////// temporal_rounding ///////////////////////
//
// Set times to the nearest value divisible by the number of seconds.
//
// Type: int

temporal_rounding = 300;

///////////// movie_on ////////////////////////////////
//
// Determine whether to start with movie looping on.
//
// Set to TRUE to start up in movie-on mode, FALSE = off.
//
// Type: boolean

movie_on = FALSE;

///////////// loop_delay_msecs ////////////////////////
//
// Set the delay at the end of the movie loop in (msec).
//
// Type: int

loop_delay_msecs = 2000;

///////////// movie_dwell_msecs ///////////////////////
//
// Set the dwell of the movie loop (msec dwell per frame).
//
// Minimum val: 30
// Maximum val: 9999
//
// Type: int

movie_dwell_msecs = 75;

///////////// movie_min_dwell_msecs ///////////////////
//
// Minimum dwell of the movie loop (msec per frame).
//
// This yields the fastest movie rate.
//
// Type: int

movie_min_dwell_msecs = 30;

///////////// movie_max_dwell_msecs ///////////////////
//
// Maximum dwell of the movie loop (msec per frame).
//
// This yields the slowest movie rate.
//
// Type: int

movie_max_dwell_msecs = 500;

///////////// reset_frames ////////////////////////////
//
// Forces reload of all data every time the movie frames rotate one old 
//   frame out and generate a new frame.
//
// If TRUE, this will slow down data gathering for movie rendering.
//
// Type: boolean

reset_frames = FALSE;

///////////// movie_magnify_factor ////////////////////
//
// When a Forecast hour is chosen, magnify the time interval by this 
//   factor.
//
// This adjusts the frame time_interval to be more appropriate for 
//   forecast (model) data, which is often output on a more coarse time 
//   interval. When 'Now' is selected the magnification is undone.
//
// Type: double

movie_magnify_factor = 1;

///////////// moviestart_time_format //////////////////
//
// Set the format for the time string in the movie start time text field 
//   of the movie pop-up window.
//
// This is set separately from the general time string because you 
//   generally don't want any extra text and want to display things in an 
//   order that allows for easier entry.
//
// Type: string

moviestart_time_format = "%Y/%m/%d %H:%M:%S";

///////////// climo_mode //////////////////////////////
//
// Options are 'regular', 'daily' or 'yearly'.
//
// Users can do this interactively by entering '1 yr' or '1 day' in the 
//   movie control panel interval text widget. CIDD will recognize these 
//   special 'intervals' and will do the right thing.
//
// Type: string

climo_mode = "regular";

///////////// climo_max_time_span_days ////////////////
//
// Maximum number of days over which to request time lists.
//
// If the epoch exceeds this number of days, then no time list requests 
//   will be made. Time lists requests spanning many years can take too 
//   long.
//
// Type: int

climo_max_time_span_days = 365;

///////////// climo_frame_span_mins ///////////////////
//
// Span in minutes a frame covers in Climo mode.
//
// The time_interval will be either '1 day' or '1 year'.
//
// Type: double

climo_frame_span_mins = 10;

///////////// redraw_interval /////////////////////////
//
// Number of milliseconds between checks for images needing redrawn.
//
// Set this lower on faster hardware - Recommended 50-250. This sets the 
//   ultimate speed of the movie looping.
//
// Type: int

redraw_interval = 100;

//======================================================================
//
// </MOVIE_LOOPS>.
//
//======================================================================
 
//======================================================================
//
// <ZOOM_DOMAINS>.
//
//======================================================================
 
//======================================================================
//
// Zoom views.
//
// These are the pre-defined zoom levels.
//
//======================================================================
 
///////////// zoom_levels /////////////////////////////
//
// Pre-defined zoom levels.
//
// /nlabel: label in GUI for selecting zoom level. /nmin_x: X value of 
//   SW corner./nmin_y: Y value of SW corner./nmax_x: X value of NE 
//   corner./nmax_y: Y value of NE corner./n.
//
// Type: struct
//   typedef struct {
//      string label;
//      double min_x;
//      double min_y;
//      double max_x;
//      double max_y;
//   }
//
// 1D array - variable length.

zoom_levels = {
  {
    label = "100km",
    min_x = -100,
    min_y = -100,
    max_x = 100,
    max_y = 100
  }
  ,
  {
    label = "200km",
    min_x = -200,
    min_y = -200,
    max_x = 200,
    max_y = 200
  }
  ,
  {
    label = "300km",
    min_x = -300,
    min_y = -300,
    max_x = 300,
    max_y = 300
  }
};

///////////// start_zoom_label ////////////////////////
//
// Label of zoom level on which to start.
//
// This specifies which zoom level is to be used when the display 
//   starts.
//
// Type: string

start_zoom_label = "100km";

///////////// zoom_limits_in_latlon ///////////////////
//
// The units of the zoom limits are in deg lat/lon.
//
// Type: boolean

zoom_limits_in_latlon = FALSE;

///////////// num_cache_zooms /////////////////////////
//
// The number of Cached images for zooms.
//
// Type: int

num_cache_zooms = 1;

///////////// min_zoom_threshold //////////////////////
//
// Minimum distance to zoom into to in KM.
//
// Won't allow the user to define custom zooms small than this size 
//   (along the longest edge).
//
// Type: double

min_zoom_threshold = 5;

//======================================================================
//
// Zoom domain limits.
//
// Overlays are clipped to this domain and pan/moves cannot exceed these 
//   edge limits. Note: CIDD does not pan on the outermost domain.
//
// Note: for Lat/Lon Domains, Choose 0-360, -90+90. to get whole earth.
//
// One can also choose Longitude range -180 to 180, -90 to 270, etc.
// For whole earth views, aspect ration 1.0,  set the outer most domain 
//   to -180 to 180 and -180 to 180. Otherwise, set the aspect ratio to 
//   2.0 and use -180 to 180 and -90 to 90.
//
//======================================================================
 
///////////// domain_limit_min_x //////////////////////
//
// Minimum X for outer domain.
//
// Type: double

domain_limit_min_x = -10000;

///////////// domain_limit_max_x //////////////////////
//
// Maximum X for outer domain.
//
// Type: double

domain_limit_max_x = 10000;

///////////// domain_limit_min_y //////////////////////
//
// Minimum Y for outer domain.
//
// Type: double

domain_limit_min_y = -10000;

///////////// domain_limit_max_y //////////////////////
//
// Maximum Y for outer domain.
//
// Type: double

domain_limit_max_y = 10000;

//======================================================================
//
// </ZOOM_DOMAINS>.
//
//======================================================================
 
//======================================================================
//
// <GUI>.
//
//======================================================================
 
///////////// num_field_menu_cols /////////////////////
//
// Set this parameter to force the field menu pop-up to this many 
//   columns.
//
// Type: int

num_field_menu_cols = 0;

///////////// one_click_rhi ///////////////////////////
//
// This parameter allows the user to define a route/rhi with one mouse 
//   click and drag.
//
// When set to TRUE, disallows multi way point cross sections. RHI are 
//   defined by clicking right mouse near the radar origin and dragging 
//   away from the radar along the desired  azimuth and releasing.
//
// Type: boolean

one_click_rhi = FALSE;

///////////// rotate_coarse_adjust ////////////////////
//
// CIDD uses the number pad keys 7,9,4,6,1,3 to rotate the RHI by +/- 
//   these amounts (deg).
//
// 7-9 is coarse, 4-6 is medium, and 1-3 is fine.
//
// Type: double

rotate_coarse_adjust = 6;

///////////// rotate_medium_adjust ////////////////////
//
// Adjust RHI azimuth in medium mode.
//
// Keys 4-6.
//
// Type: double

rotate_medium_adjust = 2;

///////////// rotate_fine_adjust //////////////////////
//
// Adjust RHI azimuth in fine mode.
//
// Keys 1-3.
//
// Type: double

rotate_fine_adjust = 0.5;

///////////// disable_pick_mode ///////////////////////
//
// Disable pick feature.
//
// Type: boolean

disable_pick_mode = TRUE;

///////////// close_popups ////////////////////////////
//
// Close CIDD's pop ups When the main window is closed.
//
// Set this to FALSE if you don't want CIDD to close its pop ups when 
//   switching between virtual desktops.
//
// Type: boolean

close_popups = FALSE;

///////////// status_info_file ////////////////////////
//
// System NO-Data Status/Info File.
//
// Will check for updates to this file, if it exists, and will replace 
//   the no_data_message with the text from this file. Leave blank if no 
//   file is to be checked.
//
// Type: string

status_info_file = "";

///////////// enable_status_window ////////////////////
//
// Enable the status window.
//
// If FALSE, no status window is displayed.
//
// Type: boolean

enable_status_window = FALSE;

///////////// report_clicks_in_status_window //////////
//
// Report clicks in the status window.
//
// By default distance are in km and bearings in deg T.
//
// Type: boolean

report_clicks_in_status_window = FALSE;

//======================================================================
//
// Analog clock.
//
//======================================================================
 
///////////// show_clock //////////////////////////////
//
// Set TRUE for displaying an analog clock in the upper right hand 
//   corner of the image.
//
// Type: boolean

show_clock = FALSE;

///////////// draw_clock_local ////////////////////////
//
// Set TRUE for clock in local time.
//
// Otherwise UTC.
//
// Type: boolean

draw_clock_local = FALSE;

///////////// use_local_timestamps ////////////////////
//
// TRUE: time stamps are local. FALSE: time stamps are UTC.
//
// All Input time widgets expect UTC when FALSE, local times when set 
//   TRUE.
//
// Type: boolean

use_local_timestamps = FALSE;

///////////// label_font_size /////////////////////////
//
// Basic font size for labels (pixels).
//
// Some of the labels are scaled relative to this size.
//
// Type: int

label_font_size = 12;

///////////// range_ring_label_font_size //////////////
//
// Font size for labels on range rings (pixels).
//
// Type: int

range_ring_label_font_size = 8;

///////////// click_cross_size ////////////////////////
//
// Size of cross at click point (pixels).
//
// Size of cross drawn at click point, to select data.
//
// Type: int

click_cross_size = 11;

///////////// click_cross_line_width //////////////////
//
// Line width for click cross.
//
// Type: int

click_cross_line_width = 1;

///////////// vlevel_selector_width ///////////////////
//
// Width of vlevel selector (pixels).
//
// Type: int

vlevel_selector_width = 90;

///////////// vlevel_selector_top_margin //////////////
//
// Height of top margin in VLEVEL_SELECTOR mode (pixels).
//
// Titles go in the top margin.
//
// Type: int

vlevel_selector_top_margin = 70;

///////////// vlevel_selector_bottom_margin ///////////
//
// Height of bottom margin in VLEVEL_SELECTOR mode (pixels).
//
// Time scale goes in the bottom margin.
//
// Type: int

vlevel_selector_bottom_margin = 10;

///////////// vlevel_selector_left_margin /////////////
//
// Width of left margin in VLEVEL_SELECTOR mode (pixels).
//
// Height scale goes in the left margin.
//
// Type: int

vlevel_selector_left_margin = 30;

///////////// vlevel_selector_right_margin ////////////
//
// Width of right margin in VLEVEL_SELECTOR mode (pixels).
//
// Height scale goes in the right margin.
//
// Type: int

vlevel_selector_right_margin = 4;

///////////// vlevel_selector_axis_tick_len ///////////
//
// Length of ticks on axes (pixels).
//
// Type: int

vlevel_selector_axis_tick_len = 10;

///////////// vlevel_selector_n_ticks_ideal ///////////
//
// Ideal number of ticks on axes.
//
// Type: int

vlevel_selector_n_ticks_ideal = 16;

///////////// vlevel_selector_axis_text_margin ////////
//
// Margin around some text (pixels).
//
// Type: int

vlevel_selector_axis_text_margin = 5;

///////////// vlevel_selector_title_font_size /////////
//
// Font size of center title (pixels).
//
// Type: int

vlevel_selector_title_font_size = 10;

///////////// vlevel_selector_labels_font_size ////////
//
// Font size of axis labels in vlevel_selector (pixels).
//
// Type: int

vlevel_selector_labels_font_size = 10;

///////////// vlevel_selector_background_color ////////
//
// Color of background in vlevel selector.
//
// Type: string

vlevel_selector_background_color = "darkslateblue";

///////////// vlevel_selector_title_color /////////////
//
// Color of titles in vlevel selector.
//
// Type: string

vlevel_selector_title_color = "orange";

///////////// vlevel_selector_axis_color //////////////
//
// Color of axes in vlevel selector.
//
// Type: string

vlevel_selector_axis_color = "white";

///////////// vlevel_selector_labels_color ////////////
//
// Color of labels in vlevel_selector.
//
// Type: string

vlevel_selector_labels_color = "white";

///////////// vlevel_selector_marker_color ////////////
//
// Color of selection marker in vlevel selector.
//
// Type: string

vlevel_selector_marker_color = "orange";

///////////// vlevel_selector_data_values_color ///////
//
// Color of data values in vlevel selector.
//
// Type: string

vlevel_selector_data_values_color = "cyan";

//======================================================================
//
// </GUI>.
//
//======================================================================
 
//======================================================================
//
// <WINDOWS>.
//
//======================================================================
 
///////////// horiz_window_x_pos //////////////////////
//
// Startup X for main horizontal window (pixels).
//
// This is relative to the top left corner of the screen, which is 
//   (0,0). In screen coordinates x is positive downwards.
//
// Type: int

horiz_window_x_pos = 0;

///////////// horiz_window_y_pos //////////////////////
//
// Startup Y for main horizontal window (pixels).
//
// This is relative to the top left corner of the screen, which is 
//   (0,0). In screen coordinates y is positive to the right.
//
// Type: int

horiz_window_y_pos = 0;

///////////// horiz_plot_width ////////////////////////
//
// Startup width of horizontal plot (pixels).
//
// This is for the plot only. It does not include color scale width.
//
// Type: int

horiz_plot_width = 1000;

///////////// horiz_plot_height ///////////////////////
//
// Startup height of horizontal plot (pixels).
//
// Type: int

horiz_plot_height = 1000;

///////////// horiz_color_scale_width /////////////////
//
// Width of color scale (pixels).
//
// Type: int

horiz_color_scale_width = 40;

///////////// vert_window_x_pos ///////////////////////
//
// Startup X for vertical view window (pixels).
//
// This is relative to the top left corner of the screen, which is 
//   (0,0). In screen coordinates x is positive downwards. If -1 the 
//   position will be automatically determined.
//
// Type: int

vert_window_x_pos = -1;

///////////// vert_window_y_pos ///////////////////////
//
// Startup Y for vertical view window (pixels).
//
// This is relative to the top left corner of the screen, which is 
//   (0,0). In screen coordinates y is positive to the right. If -1 the 
//   position will be automatically determined.
//
// Type: int

vert_window_y_pos = -1;

///////////// vert_plot_width /////////////////////////
//
// Startup width of vertical plot (pixels).
//
// This is for the plot only. It does not include color scale width.
//
// Type: int

vert_plot_width = 1000;

///////////// vert_plot_height ////////////////////////
//
// Startup height of vertical plot (pixels).
//
// Type: int

vert_plot_height = 600;

///////////// horiz_window_min_width //////////////////
//
// Minimum width of main window (pixels).
//
// The user cannot shrink the main window smaller than this.
//
// Type: int

horiz_window_min_width = 600;

///////////// horiz_window_min_height /////////////////
//
// Minimum height of main window (pixels).
//
// The user cannot shrink the main window smaller than this.
//
// Type: int

horiz_window_min_height = 400;

///////////// vert_window_min_width ///////////////////
//
// Minimum width of vertical window (pixels).
//
// The user cannot shrink the vertical window smaller than this.
//
// Type: int

vert_window_min_width = 600;

///////////// vert_window_min_height //////////////////
//
// Minimum height of vertical window (pixels).
//
// The user cannot shrink the vertical window smaller than this.
//
// Type: int

vert_window_min_height = 400;

//======================================================================
//
// Vertical Range and Resolution - Establishes a vertical coordinate 
//   system for the cross sectional imagery.
//
//  All data must map into this range for it to be visible.
// 	min_ht is value nearest the ground - Plotted at the bottom.
// 	max_ht is the value furtherest from the ground - Plotted at the top.
//
// Units are ignored and no inter conversions or re-mappings are 
//   performed.
//
// Returned cross sections are are often km, but could be sigma, 
//   pressure or degrees elevation.
//
// Examples:
// 	Sigma : min_ht = 1.0, max_ht = 0.0, ht_interval = .1
// 	Pressure : min_ht = 1100.0, max_ht = 100.0, ht_interval = -100
// 	Radial Radar:  min_ht = 0.0 max_ht = 25.0, ht_interval = 1.0.
//
//======================================================================
 
///////////// min_ht //////////////////////////////////
//
// Minimum ht of cross section.
//
// Type: double

min_ht = 0;

///////////// max_ht //////////////////////////////////
//
// Maximum ht of cross section.
//
// Type: double

max_ht = 30;

///////////// start_ht ////////////////////////////////
//
// Starting height of horizontal view.
//
// Type: double

start_ht = 0;

//======================================================================
//
// </WINDOWS>.
//
//======================================================================
 
//======================================================================
//
// <HORIZ_VIEW>.
//
//======================================================================
 
///////////// label_time_format ///////////////////////
//
// Set the format for the time strings.
//
// See 'man strftime' for format options. Can add additional text as 
//   part of the Time string.
//
// Type: string

label_time_format = "%Y/%m/%d %H:%M:%S";

///////////// frame_range_time_format /////////////////
//
// Set the format for the time strings in the frame range text fields.
//
// Type: string

frame_range_time_format = "%H:%M";

///////////// layer_legends_on ////////////////////////
//
// Plot a Legend for each Grid overlay.
//
// Type: boolean

layer_legends_on = TRUE;

///////////// cont_legends_on /////////////////////////
//
// Plot a Legend for each Contour overlay.
//
// Type: boolean

cont_legends_on = TRUE;

///////////// wind_legends_on /////////////////////////
//
// Plot a Legend for each Wind overlay.
//
// Type: boolean

wind_legends_on = TRUE;

///////////// display_labels //////////////////////////
//
// Switch to turn off all data labels on the display.
//
// Type: boolean

display_labels = TRUE;

///////////// display_ref_lines ///////////////////////
//
// Switch to turn on/off Height, Route and Wind Scale reference lines.
//
// Type: boolean

display_ref_lines = TRUE;

///////////// horiz_top_margin ////////////////////////
//
// Height of top margin (pixels).
//
// Size of top margin for horiz window.
//
// Type: int

horiz_top_margin = 20;

///////////// horiz_bot_margin ////////////////////////
//
// Height of bottom margin (pixels).
//
// Size of bottom margin for horiz window.
//
// Type: int

horiz_bot_margin = 20;

///////////// horiz_left_margin ///////////////////////
//
// Width of left margin (pixels).
//
// Size of left margin for horiz window.
//
// Type: int

horiz_left_margin = 20;

///////////// horiz_right_margin //////////////////////
//
// Width of right margin (pixels).
//
// Size of right margin for horiz window.
//
// Type: int

horiz_right_margin = 6;

///////////// horiz_title_text_margin /////////////////
//
// Width of title text margin (pixels).
//
// Size of title test margin for horiz window.
//
// Type: int

horiz_title_text_margin = 6;

///////////// horiz_legend_text_margin ////////////////
//
// Width of legend text margin (pixels).
//
// Size of legend test margin for horiz window.
//
// Type: int

horiz_legend_text_margin = 5;

///////////// horiz_legend_color //////////////////////
//
// Color for legends in horizontal plot.
//
// Type: string

horiz_legend_color = "white";

///////////// horiz_axis_text_margin //////////////////
//
// Width of axis text margin (pixels).
//
// Size of axis test margin for horiz window.
//
// Type: int

horiz_axis_text_margin = 5;

///////////// horiz_axis_tick_len /////////////////////
//
// Length of ticks on axes (pixels).
//
// Type: int

horiz_axis_tick_len = 6;

///////////// horiz_n_ticks_ideal /////////////////////
//
// Ideal number of ticks on axes.
//
// Type: int

horiz_n_ticks_ideal = 10;

///////////// horiz_title_font_size ///////////////////
//
// Font size of center title (pixels).
//
// Type: int

horiz_title_font_size = 12;

///////////// horiz_axis_label_font_size //////////////
//
// Font size of axis labels in horiz view (pixels).
//
// Type: int

horiz_axis_label_font_size = 10;

///////////// horiz_tick_values_font_size /////////////
//
// Font size of tick values (pixels).
//
// Type: int

horiz_tick_values_font_size = 8;

///////////// horiz_tick_values_inside ////////////////
//
// Draw tick value labels inside the plot.
//
// If FALSE the value labels will be drawn in the margins.
//
// Type: boolean

horiz_tick_values_inside = FALSE;

///////////// horiz_legend_font_size //////////////////
//
// Font size of legends (pixels).
//
// Type: int

horiz_legend_font_size = 8;

///////////// horiz_title_color ///////////////////////
//
// Color for title text.
//
// Type: string

horiz_title_color = "white";

///////////// horiz_axes_color ////////////////////////
//
// Color for axes.
//
// Type: string

horiz_axes_color = "white";

///////////// horiz_grid_color ////////////////////////
//
// Color for grid (if plotted).
//
// Type: string

horiz_grid_color = "gray";

///////////// horiz_grids_on_at_startup ///////////////
//
// Set HORIZ grids overlay on at startup.
//
// Type: boolean

horiz_grids_on_at_startup = FALSE;

///////////// horiz_range_rings_on_at_startup /////////
//
// Set HORIZ range rings overlay on at startup.
//
// Type: boolean

horiz_range_rings_on_at_startup = TRUE;

///////////// horiz_azimuth_lines_on_at_startup ///////
//
// Set HORIZ azimuth lines overlay on at startup.
//
// Type: boolean

horiz_azimuth_lines_on_at_startup = TRUE;

///////////// horiz_main_legend_pos ///////////////////
//
// Position of main legend in the HORIZ plot window.
//
// This include time, field name and elevation angle.
//
// Type: enum
// Options:
//     LEGEND_TOP_LEFT
//     LEGEND_TOP_RIGHT
//     LEGEND_BOTTOM_LEFT
//     LEGEND_BOTTOM_RIGHT

horiz_main_legend_pos = LEGEND_TOP_LEFT;

///////////// horiz_override_rendering_beam_width /////
//
// Option to override the azimuth beam width for rendering.
//
// Normally Lucid determines the azimuth rendering beam width 
//   automatically. You can override this and specifcally set the azimuth 
//   beam width for rendering.
//
// Type: boolean

horiz_override_rendering_beam_width = FALSE;

///////////// horiz_rendering_beam_width //////////////
//
// Rendering beam width, if override is active.
//
// See 'horiz_override_rendering_beam_width'.
//
// Type: double

horiz_rendering_beam_width = 1;

//======================================================================
//
// </HORIZ_VIEW>.
//
//======================================================================
 
//======================================================================
//
// <VERT_VIEW>.
//
//======================================================================
 
///////////// vert_top_margin /////////////////////////
//
// Height of top margin (pixels).
//
// Size of top margin for vert section window.
//
// Type: int

vert_top_margin = 20;

///////////// vert_bot_margin /////////////////////////
//
// Height of bottom margin (pixels).
//
// Size of bottom margin for vert section window.
//
// Type: int

vert_bot_margin = 20;

///////////// vert_left_margin ////////////////////////
//
// Width of left margin (pixels).
//
// Size of left margin for vert section window.
//
// Type: int

vert_left_margin = 20;

///////////// vert_right_margin ///////////////////////
//
// Width of right margin (pixels).
//
// Size of right margin for vert section window.
//
// Type: int

vert_right_margin = 80;

///////////// vert_title_text_margin //////////////////
//
// Width of title text margin (pixels).
//
// Size of title test margin for vert window.
//
// Type: int

vert_title_text_margin = 5;

///////////// vert_legend_text_margin /////////////////
//
// Width of legend text margin (pixels).
//
// Size of legend test margin for vert window.
//
// Type: int

vert_legend_text_margin = 5;

///////////// vert_axis_text_margin ///////////////////
//
// Width of axis text margin (pixels).
//
// Size of axis test margin for vert window.
//
// Type: int

vert_axis_text_margin = 5;

///////////// vert_axis_tick_len //////////////////////
//
// Length of ticks on axes (pixels).
//
// Type: int

vert_axis_tick_len = 7;

///////////// vert_n_ticks_ideal //////////////////////
//
// Ideal number of ticks on axes.
//
// Type: int

vert_n_ticks_ideal = 7;

///////////// vert_title_font_size ////////////////////
//
// Font size of center title (pixels).
//
// Type: int

vert_title_font_size = 12;

///////////// vert_axis_label_font_size ///////////////
//
// Font size of axis labels in vert (pixels).
//
// Type: int

vert_axis_label_font_size = 10;

///////////// vert_tick_values_font_size //////////////
//
// Font size of tick values (pixels).
//
// Type: int

vert_tick_values_font_size = 8;

///////////// vert_tick_values_inside /////////////////
//
// Draw tick value labels inside the plot.
//
// If FALSE the value labels will be drawn in the margins.
//
// Type: boolean

vert_tick_values_inside = FALSE;

///////////// vert_legend_font_size ///////////////////
//
// Font size of legends (pixels).
//
// Type: int

vert_legend_font_size = 8;

///////////// vert_title_color ////////////////////////
//
// Color for title text.
//
// Type: string

vert_title_color = "white";

///////////// vert_axes_color /////////////////////////
//
// Color for axes.
//
// Type: string

vert_axes_color = "white";

///////////// vert_grid_color /////////////////////////
//
// Color for grid (if plotted).
//
// Type: string

vert_grid_color = "white";

///////////// vert_window_width ///////////////////////
//
// Startup width of VERT window (pixels).
//
// Type: int

vert_window_width = 500;

///////////// vert_window_height //////////////////////
//
// Startup height of VERT window (pixels).
//
// Type: int

vert_window_height = 500;

///////////// vert_window_start_x /////////////////////
//
// Startup X for VERT window (pixels).
//
// Type: int

vert_window_start_x = 1100;

///////////// vert_window_start_y /////////////////////
//
// Startup Y for VERT window (pixels).
//
// Type: int

vert_window_start_y = 0;

///////////// vert_top_margin2 ////////////////////////
//
// Height of top margin in VERT mode (pixels).
//
// Titles go in the top margin.
//
// Type: int

vert_top_margin2 = 20;

///////////// vert_bottom_margin //////////////////////
//
// Height of bottom margin in VERT mode (pixels).
//
// Time scale goes in the bottom margin.
//
// Type: int

vert_bottom_margin = 20;

///////////// vert_left_margin2 ///////////////////////
//
// Width of left margin in VERT mode (pixels).
//
// Height scale goes in the left margin.
//
// Type: int

vert_left_margin2 = 20;

///////////// vert_right_margin2 //////////////////////
//
// Width of right margin in VERT mode (pixels).
//
// Height scale goes in the right margin.
//
// Type: int

vert_right_margin2 = 20;

///////////// vert_label_font_size ////////////////////
//
// Font size for labels on range rings (pixels).
//
// Type: int

vert_label_font_size = 8;

///////////// vert_text_margin ////////////////////////
//
// Margin around some text (pixels).
//
// Type: int

vert_text_margin = 5;

///////////// vert_max_height_km //////////////////////
//
// Max height of data in VERT window (km).
//
// Type: double

vert_max_height_km = 25;

///////////// vert_color_scale_width //////////////////
//
// Width of color scale for VERT window (pixels).
//
// Type: int

vert_color_scale_width = 40;

///////////// vert_grids_on_at_startup ////////////////
//
// Set VERT grids overlay on at startup.
//
// Type: boolean

vert_grids_on_at_startup = TRUE;

///////////// vert_range_rings_on_at_startup //////////
//
// Set VERT range rings overlay on at startup.
//
// Type: boolean

vert_range_rings_on_at_startup = TRUE;

///////////// vert_elevation_lines_on_at_startup //////
//
// Set VERT elevation lines overlay on at startup.
//
// Type: boolean

vert_elevation_lines_on_at_startup = FALSE;

///////////// vert_main_legend_pos ////////////////////
//
// Position of main legend in the VERT plot window.
//
// This include time, field name and elevation angle.
//
// Type: enum
// Options:
//     LEGEND_TOP_LEFT
//     LEGEND_TOP_RIGHT
//     LEGEND_BOTTOM_LEFT
//     LEGEND_BOTTOM_RIGHT

vert_main_legend_pos = LEGEND_TOP_LEFT;

///////////// vert_beam_queue_size ////////////////////
//
// Size of the queue for VERT beams.
//
// After the queue reaches this size, older beams are discarded.
//
// Type: int

vert_beam_queue_size = 360;

///////////// vert_override_rendering_beam_width //////
//
// Option to override the azimuth beam width for rendering.
//
// Normally Lucid determines the azimuth rendering beam width 
//   automatically. You can override this and specifcally set the azimuth 
//   beam width for rendering.
//
// Type: boolean

vert_override_rendering_beam_width = FALSE;

///////////// vert_rendering_beam_width ///////////////
//
// Rendering beam width, if override is active.
//
// See 'vert_override_rendering_beam_width'.
//
// Type: double

vert_rendering_beam_width = 1;

//======================================================================
//
// </VERT_VIEW>.
//
//======================================================================
 
//======================================================================
//
// <COLORS>.
//
//======================================================================
 
///////////// foreground_color ////////////////////////
//
// Legends, scales.
//
// Type: string

foreground_color = "white";

///////////// background_color ////////////////////////
//
// Background of images.
//
// Type: string

background_color = "black";

///////////// background_color2 ///////////////////////
//
// Color of main display background.
//
// Type: string

background_color2 = "black";

///////////// text_color //////////////////////////////
//
// Color of text annotation in main display.
//
// Type: string

text_color = "white";

///////////// grid_and_range_ring_color ///////////////
//
// Color of grids and range rings.
//
// Type: string

grid_and_range_ring_color = "white";

///////////// click_cross_color ///////////////////////
//
// Color of cross at click point.
//
// Type: string

click_cross_color = "cyan";

///////////// margin_color ////////////////////////////
//
// Background of margins.
//
// Type: string

margin_color = "black";

///////////// out_of_range_color //////////////////////
//
// Render values outside the data range of the color scale.
//
// Type: string

out_of_range_color = "transparent";

///////////// route_path_color ////////////////////////
//
// Color of the cross section reference line.
//
// Type: string

route_path_color = "yellow";

///////////// time_axis_color /////////////////////////
//
// Text in the time axis margins.
//
// Type: string

time_axis_color = "pink";

///////////// time_frame_color ////////////////////////
//
// A solid rectangle showing the movie frame extent.
//
// Type: string

time_frame_color = "gray50";

///////////// height_axis_color ///////////////////////
//
// The text in the height selector margin.
//
// Type: string

height_axis_color = "pink";

///////////// height_indicator_color //////////////////
//
// A solid rectangle showing the height extent of the data plane.
//
// Type: string

height_indicator_color = "gray50";

///////////// range_ring_color ////////////////////////
//
// Range rings and azimuth lines.
//
// Type: string

range_ring_color = "grey";

///////////// missing_data_color //////////////////////
//
// Set to 'transparent' to avoid having these plotted. .
//
// Otherwise, these data will be plotted in the indicated color.
//
// Type: string

missing_data_color = "transparent";

///////////// bad_data_color //////////////////////////
//
// Set to 'transparent' to avoid having these plotted. .
//
// Otherwise, these data will be plotted in the indicated color.
//
// Type: string

bad_data_color = "transparent";

///////////// epoch_indicator_color ///////////////////
//
// Time Control (Movie) Pop-up Colors.
//
// Type: string

epoch_indicator_color = "orange";

///////////// now_time_color //////////////////////////
//
// Color of current time tick.
//
// Type: string

now_time_color = "red";

///////////// time_tick_color /////////////////////////
//
// Color of time ticks - main grid.
//
// Type: string

time_tick_color = "yellow";

///////////// time_tick_colors ////////////////////////
//
// List of colors for time ticks for symbolic products.
//
// The time ticks are drawn in order, from top down, in the time control 
//   GUI.
//
// Type: string
// 1D array - variable length.

time_tick_colors = {
 "cyan",
 "yellow",
 "magenta",
 "green",
 "red",
 "blue"
};

//======================================================================
//
// </COLORS>.
//
//======================================================================
 
//======================================================================
//
// <OVERLAYS>.
//
//======================================================================
 
//======================================================================
//
// Legends displayed within the plot window.
//
// A legend can be displayed for each data layer. Explicitly set the 
//   Label start coords, and delta Y. If left unset, legends start 
//   relative to the top and left margins.
//
//======================================================================
 
//======================================================================
//
// Draw range rings and azimuth lines.
//
// These apply to radars only.
//
//======================================================================
 
///////////// range_rings /////////////////////////////
//
// Turn range rings on/off.
//
// TRUE means on - i.r. plot range rings.
//
// Type: boolean

range_rings = FALSE;

///////////// range_ring_spacing //////////////////////
//
// Spacing between range rings (km).
//
// Type: double

range_ring_spacing = 50;

///////////// max_ring_range //////////////////////////
//
// Maximum range ring (km).
//
// Type: double

max_ring_range = 500;

///////////// range_ring_follows_data /////////////////
//
// Plot range rings relative to radar location.
//
// We get the location from the data. If FALSE, rings are relative to 
//   plot origin.
//
// Type: boolean

range_ring_follows_data = FALSE;

///////////// range_ring_for_radar_only ///////////////
//
// Only plot range rings for radar data sets.
//
// TRUE turns off rings for non-radar data sets.
//
// Type: boolean

range_ring_for_radar_only = TRUE;

///////////// domain_follows_data /////////////////////
//
// Plot domain moves with origin of the data set.
//
// Shift the domain limits if the data origin shifts.
//
// Type: boolean

domain_follows_data = FALSE;

///////////// range_ring_x_space //////////////////////
//
// Spacing in x for range ring labels (pixels).
//
// Type: int

range_ring_x_space = 50;

///////////// range_ring_y_space //////////////////////
//
// Spacing in y for range ring labels (pixels).
//
// Type: int

range_ring_y_space = 15;

///////////// range_ring_labels ///////////////////////
//
// Plot range ring labels.
//
// Label the range for each ring.
//
// Type: boolean

range_ring_labels = TRUE;

///////////// azimuth_lines ///////////////////////////
//
// Draw azimuth lines for a radar location.
//
// These complement range rings, to provide guidance on azimuths for 
//   radar gates.
//
// Type: boolean

azimuth_lines = FALSE;

///////////// azimuth_interval ////////////////////////
//
// Interval for azimuth lines.
//
// If azimuth lines are on.
//
// Type: double

azimuth_interval = 30;

///////////// azimuth_radius //////////////////////////
//
// Max radius for azimuth lines.
//
// If azimuth lines are on.
//
// Type: double

azimuth_radius = 200;

///////////// clip_overlay_fields /////////////////////
//
// The default behavior is to render the overlay fields using the same 
//   render method as the primary field.
//
// CIDD can Render Overlay fields using filled polygons, and clip the 
//   data between some minimum and maximum. This is useful, for example, 
//   if one wants to show Radar data over +40dB overlaid on satellite 
//   imagery.
//
// Type: boolean

clip_overlay_fields = FALSE;

///////////// horiz_frame_label ///////////////////////
//
// Label in top bar of main window.
//
// Type: string

horiz_frame_label = "Lucid";

///////////// no_data_message /////////////////////////
//
// Message to display when no data is found.
//
// Type: string

no_data_message = "NO DATA FOUND (in this area at the selected time)";

//======================================================================
//
// </OVERLAYS>.
//
//======================================================================
 
//======================================================================
//
// <RENDERING>.
//
//======================================================================
 
//======================================================================
//
// Plotting contours in data fields.
//
// In the data layers section you can select contour plotting.
//
//======================================================================
 
///////////// contour_fields //////////////////////////
//
// Fields to be contoured.
//
// /nfield_name: name of field in GRIDS list. /ncolor: color for contour 
//   lines. /non_at_startup: field on when app starts./n.
//
// Type: struct
//   typedef struct {
//      string field_name;
//      string color;
//      boolean on_at_startup;
//   }
//
// 1D array - variable length.

contour_fields = {
  {
    field_name = "FzLevel",
    color = "red",
    on_at_startup = FALSE
  }
  ,
  {
    field_name = "SURF_T",
    color = "white",
    on_at_startup = TRUE
  }
};

///////////// label_contours //////////////////////////
//
// Set to TRUE to have numeric labels on line contours.
//
// Type: boolean

label_contours = TRUE;

///////////// contour_line_width //////////////////////
//
// Width of contour lines.
//
// Type: int

contour_line_width = 1;

///////////// smooth_contours /////////////////////////
//
// Apply smoothing to data grids before contouring.
//
// 0 = Off, 1 = single pass, 2 = double pass.
//
// Type: int

smooth_contours = 0;

///////////// use_alt_contours ////////////////////////
//
// Use Alternate (Mdvx) Contouring Routines.
//
// Slower - Nicer labeling - Less smooth. Warning - Does not work 
//   correctly when data and display origins are different. Works fine in 
//   lat/lon projections.
//
// Type: boolean

use_alt_contours = FALSE;

///////////// add_noise ///////////////////////////////
//
// Add 1 part in 250 Noise to help smooth contours.
//
// Type: boolean

add_noise = FALSE;

///////////// special_contour_value ///////////////////
//
// Specify special contour value.
//
// Contours at this value will have a wider line.
//
// Type: double

special_contour_value = 0;

///////////// map_bad_to_min_value ////////////////////
//
// Contour the bad value, by setting bad cells to have min value in 
//   data.
//
// Sometimes, for CONTOURING it is useful to make the assumption that 
//   the bad and/or missing values should be considered at the minimum of 
//   the dynamic range of the data. i.e. if you want bad contoured, set 
//   this to TRUE.
//
// Type: boolean

map_bad_to_min_value = FALSE;

///////////// map_missing_to_min_value ////////////////
//
// Contour the missing value, by setting missing cells to have min value 
//   in data.
//
// Sometimes, for CONTOURING it is useful to make the assumption that 
//   the missing and/or missing values should be considered at the minimum 
//   of the dynamic range of the data. i.e. if you want missing contoured, 
//   set this to TRUE.
//
// Type: boolean

map_missing_to_min_value = FALSE;

//======================================================================
//
// Overlain fields as layers.
//
// Layers are rendered in order. i.e. last layer will be on top.
//
//======================================================================
 
///////////// layer_fields ////////////////////////////
//
// Field for layers as overlays.
//
// /nfield_name: name of field in GRIDS list. /non_at_startup: field on 
//   when app starts./n.
//
// Type: struct
//   typedef struct {
//      string field_name;
//      boolean on_at_startup;
//   }
//
// 1D array - variable length.

layer_fields = {
  {
    field_name = "KCYS-DBZ",
    on_at_startup = FALSE
  }
  ,
  {
    field_name = "KPUX-DBZ",
    on_at_startup = FALSE
  }
  ,
  {
    field_name = "KGJX-DBZ",
    on_at_startup = FALSE
  }
  ,
  {
    field_name = "KGLD-DBZ",
    on_at_startup = FALSE
  }
  ,
  {
    field_name = "KLNX-DBZ",
    on_at_startup = FALSE
  }
};

//======================================================================
//
// Overall rendering order.
//
//======================================================================
 
///////////// draw_main_on_top ////////////////////////
//
// TRUE: render main field first, then layers.
//
// FALSE: render main field on top of layers.
//
// Type: boolean

draw_main_on_top = FALSE;

//======================================================================
//
// Marking click location from separate app.
//
// CIDD can cooperate with a secondary app, receiving click details via 
//   shared memo.
//
//======================================================================
 
///////////// mark_latest_click_location //////////////
//
// Option to mark latest click location from client app.
//
// Type: boolean

mark_latest_click_location = FALSE;

///////////// latest_click_mark_size //////////////////
//
// Size of marker at latest click location (pixels).
//
// Location clicked in client app.
//
// Type: int

latest_click_mark_size = 11;

///////////// image_inten /////////////////////////////
//
// Sets the relative intensity of images, relative to the overlays.
//
// Set between 0.2 and 1.0.
//
// Type: double

image_inten = 0.8;

///////////// inten_levels ////////////////////////////
//
// The number of selectable intensity levels in the slider control.
//
// Type: int

inten_levels = 32;

///////////// data_inten //////////////////////////////
//
// Sets the relative intensity of data grid colors, relative to the 
//   overlays.
//
// Type: double

data_inten = 1;

///////////// image_fill_threshold ////////////////////
//
// Sets the threshold in drawable grid points where image rendering is 
//   done by a filling method on the client, rather than by rectangles on 
//   the Xserver.
//
// Set this high if the X server is fast or the comm link to the server 
//   is slow. Set this low if the X server is slow. Typical values range 
//   from 10,000 to 100,000  Used for 'cart' style rendering.
//
// Type: int

image_fill_threshold = 120000;

///////////// dynamic_contour_threshold ///////////////
//
// This sets the threshold in grid cells when the the display will 
//   render a grid as contours or as filled rectangles.
//
// Grids containing less than the threshold cells will be rendered as 
//   filled contours. Used for 'dcont' style rendering.
//
// Type: int

dynamic_contour_threshold = 160000;

///////////// scale_units_per_km //////////////////////
//
// Set the scale factor and label for Range rings and Distance scales.
//
// Type: double

scale_units_per_km = 0.539593;

///////////// scale_units_label ///////////////////////
//
// Set the units labels.
//
// km, nm, deg.
//
// Type: string

scale_units_label = "km";

//======================================================================
//
// </RENDERING>.
//
//======================================================================
 
//======================================================================
//
// <SYMBOLIC_PRODUCTS>.
//
//======================================================================
 
///////////// products_on /////////////////////////////
//
// Render all of the products in the overlay menu.
//
// Type: boolean

products_on = TRUE;

///////////// product_line_width //////////////////////
//
// Line width for rendering products.
//
// Type: int

product_line_width = 1;

///////////// product_font_size ///////////////////////
//
// Default font size for products.
//
// Starting size of fonts for symbolic products - from the fonts array.
//
// Type: int

product_font_size = 1;

///////////// scale_constant //////////////////////////
//
// Product scaling constant.
//
// Set this constant to determine at what zoom icons and will have a 
//   scale factor of 1.0. Default = 300. Function = log10(Constant 
//   /km_across_screen) + 1.0; Set to less than 0 to disable icon scaling.
//
// Type: double

scale_constant = 300;

///////////// product_adjustments /////////////////////
//
// Thresholds and adjustment for font sizes for products.
//
// The adjustment increases or decreases the font index. This index is 
//   used to choose the font from the fonts[] array. The thresholds are 
//   computed as units of km across the image.
//
// Type: struct
//   typedef struct {
//      double threshold;
//      int font_index_adj;
//   }
//
// 1D array - fixed length - 3 elements.

product_adjustments = {
  {
    threshold = 50,
    font_index_adj = 3
  }
  ,
  {
    threshold = 200,
    font_index_adj = 2
  }
  ,
  {
    threshold = 400,
    font_index_adj = 1
  }
};

//======================================================================
//
// <SYMBOLIC_PRODUCTS>.
//
//======================================================================
 
///////////// symprods_enabled_at_startup /////////////
//
// Enable symprods at start.
//
// If FALSE, symbolic products will not be emabled at startup. You will 
//   have to turn them on via the products menu.
//
// Type: boolean

symprods_enabled_at_startup = TRUE;

///////////// symprod_debug ///////////////////////////
//
// Debug option.
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     SYMPROD_DEBUG_OFF
//     SYMPROD_DEBUG_NORM
//     SYMPROD_DEBUG_VERBOSE

symprod_debug = SYMPROD_DEBUG_OFF;

///////////// symprod_short_requests //////////////////
//
// Gather Data Frame by Frame, Otherwise by loop span.
//
// Gathers Products valid for the current frame only - Speeds up 
//   gathering of large data sets, like METAR data.
//
// Type: boolean

symprod_short_requests = FALSE;

///////////// symprod_gzip_requests ///////////////////
//
// Request data using GZIP compression.
//
// If true, symprod data will be GZIP compressed by the server.
//
// Type: boolean

symprod_gzip_requests = FALSE;

///////////// symprod_prod_info ///////////////////////
//
// Product Source and Rendering Information Array.
//
// The fields in the structure are as follows:
//
//   menu_label: label to be used for the product in menu.
//
//   url: for retrieving the data.
//     example: 
//   spdbp:transform_executable:[param_file]//host.dom:[port]:dir1/dir2
//
//   data_type: used when querying the SPDB data server
//     (set to 0 to retrieve all data).
//
//   render_type: Select how temporal clipping is done:
//     SYMPROD_RENDER_ALL: Do no temporal clipping.
//     SYMPROD_RENDER_ALL_VALID: Render all Valid in frame
//     SYMPROD_RENDER_VALID_IN_LAST_FRAME: Render all Valid in the last 
//   frame
//     SYMPROD_RENDER_LATEST_IN_FRAME: Render the latest product of like 
//   data_types (ID)  in the frame.
//     SYMPROD_RENDER_LATEST_IN_LOOP:  Render the latest product of like 
//   data_types (ID)  valid in the movie loop.
//     SYMPROD_RENDER_FIRST_BEFORE_FRAME_TIME:  Render the latest 
//   product of like data_types (ID) before the end of frame time
//     SYMPROD_RENDER_FIRST_BEFORE_DATA_TIME:   Render the latest 
//   product of like data_types (ID  before the data time in each frame.
//     SYMPROD_RENDER_FIRST_AFTER_DATA_TIME:    Render the earliest 
//   product after the data time in each frame.
//     SYMPROD_RENDER_ALL_BEFORE_DATA_TIME:     Render all valid 
//   products before the data time in each frame.
//     SYMPROD_RENDER_ALL_AFTER_DATA_TIME:      Render all valid 
//   products after the data time in each frame.
//     SYMPROD_RENDER_GET_VALID:      Render all valid products returned 
//   with a GetValid Spdb call.
//     SYMPROD_RENDER_GET_VALID_AT_FRAME_TIME:  Render products which 
//   have not expired at the frame time
//
// Note: all comparisons are less than or equal or greater than or equal
//
//   on_by_default: True or False
//
//   minutes_allow_before: Stretch the frame time this many minutes - 
//   prior
//   minutes_allow_after: Stretch the frame time this many minutes - 
//   after
//
//   text_off_threshold: Threshold where text disappears. Use the 
//   function:
//       log10(scaling_constant/km_distance_across_screen ) + 1.0
//       Use 0.0 to disable the off feature. (always displayed)
//
//   request_data_on_zoom: Flag indicating whether to request new data 
//   for
//       this product whenever the user changes the zoom.  Normally, 
//   this
//       should be set to false for efficiency reasons.  If the products
//       to be rendered would change with a zoom change then this should 
//   be
//       set to true.
//
//   request_data_on_vert_change: Flag indicating whether to request new 
//   data
//       for this product whenever the user changes the currently 
//   displayed
//       vertical level.  Normally, this should be set to false for 
//   efficiency
//       reasons.  If the products to be rendered would change with a 
//   zoom
//       change then this should be set to true.
//
// Type: struct
//   typedef struct {
//      string menu_label;
//      string url;
//      int data_type;
//      symprod_render_type_t render_type;
//        Options:
//          SYMPROD_RENDER_ALL
//          SYMPROD_RENDER_ALL_VALID
//          SYMPROD_RENDER_VALID_IN_LAST_FRAME
//          SYMPROD_RENDER_LATEST_IN_FRAME
//          SYMPROD_RENDER_LATEST_IN_LOOP
//          SYMPROD_RENDER_FIRST_BEFORE_FRAME_TIME
//          SYMPROD_RENDER_FIRST_BEFORE_DATA_TIME
//          SYMPROD_RENDER_FIRST_AFTER_DATA_TIME
//          SYMPROD_RENDER_ALL_BEFORE_DATA_TIME
//          SYMPROD_RENDER_ALL_AFTER_DATA_TIME
//          SYMPROD_RENDER_GET_VALID
//          SYMPROD_RENDER_GET_VALID_AT_FRAME_TIME
//      boolean on_by_default;
//      double minutes_allow_before;
//      double minutes_allow_after;
//      double text_off_threshold;
//      boolean request_data_on_zoom;
//      boolean request_data_on_vert_change;
//   }
//
// 1D array - variable length.

symprod_prod_info = {
  {
    menu_label = "RHI-ticks",
    url = "spdbp:Rhi2Symprod://localhost::spdb/rhi",
    data_type = 0,
    render_type = SYMPROD_RENDER_ALL_VALID,
    on_by_default = FALSE,
    minutes_allow_before = 20,
    minutes_allow_after = 10,
    text_off_threshold = 0.4,
    request_data_on_zoom = FALSE,
    request_data_on_vert_change = FALSE
  }
};

//======================================================================
//
// </SYMBOLIC_PRODUCTS>.
//
//======================================================================
 
//======================================================================
//
// <TERRAIN>.
//
// Note: Terrain Fields must be on the same projection as the Display.
//
//======================================================================
 
///////////// terrain_active //////////////////////////
//
// Is the terrain section active?.
//
// Type: boolean

terrain_active = FALSE;

///////////// terrain_id_label ////////////////////////
//
// Label used for legends.
//
// Type: string

terrain_id_label = "Terrain";

///////////// terrain_url /////////////////////////////
//
// Used to located gridded terrain data. Set to empty string for no 
//   terrain.
//
// Terrain_URL 
//  Note example URL:
//   mdvp::static//venus::mdv/terrain&Elevation
//  Field name follows the Ampersand. Use #N for field number override   
//   Use caret: ^ as a substitute for spaces in field names.
//
// Type: string

terrain_url = "";

///////////// terrain_height_scaler ///////////////////
//
// Conversion from terrain units to local coords.
//
// Choose a scaler which converts plane height values
// Default is Hecto-feet (FL) per meter.
//
// Type: double

terrain_height_scaler = 0.0328083;

///////////// landuse_url /////////////////////////////
//
// Used to located gridded land use data.
//
// Land Use URL 
//  Note URL is of the form 
//   mdvp::[param_file]//host.dom::dir/dir&field_name
//  Field name follows the Ampersand. Use #N for field number override   
//   Use caret: ^ as a substitute for spaces in field names.
//
// Type: string

landuse_url = "mdvp:://tempest:0:topo/relief/mdv&RGBA";

///////////// landuse_colorscale //////////////////////
//
// Color lookup table for Land use.
//
// Land Use colorscale file name
//  Note: CIDD looks in the colorscale dir, then in the current dir for 
//   this file.
//
// Type: string

landuse_colorscale = "terrain.colors";

///////////// landuse_render_method ///////////////////
//
// Land Use rendering style.
//
// Use Contours only for continious data like elevation.
//
// Type: enum
// Options:
//     TERRAIN_RENDER_FILLED_CONT
//     TERRAIN_RENDER_RECTANGLES
//     TERRAIN_RENDER_DYNAMIC_CONTOURS

landuse_render_method = TERRAIN_RENDER_RECTANGLES;

///////////// landuse_active //////////////////////////
//
// Default Display state of Land Use/ Basemap.
//
// Type: boolean

landuse_active = FALSE;

///////////// terrain_earth_color1 ////////////////////
//
// Earth's skin color.
//
// Type: string

terrain_earth_color1 = "sienna";

///////////// terrain_earth_color2 ////////////////////
//
// Earth's core color.
//
// Type: string

terrain_earth_color2 = "red4";

//======================================================================
//
// </TERRAIN>.
//
//======================================================================
 
//======================================================================
//
// <WINDS>.
//
// Plotting wind vector overlays on grids.
//
//======================================================================
 
///////////// winds_on_at_startup /////////////////////
//
// Enable winds at start.
//
// If FALSE, winds will not be enabled at startup. You will have to turn 
//   them on via the winds menu.
//
// Type: boolean

winds_on_at_startup = TRUE;

///////////// winds ///////////////////////////////////
//
// Winds to be displayed.
//
// button_label: appears on the GUI. 
// legend_label: appears in the plot. 
// url: location of data or data server. Form is 
//   'protocol://host:port/dir/'
// u_field_name: U component field name. 
// v_field_name: V component field name. 
// w_field_name: W component field name. Set to 'none' if no W vectors.
// units: wind speed units. 
// line_width: line width to be used for wind vectors. 
// marker_type:
//   ARROW: centered on data point.
//   VECTOR: vertex at data point.
//   BARB: N hemisphere.
//   LABELEDBARB: labeled to nearest 10 degrees at the center - 
//   N.Hemisphere.
//   TUFT: like a piece of yarn - the least obtrusive - like a headless 
//   vector.
//   TICKVECTOR: Cross ticks at wind_time_scale_interval minutes.
//   METBARB: Calcs latitude. Works for both hemispheres and adds a 
//   label of the 10's digit off the end of the barb, ala winds aloft 
//   charts auto switching between cart and cont. Uses 
//   dynamic_contour_treshold.
//   BARB_SH: S Hemisphere.
//   LABELEDBARB_SH: labeled to nearest 10 degrees at the center - N. 
//   Hemisp.
//
// NOTE: When using arrow,vector,tuft,tickvector, the data must be in 
//   m/sec for the scaling to work correctly. For the others (Barbs), the 
//   units are arbitrary, but the flag units on the barbs will reflect the 
//   data's native units.
//
// Example: '-2,metbarb' --> width 2, off to start, using winds aloft 
//   chart barbs
// Example: '1'  --> Width 1, on to start, uses cidd.wind_marker_type: 
//   defined in main section.
//
// Type: struct
//   typedef struct {
//      string button_label;
//      string legend_label;
//      string url;
//      string u_field_name;
//      string v_field_name;
//      string w_field_name;
//      string units;
//      int line_width;
//      wind_marker_t marker_type;
//        Options:
//          WIND_ARROW
//          WIND_VECTOR
//          WIND_BARB
//          WIND_LABELEDBARB
//          WIND_TUFT
//          WIND_TICKVECTOR
//          WIND_METBARB
//          WIND_BARB_SH
//          WIND_LABELEDBARB_SH
//      string color;
//      boolean on_at_startup;
//   }
//
// 1D array - variable length.

winds = {
  {
    button_label = "GFS",
    legend_label = "GFS",
    url = "mdvp:://front.eol.ucar.edu:8080:relampago/mdv/gfs/relampago",
    u_field_name = "U",
    v_field_name = "V",
    w_field_name = "W",
    units = "m/s",
    line_width = 1,
    marker_type = WIND_ARROW,
    color = "white",
    on_at_startup = TRUE
  }
  ,
  {
    button_label = "WRF",
    legend_label = "WRF",
    url = "mdvp:://front.eol.ucar.edu:8080:relampago/mdv/wrf/relampago",
    u_field_name = "U",
    v_field_name = "V",
    w_field_name = "W",
    units = "m/s",
    line_width = 1,
    marker_type = WIND_ARROW,
    color = "yellow",
    on_at_startup = TRUE
  }
};

///////////// wind_barb_shaft_len /////////////////////
//
// Wind barb shaft length (pixels).
//
// Type: int

wind_barb_shaft_len = 33;

///////////// wind_ideal_x_vectors ////////////////////
//
// Ideal number of vectors in the x dimension.
//
// The display will space the wind vectors in x accordingly.
//
// Type: int

wind_ideal_x_vectors = 20;

///////////// wind_ideal_y_vectors ////////////////////
//
// Ideal number of vectors in the y dimension.
//
// The display will space the wind vectors in y accordingly.
//
// Type: int

wind_ideal_y_vectors = 20;

///////////// wind_head_size //////////////////////////
//
// Minimum arrow head size for wind vectors (pixels).
//
// Type: int

wind_head_size = 5;

///////////// wind_head_angle /////////////////////////
//
// Angle of arrow head for wind vectors (deg).
//
// Type: double

wind_head_angle = 45;

///////////// wind_scaler /////////////////////////////
//
// The display will space the wind vectors in x accordingly.
//
// Vectors will be drawn to show wind_scaler * wind_time_scale_interval 
//   minutes of motion.
//
// Type: int

wind_scaler = 3;

///////////// wind_time_scale_interval ////////////////
//
// inutes between steps on the wind scaling slider.
//
// Wind vector length = wind_scaler * wind_time_scale_interval *  wind 
//   velocity.
//
// Type: double

wind_time_scale_interval = 10;

///////////// wind_marker_type ////////////////////////
//
// Wind marker rendering style.
//
// See WIND section for details on rendering style.
//
// Type: enum
// Options:
//     WIND_ARROW
//     WIND_VECTOR
//     WIND_BARB
//     WIND_LABELEDBARB
//     WIND_TUFT
//     WIND_TICKVECTOR
//     WIND_METBARB
//     WIND_BARB_SH
//     WIND_LABELEDBARB_SH

wind_marker_type = WIND_ARROW;

///////////// wind_w_scale_factor /////////////////////
//
// Scale the vertical velocity by this factor, relative to the U/V. .
//
// W tends to be small compared to U/V. Scaling it up makes the 
//   rendering more meaningful.
//
// Type: double

wind_w_scale_factor = 10;

///////////// wind_units_scale_factor /////////////////
//
// Value to convert from the your reference speed units to m/sec. .
//
// i.e. wind_units_scale_factor =  m/sec / chosen units.
//
// Type: double

wind_units_scale_factor = 1;

///////////// wind_reference_speed ////////////////////
//
// Sets the length of the wind vector reference legend.
//
// The legend shows a symbos representing a wind speed of this value.
//
// Type: double

wind_reference_speed = 10;

///////////// wind_units_label ////////////////////////
//
// Select the label to be printed next to the reference bar.
//
// Type: string

wind_units_label = "m/sec";

//======================================================================
//
// </WINDS>.
//
//======================================================================
 
//======================================================================
//
// <IMAGE_GENERATION>.
//
// In creating files for the field catalog, the file name is of the 
//   form:
//
// 	category.platform.YYYYMMDDHHmm.product_name.ext
//
// The following parameters control the output directory, and the 
//   construction of the file name.
//
//======================================================================
 
///////////// images_output_dir ///////////////////////
//
// Output directory for images generated by this app.
//
// Type: string

images_output_dir = "/tmp/images/Lucid";

///////////// images_write_to_day_dir /////////////////
//
// Option to create a subdirectory for each day.
//
// Type: boolean

images_write_to_day_dir = TRUE;

///////////// images_file_name_category ///////////////
//
// Set the category string.
//
// If empty, no category will be included.
//
// Type: string

images_file_name_category = "radar";

///////////// images_file_name_platform ///////////////
//
// Set the platform string.
//
// If empty, no platform will be included.
//
// Type: string

images_file_name_platform = "NSF_NCAR_GV_HCR";

///////////// images_file_name_extension //////////////
//
// Set the extension string. This also governs the file format. It 
//   should be 'png', 'jpg', 'gif' etc.
//
// An extension is always required.
//
// Type: string

images_file_name_extension = "png";

///////////// images_file_name_delimiter //////////////
//
// Set the delimiter between the parts of the file name.
//
// NOTE: before the extension the delimited is always a period: '.'.
//
// Type: string

images_file_name_delimiter = ".";

///////////// images_include_time_part_in_file_name ///
//
// Normally the file name includes a time part: YYYYMMDDHHMMSS.
//
// If FALSE, the time part will be omitted.
//
// Type: boolean

images_include_time_part_in_file_name = TRUE;

///////////// images_include_seconds_in_time_part /////
//
// Normally the time part include the seconds: YYYYMMDDHHMMSS.
//
// If FALSE, the SS will be excluuded from the time part.
//
// Type: boolean

images_include_seconds_in_time_part = FALSE;

///////////// images_include_field_label_in_file_name /
//
// Normally the file name includes the field label (product type).
//
// If FALSE, the field label will be omitted.
//
// Type: boolean

images_include_field_label_in_file_name = TRUE;

///////////// images_include_scan_type_in_file_name ///
//
// Option to include the scan type in the image file name.
//
// If TRUE, the scan type will be added to the image file name.
//
// Type: boolean

images_include_scan_type_in_file_name = FALSE;

///////////// images_include_scan_id_in_file_name /////
//
// Option to include the scan Id in the image file name.
//
// If TRUE, the scan Id will be added to the image file name.
//
// Type: boolean

images_include_scan_id_in_file_name = FALSE;

///////////// images_write_latest_data_info ///////////
//
// Option to write latest_data_info files when an image is created.
//
// Type: boolean

images_write_latest_data_info = TRUE;

///////////// images_auto_create //////////////////////
//
// Option to create images automatically.
//
// Type: boolean

images_auto_create = FALSE;

///////////// images_creation_mode ////////////////////
//
// Mode for controlling auto image creation.
//

//
// CREATE_IMAGES_FROM_GUI: create images interactively using the GUI.
//
// CREATE_IMAGES_THEN_EXIT: for the specified start time and time span, 
//   create an output image for every field in the fields array, and then 
//   exit.
//
// CREATE_IMAGES_ON_REALTIME_SCHEDULE: wait for the scheduled time, then 
//   generate an image for each field.
//
// CREATE_IMAGES_ON_ARCHIVE_SCHEDULE: for each scheduled time between 
//   the start and end times, generate an image for each field.
//
// Type: enum
// Options:
//     CREATE_IMAGES_THEN_EXIT
//     CREATE_IMAGES_ON_REALTIME_SCHEDULE
//     CREATE_IMAGES_ON_ARCHIVE_SCHEDULE

images_creation_mode = CREATE_IMAGES_THEN_EXIT;

///////////// images_schedule_interval_secs ///////////
//
// Interval at which images are created on schedule (secs).
//
// The application waits until the interval has passed, plus any 
//   specified delay, and then creates the images.
//
// Type: int

images_schedule_interval_secs = 300;

///////////// images_schedule_delay_secs //////////////
//
// Delay between scheduled time and image creation (secs).
//
// In order to ensure that the data has been written, a delay may be 
//   provided. This allows for the writing application to complete writing 
//   the data before this application tries to access it.
//
// Type: int

images_schedule_delay_secs = 60;

///////////// images_archive_start_time ///////////////
//
// Start time for image generation in archive mode.
//
// Image generation starts with a seach at this time, and the proceeds 
//   at increments of images_schedule_interval_secs.
//
// Type: string

images_archive_start_time = "1970 01 01 00 00 00";

///////////// images_archive_end_time /////////////////
//
// End time for image generation in archive mode.
//
// Image generation is terminated when the search time exceeds this end 
//   time.
//
// Type: string

images_archive_end_time = "1970 01 01 00 00 00";

///////////// images_scan_interval_secs ///////////////
//
// Time between scans in archive mode (secs).
//
// Only applies to POLAR (HORIZ/VERT) mode, not BSCAN mode.
//
// Type: int

images_scan_interval_secs = 300;

///////////// images_set_sweep_index_list /////////////
//
// Option to specify the sweep indexes for the image generation.
//
// If TRUE, only the specified sweeps will be processed.
//
// Type: boolean

images_set_sweep_index_list = FALSE;

///////////// images_sweep_index_list /////////////////
//
// List of valid sweep indexes for image generation.
//
// See 'images_set_sweep_index_list'. Images will only be generated for 
//   the specified sweep indexes.
//
// Type: int
// 1D array - variable length.

images_sweep_index_list = {
 0,
 1,
 2
};

///////////// enable_save_image_panel /////////////////
//
// Enable the single middle button click to save image feature.
//
// Warning - will allow users shell access, or to write to other dirs.
//
// Type: boolean

enable_save_image_panel = FALSE;

///////////// image_generation_active /////////////////
//
// Is the image generation section active?.
//
// Type: boolean

image_generation_active = FALSE;

///////////// image_debug /////////////////////////////
//
// Debug option.
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     IMAGE_DEBUG_OFF
//     IMAGE_DEBUG_NORM
//     IMAGE_DEBUG_VERBOSE

image_debug = IMAGE_DEBUG_OFF;

///////////// image_generate_vsection /////////////////
//
// Generate images for specified vertical sections.
//
// If TRUE, and CIDD is in html_mode, it will generate vertical section 
//   images in addition to the normal plan view images.
//
// Type: boolean

image_generate_vsection = FALSE;

///////////// image_vsection_waypts_in_latlon /////////
//
// The specified waypts are in latlon degree units.
//
// If TRUE, the waypts are specified in lat/lon degrees. If FALSE, they 
//   are specified in (xkm, ykm) units in the current projection.
//
// Type: boolean

image_vsection_waypts_in_latlon = FALSE;

///////////// image_vsection_spec /////////////////////
//
// Vertical section information array.
//
// The fields in the structure are as follows:
//
//   vsection_label: label to be used for the specified vertical 
//   section.
//
//   n_waypts: number of waypts for specifying the vert section.
//             Normally this is 2 - for a single vertical section 
//   segment.
//
//   waypt_locs: location of way points. This is a string with pairs of 
//   points in it, with the following format: (x, y) (x, y) ..... (x, y).
//
// Type: struct
//   typedef struct {
//      string vsection_label;
//      int n_waypts;
//      string waypt_locs;
//   }
//
// 1D array - variable length.

image_vsection_spec = {
  {
    vsection_label = "RHI-north",
    n_waypts = 2,
    waypt_locs = "(0, 0) (0, 150)"
  }
};

//======================================================================
//
// Orig CIDD image generation.
//
//======================================================================
 
///////////// html_mode ///////////////////////////////
//
// Set this to TRUE to activate automatic HTML output mode.
//
// Note: image_dir MUST be set.
//
// Type: boolean

html_mode = FALSE;

///////////// run_once_and_exit ///////////////////////
//
// After this period of inactivity, the display will reset itself to a 
//   known starting point.
//
// Set this to FALSE to essentially turn off.
//
// Type: boolean

run_once_and_exit = FALSE;

///////////// transparent_images //////////////////////
//
// Set transparency of generated images.
//
// If FALSE, the normal background color is used. Set to TRUE for 
//   transparent background.
//
// Type: boolean

transparent_images = FALSE;

///////////// image_dir ///////////////////////////////
//
// Directory for output image plots.
//
// Type: string

image_dir = "/tmp/image_dir";

///////////// save_images_to_day_subdir ///////////////
//
// Save images to subdirs based on date.
//
// Type: boolean

save_images_to_day_subdir = FALSE;

///////////// image_ext ///////////////////////////////
//
// Sets the output image type.
//
// In latest version, only png type is available.
//
// Type: string

image_ext = "png";

///////////// image_horiz_prefix //////////////////////
//
// The prefix for the horiz (plan view) image file names.
//
// Type: string

image_horiz_prefix = "CP";

///////////// image_vert_prefix ///////////////////////
//
// The prefix for the vert image file names.
//
// Type: string

image_vert_prefix = "CV";

///////////// image_name_separator ////////////////////
//
// The separator used in the image file names.
//
// Type: string

image_name_separator = "_";

//======================================================================
//
// The HTML MODE Output file name is built from parts.
//
// Some of these are optional - see related parameters below. 'Prefix' + 
//   Frame_number + legend_label + zoom_level + [button_label] + [height] 
//   + frame_time + [data_generation_time] + [data_valid_time] + 
//   .'cidd.image_ext'.
//
//======================================================================
 
///////////// add_height_to_filename //////////////////
//
// Adds height to the output file name.
//
// Type: boolean

add_height_to_filename = FALSE;

///////////// add_frame_time_to_filename //////////////
//
// Adds frame time to the output file name.
//
// Type: boolean

add_frame_time_to_filename = TRUE;

///////////// add_button_name_to_filename /////////////
//
// Adds GUI button label to the output file name.
//
// Type: boolean

add_button_name_to_filename = FALSE;

///////////// add_frame_num_to_filename ///////////////
//
// Adds frame number to the output file name.
//
// Type: boolean

add_frame_num_to_filename = FALSE;

///////////// add_gen_time_to_filename ////////////////
//
// Adds model gen time to the output file name.
//
// Type: boolean

add_gen_time_to_filename = FALSE;

///////////// add_valid_time_to_filename //////////////
//
// Adds data valid time to the output file name.
//
// Type: boolean

add_valid_time_to_filename = FALSE;

//======================================================================
//
// Separate Horizontal and Vertical Image save resources.
//
// NOTE: we append the image name to the command string before 
//   executing.This allows the script to pull the name off the command 
//   line. It is often useful to place a 'rm' as the last command to 
//   remove the image after printing, conversion, etc.
//
//======================================================================
 
///////////// horiz_image_dir /////////////////////////
//
// Image directory for horiz images.
//
// Note - this is initially set to image_dir.
//
// Type: string

horiz_image_dir = "/tmp/cidd_horiz_image_dir";

///////////// horiz_image_fname ///////////////////////
//
// The default file name until reset by the user.
//
// Appends other info automatically.
//
// Type: string

horiz_image_fname = "cidd_horiz_view.png";

///////////// horiz_image_command /////////////////////
//
// Command to be run after image is created.
//
// Note that this is initially set to 'image_convert_script'.
//
// Type: string

horiz_image_command = "convert_image.csh";

///////////// vert_image_dir //////////////////////////
//
// Image directory for vert images.
//
// Note - this is initially set to image_dir.
//
// Type: string

vert_image_dir = "/tmp/cidd_vert_image_dir";

///////////// vert_image_fname ////////////////////////
//
// The default file name until reset by the user.
//
// Appends other info automatically.
//
// Type: string

vert_image_fname = "cidd_vert_view.png";

///////////// vert_image_command //////////////////////
//
// Command to be run after image is created.
//
// Note that this is initially set to 'image_convert_script'.
//
// Type: string

vert_image_command = "convert_image.csh";

///////////// output_geo_xml //////////////////////////
//
// Output an imagename.xml file which contains geo referencing 
//   information.
//
// If use_latlon_in_geo_xml is true, then the georeferencing information 
//   will be given in latitude/longitude values.
//
// Type: boolean

output_geo_xml = FALSE;

///////////// use_latlon_in_geo_xml ///////////////////
//
// Georef info is in lat/lon projection.
//
// For a lat/lon projection, information is always given in 
//   latitude/longitude. Otherwise projection information will be used.
//
// Type: boolean

use_latlon_in_geo_xml = FALSE;

///////////// movieframe_time_format //////////////////
//
// Set the format for the time fields in the names of output xwd images.
//
// See strftime(3) for options.  Default is: %H%M.
//
// Type: string

movieframe_time_format = "%H%M";

///////////// movieframe_time_mode ////////////////////
//
// Type: int

movieframe_time_mode = 0;

///////////// image_convert_script ////////////////////
//
// This script will be exec'd if set whenever an html_mode image is 
//   output.
//
// The full path name of the xwd image will be sent as the script 
//   argument. Setting horiz_image_command or cidd.horiz_image_command 
//   will override this and allow separate scripts to be called for horiz 
//   and vert images.
//
// Type: string

image_convert_script = "convert_image.csh";

///////////// print_script ////////////////////////////
//
// This script will be exec'd if set whenever a print command is issued.
//
// The full path name of the xwd image will be sent as the script 
//   argument.
//
// Type: string

print_script = "do_print.csh";

///////////// series_convert_script ///////////////////
//
// When the user selects the OutputLoop button, this script will be 
//   exec'd after the last image in a loop has been written.
//
// The arguments will be a list of each output file in the series. CIDD 
//   will prepend the cidd.image_dir to each file name which takes the 
//   form: cidd_field_name_zoom_name.xwd.
//
// Type: string

series_convert_script = "make_anim.csh";

//======================================================================
//
// </IMAGE_GENERATION>.
//
//======================================================================
 
//======================================================================
//
// <AUTO_VERT>.
//
// Predefined vertical sections for image generation.
//
//======================================================================
 
///////////// route_winds_active //////////////////////
//
// Activates route winds vert section.
//
// If FALSE, no route winds functionality is available.
//
// Type: boolean

route_winds_active = FALSE;

///////////// route_debug /////////////////////////////
//
// Set to DEBUG_NORM or DEBUG_VERBOSE for diagnostic output.
//
// Type: enum
// Options:
//     ROUTE_DEBUG_OFF
//     ROUTE_DEBUG_NORM
//     ROUTE_DEBUG_VERBOSE

route_debug = ROUTE_DEBUG_OFF;

///////////// route_font_height ///////////////////////
//
//  Maximum height in Pixels of labels.
//
// Type: int

route_font_height = 13;

///////////// route_add_waypoints_labels //////////////
//
// Default state of the add_waypoints_labels.
//
// 0 = off, 1 = on.
//
// Type: int

route_add_waypoints_labels = 1;

///////////// route_add_wind_text /////////////////////
//
// Default state of the add_wind_text labels.
//
// 0 = off, 1 = on.
//
// Type: int

route_add_wind_text = 1;

///////////// route_label_style ///////////////////////
//
// How to space the labels along the route.
//
// REGULAR_INTERVALS: use total_length / label_interval. 
//   EQUAL_DIVISIONS: use num_labels.
//
// Type: enum
// Options:
//     ROUTE_REGULAR_INTERVALS
//     ROUTE_EQUAL_DIVISIONS

route_label_style = ROUTE_REGULAR_INTERVALS;

///////////// route_label_interval ////////////////////
//
// Distance in km between winds labels.
//
// Used if label_style is set to REGULAR_INTERVALS.
//
// Type: double

route_label_interval = 55.6;

///////////// route_num_labels ////////////////////////
//
// number of route wind labels to plot along the route.
//
// Typically this should be set between 5 and 20.
//
// Minimum val: 2
// Maximum val: 100
//
// Type: int

route_num_labels = 10;

///////////// route_track_line_width //////////////////
//
// Width in pixels of the route winds track.
//
// Minimum val: 1
// Maximum val: 20
//
// Type: int

route_track_line_width = 3;

///////////// route_u_url /////////////////////////////
//
// U Wind Componet.
//
//  URL's take the form  mdvp::[paramfile]//host.dom::dir/dir&fieldname.
//
// Type: string

route_u_url = "mdvp::zoom_mds//neptune::mdv/mm5&U";

///////////// route_v_url /////////////////////////////
//
// v Wind Componet.
//
// Type: string

route_v_url = "mdvp::zoom_mds//neptune::mdv/mm5&V";

///////////// route_turb_url //////////////////////////
//
// Turbulence Index.
//
// Type: string

route_turb_url = "mdvp::d3_d4//neptune::mdv/mm5&Turb";

///////////// route_turb_low_thresh ///////////////////
//
// Value at which the turbulence is considered Low.
//
// Type: double

route_turb_low_thresh = 0.25;

///////////// route_turb_mod_thresh ///////////////////
//
// Value at which the turbulence is considered Moderate.
//
// Type: double

route_turb_mod_thresh = 0.5;

///////////// route_turb_high_thresh //////////////////
//
// Value at which the turbulence is considered High.
//
// Type: double

route_turb_high_thresh = 0.75;

///////////// route_icing_url /////////////////////////
//
// Icing Index.
//
// Type: string

route_icing_url = "mdvp::d3_d4//neptune::mdv/mm5&Icing";

///////////// route_icing_low_thresh //////////////////
//
// Value at which the icing is considered Light.
//
// Type: double

route_icing_low_thresh = 0.25;

///////////// route_icing_mod_thresh //////////////////
//
// Value at which the icing is considered Moderate.
//
// Type: double

route_icing_mod_thresh = 0.5;

///////////// route_icing_high_thresh /////////////////
//
// Value at which the icing is considered Heavy.
//
// Type: double

route_icing_high_thresh = 0.75;

///////////// route_paths /////////////////////////////
//
//  Route path strings - Format of each string isROUTE_LABEL NPOINTS  
//   ID_String Lat Lon ID_String LAT Lon ...
//
// ROUTE_LABEL will be used in the menu, 
// NPoints = Number of way points in route 
//   Followed by NPoint triplets of the following:
// ID_string -> usually a Airport or VOR 
// Lat Lon :  decimal degrees.
//
// Type: string
// 1D array - variable length.

route_paths = {
 "A-1 8 BULAN 27.0917 124.0000 OSTAR 26.3317 123.0000 SHARK 25.8333 122.3583 ANNNA 25.5717 122.0217 APU 25.1767 121.5233 HLG 24.6400 120.7833 MKG 23.5583 119.6283 ELATO 22.3333 117.5000 ",
 "M-750 12 MOLKA 26.6583 124.0000 MORSU 25.9100 123.0000 LEKOS 25.5100 122.4717 ROBIN 25.4200 122.2083 NOKAS 25.1317 121.9917 SANAS 24.8967 121.6917 PILOX 24.4150 121.0250 ANLOT 23.9417 120.5233 TOROX 23.3533 119.9083 RENOT 22.5683 118.5117 DADON 22.2767 118.0033 ENVAR 21.9917 117.5000 ",
 "G-581 7 IGURU 23.9500 124.0000 TULTO 23.3233 123.0000 HCN 21.9283 120.8433 PARPA 22.0150 120.1683 CYRUS 22.2167 118.5317 DADON 22.2767 118.0033 ELATO 22.3333 117.5000 ",
 "B-591 9 APU 25.1767 121.5233 SANAS 24.8967 121.6917 TINHO 24.3533 122.0283 TITUS 23.8283 121.8517 TACLE 22.9933 121.5867 GID 22.6733 121.4867 TUNNY 22.3600 121.2150 HCN 21.9283 120.8433 DOREX 21.0000 120.7833 ",
 "R-583 5 BORDO 26.0167 124.0000 KIKIT 25.8817 123.5917 PABSO 25.6517 122.8750 LEKOS 25.5100 122.4717 APU 25.1767 121.5233 ",
 "G-86 3 HCN 21.9283 120.8433 ANDRE 21.7783 120.1683 KAPLI 21.1667 117.5000 ",
 "B-576 3 SALMI 28.3150 124.0000 BERBA 27.0783 123.0000 APU 25.1767 121.5233 "
};

//======================================================================
//
// </AUTO_VERT>.
//
//======================================================================
 
//======================================================================
//
// <PLUGINS>.
//
// Communicating with other applications.
//
//======================================================================
 
///////////// click_point_fmq_url /////////////////////
//
// URL for click point URL.
//
// The details of the latest click point are written to an FMQ. The 
//   format is XML. You can view the FMQ using FmqMon -mode ASCII_PRINT.
//
// Type: string

click_point_fmq_url = "/tmp/fmq/click_point";

///////////// simple_command_timeout_secs /////////////
//
// Length of time to wait before killing simple external commands.
//
// Used When running single image convert scripts and driving Browsers 
//   to web pages.
//
// Type: int

simple_command_timeout_secs = 30;

///////////// complex_command_timeout_secs ////////////
//
// Length of time to wait before killing complex external commands.
//
// Used when spawning animation building script.
//
// Type: int

complex_command_timeout_secs = 180;

///////////// latest_click_mark_color /////////////////
//
// Color of mark showing latest click location.
//
// Type: string

latest_click_mark_color = "red";

///////////// click_posn_rel_to_origin ////////////////
//
// Compute click posn in coords relative to display origin.
//
// If FALSE, click posn is computed in absolute coords for the 
//   projection in use.
//
// Type: boolean

click_posn_rel_to_origin = FALSE;

///////////// latest_client_mark_color ////////////////
//
// Color of mark showing latest click of remote client.
//
// Type: string

latest_client_mark_color = "yellow";

///////////// remote_ui_url ///////////////////////////
//
// FMQ Type URL for Receiving Remote commands.
//
// Type: string

remote_ui_url = "/tmp/remoteUI";

///////////// draw_export_active //////////////////////
//
// Is drawing for export active?.
//
// Type: boolean

draw_export_active = FALSE;

///////////// draw_export_info ////////////////////////
//
// Human Drawn Products for Export Parameters.
//
//  Each Entry needs:
// ID_Label FMQ_URL Valid_Minutes Default_ID_no    ID_LABEL - This is 
//   used to designate Product types
//     FMQ_URL: example: fmqp:://host::dir/file 
//    Valid_Minutes: How many minutes the product is valid by default
//    Default_ID_no: Default Data Type (Enumerated ID)
//    Default_label: Test to place into Label field by default.
//
// Type: struct
//   typedef struct {
//      string id_label;
//      string url;
//      double valid_minutes;
//      int default_id_no;
//      string default_label;
//   }
//
// 1D array - variable length.

draw_export_info = {
  {
    id_label = "Boundry",
    url = "/tmp/cidd.fmq",
    valid_minutes = 60,
    default_id_no = 0,
    default_label = "A"
  }
  ,
  {
    id_label = "Boundry-b",
    url = "/tmp/cidd.fmq",
    valid_minutes = 60,
    default_id_no = 0,
    default_label = "B"
  }
};

//======================================================================
//
// </PLUGINS>.
//
//======================================================================
 
//======================================================================
//
// <HELP>.
//
//======================================================================
 
///////////// help_command ////////////////////////////
//
// Main command to run to get help.
//
// Type: string

help_command = "chrome http://front.eol.ucar.edu/displayParams/CIDD'";

///////////// canvas_help /////////////////////////////
//
// Help text links.
//
// These take the form:
// widget_name_help: file_name:file_index_key_string.
// The HELPPATH environment variable must be set or the help file must 
//   be located in /usr/lib/help.
// Note the file name gets expanded to file_name.info.
//
// Type: string

canvas_help = "cidd_help::canvas";

///////////// frame_message_help //////////////////////
//
// Help text links.
//
// These take the form:
// widget_name_help: file_name:file_index_key_string.
// The HELPPATH environment variable must be set or the help file must 
//   be located in /usr/lib/help.
// Note the file name gets expanded to file_name.info.
//
// Type: string

frame_message_help = "cidd_help:frame_message";

//======================================================================
//
// </HELP>.
//
//======================================================================
 
