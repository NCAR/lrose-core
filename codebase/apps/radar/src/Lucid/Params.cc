/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Lucid
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Lucid is an app for integrating multiple weather data products into a single display.");
    tt->comment_text = tdrpStrDup("Lucid is a C++ application using the QT GUI toolkit. It is based on the legacy CIDD app.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("Parameter sections in this file:");
    tt->comment_text = tdrpStrDup("\t<DEBUGGING> - set debug levels\n\t<PROCESS_CONTROL> - and interprocess communication\n\t<FIELDS> - fields to be displayed\n\t<DATA_RETRIEVAL> - how to read the data\n\t<MAPS> - map overlays\n\t<PROJECTION> - world coordinate projection for main window\n\t<MOVIE_LOOPS> - animations\n\t<ZOOM_DOMAINS> - pre-defined zooms\n\t<GUI> - User interface\n\t<WINDOWS> - window size and placement\n\t<HORIZ_VIEW> - horizontal plan-view display\n\t<VERT_VIEW> - vertical cross-section display\n\t<COLORS> - colors for display elements\n\t<OVERLAYS> - geometric overlays and legends\n\t<RENDERING> - details on rendering\n\t<SYMBOLIC_PRODUCTS> - rendering products as overlays\n\t<TERRAIN> - getting and rendering terrain data\n\t<WINDS> - getting and rendering gridded winds\n\t<IMAGE_GENERATION> - image generation\n\t<AUTO_VERT> - predefined vertical sections for image generation\n\t<PLUGINS> - Communicating with other applications\n\t<HELP> - user help\n\n");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("<DEBUGGING>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'debug_flag'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug_flag");
    tt->descr = tdrpStrDup("Basic debug flag.");
    tt->help = tdrpStrDup("General informational messages - Initialization messages.");
    tt->val_offset = (char *) &debug_flag - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'debug1_flag'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug1_flag");
    tt->descr = tdrpStrDup("More verbose debug flag.");
    tt->help = tdrpStrDup("Data flow related messages.");
    tt->val_offset = (char *) &debug1_flag - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'debug2_flag'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug2_flag");
    tt->descr = tdrpStrDup("Verbose diagnostics.");
    tt->help = tdrpStrDup("Developer debugging information.");
    tt->val_offset = (char *) &debug2_flag - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("</DEBUGGING>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("<PROCESS_CONTROL>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'register_with_procmap'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("register_with_procmap");
    tt->descr = tdrpStrDup("Option to register this process with the process mapper (procmap).");
    tt->help = tdrpStrDup("If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.");
    tt->val_offset = (char *) &register_with_procmap - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'top_level_cache_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("top_level_cache_dir");
    tt->descr = tdrpStrDup("Directory for storing temporary files as a cache.");
    tt->help = tdrpStrDup("The temporary files we cache are for the maps and color scales. Below this top level directory Lucid will create subdirectories as follows:\n\t(maps) 'top_level_cache_dir/Lucid/params_file_name/maps'\n\t(color_scales) 'top_level_cache_dir/Lucid/params_file_name/color_scales'");
    tt->val_offset = (char *) &top_level_cache_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/cache");
    tt++;
    
    // Parameter 'clear_cache'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("clear_cache");
    tt->descr = tdrpStrDup("Clear the cached maps and color_scales files.");
    tt->help = tdrpStrDup("If true, the cached files will be cleared to ensure a new download.");
    tt->val_offset = (char *) &clear_cache - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_curl_for_downloads'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_curl_for_downloads");
    tt->descr = tdrpStrDup("Option to use 'curl' do download remote map and color_scale files.");
    tt->help = tdrpStrDup("If true, we use the curl app for the downloads. If false, we use http requests generated natively within Lucid.");
    tt->val_offset = (char *) &use_curl_for_downloads - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'idle_reset_seconds'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("idle_reset_seconds");
    tt->descr = tdrpStrDup("After this period of inactivity, the display will reset itself to a known starting point");
    tt->help = tdrpStrDup("Set this <= 0 to essentially turn off.");
    tt->val_offset = (char *) &idle_reset_seconds - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'coord_key'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("coord_key");
    tt->descr = tdrpStrDup("Key for coordinate in shared memory.");
    tt->help = tdrpStrDup("Store clicked locations in shmem. Other apps can watch for those clicks, and respond approppriately.");
    tt->val_offset = (char *) &coord_key - &_start_;
    tt->single_val.i = 61500;
    tt++;
    
    // Parameter 'titan_key'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("titan_key");
    tt->descr = tdrpStrDup("Key for titan clicks in shared memory.");
    tt->help = tdrpStrDup("Store clicked locations in shmem. Rview and TimeHist can watch for those clicks, and respond approppriately.");
    tt->val_offset = (char *) &titan_key - &_start_;
    tt->single_val.i = 61600;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("STARTUP MODE and TIME parameters");
    tt->comment_text = tdrpStrDup("Start up in REALTIME or ARCHIVE mode.");
    tt++;
    
    // Parameter 'start_mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("start_mode");
    tt->descr = tdrpStrDup("Operating mode at start.");
    tt->help = tdrpStrDup("In ARCHIVE mode, the movie start time will be set to archive_start_time. In REALTIME mode the movie end time will be set to NOW, and the movie start time will be computed relative to the end time.");
    tt->val_offset = (char *) &start_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("MODE_REALTIME");
      tt->enum_def.fields[0].val = MODE_REALTIME;
      tt->enum_def.fields[1].name = tdrpStrDup("MODE_ARCHIVE");
      tt->enum_def.fields[1].val = MODE_ARCHIVE;
    tt->single_val.e = MODE_ARCHIVE;
    tt++;
    
    // Parameter 'archive_start_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("archive_start_time");
    tt->descr = tdrpStrDup("Start time for archive mode.");
    tt->help = tdrpStrDup("This is the start of the movie time interval.");
    tt->val_offset = (char *) &archive_start_time - &_start_;
    tt->single_val.s = tdrpStrDup("2022 05 26 01 00 00");
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("</PROCESS_CONTROL>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("<FIELDS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'color_scale_urls'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("color_scale_urls");
    tt->descr = tdrpStrDup("URLs for color scales. Use a comma-delimited list to seach in multiple locations.");
    tt->help = tdrpStrDup("This can be either (a) a local directory in the file system, or (b) a remote URL using http or https.");
    tt->val_offset = (char *) &color_scale_urls - &_start_;
    tt->single_val.s = tdrpStrDup("$(HOME)/git/lrose-displays/color_scales,http://front.eol.ucar.edu/color_scales");
    tt++;
    
    // Parameter 'fields'
    // ctype is '_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fields");
    tt->descr = tdrpStrDup("Fields to be displayed.");
    tt->help = tdrpStrDup("/ngroup_name: we organize the fields into groups. If all are the same we use a single group. Set the group name to empty if this is just a filler field to organize the field list in the gui./nbutton_label: appears on the GUI. /nlegend_label: appears in the plot. /nurl: location of data or data server. /nfield_name: name in the file. /ncolor_map: name of color map in color_scale_dir. /nunits: units to appear on the display. /ncontour_low: contour rendering lower limit. /ncontour_high: contour rendering upper limit. /ncontour_interval: contour rendering interval. /nrender_mode:/n  POLYGONS: Rectangle/polygon fills of gridded data./n  FILLED_CONTOURS: false color filled contours./n  LINE_CONTOURS: line contours./n  DYNAMIC_CONTOURS: auto switching between cart and cont./n         uses dynamic_contour_treshold./ndisplay_in_menu: display this field in the menu./nbackground_render: render this field automatically in the background./ncomposite_mode: display max over height./nauto_scale: scale automatically./nauto_render: render automatically./n");
    tt->array_offset = (char *) &_fields - &_start_;
    tt->array_n_offset = (char *) &fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("field_t");
    tt->struct_def.nfields = 16;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("group_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fields->group_name - (char *) _fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("button_label");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fields->button_label - (char *) _fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("legend_label");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_fields->legend_label - (char *) _fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("url");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_fields->url - (char *) _fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_fields->field_name - (char *) _fields;
      tt->struct_def.fields[5].ftype = tdrpStrDup("string");
      tt->struct_def.fields[5].fname = tdrpStrDup("color_map");
      tt->struct_def.fields[5].ptype = STRING_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_fields->color_map - (char *) _fields;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("field_units");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_fields->field_units - (char *) _fields;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("contour_low");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_fields->contour_low - (char *) _fields;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("contour_high");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_fields->contour_high - (char *) _fields;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("contour_interval");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_fields->contour_interval - (char *) _fields;
      tt->struct_def.fields[10].ftype = tdrpStrDup("grid_render_mode_t");
      tt->struct_def.fields[10].fname = tdrpStrDup("render_mode");
      tt->struct_def.fields[10].ptype = ENUM_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_fields->render_mode - (char *) _fields;
        tt->struct_def.fields[10].enum_def.name = tdrpStrDup("grid_render_mode_t");
        tt->struct_def.fields[10].enum_def.nfields = 4;
        tt->struct_def.fields[10].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[10].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[10].enum_def.fields[0].name = tdrpStrDup("POLYGONS");
        tt->struct_def.fields[10].enum_def.fields[0].val = POLYGONS;
        tt->struct_def.fields[10].enum_def.fields[1].name = tdrpStrDup("FILLED_CONTOURS");
        tt->struct_def.fields[10].enum_def.fields[1].val = FILLED_CONTOURS;
        tt->struct_def.fields[10].enum_def.fields[2].name = tdrpStrDup("DYNAMIC_CONTOURS");
        tt->struct_def.fields[10].enum_def.fields[2].val = DYNAMIC_CONTOURS;
        tt->struct_def.fields[10].enum_def.fields[3].name = tdrpStrDup("LINE_CONTOURS");
        tt->struct_def.fields[10].enum_def.fields[3].val = LINE_CONTOURS;
      tt->struct_def.fields[11].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[11].fname = tdrpStrDup("display_in_menu");
      tt->struct_def.fields[11].ptype = BOOL_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_fields->display_in_menu - (char *) _fields;
      tt->struct_def.fields[12].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[12].fname = tdrpStrDup("background_render");
      tt->struct_def.fields[12].ptype = BOOL_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_fields->background_render - (char *) _fields;
      tt->struct_def.fields[13].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[13].fname = tdrpStrDup("composite_mode");
      tt->struct_def.fields[13].ptype = BOOL_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_fields->composite_mode - (char *) _fields;
      tt->struct_def.fields[14].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[14].fname = tdrpStrDup("auto_scale");
      tt->struct_def.fields[14].ptype = BOOL_TYPE;
      tt->struct_def.fields[14].rel_offset = 
        (char *) &_fields->auto_scale - (char *) _fields;
      tt->struct_def.fields[15].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[15].fname = tdrpStrDup("auto_render");
      tt->struct_def.fields[15].ptype = BOOL_TYPE;
      tt->struct_def.fields[15].rel_offset = 
        (char *) &_fields->auto_render - (char *) _fields;
    tt->n_struct_vals = 32;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("main");
      tt->struct_vals[1].s = tdrpStrDup("DBZ_F");
      tt->struct_vals[2].s = tdrpStrDup("DBZ_F");
      tt->struct_vals[3].s = tdrpStrDup("mdvp:://front.eol.ucar.edu:8080:dynamo/cfradial/orig/moments/sband/sur");
      tt->struct_vals[4].s = tdrpStrDup("DBZ_F");
      tt->struct_vals[5].s = tdrpStrDup("dbz.colors");
      tt->struct_vals[6].s = tdrpStrDup("dBZ");
      tt->struct_vals[7].d = -5;
      tt->struct_vals[8].d = 80;
      tt->struct_vals[9].d = 5;
      tt->struct_vals[10].e = POLYGONS;
      tt->struct_vals[11].b = pTRUE;
      tt->struct_vals[12].b = pFALSE;
      tt->struct_vals[13].b = pFALSE;
      tt->struct_vals[14].b = pFALSE;
      tt->struct_vals[15].b = pFALSE;
      tt->struct_vals[16].s = tdrpStrDup("main");
      tt->struct_vals[17].s = tdrpStrDup("VEL_F");
      tt->struct_vals[18].s = tdrpStrDup("VEL_F");
      tt->struct_vals[19].s = tdrpStrDup("mdvp:://front.eol.ucar.edu:8080:dynamo/cfradial/orig/moments/sband/sur");
      tt->struct_vals[20].s = tdrpStrDup("VEL_F");
      tt->struct_vals[21].s = tdrpStrDup("vel.colors");
      tt->struct_vals[22].s = tdrpStrDup("m/s");
      tt->struct_vals[23].d = -5;
      tt->struct_vals[24].d = 80;
      tt->struct_vals[25].d = 5;
      tt->struct_vals[26].e = POLYGONS;
      tt->struct_vals[27].b = pTRUE;
      tt->struct_vals[28].b = pFALSE;
      tt->struct_vals[29].b = pFALSE;
      tt->struct_vals[30].b = pFALSE;
      tt->struct_vals[31].b = pFALSE;
    tt++;
    
    // Parameter 'replace_underscores'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("replace_underscores");
    tt->descr = tdrpStrDup("Underscores in field names and legends are replaced by spaces.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &replace_underscores - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("</FIELDS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("<DATA_RETRIEVAL>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'check_data_times'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_data_times");
    tt->descr = tdrpStrDup("Used to reject 'out of date' data.");
    tt->help = tdrpStrDup("Set this param to TRUE to check and reject for rendering any data that falls outside the movie frame interval + the slop/stretch_factor.");
    tt->val_offset = (char *) &check_data_times - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'time_search_stretch_factor'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("time_search_stretch_factor");
    tt->descr = tdrpStrDup("Sets the allowable time error for data to appear in movie frames.");
    tt->help = tdrpStrDup("(times the time_interval) (6 min * 6 = 36 minutes before or after the beginning or end of the movie frame times.");
    tt->val_offset = (char *) &time_search_stretch_factor - &_start_;
    tt->single_val.d = 6;
    tt++;
    
    // Parameter 'gather_data_mode'
    // ctype is '_gather_data_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("gather_data_mode");
    tt->descr = tdrpStrDup("Sets whether we request data closest to the start, midpoint or end of a movie frame.");
    tt->help = tdrpStrDup("CLOSEST_TO_FRAME_CENTER: closest to frame midpoint; FIRST_BEFORE_END_OF_FRAME: closest to frame end time; FIRST_AFTER_START_OF_FRAME: closest to the start time of the frame. Typically, real-time operation should operate as closest to end of frame. Choose CENTER if you want to enter a time and have data the data at that time appear, regardless of how wide the movie frame interval is.");
    tt->val_offset = (char *) &gather_data_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("gather_data_mode_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLOSEST_TO_FRAME_CENTER");
      tt->enum_def.fields[0].val = CLOSEST_TO_FRAME_CENTER;
      tt->enum_def.fields[1].name = tdrpStrDup("FIRST_BEFORE_END_OF_FRAME");
      tt->enum_def.fields[1].val = FIRST_BEFORE_END_OF_FRAME;
      tt->enum_def.fields[2].name = tdrpStrDup("FIRST_AFTER_START_OF_FRAME");
      tt->enum_def.fields[2].val = FIRST_AFTER_START_OF_FRAME;
    tt->single_val.e = CLOSEST_TO_FRAME_CENTER;
    tt++;
    
    // Parameter 'update_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("update_interval");
    tt->descr = tdrpStrDup("Number of seconds between data update requests.");
    tt->help = tdrpStrDup("The display will check the Data Mapper for new data every interval in real-time mode. At every interval we will check for updates to each grid and product. If no datamap_host is set, the data is assumed to be old and will be reloaded every interval. Set this wisely. Values of 10-900 are typical. Default=120 Setting this below 3 seconds is not advised.  interacts with the Data Mapper Host parameter: cidd.datamap_host:");
    tt->val_offset = (char *) &update_interval - &_start_;
    tt->single_val.i = 120;
    tt++;
    
    // Parameter 'datamap_host'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("datamap_host");
    tt->descr = tdrpStrDup("DataMapper Host");
    tt->help = tdrpStrDup("Host on which the DataMapper app is running.");
    tt->val_offset = (char *) &datamap_host - &_start_;
    tt->single_val.s = tdrpStrDup("localhost");
    tt++;
    
    // Parameter 'data_timeout_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("data_timeout_secs");
    tt->descr = tdrpStrDup("Number of seconds to wait for data to come in before giving up.");
    tt->help = tdrpStrDup("On very slow networks this may need to go as high as 180 seconds.");
    tt->val_offset = (char *) &data_timeout_secs - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'request_compressed_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("request_compressed_data");
    tt->descr = tdrpStrDup("Request data from MDV servers be compressed.");
    tt->help = tdrpStrDup("When a remote URL is used, the server can compress the data for transmission. This makes sense for slow remote connections.");
    tt->val_offset = (char *) &request_compressed_data - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'request_gzip_vol_compression'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("request_gzip_vol_compression");
    tt->descr = tdrpStrDup("Use gzip-style compression for remote data access.");
    tt->help = tdrpStrDup("See 'request_compressed_data'.");
    tt->val_offset = (char *) &request_gzip_vol_compression - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'model_run_list_hours'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("model_run_list_hours");
    tt->descr = tdrpStrDup("Gather model run times within these number of hours from the end of the movie loop.");
    tt->help = tdrpStrDup("More hours means more Model runs will appear in the menu.");
    tt->val_offset = (char *) &model_run_list_hours - &_start_;
    tt->single_val.i = 24;
    tt++;
    
    // Parameter 'forecast_interval_hours'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("forecast_interval_hours");
    tt->descr = tdrpStrDup("This parameter sets the maximum number of hours in the future a user can select from the quick forecast menu");
    tt->help = tdrpStrDup("See SHOW_FORECAST_MENU menu bar button");
    tt->val_offset = (char *) &forecast_interval_hours - &_start_;
    tt->single_val.d = 24;
    tt++;
    
    // Parameter 'past_interval_hours'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("past_interval_hours");
    tt->descr = tdrpStrDup("The maximum number of hours in the PAST a user can selectfrom the quick forecast menu");
    tt->help = tdrpStrDup("See SHOW_PAST_MENU menu bar button.");
    tt->val_offset = (char *) &past_interval_hours - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'clip_to_current_zoom_on_mdv_request'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("clip_to_current_zoom_on_mdv_request");
    tt->descr = tdrpStrDup("Clip the MDV request to just larger than the current zoom limits.");
    tt->help = tdrpStrDup("If TRUE, this will sometimes reduce the volume of data retrieved, for efficiency. But this does mean that a new request is made with every zoom change. If FALSE, the entire data domain is returned on the first request, which means that the data does not need to be requested after each zoom change.");
    tt->val_offset = (char *) &clip_to_current_zoom_on_mdv_request - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'decimate_resolution_on_mdv_request'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("decimate_resolution_on_mdv_request");
    tt->descr = tdrpStrDup("Decimate the data resolution on the MDV request, to match the pixel resolution of the display.");
    tt->help = tdrpStrDup("If FALSE, the finest data resolution will be preserved. If TRUE, the data retrieval will decimate the number of data points to approximately match the number of pixels on the display side.");
    tt->val_offset = (char *) &decimate_resolution_on_mdv_request - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'clip_to_current_zoom_on_symprod_request'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("clip_to_current_zoom_on_symprod_request");
    tt->descr = tdrpStrDup("Clip the symbolic product request to just larger than the current zoom limits.");
    tt->help = tdrpStrDup("If TRUE, this will reduce the volume of data retrieved, for efficiency. But this does mean that a new request is made with every zoom change. If FALSE, the entire data domain is returned on the first request, which means that the data does not need to be requested after each zoom change.");
    tt->val_offset = (char *) &clip_to_current_zoom_on_symprod_request - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'check_clipping'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_clipping");
    tt->descr = tdrpStrDup("Set this parameter to TRUE when displaying data on dissimilar grid projection and stripes or other artifacts are rendered.");
    tt->help = tdrpStrDup("Each polygon will be checked to make sure it will render correctly. This slows down the rendering a bit so it is FALSE by default.");
    tt->val_offset = (char *) &check_clipping - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'http_tunnel_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("http_tunnel_url");
    tt->descr = tdrpStrDup("Tunnel for all DsServer (mdvp,spdbp,etc) Protocols.");
    tt->help = tdrpStrDup("USE THIS TO CROSS A FIREWALL ON THE SERVER END OF THE CHAI. Set this to the special http tunnel that resides in the same local network as the  data server hosts. This allows 'tunneling' the MDV and Spdb data protocols through a host, running apache:httpd that is visible from the Internet or intranet. Note: a special  'Apache::Mod_perl' extension (The tunnel - it's similar to a cgi mechanism) must be installed on the http server for this to work.");
    tt->val_offset = (char *) &http_tunnel_url - &_start_;
    tt->single_val.s = tdrpStrDup("http://www.rap.ucar.edu/DsServerTunnel.");
    tt++;
    
    // Parameter 'http_proxy_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("http_proxy_url");
    tt->descr = tdrpStrDup("USE THIS TO CROSS A FIREWALL AT THE Client/Lucid End of the Chain.");
    tt->help = tdrpStrDup("# Set this to the url of a http forwarding proxy to pass http requests through the proxy. This is usually the same as the HTTP proxy URL in your browser. Note. If you need the data to flow through the proxy the http_tunnel_url must be enabled.\n\n");
    tt->val_offset = (char *) &http_proxy_url - &_start_;
    tt->single_val.s = tdrpStrDup("http://webcache.ucar.edu:3128/");
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("Another view of the possible Service Topologies.");
    tt->comment_text = tdrpStrDup("All Local - No Firewalls - Standard Setup\n--------- Local Lan --------------\nLucid<--- MDVP --->DsMdvServer\n\nData Services Behind a firewall\n----- Internet ----|Firewall|------ Local Lan ----------------\nLucid<---HTTP--->DsServer Tunnel<---MDVP--->DsMdvServer\n\nBoth Client and Data Services behind Firewalls\n---Local Lan ---|Firewall|--Internet----|Firewall|--------Local Lan ----------\nLucid<---HTTP--->Http Proxy<---HTTP--->DsServer Tunnel<---MDVP--->DsMdvServer");
    tt++;
    
    // Parameter 'locator_margin_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("locator_margin_km");
    tt->descr = tdrpStrDup("Station locator features.");
    tt->help = tdrpStrDup("Maximum allowed  Distance in km between request point and station.");
    tt->val_offset = (char *) &locator_margin_km - &_start_;
    tt->single_val.d = 50;
    tt++;
    
    // Parameter 'station_loc_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("station_loc_url");
    tt->descr = tdrpStrDup("Full Path File name or http URL to a station data file.");
    tt->help = tdrpStrDup("The format of each line is:  ID, LAT, LON, ALT(m), TYPE.");
    tt->val_offset = (char *) &station_loc_url - &_start_;
    tt->single_val.s = tdrpStrDup("http://www.rap.ucar.edu/maps/Taiwan_stations.dat");
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("</DATA_RETRIEVAL>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("<MAPS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'map_urls'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("map_urls");
    tt->descr = tdrpStrDup("URLs for maps. Use a comma-delimited list to seach in multiple locations.");
    tt->help = tdrpStrDup("This can be either (a) a local directory in the file system, or (b) a remote URL using http or https.");
    tt->val_offset = (char *) &map_urls - &_start_;
    tt->single_val.s = tdrpStrDup("$(HOME)/git/lrose-displays/maps,http://front.eol.ucar.edu/maps");
    tt++;
    
    // Parameter 'maps_enabled_at_startup'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("maps_enabled_at_startup");
    tt->descr = tdrpStrDup("Enable maps at start.");
    tt->help = tdrpStrDup("If FALSE, maps will not be emabled at startup. You will have to turn them on via the maps menu.");
    tt->val_offset = (char *) &maps_enabled_at_startup - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'maps'
    // ctype is '_map_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("maps");
    tt->descr = tdrpStrDup("Map overlays to be displayed.");
    tt->help = tdrpStrDup("map_code: name of the map, appears on the GUI. \ncontrol_label: appears in the plot. \nmap_file_name: name of map file in maps directory\nline_width: line width to be used for map vectors. \ndetail_thresh_min: min detail threshold for displaying map. Detail thresholds are computed as units of km across the image. \ndetail_thresh_max: max detail threshold for displaying map. Detail thresholds are computed as units of km across the image. \ncolor: X color name.\non_at_startup: display overlay when app starts up.\n");
    tt->array_offset = (char *) &_maps - &_start_;
    tt->array_n_offset = (char *) &maps_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(map_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("map_t");
    tt->struct_def.nfields = 8;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("map_code");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_maps->map_code - (char *) _maps;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("control_label");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_maps->control_label - (char *) _maps;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("map_file_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_maps->map_file_name - (char *) _maps;
      tt->struct_def.fields[3].ftype = tdrpStrDup("int");
      tt->struct_def.fields[3].fname = tdrpStrDup("line_width");
      tt->struct_def.fields[3].ptype = INT_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_maps->line_width - (char *) _maps;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("detail_thresh_min");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_maps->detail_thresh_min - (char *) _maps;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("detail_thresh_max");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_maps->detail_thresh_max - (char *) _maps;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("color");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_maps->color - (char *) _maps;
      tt->struct_def.fields[7].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[7].fname = tdrpStrDup("on_at_startup");
      tt->struct_def.fields[7].ptype = BOOL_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_maps->on_at_startup - (char *) _maps;
    tt->n_struct_vals = 16;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("US_Highways");
      tt->struct_vals[1].s = tdrpStrDup("US_Highways");
      tt->struct_vals[2].s = tdrpStrDup("conus_ushwys.map");
      tt->struct_vals[3].i = 1;
      tt->struct_vals[4].d = 0;
      tt->struct_vals[5].d = 1000;
      tt->struct_vals[6].s = tdrpStrDup("grey");
      tt->struct_vals[7].b = pTRUE;
      tt->struct_vals[8].s = tdrpStrDup("Interstates");
      tt->struct_vals[9].s = tdrpStrDup("Interstates");
      tt->struct_vals[10].s = tdrpStrDup("conus_interstates.map");
      tt->struct_vals[11].i = 1;
      tt->struct_vals[12].d = 0;
      tt->struct_vals[13].d = 10000;
      tt->struct_vals[14].s = tdrpStrDup("white");
      tt->struct_vals[15].b = pTRUE;
    tt++;
    
    // Parameter 'maps_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("maps_font_size");
    tt->descr = tdrpStrDup("Font size for labels on maps.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &maps_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'map_font_background'
    // ctype is '_map_font_background_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("map_font_background");
    tt->descr = tdrpStrDup("Font rendering mode for maps.");
    tt->help = tdrpStrDup("MAP_FONT_BACKGROUND_OPAQUE: Clears background behind label text. MAP_FONT_BACKGROUND_TRANSPARENT: does not clear background.");
    tt->val_offset = (char *) &map_font_background - &_start_;
    tt->enum_def.name = tdrpStrDup("map_font_background_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("MAP_FONT_BACKGROUND_TRANSPARENT");
      tt->enum_def.fields[0].val = MAP_FONT_BACKGROUND_TRANSPARENT;
      tt->enum_def.fields[1].name = tdrpStrDup("MAP_FONT_BACKGROUND_OPAQUE");
      tt->enum_def.fields[1].val = MAP_FONT_BACKGROUND_OPAQUE;
    tt->single_val.e = MAP_FONT_BACKGROUND_TRANSPARENT;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("</MAPS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("<PROJECTION>");
    tt->comment_text = tdrpStrDup("Geographic projection for horizontal view.");
    tt++;
    
    // Parameter 'proj_type'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("proj_type");
    tt->descr = tdrpStrDup("Projection for mapping in x,y. See projection param below.");
    tt->help = tdrpStrDup("\tPROJ_LATLON: simple lat/lon grid (Equidistant Cylindrical)\n\tPROJ_FLAT: Azimuthal Equidistant (Radar)\n\tPROJ_LAMBERT_CONF: Lambert Conformal Conic\n\tPROJ_LAMBERT_AZIM: Lambert Azimuthal Equal Area\n\tPROJ_MERCATOR: Mercator - EW orientation\n\tPROJ_TRANS_MERCATOR: Tranverse Mercator - NS orientation\n\tPROJ_POLAR_STEREO: Stereographic- polar aspect\n\tPROJ_OBLIQUE_STEREO: Stereographic - oblique aspect\n\tPROJ_ALBERS: Albers Equal Area Conic\n");
    tt->val_offset = (char *) &proj_type - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 9;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_LATLON");
      tt->enum_def.fields[0].val = PROJ_LATLON;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_LAMBERT_CONF");
      tt->enum_def.fields[1].val = PROJ_LAMBERT_CONF;
      tt->enum_def.fields[2].name = tdrpStrDup("PROJ_MERCATOR");
      tt->enum_def.fields[2].val = PROJ_MERCATOR;
      tt->enum_def.fields[3].name = tdrpStrDup("PROJ_POLAR_STEREO");
      tt->enum_def.fields[3].val = PROJ_POLAR_STEREO;
      tt->enum_def.fields[4].name = tdrpStrDup("PROJ_FLAT");
      tt->enum_def.fields[4].val = PROJ_FLAT;
      tt->enum_def.fields[5].name = tdrpStrDup("PROJ_OBLIQUE_STEREO");
      tt->enum_def.fields[5].val = PROJ_OBLIQUE_STEREO;
      tt->enum_def.fields[6].name = tdrpStrDup("PROJ_TRANS_MERCATOR");
      tt->enum_def.fields[6].val = PROJ_TRANS_MERCATOR;
      tt->enum_def.fields[7].name = tdrpStrDup("PROJ_ALBERS");
      tt->enum_def.fields[7].val = PROJ_ALBERS;
      tt->enum_def.fields[8].name = tdrpStrDup("PROJ_LAMBERT_AZIM");
      tt->enum_def.fields[8].val = PROJ_LAMBERT_AZIM;
    tt->single_val.e = PROJ_FLAT;
    tt++;
    
    // Parameter 'proj_origin_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_origin_lat");
    tt->descr = tdrpStrDup("Projection grid origin latitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.");
    tt->val_offset = (char *) &proj_origin_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_origin_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_origin_lon");
    tt->descr = tdrpStrDup("Projection grid origin longitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.");
    tt->val_offset = (char *) &proj_origin_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_rotation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_rotation");
    tt->descr = tdrpStrDup("Amount grids are rotated clockwise to true north.");
    tt->help = tdrpStrDup("This applies to only to PROJ_FLAT projection.");
    tt->val_offset = (char *) &proj_rotation - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_lat1'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_lat1");
    tt->descr = tdrpStrDup("Projection grid reference latitude 1.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &proj_lat1 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_lat2'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_lat2");
    tt->descr = tdrpStrDup("Projection grid reference latitude 2.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &proj_lat2 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_central_scale'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_central_scale");
    tt->descr = tdrpStrDup("Central scale for projection.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO, OBLIQUE_STEREO and TRANSVERSE_MERCATOR projections.");
    tt->val_offset = (char *) &proj_central_scale - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'proj_tangent_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_tangent_lat");
    tt->descr = tdrpStrDup("Projection tangent latitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO only.");
    tt->val_offset = (char *) &proj_tangent_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_tangent_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_tangent_lon");
    tt->descr = tdrpStrDup("Projection tangent longitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO and POLAR_STEREO.");
    tt->val_offset = (char *) &proj_tangent_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_pole_is_north'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("proj_pole_is_north");
    tt->descr = tdrpStrDup("Flag indicating stereogtraphic is over the NORTH pole.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO. If false, the projection is over the south pole.");
    tt->val_offset = (char *) &proj_pole_is_north - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'proj_persp_radius'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_persp_radius");
    tt->descr = tdrpStrDup("Radius of perspective point (km).");
    tt->help = tdrpStrDup("This applies to VERT_PERSP.");
    tt->val_offset = (char *) &proj_persp_radius - &_start_;
    tt->single_val.d = 35786;
    tt++;
    
    // Parameter 'proj_false_northing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_false_northing");
    tt->descr = tdrpStrDup("Projection false northing correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the Y coordinate so that all coordinates are positive. Normally 0. As an alternative to false_northing and false_easting, you can set the offset_latitude and offset_longitude");
    tt->val_offset = (char *) &proj_false_northing - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_false_easting'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_false_easting");
    tt->descr = tdrpStrDup("Projection false easting correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the X coordinate so that all coordinates are positive. Normally 0.");
    tt->val_offset = (char *) &proj_false_easting - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_set_offset_origin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("proj_set_offset_origin");
    tt->descr = tdrpStrDup("Do you want to specify an offset origin using lat/lon instead of false_northing and false_easting?");
    tt->help = tdrpStrDup("If true, set proj_offset_origin_latitude and proj_offset_origin_longitude.");
    tt->val_offset = (char *) &proj_set_offset_origin - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'proj_offset_origin_latitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_offset_origin_latitude");
    tt->descr = tdrpStrDup("Latitude of offset origin.");
    tt->help = tdrpStrDup("See proj_set_offset_origin.");
    tt->val_offset = (char *) &proj_offset_origin_latitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'proj_offset_origin_longitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("proj_offset_origin_longitude");
    tt->descr = tdrpStrDup("Longitude of offset origin.");
    tt->help = tdrpStrDup("See proj_set_offset_origin.");
    tt->val_offset = (char *) &proj_offset_origin_longitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'use_cosine_correction'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_cosine_correction");
    tt->descr = tdrpStrDup("Diagnostic mode used to ignore the Elevation angle on polar data (radars, etc).");
    tt->help = tdrpStrDup("Set to FALSE to display all polar grids as if the elevation were always 0.0 degrees. This allows one to view radial data near 90 degrees elevation.");
    tt->val_offset = (char *) &use_cosine_correction - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'report_clicks_in_degM_and_nm'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("report_clicks_in_degM_and_nm");
    tt->descr = tdrpStrDup("Report click position in degrees magnetic and nautical miles.");
    tt->help = tdrpStrDup("By default distance are in km and bearings in deg T.");
    tt->val_offset = (char *) &report_clicks_in_degM_and_nm - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'magnetic_variation_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("magnetic_variation_deg");
    tt->descr = tdrpStrDup("Set the magnetic variation for the display location.");
    tt->help = tdrpStrDup("Variation is true minus magnetic.");
    tt->val_offset = (char *) &magnetic_variation_deg - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("</PROJECTION>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("<MOVIE_LOOPS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'n_movie_frames'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_movie_frames");
    tt->descr = tdrpStrDup("The number of frames in the movie at startup.");
    tt->help = tdrpStrDup("The movie duration is the number of frames multiplied by the frame duration.");
    tt->val_offset = (char *) &n_movie_frames - &_start_;
    tt->single_val.i = 12;
    tt++;
    
    // Parameter 'frame_interval_secs'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("frame_interval_secs");
    tt->descr = tdrpStrDup("Interval between movie time frames (secs).");
    tt->help = tdrpStrDup("The data for each frame is requested for the center of the frame.");
    tt->val_offset = (char *) &frame_interval_secs - &_start_;
    tt->single_val.d = 300;
    tt++;
    
    // Parameter 'max_frame_interval_secs'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_frame_interval_secs");
    tt->descr = tdrpStrDup("Max interval between movie time frames (secs).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &max_frame_interval_secs - &_start_;
    tt->single_val.d = 3600;
    tt++;
    
    // Parameter 'temporal_rounding'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("temporal_rounding");
    tt->descr = tdrpStrDup("Set times to the nearest value divisible by the number of seconds.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &temporal_rounding - &_start_;
    tt->single_val.i = 300;
    tt++;
    
    // Parameter 'movie_on'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("movie_on");
    tt->descr = tdrpStrDup("Determine whether to start with movie looping on.");
    tt->help = tdrpStrDup("Set to TRUE to start up in movie-on mode, FALSE = off");
    tt->val_offset = (char *) &movie_on - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'loop_delay_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("loop_delay_msecs");
    tt->descr = tdrpStrDup("Set the delay at the end of the movie loop in (msec).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &loop_delay_msecs - &_start_;
    tt->single_val.i = 2000;
    tt++;
    
    // Parameter 'movie_dwell_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("movie_dwell_msecs");
    tt->descr = tdrpStrDup("Set the dwell of the movie loop (msec dwell per frame).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &movie_dwell_msecs - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 30;
    tt->max_val.i = 9999;
    tt->single_val.i = 75;
    tt++;
    
    // Parameter 'movie_min_dwell_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("movie_min_dwell_msecs");
    tt->descr = tdrpStrDup("Minimum dwell of the movie loop (msec per frame).");
    tt->help = tdrpStrDup("This yields the fastest movie rate.");
    tt->val_offset = (char *) &movie_min_dwell_msecs - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'movie_max_dwell_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("movie_max_dwell_msecs");
    tt->descr = tdrpStrDup("Maximum dwell of the movie loop (msec per frame).");
    tt->help = tdrpStrDup("This yields the slowest movie rate.");
    tt->val_offset = (char *) &movie_max_dwell_msecs - &_start_;
    tt->single_val.i = 500;
    tt++;
    
    // Parameter 'reset_frames'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("reset_frames");
    tt->descr = tdrpStrDup("Forces reload of all data every time the movie frames rotate one old frame out and generate a new frame.");
    tt->help = tdrpStrDup("If TRUE, this will slow down data gathering for movie rendering.");
    tt->val_offset = (char *) &reset_frames - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'movie_magnify_factor'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("movie_magnify_factor");
    tt->descr = tdrpStrDup("When a Forecast hour is chosen, magnify the time interval by this factor.");
    tt->help = tdrpStrDup("This adjusts the frame time_interval to be more appropriate for forecast (model) data, which is often output on a more coarse time interval. When 'Now' is selected the magnification is undone.");
    tt->val_offset = (char *) &movie_magnify_factor - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'moviestart_time_format'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("moviestart_time_format");
    tt->descr = tdrpStrDup("Set the format for the time string in the movie start time text field of the movie pop-up window.");
    tt->help = tdrpStrDup("This is set separately from the general time string because you generally don't want any extra text and want to display things in an order that allows for easier entry.");
    tt->val_offset = (char *) &moviestart_time_format - &_start_;
    tt->single_val.s = tdrpStrDup("%Y/%m/%d %H:%M:%S");
    tt++;
    
    // Parameter 'climo_mode'
    // ctype is '_climo_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("climo_mode");
    tt->descr = tdrpStrDup("Sets the interval over which the climatology is computed.");
    tt->help = tdrpStrDup("Users can do this interactively by entering '1 yr' or '1 day' in the movie control panel interval text widget. Lucid will recognize these special 'intervals' and will do the right thing.");
    tt->val_offset = (char *) &climo_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("climo_mode_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLIMO_REGULAR_INTERVAL");
      tt->enum_def.fields[0].val = CLIMO_REGULAR_INTERVAL;
      tt->enum_def.fields[1].name = tdrpStrDup("CLIMO_DAILY_INTERVAL");
      tt->enum_def.fields[1].val = CLIMO_DAILY_INTERVAL;
      tt->enum_def.fields[2].name = tdrpStrDup("CLIMO_YEARLY_INTERVAL");
      tt->enum_def.fields[2].val = CLIMO_YEARLY_INTERVAL;
    tt->single_val.e = CLIMO_REGULAR_INTERVAL;
    tt++;
    
    // Parameter 'climo_max_time_span_days'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("climo_max_time_span_days");
    tt->descr = tdrpStrDup("Maximum number of days over which to request time lists.");
    tt->help = tdrpStrDup("If the epoch exceeds this number of days, then no time list requests will be made. Time lists requests spanning many years can take too long.");
    tt->val_offset = (char *) &climo_max_time_span_days - &_start_;
    tt->single_val.i = 365;
    tt++;
    
    // Parameter 'climo_frame_span_mins'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("climo_frame_span_mins");
    tt->descr = tdrpStrDup("Span in minutes a frame covers in Climo mode.");
    tt->help = tdrpStrDup("The time_interval will be either '1 day' or '1 year'");
    tt->val_offset = (char *) &climo_frame_span_mins - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'redraw_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("redraw_interval");
    tt->descr = tdrpStrDup("Number of milliseconds between checks for images needing redrawn.");
    tt->help = tdrpStrDup("Set this lower on faster hardware - Recommended 50-250. This sets the ultimate speed of the movie looping.");
    tt->val_offset = (char *) &redraw_interval - &_start_;
    tt->single_val.i = 100;
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("</MOVIE_LOOPS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("<ZOOM_DOMAINS>");
    tt->comment_text = tdrpStrDup("These are the pre-defined zoom levels.");
    tt++;
    
    // Parameter 'zoom_levels'
    // ctype is '_zoom_level_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("zoom_levels");
    tt->descr = tdrpStrDup("Pre-defined zoom levels.");
    tt->help = tdrpStrDup("/nlabel: label in GUI for selecting zoom level. /nmin_x: X value of SW corner./nmin_y: Y value of SW corner./nmax_x: X value of NE corner./nmax_y: Y value of NE corner./nunits: the units for the zoom limits for this entry./n");
    tt->array_offset = (char *) &_zoom_levels - &_start_;
    tt->array_n_offset = (char *) &zoom_levels_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(zoom_level_t);
    tt->array_n = 3;
    tt->struct_def.name = tdrpStrDup("zoom_level_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("label");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_zoom_levels->label - (char *) _zoom_levels;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_x");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_zoom_levels->min_x - (char *) _zoom_levels;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("min_y");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_zoom_levels->min_y - (char *) _zoom_levels;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("max_x");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_zoom_levels->max_x - (char *) _zoom_levels;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("max_y");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_zoom_levels->max_y - (char *) _zoom_levels;
      tt->struct_def.fields[5].ftype = tdrpStrDup("zoom_units_t");
      tt->struct_def.fields[5].fname = tdrpStrDup("units");
      tt->struct_def.fields[5].ptype = ENUM_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_zoom_levels->units - (char *) _zoom_levels;
        tt->struct_def.fields[5].enum_def.name = tdrpStrDup("zoom_units_t");
        tt->struct_def.fields[5].enum_def.nfields = 2;
        tt->struct_def.fields[5].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[5].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[5].enum_def.fields[0].name = tdrpStrDup("ZOOM_LIMITS_IN_KM");
        tt->struct_def.fields[5].enum_def.fields[0].val = ZOOM_LIMITS_IN_KM;
        tt->struct_def.fields[5].enum_def.fields[1].name = tdrpStrDup("ZOOM_LIMITS_IN_DEG");
        tt->struct_def.fields[5].enum_def.fields[1].val = ZOOM_LIMITS_IN_DEG;
    tt->n_struct_vals = 18;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("100km");
      tt->struct_vals[1].d = -100;
      tt->struct_vals[2].d = -100;
      tt->struct_vals[3].d = 100;
      tt->struct_vals[4].d = 100;
      tt->struct_vals[5].e = ZOOM_LIMITS_IN_KM;
      tt->struct_vals[6].s = tdrpStrDup("200km");
      tt->struct_vals[7].d = -200;
      tt->struct_vals[8].d = -200;
      tt->struct_vals[9].d = 200;
      tt->struct_vals[10].d = 200;
      tt->struct_vals[11].e = ZOOM_LIMITS_IN_KM;
      tt->struct_vals[12].s = tdrpStrDup("300km");
      tt->struct_vals[13].d = -300;
      tt->struct_vals[14].d = -300;
      tt->struct_vals[15].d = 300;
      tt->struct_vals[16].d = 300;
      tt->struct_vals[17].e = ZOOM_LIMITS_IN_KM;
    tt++;
    
    // Parameter 'start_zoom_label'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("start_zoom_label");
    tt->descr = tdrpStrDup("Label of zoom level on which to start.");
    tt->help = tdrpStrDup("This specifies which zoom level is to be used when the display starts.");
    tt->val_offset = (char *) &start_zoom_label - &_start_;
    tt->single_val.s = tdrpStrDup("100km");
    tt++;
    
    // Parameter 'zoom_limits_in_latlon'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("zoom_limits_in_latlon");
    tt->descr = tdrpStrDup("The units of the zoom limits are in deg lat/lon.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &zoom_limits_in_latlon - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'num_cache_zooms'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("num_cache_zooms");
    tt->descr = tdrpStrDup("The number of Cached images for zooms.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &num_cache_zooms - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'min_zoom_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_zoom_threshold");
    tt->descr = tdrpStrDup("Minimum distance to zoom into to in KM.");
    tt->help = tdrpStrDup("Won't allow the user to define custom zooms small than this size (along the longest edge).");
    tt->val_offset = (char *) &min_zoom_threshold - &_start_;
    tt->single_val.d = 5;
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("Zoom domain limits.");
    tt->comment_text = tdrpStrDup("Overlays are clipped to this domain and pan/moves cannot exceed these edge limits. Note: Lucid does not pan on the outermost domain.\n\nNote: for Lat/Lon Domains, Choose 0-360, -90+90. to get whole earth.\n\nOne can also choose Longitude range -180 to 180, -90 to 270, etc.\nFor whole earth views, aspect ration 1.0,  set the outer most domain to -180 to 180 and -180 to 180. Otherwise, set the aspect ratio to 2.0 and use -180 to 180 and -90 to 90.");
    tt++;
    
    // Parameter 'domain_limit_min_x'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("domain_limit_min_x");
    tt->descr = tdrpStrDup("Minimum X for outer domain.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &domain_limit_min_x - &_start_;
    tt->single_val.d = -10000;
    tt++;
    
    // Parameter 'domain_limit_max_x'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("domain_limit_max_x");
    tt->descr = tdrpStrDup("Maximum X for outer domain.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &domain_limit_max_x - &_start_;
    tt->single_val.d = 10000;
    tt++;
    
    // Parameter 'domain_limit_min_y'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("domain_limit_min_y");
    tt->descr = tdrpStrDup("Minimum Y for outer domain.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &domain_limit_min_y - &_start_;
    tt->single_val.d = -10000;
    tt++;
    
    // Parameter 'domain_limit_max_y'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("domain_limit_max_y");
    tt->descr = tdrpStrDup("Maximum Y for outer domain.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &domain_limit_max_y - &_start_;
    tt->single_val.d = 10000;
    tt++;
    
    // Parameter 'zoom_domain_follows_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("zoom_domain_follows_data");
    tt->descr = tdrpStrDup("Plot domain moves with origin of the data set.");
    tt->help = tdrpStrDup("Intended for mobile platforms. Shift the zoom domain limits as the data origin shifts.");
    tt->val_offset = (char *) &zoom_domain_follows_data - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 20'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 20");
    tt->comment_hdr = tdrpStrDup("</ZOOM_DOMAINS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 21'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 21");
    tt->comment_hdr = tdrpStrDup("<GUI>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'num_field_menu_cols'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("num_field_menu_cols");
    tt->descr = tdrpStrDup("Set this parameter to force the field menu pop-up to this many columns.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &num_field_menu_cols - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'one_click_rhi'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("one_click_rhi");
    tt->descr = tdrpStrDup("This parameter allows the user to define a route/rhi with one mouse click and drag.");
    tt->help = tdrpStrDup("When set to TRUE, disallows multi way point cross sections. RHI are defined by clicking right mouse near the radar origin and dragging away from the radar along the desired  azimuth and releasing.");
    tt->val_offset = (char *) &one_click_rhi - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'rotate_coarse_adjust'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("rotate_coarse_adjust");
    tt->descr = tdrpStrDup("Lucid uses the number pad keys 7,9,4,6,1,3 to rotate the RHI by +/- these amounts (deg).");
    tt->help = tdrpStrDup("7-9 is coarse, 4-6 is medium, and 1-3 is fine.");
    tt->val_offset = (char *) &rotate_coarse_adjust - &_start_;
    tt->single_val.d = 6;
    tt++;
    
    // Parameter 'rotate_medium_adjust'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("rotate_medium_adjust");
    tt->descr = tdrpStrDup("Adjust RHI azimuth in medium mode.");
    tt->help = tdrpStrDup("Keys 4-6.");
    tt->val_offset = (char *) &rotate_medium_adjust - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'rotate_fine_adjust'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("rotate_fine_adjust");
    tt->descr = tdrpStrDup("Adjust RHI azimuth in fine mode.");
    tt->help = tdrpStrDup("Keys 1-3.");
    tt->val_offset = (char *) &rotate_fine_adjust - &_start_;
    tt->single_val.d = 0.5;
    tt++;
    
    // Parameter 'disable_pick_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("disable_pick_mode");
    tt->descr = tdrpStrDup("Disable pick feature.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &disable_pick_mode - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'close_popups'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("close_popups");
    tt->descr = tdrpStrDup("Close Lucid's pop ups When the main window is closed.");
    tt->help = tdrpStrDup("Set this to FALSE if you don't want Lucid to close its pop ups when switching between virtual desktops");
    tt->val_offset = (char *) &close_popups - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'status_info_file'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("status_info_file");
    tt->descr = tdrpStrDup("System NO-Data Status/Info File.");
    tt->help = tdrpStrDup("Will check for updates to this file, if it exists, and will replace the no_data_message with the text from this file. Leave blank if no file is to be checked.");
    tt->val_offset = (char *) &status_info_file - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'enable_status_window'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("enable_status_window");
    tt->descr = tdrpStrDup("Enable the status window.");
    tt->help = tdrpStrDup("If FALSE, no status window is displayed.");
    tt->val_offset = (char *) &enable_status_window - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'report_clicks_in_status_window'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("report_clicks_in_status_window");
    tt->descr = tdrpStrDup("Report clicks in the status window.");
    tt->help = tdrpStrDup("By default distance are in km and bearings in deg T.");
    tt->val_offset = (char *) &report_clicks_in_status_window - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'show_clock'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("show_clock");
    tt->descr = tdrpStrDup("Set TRUE for displaying an analog clock in the upper right hand corner of the image.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &show_clock - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'draw_clock_local'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("draw_clock_local");
    tt->descr = tdrpStrDup("Set TRUE for clock in local time.");
    tt->help = tdrpStrDup("Otherwise UTC.");
    tt->val_offset = (char *) &draw_clock_local - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_local_timestamps'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_local_timestamps");
    tt->descr = tdrpStrDup("TRUE: time stamps are local. FALSE: time stamps are UTC.");
    tt->help = tdrpStrDup("All Input time widgets expect UTC when FALSE, local times when set TRUE.");
    tt->val_offset = (char *) &use_local_timestamps - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'label_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("label_font_size");
    tt->descr = tdrpStrDup("Basic font size for labels (pixels).");
    tt->help = tdrpStrDup("Some of the labels are scaled relative to this size.");
    tt->val_offset = (char *) &label_font_size - &_start_;
    tt->single_val.i = 12;
    tt++;
    
    // Parameter 'range_ring_label_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("range_ring_label_font_size");
    tt->descr = tdrpStrDup("Font size for labels on range rings (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &range_ring_label_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'click_cross_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("click_cross_size");
    tt->descr = tdrpStrDup("Size of cross at click point (pixels).");
    tt->help = tdrpStrDup("Size of cross drawn at click point, to select data.");
    tt->val_offset = (char *) &click_cross_size - &_start_;
    tt->single_val.i = 11;
    tt++;
    
    // Parameter 'click_cross_line_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("click_cross_line_width");
    tt->descr = tdrpStrDup("Line width for click cross.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &click_cross_line_width - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'vlevel_selector_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_width");
    tt->descr = tdrpStrDup("Width of vlevel selector (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_width - &_start_;
    tt->single_val.i = 90;
    tt++;
    
    // Parameter 'vlevel_selector_top_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_top_margin");
    tt->descr = tdrpStrDup("Height of top margin in VLEVEL_SELECTOR mode (pixels).");
    tt->help = tdrpStrDup("Titles go in the top margin.");
    tt->val_offset = (char *) &vlevel_selector_top_margin - &_start_;
    tt->single_val.i = 70;
    tt++;
    
    // Parameter 'vlevel_selector_bottom_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_bottom_margin");
    tt->descr = tdrpStrDup("Height of bottom margin in VLEVEL_SELECTOR mode (pixels).");
    tt->help = tdrpStrDup("Time scale goes in the bottom margin.");
    tt->val_offset = (char *) &vlevel_selector_bottom_margin - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'vlevel_selector_left_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_left_margin");
    tt->descr = tdrpStrDup("Width of left margin in VLEVEL_SELECTOR mode (pixels).");
    tt->help = tdrpStrDup("Height scale goes in the left margin.");
    tt->val_offset = (char *) &vlevel_selector_left_margin - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'vlevel_selector_right_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_right_margin");
    tt->descr = tdrpStrDup("Width of right margin in VLEVEL_SELECTOR mode (pixels).");
    tt->help = tdrpStrDup("Height scale goes in the right margin.");
    tt->val_offset = (char *) &vlevel_selector_right_margin - &_start_;
    tt->single_val.i = 4;
    tt++;
    
    // Parameter 'vlevel_selector_axis_tick_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_axis_tick_len");
    tt->descr = tdrpStrDup("Length of ticks on axes (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_axis_tick_len - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'vlevel_selector_n_ticks_ideal'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_n_ticks_ideal");
    tt->descr = tdrpStrDup("Ideal number of ticks on axes.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_n_ticks_ideal - &_start_;
    tt->single_val.i = 16;
    tt++;
    
    // Parameter 'vlevel_selector_axis_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_axis_text_margin");
    tt->descr = tdrpStrDup("Margin around some text (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_axis_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'vlevel_selector_title_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_title_font_size");
    tt->descr = tdrpStrDup("Font size of center title (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_title_font_size - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'vlevel_selector_labels_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_labels_font_size");
    tt->descr = tdrpStrDup("Font size of axis labels in vlevel_selector (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_labels_font_size - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'vlevel_selector_background_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_background_color");
    tt->descr = tdrpStrDup("Color of background in vlevel selector.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_background_color - &_start_;
    tt->single_val.s = tdrpStrDup("darkslateblue");
    tt++;
    
    // Parameter 'vlevel_selector_title_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_title_color");
    tt->descr = tdrpStrDup("Color of titles in vlevel selector.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_title_color - &_start_;
    tt->single_val.s = tdrpStrDup("orange");
    tt++;
    
    // Parameter 'vlevel_selector_axis_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_axis_color");
    tt->descr = tdrpStrDup("Color of axes in vlevel selector.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_axis_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'vlevel_selector_labels_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_labels_color");
    tt->descr = tdrpStrDup("Color of labels in vlevel_selector.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_labels_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'vlevel_selector_marker_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_marker_color");
    tt->descr = tdrpStrDup("Color of selection marker in vlevel selector.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_marker_color - &_start_;
    tt->single_val.s = tdrpStrDup("orange");
    tt++;
    
    // Parameter 'vlevel_selector_data_values_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vlevel_selector_data_values_color");
    tt->descr = tdrpStrDup("Color of data values in vlevel selector.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vlevel_selector_data_values_color - &_start_;
    tt->single_val.s = tdrpStrDup("cyan");
    tt++;
    
    // Parameter 'Comment 22'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 22");
    tt->comment_hdr = tdrpStrDup("</GUI>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 23'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 23");
    tt->comment_hdr = tdrpStrDup("<WINDOWS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'horiz_window_x_pos'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_window_x_pos");
    tt->descr = tdrpStrDup("Startup X for main horizontal window (pixels).");
    tt->help = tdrpStrDup("This is relative to the top left corner of the screen, which is (0,0). In screen coordinates x is positive downwards.");
    tt->val_offset = (char *) &horiz_window_x_pos - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'horiz_window_y_pos'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_window_y_pos");
    tt->descr = tdrpStrDup("Startup Y for main horizontal window (pixels).");
    tt->help = tdrpStrDup("This is relative to the top left corner of the screen, which is (0,0). In screen coordinates y is positive to the right.");
    tt->val_offset = (char *) &horiz_window_y_pos - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'horiz_plot_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_plot_width");
    tt->descr = tdrpStrDup("Startup width of horizontal plot (pixels).");
    tt->help = tdrpStrDup("This is for the plot only. It does not include color scale width.");
    tt->val_offset = (char *) &horiz_plot_width - &_start_;
    tt->single_val.i = 1000;
    tt++;
    
    // Parameter 'horiz_plot_height'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_plot_height");
    tt->descr = tdrpStrDup("Startup height of horizontal plot (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_plot_height - &_start_;
    tt->single_val.i = 1000;
    tt++;
    
    // Parameter 'horiz_color_scale_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_color_scale_width");
    tt->descr = tdrpStrDup("Width of color scale (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_color_scale_width - &_start_;
    tt->single_val.i = 40;
    tt++;
    
    // Parameter 'vert_window_x_pos'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_x_pos");
    tt->descr = tdrpStrDup("Startup X for vertical view window (pixels).");
    tt->help = tdrpStrDup("This is relative to the top left corner of the screen, which is (0,0). In screen coordinates x is positive downwards. If -1 the position will be automatically determined.");
    tt->val_offset = (char *) &vert_window_x_pos - &_start_;
    tt->single_val.i = -1;
    tt++;
    
    // Parameter 'vert_window_y_pos'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_y_pos");
    tt->descr = tdrpStrDup("Startup Y for vertical view window (pixels).");
    tt->help = tdrpStrDup("This is relative to the top left corner of the screen, which is (0,0). In screen coordinates y is positive to the right. If -1 the position will be automatically determined.");
    tt->val_offset = (char *) &vert_window_y_pos - &_start_;
    tt->single_val.i = -1;
    tt++;
    
    // Parameter 'vert_plot_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_plot_width");
    tt->descr = tdrpStrDup("Startup width of vertical plot (pixels).");
    tt->help = tdrpStrDup("This is for the plot only. It does not include color scale width.");
    tt->val_offset = (char *) &vert_plot_width - &_start_;
    tt->single_val.i = 1000;
    tt++;
    
    // Parameter 'vert_plot_height'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_plot_height");
    tt->descr = tdrpStrDup("Startup height of vertical plot (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_plot_height - &_start_;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'horiz_window_min_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_window_min_width");
    tt->descr = tdrpStrDup("Minimum width of main window (pixels).");
    tt->help = tdrpStrDup("The user cannot shrink the main window smaller than this.");
    tt->val_offset = (char *) &horiz_window_min_width - &_start_;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'horiz_window_min_height'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_window_min_height");
    tt->descr = tdrpStrDup("Minimum height of main window (pixels).");
    tt->help = tdrpStrDup("The user cannot shrink the main window smaller than this.");
    tt->val_offset = (char *) &horiz_window_min_height - &_start_;
    tt->single_val.i = 400;
    tt++;
    
    // Parameter 'vert_window_min_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_min_width");
    tt->descr = tdrpStrDup("Minimum width of vertical window (pixels).");
    tt->help = tdrpStrDup("The user cannot shrink the vertical window smaller than this.");
    tt->val_offset = (char *) &vert_window_min_width - &_start_;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'vert_window_min_height'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_min_height");
    tt->descr = tdrpStrDup("Minimum height of vertical window (pixels).");
    tt->help = tdrpStrDup("The user cannot shrink the vertical window smaller than this.");
    tt->val_offset = (char *) &vert_window_min_height - &_start_;
    tt->single_val.i = 400;
    tt++;
    
    // Parameter 'Comment 24'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 24");
    tt->comment_hdr = tdrpStrDup("</WINDOWS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 25'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 25");
    tt->comment_hdr = tdrpStrDup("<HORIZ_VIEW>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'label_time_format'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("label_time_format");
    tt->descr = tdrpStrDup("Set the format for the time strings.");
    tt->help = tdrpStrDup("See 'man strftime' for format options. Can add additional text as part of the Time string.");
    tt->val_offset = (char *) &label_time_format - &_start_;
    tt->single_val.s = tdrpStrDup("%Y/%m/%d %H:%M:%S");
    tt++;
    
    // Parameter 'frame_range_time_format'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("frame_range_time_format");
    tt->descr = tdrpStrDup("Set the format for the time strings in the frame range text fields.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &frame_range_time_format - &_start_;
    tt->single_val.s = tdrpStrDup("%H:%M");
    tt++;
    
    // Parameter 'layer_legends_on'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("layer_legends_on");
    tt->descr = tdrpStrDup("Plot a Legend for each Grid overlay.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &layer_legends_on - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'cont_legends_on'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("cont_legends_on");
    tt->descr = tdrpStrDup("Plot a Legend for each Contour overlay.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cont_legends_on - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'wind_legends_on'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("wind_legends_on");
    tt->descr = tdrpStrDup("Plot a Legend for each Wind overlay.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &wind_legends_on - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'display_labels'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("display_labels");
    tt->descr = tdrpStrDup("Switch to turn off all data labels on the display.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &display_labels - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'display_ref_lines'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("display_ref_lines");
    tt->descr = tdrpStrDup("Switch to turn on/off Height, Route and Wind Scale reference lines.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &display_ref_lines - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'horiz_top_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_top_margin");
    tt->descr = tdrpStrDup("Height of top margin (pixels).");
    tt->help = tdrpStrDup("Size of top margin for horiz window.");
    tt->val_offset = (char *) &horiz_top_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'horiz_bot_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_bot_margin");
    tt->descr = tdrpStrDup("Height of bottom margin (pixels).");
    tt->help = tdrpStrDup("Size of bottom margin for horiz window.");
    tt->val_offset = (char *) &horiz_bot_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'horiz_left_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_left_margin");
    tt->descr = tdrpStrDup("Width of left margin (pixels).");
    tt->help = tdrpStrDup("Size of left margin for horiz window.");
    tt->val_offset = (char *) &horiz_left_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'horiz_right_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_right_margin");
    tt->descr = tdrpStrDup("Width of right margin (pixels).");
    tt->help = tdrpStrDup("Size of right margin for horiz window.");
    tt->val_offset = (char *) &horiz_right_margin - &_start_;
    tt->single_val.i = 6;
    tt++;
    
    // Parameter 'horiz_title_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_title_text_margin");
    tt->descr = tdrpStrDup("Width of title text margin (pixels).");
    tt->help = tdrpStrDup("Size of title test margin for horiz window.");
    tt->val_offset = (char *) &horiz_title_text_margin - &_start_;
    tt->single_val.i = 6;
    tt++;
    
    // Parameter 'horiz_legend_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_legend_text_margin");
    tt->descr = tdrpStrDup("Width of legend text margin (pixels).");
    tt->help = tdrpStrDup("Size of legend test margin for horiz window.");
    tt->val_offset = (char *) &horiz_legend_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'horiz_legend_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_legend_color");
    tt->descr = tdrpStrDup("Color for legends in horizontal plot.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_legend_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'horiz_axis_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_axis_text_margin");
    tt->descr = tdrpStrDup("Width of axis text margin (pixels).");
    tt->help = tdrpStrDup("Size of axis test margin for horiz window.");
    tt->val_offset = (char *) &horiz_axis_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'horiz_axis_tick_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_axis_tick_len");
    tt->descr = tdrpStrDup("Length of ticks on axes (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_axis_tick_len - &_start_;
    tt->single_val.i = 6;
    tt++;
    
    // Parameter 'horiz_n_ticks_ideal'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_n_ticks_ideal");
    tt->descr = tdrpStrDup("Ideal number of ticks on axes.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_n_ticks_ideal - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'horiz_title_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_title_font_size");
    tt->descr = tdrpStrDup("Font size of center title (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_title_font_size - &_start_;
    tt->single_val.i = 12;
    tt++;
    
    // Parameter 'horiz_axis_label_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_axis_label_font_size");
    tt->descr = tdrpStrDup("Font size of axis labels in horiz view (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_axis_label_font_size - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'horiz_tick_values_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_tick_values_font_size");
    tt->descr = tdrpStrDup("Font size of tick values (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_tick_values_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'horiz_tick_values_inside'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("horiz_tick_values_inside");
    tt->descr = tdrpStrDup("Draw tick value labels inside the plot.");
    tt->help = tdrpStrDup("If FALSE the value labels will be drawn in the margins.");
    tt->val_offset = (char *) &horiz_tick_values_inside - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'horiz_legend_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("horiz_legend_font_size");
    tt->descr = tdrpStrDup("Font size of legends (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_legend_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'horiz_title_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_title_color");
    tt->descr = tdrpStrDup("Color for title text.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_title_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'horiz_axes_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_axes_color");
    tt->descr = tdrpStrDup("Color for axes.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_axes_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'horiz_grid_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_grid_color");
    tt->descr = tdrpStrDup("Color for grid (if plotted).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_grid_color - &_start_;
    tt->single_val.s = tdrpStrDup("gray");
    tt++;
    
    // Parameter 'horiz_grids_on_at_startup'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("horiz_grids_on_at_startup");
    tt->descr = tdrpStrDup("Set HORIZ grids overlay on at startup.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_grids_on_at_startup - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'horiz_main_legend_pos'
    // ctype is '_legend_pos_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("horiz_main_legend_pos");
    tt->descr = tdrpStrDup("Position of main legend in the HORIZ plot window");
    tt->help = tdrpStrDup("This include time, field name and elevation angle.");
    tt->val_offset = (char *) &horiz_main_legend_pos - &_start_;
    tt->enum_def.name = tdrpStrDup("legend_pos_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("LEGEND_TOP_LEFT");
      tt->enum_def.fields[0].val = LEGEND_TOP_LEFT;
      tt->enum_def.fields[1].name = tdrpStrDup("LEGEND_TOP_RIGHT");
      tt->enum_def.fields[1].val = LEGEND_TOP_RIGHT;
      tt->enum_def.fields[2].name = tdrpStrDup("LEGEND_BOTTOM_LEFT");
      tt->enum_def.fields[2].val = LEGEND_BOTTOM_LEFT;
      tt->enum_def.fields[3].name = tdrpStrDup("LEGEND_BOTTOM_RIGHT");
      tt->enum_def.fields[3].val = LEGEND_BOTTOM_RIGHT;
    tt->single_val.e = LEGEND_TOP_LEFT;
    tt++;
    
    // Parameter 'horiz_override_rendering_beam_width'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("horiz_override_rendering_beam_width");
    tt->descr = tdrpStrDup("Option to override the azimuth beam width for rendering.");
    tt->help = tdrpStrDup("Normally Lucid determines the azimuth rendering beam width automatically. You can override this and specifcally set the azimuth beam width for rendering.");
    tt->val_offset = (char *) &horiz_override_rendering_beam_width - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'horiz_rendering_beam_width'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("horiz_rendering_beam_width");
    tt->descr = tdrpStrDup("Rendering beam width, if override is active.");
    tt->help = tdrpStrDup("See 'horiz_override_rendering_beam_width'");
    tt->val_offset = (char *) &horiz_rendering_beam_width - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 26'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 26");
    tt->comment_hdr = tdrpStrDup("</HORIZ_VIEW>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 27'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 27");
    tt->comment_hdr = tdrpStrDup("<VERT_VIEW>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 28'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 28");
    tt->comment_hdr = tdrpStrDup("Vertical Range and Resolution - Establishes a vertical coordinate system for the cross sectional imagery.");
    tt->comment_text = tdrpStrDup(" All data must map into this range for it to be visible.\n\tmin_ht is value nearest the ground - Plotted at the bottom.\n\tmax_ht is the value furtherest from the ground - Plotted at the top.\n\nUnits are ignored and no inter conversions or re-mappings are performed.\n\nReturned cross sections are are often km, but could be sigma, pressure or degrees elevation.\n\nExamples:\n\tSigma : min_ht = 1.0, max_ht = 0.0, ht_interval = .1\n\tPressure : min_ht = 1100.0, max_ht = 100.0, ht_interval = -100\n\tRadial Radar:  min_ht = 0.0 max_ht = 25.0, ht_interval = 1.0");
    tt++;
    
    // Parameter 'min_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_ht");
    tt->descr = tdrpStrDup("Minimum ht of cross section.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &min_ht - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'max_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_ht");
    tt->descr = tdrpStrDup("Maximum ht of cross section.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &max_ht - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'start_ht'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("start_ht");
    tt->descr = tdrpStrDup("Starting height of horizontal view.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &start_ht - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'vert_top_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_top_margin");
    tt->descr = tdrpStrDup("Height of top margin (pixels).");
    tt->help = tdrpStrDup("Size of top margin for vert section window.");
    tt->val_offset = (char *) &vert_top_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_bot_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_bot_margin");
    tt->descr = tdrpStrDup("Height of bottom margin (pixels).");
    tt->help = tdrpStrDup("Size of bottom margin for vert section window.");
    tt->val_offset = (char *) &vert_bot_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_left_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_left_margin");
    tt->descr = tdrpStrDup("Width of left margin (pixels).");
    tt->help = tdrpStrDup("Size of left margin for vert section window.");
    tt->val_offset = (char *) &vert_left_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_right_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_right_margin");
    tt->descr = tdrpStrDup("Width of right margin (pixels).");
    tt->help = tdrpStrDup("Size of right margin for vert section window.");
    tt->val_offset = (char *) &vert_right_margin - &_start_;
    tt->single_val.i = 80;
    tt++;
    
    // Parameter 'vert_title_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_title_text_margin");
    tt->descr = tdrpStrDup("Width of title text margin (pixels).");
    tt->help = tdrpStrDup("Size of title test margin for vert window.");
    tt->val_offset = (char *) &vert_title_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'vert_legend_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_legend_text_margin");
    tt->descr = tdrpStrDup("Width of legend text margin (pixels).");
    tt->help = tdrpStrDup("Size of legend test margin for vert window.");
    tt->val_offset = (char *) &vert_legend_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'vert_axis_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_axis_text_margin");
    tt->descr = tdrpStrDup("Width of axis text margin (pixels).");
    tt->help = tdrpStrDup("Size of axis test margin for vert window.");
    tt->val_offset = (char *) &vert_axis_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'vert_axis_tick_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_axis_tick_len");
    tt->descr = tdrpStrDup("Length of ticks on axes (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_axis_tick_len - &_start_;
    tt->single_val.i = 7;
    tt++;
    
    // Parameter 'vert_n_ticks_ideal'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_n_ticks_ideal");
    tt->descr = tdrpStrDup("Ideal number of ticks on axes.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_n_ticks_ideal - &_start_;
    tt->single_val.i = 7;
    tt++;
    
    // Parameter 'vert_title_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_title_font_size");
    tt->descr = tdrpStrDup("Font size of center title (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_title_font_size - &_start_;
    tt->single_val.i = 12;
    tt++;
    
    // Parameter 'vert_axis_label_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_axis_label_font_size");
    tt->descr = tdrpStrDup("Font size of axis labels in vert (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_axis_label_font_size - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'vert_tick_values_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_tick_values_font_size");
    tt->descr = tdrpStrDup("Font size of tick values (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_tick_values_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'vert_tick_values_inside'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vert_tick_values_inside");
    tt->descr = tdrpStrDup("Draw tick value labels inside the plot.");
    tt->help = tdrpStrDup("If FALSE the value labels will be drawn in the margins.");
    tt->val_offset = (char *) &vert_tick_values_inside - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vert_legend_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_legend_font_size");
    tt->descr = tdrpStrDup("Font size of legends (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_legend_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'vert_title_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_title_color");
    tt->descr = tdrpStrDup("Color for title text.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_title_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'vert_axes_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_axes_color");
    tt->descr = tdrpStrDup("Color for axes.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_axes_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'vert_grid_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_grid_color");
    tt->descr = tdrpStrDup("Color for grid (if plotted).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_grid_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'vert_window_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_width");
    tt->descr = tdrpStrDup("Startup width of VERT window (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_window_width - &_start_;
    tt->single_val.i = 500;
    tt++;
    
    // Parameter 'vert_window_height'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_height");
    tt->descr = tdrpStrDup("Startup height of VERT window (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_window_height - &_start_;
    tt->single_val.i = 500;
    tt++;
    
    // Parameter 'vert_window_start_x'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_start_x");
    tt->descr = tdrpStrDup("Startup X for VERT window (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_window_start_x - &_start_;
    tt->single_val.i = 1100;
    tt++;
    
    // Parameter 'vert_window_start_y'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_window_start_y");
    tt->descr = tdrpStrDup("Startup Y for VERT window (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_window_start_y - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'vert_top_margin2'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_top_margin2");
    tt->descr = tdrpStrDup("Height of top margin in VERT mode (pixels).");
    tt->help = tdrpStrDup("Titles go in the top margin.");
    tt->val_offset = (char *) &vert_top_margin2 - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_bottom_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_bottom_margin");
    tt->descr = tdrpStrDup("Height of bottom margin in VERT mode (pixels).");
    tt->help = tdrpStrDup("Time scale goes in the bottom margin.");
    tt->val_offset = (char *) &vert_bottom_margin - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_left_margin2'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_left_margin2");
    tt->descr = tdrpStrDup("Width of left margin in VERT mode (pixels).");
    tt->help = tdrpStrDup("Height scale goes in the left margin.");
    tt->val_offset = (char *) &vert_left_margin2 - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_right_margin2'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_right_margin2");
    tt->descr = tdrpStrDup("Width of right margin in VERT mode (pixels).");
    tt->help = tdrpStrDup("Height scale goes in the right margin.");
    tt->val_offset = (char *) &vert_right_margin2 - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'vert_label_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_label_font_size");
    tt->descr = tdrpStrDup("Font size for labels on range rings (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_label_font_size - &_start_;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'vert_text_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_text_margin");
    tt->descr = tdrpStrDup("Margin around some text (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_text_margin - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'vert_max_height_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("vert_max_height_km");
    tt->descr = tdrpStrDup("Max height of data in VERT window (km).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_max_height_km - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'vert_color_scale_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_color_scale_width");
    tt->descr = tdrpStrDup("Width of color scale for VERT window (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_color_scale_width - &_start_;
    tt->single_val.i = 40;
    tt++;
    
    // Parameter 'vert_grids_on_at_startup'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vert_grids_on_at_startup");
    tt->descr = tdrpStrDup("Set VERT grids overlay on at startup.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vert_grids_on_at_startup - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'vert_main_legend_pos'
    // ctype is '_legend_pos_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("vert_main_legend_pos");
    tt->descr = tdrpStrDup("Position of main legend in the VERT plot window");
    tt->help = tdrpStrDup("This include time, field name and elevation angle.");
    tt->val_offset = (char *) &vert_main_legend_pos - &_start_;
    tt->enum_def.name = tdrpStrDup("legend_pos_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("LEGEND_TOP_LEFT");
      tt->enum_def.fields[0].val = LEGEND_TOP_LEFT;
      tt->enum_def.fields[1].name = tdrpStrDup("LEGEND_TOP_RIGHT");
      tt->enum_def.fields[1].val = LEGEND_TOP_RIGHT;
      tt->enum_def.fields[2].name = tdrpStrDup("LEGEND_BOTTOM_LEFT");
      tt->enum_def.fields[2].val = LEGEND_BOTTOM_LEFT;
      tt->enum_def.fields[3].name = tdrpStrDup("LEGEND_BOTTOM_RIGHT");
      tt->enum_def.fields[3].val = LEGEND_BOTTOM_RIGHT;
    tt->single_val.e = LEGEND_TOP_LEFT;
    tt++;
    
    // Parameter 'vert_beam_queue_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vert_beam_queue_size");
    tt->descr = tdrpStrDup("Size of the queue for VERT beams.");
    tt->help = tdrpStrDup("After the queue reaches this size, older beams are discarded.");
    tt->val_offset = (char *) &vert_beam_queue_size - &_start_;
    tt->single_val.i = 360;
    tt++;
    
    // Parameter 'vert_override_rendering_beam_width'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vert_override_rendering_beam_width");
    tt->descr = tdrpStrDup("Option to override the azimuth beam width for rendering.");
    tt->help = tdrpStrDup("Normally Lucid determines the azimuth rendering beam width automatically. You can override this and specifcally set the azimuth beam width for rendering.");
    tt->val_offset = (char *) &vert_override_rendering_beam_width - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vert_rendering_beam_width'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("vert_rendering_beam_width");
    tt->descr = tdrpStrDup("Rendering beam width, if override is active.");
    tt->help = tdrpStrDup("See 'vert_override_rendering_beam_width'");
    tt->val_offset = (char *) &vert_rendering_beam_width - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 29'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 29");
    tt->comment_hdr = tdrpStrDup("</VERT_VIEW>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 30'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 30");
    tt->comment_hdr = tdrpStrDup("<COLORS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'foreground_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("foreground_color");
    tt->descr = tdrpStrDup("Legends, scales.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &foreground_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'background_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("background_color");
    tt->descr = tdrpStrDup("Background of images.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &background_color - &_start_;
    tt->single_val.s = tdrpStrDup("black");
    tt++;
    
    // Parameter 'background_color2'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("background_color2");
    tt->descr = tdrpStrDup("Color of main display background.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &background_color2 - &_start_;
    tt->single_val.s = tdrpStrDup("black");
    tt++;
    
    // Parameter 'text_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("text_color");
    tt->descr = tdrpStrDup("Color of text annotation in main display.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &text_color - &_start_;
    tt->single_val.s = tdrpStrDup("white");
    tt++;
    
    // Parameter 'click_cross_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("click_cross_color");
    tt->descr = tdrpStrDup("Color of cross at click point.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &click_cross_color - &_start_;
    tt->single_val.s = tdrpStrDup("cyan");
    tt++;
    
    // Parameter 'margin_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("margin_color");
    tt->descr = tdrpStrDup("Background of margins.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &margin_color - &_start_;
    tt->single_val.s = tdrpStrDup("black");
    tt++;
    
    // Parameter 'out_of_range_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("out_of_range_color");
    tt->descr = tdrpStrDup("Render values outside the data range of the color scale.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &out_of_range_color - &_start_;
    tt->single_val.s = tdrpStrDup("transparent");
    tt++;
    
    // Parameter 'route_path_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("route_path_color");
    tt->descr = tdrpStrDup("Color of the cross section reference line.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &route_path_color - &_start_;
    tt->single_val.s = tdrpStrDup("yellow");
    tt++;
    
    // Parameter 'time_axis_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("time_axis_color");
    tt->descr = tdrpStrDup("Text in the time axis margins.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &time_axis_color - &_start_;
    tt->single_val.s = tdrpStrDup("pink");
    tt++;
    
    // Parameter 'time_frame_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("time_frame_color");
    tt->descr = tdrpStrDup("A solid rectangle showing the movie frame extent.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &time_frame_color - &_start_;
    tt->single_val.s = tdrpStrDup("gray50");
    tt++;
    
    // Parameter 'height_axis_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("height_axis_color");
    tt->descr = tdrpStrDup("The text in the height selector margin.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &height_axis_color - &_start_;
    tt->single_val.s = tdrpStrDup("pink");
    tt++;
    
    // Parameter 'height_indicator_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("height_indicator_color");
    tt->descr = tdrpStrDup("A solid rectangle showing the height extent of the data plane.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &height_indicator_color - &_start_;
    tt->single_val.s = tdrpStrDup("gray50");
    tt++;
    
    // Parameter 'range_rings_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("range_rings_color");
    tt->descr = tdrpStrDup("Range rings and azimuth lines.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &range_rings_color - &_start_;
    tt->single_val.s = tdrpStrDup("grey");
    tt++;
    
    // Parameter 'missing_data_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("missing_data_color");
    tt->descr = tdrpStrDup("Set to 'transparent' to avoid having these plotted. ");
    tt->help = tdrpStrDup("Otherwise, these data will be plotted in the indicated color.");
    tt->val_offset = (char *) &missing_data_color - &_start_;
    tt->single_val.s = tdrpStrDup("transparent");
    tt++;
    
    // Parameter 'bad_data_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("bad_data_color");
    tt->descr = tdrpStrDup("Set to 'transparent' to avoid having these plotted. ");
    tt->help = tdrpStrDup("Otherwise, these data will be plotted in the indicated color.");
    tt->val_offset = (char *) &bad_data_color - &_start_;
    tt->single_val.s = tdrpStrDup("transparent");
    tt++;
    
    // Parameter 'epoch_indicator_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("epoch_indicator_color");
    tt->descr = tdrpStrDup("Time Control (Movie) Pop-up Colors.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &epoch_indicator_color - &_start_;
    tt->single_val.s = tdrpStrDup("orange");
    tt++;
    
    // Parameter 'now_time_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("now_time_color");
    tt->descr = tdrpStrDup("Color of current time tick.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &now_time_color - &_start_;
    tt->single_val.s = tdrpStrDup("red");
    tt++;
    
    // Parameter 'time_tick_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("time_tick_color");
    tt->descr = tdrpStrDup("Color of time ticks - main grid.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &time_tick_color - &_start_;
    tt->single_val.s = tdrpStrDup("yellow");
    tt++;
    
    // Parameter 'time_tick_colors'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("time_tick_colors");
    tt->descr = tdrpStrDup("List of colors for time ticks for symbolic products.");
    tt->help = tdrpStrDup("The time ticks are drawn in order, from top down, in the time control GUI.");
    tt->array_offset = (char *) &_time_tick_colors - &_start_;
    tt->array_n_offset = (char *) &time_tick_colors_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 6;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("cyan");
      tt->array_vals[1].s = tdrpStrDup("yellow");
      tt->array_vals[2].s = tdrpStrDup("magenta");
      tt->array_vals[3].s = tdrpStrDup("green");
      tt->array_vals[4].s = tdrpStrDup("red");
      tt->array_vals[5].s = tdrpStrDup("blue");
    tt++;
    
    // Parameter 'Comment 31'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 31");
    tt->comment_hdr = tdrpStrDup("</COLORS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 32'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 32");
    tt->comment_hdr = tdrpStrDup("<OVERLAYS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'plot_range_rings_fixed'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("plot_range_rings_fixed");
    tt->descr = tdrpStrDup("Plot range rings at fixed locations.");
    tt->help = tdrpStrDup("If TRUE, range rings will be plotted at a set of fixed locations. By default this will be at the origin. See 'plot_fixed_rings_at_origin. Additional locations can be added. See 'plot_fixed_rings_at_added_locations'.");
    tt->val_offset = (char *) &plot_range_rings_fixed - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'plot_fixed_rings_at_origin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("plot_fixed_rings_at_origin");
    tt->descr = tdrpStrDup("Plot fixed range rings at the origin.");
    tt->help = tdrpStrDup("If TRUE, a set of fixed range rings will be plotted at proj_origin_lat/proj_origin_lon.");
    tt->val_offset = (char *) &plot_fixed_rings_at_origin - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'plot_fixed_rings_at_added_locations'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("plot_fixed_rings_at_added_locations");
    tt->descr = tdrpStrDup("Plot fixed range rings at additional specified points.");
    tt->help = tdrpStrDup("If TRUE, fixed range rings will be plotted at the locations specified by 'fixed_rings_locations.");
    tt->val_offset = (char *) &plot_fixed_rings_at_added_locations - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'fixed_ring_locations'
    // ctype is '_range_ring_origin_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fixed_ring_locations");
    tt->descr = tdrpStrDup("Locations for additional fixed rings.");
    tt->help = tdrpStrDup("/nlabel: name of radar or point. /nlatitude_deg: latitude of ring origin./nlongitude_deg: longitude of ring origin./n");
    tt->array_offset = (char *) &_fixed_ring_locations - &_start_;
    tt->array_n_offset = (char *) &fixed_ring_locations_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(range_ring_origin_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("range_ring_origin_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("label");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fixed_ring_locations->label - (char *) _fixed_ring_locations;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("latitude_deg");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fixed_ring_locations->latitude_deg - (char *) _fixed_ring_locations;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("longitude_deg");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_fixed_ring_locations->longitude_deg - (char *) _fixed_ring_locations;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("radar1");
      tt->struct_vals[1].d = 40;
      tt->struct_vals[2].d = -105;
      tt->struct_vals[3].s = tdrpStrDup("radar2");
      tt->struct_vals[4].d = 38;
      tt->struct_vals[5].d = -98;
    tt++;
    
    // Parameter 'plot_range_rings_from_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("plot_range_rings_from_data");
    tt->descr = tdrpStrDup("Plot range rings at origin of data fields.");
    tt->help = tdrpStrDup("If TRUE, range rings will be plotted at the origin of the data fields read in.");
    tt->val_offset = (char *) &plot_range_rings_from_data - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'range_rings_for_radar_only'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("range_rings_for_radar_only");
    tt->descr = tdrpStrDup("Plot data-driven range rings only for radar data sets.");
    tt->help = tdrpStrDup("If TRUE, range rings will be plotted at the location of the radar in radar fields.");
    tt->val_offset = (char *) &range_rings_for_radar_only - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'range_ring_spacing_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("range_ring_spacing_km");
    tt->descr = tdrpStrDup("Spacing between range rings (km).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &range_ring_spacing_km - &_start_;
    tt->single_val.d = 50;
    tt++;
    
    // Parameter 'max_ring_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_ring_range_km");
    tt->descr = tdrpStrDup("Maximum range ring (km)");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &max_ring_range_km - &_start_;
    tt->single_val.d = 500;
    tt++;
    
    // Parameter 'min_pixels_per_range_ring'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_pixels_per_range_ring");
    tt->descr = tdrpStrDup("Minimum ring spacing in pixels.");
    tt->help = tdrpStrDup("If there are fewer than this number of pixels per ring, the rings are not shown.");
    tt->val_offset = (char *) &min_pixels_per_range_ring - &_start_;
    tt->single_val.i = 15;
    tt++;
    
    // Parameter 'range_ring_follows_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("range_ring_follows_data");
    tt->descr = tdrpStrDup("Plot range rings relative to radar location.");
    tt->help = tdrpStrDup("We get the location from the data. If FALSE, rings are relative to plot origin.");
    tt->val_offset = (char *) &range_ring_follows_data - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'range_ring_x_space'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("range_ring_x_space");
    tt->descr = tdrpStrDup("Spacing in x for range ring labels (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &range_ring_x_space - &_start_;
    tt->single_val.i = 50;
    tt++;
    
    // Parameter 'range_ring_y_space'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("range_ring_y_space");
    tt->descr = tdrpStrDup("Spacing in y for range ring labels (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &range_ring_y_space - &_start_;
    tt->single_val.i = 15;
    tt++;
    
    // Parameter 'range_ring_labels'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("range_ring_labels");
    tt->descr = tdrpStrDup("Plot range ring labels.");
    tt->help = tdrpStrDup("Label the range for each ring.");
    tt->val_offset = (char *) &range_ring_labels - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'azimuth_lines_spacing_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("azimuth_lines_spacing_deg");
    tt->descr = tdrpStrDup("Spacing for azimuth lines plotted with range rings (deg).");
    tt->help = tdrpStrDup("The azimuth lines start at 0, and rotate clockwise from there.");
    tt->val_offset = (char *) &azimuth_lines_spacing_deg - &_start_;
    tt->single_val.d = 30;
    tt++;
    
    // Parameter 'clip_overlay_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("clip_overlay_fields");
    tt->descr = tdrpStrDup("The default behavior is to render the overlay fields using the same render method as the primary field.");
    tt->help = tdrpStrDup("Lucid can Render Overlay fields using filled polygons, and clip the data between some minimum and maximum. This is useful, for example, if one wants to show Radar data over +40dB overlaid on satellite imagery.");
    tt->val_offset = (char *) &clip_overlay_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'horiz_frame_label'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_frame_label");
    tt->descr = tdrpStrDup("Label in top bar of main window.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horiz_frame_label - &_start_;
    tt->single_val.s = tdrpStrDup("Lucid");
    tt++;
    
    // Parameter 'no_data_message'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("no_data_message");
    tt->descr = tdrpStrDup("Message to display when no data is found.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &no_data_message - &_start_;
    tt->single_val.s = tdrpStrDup("NO DATA FOUND (in this area at the selected time)");
    tt++;
    
    // Parameter 'Comment 33'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 33");
    tt->comment_hdr = tdrpStrDup("</OVERLAYS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 34'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 34");
    tt->comment_hdr = tdrpStrDup("<RENDERING>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 35'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 35");
    tt->comment_hdr = tdrpStrDup("Plotting contours in data fields.");
    tt->comment_text = tdrpStrDup("In the FIELDS section you can select contour plotting.");
    tt++;
    
    // Parameter 'contour_fields'
    // ctype is '_contour_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("contour_fields");
    tt->descr = tdrpStrDup("Fields to be contoured.");
    tt->help = tdrpStrDup("/nfield_name: name of field in GRIDS list. /ncolor: color for contour lines. /non_at_startup: field on when app starts./n");
    tt->array_offset = (char *) &_contour_fields - &_start_;
    tt->array_n_offset = (char *) &contour_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(contour_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("contour_field_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_contour_fields->field_name - (char *) _contour_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("color");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_contour_fields->color - (char *) _contour_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[2].fname = tdrpStrDup("on_at_startup");
      tt->struct_def.fields[2].ptype = BOOL_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_contour_fields->on_at_startup - (char *) _contour_fields;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("FzLevel");
      tt->struct_vals[1].s = tdrpStrDup("red");
      tt->struct_vals[2].b = pFALSE;
      tt->struct_vals[3].s = tdrpStrDup("SURF_T");
      tt->struct_vals[4].s = tdrpStrDup("white");
      tt->struct_vals[5].b = pTRUE;
    tt++;
    
    // Parameter 'label_contours'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("label_contours");
    tt->descr = tdrpStrDup("Set to TRUE to have numeric labels on line contours.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &label_contours - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'contour_line_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("contour_line_width");
    tt->descr = tdrpStrDup("Width of contour lines.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &contour_line_width - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'smooth_contours'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("smooth_contours");
    tt->descr = tdrpStrDup("Apply smoothing to data grids before contouring.");
    tt->help = tdrpStrDup("0 = Off, 1 = single pass, 2 = double pass.");
    tt->val_offset = (char *) &smooth_contours - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'use_alt_contours'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_alt_contours");
    tt->descr = tdrpStrDup("Use Alternate (Mdvx) Contouring Routines.");
    tt->help = tdrpStrDup("Slower - Nicer labeling - Less smooth. Warning - Does not work correctly when data and display origins are different. Works fine in lat/lon projections");
    tt->val_offset = (char *) &use_alt_contours - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'add_noise'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_noise");
    tt->descr = tdrpStrDup("Add 1 part in 250 Noise to help smooth contours.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_noise - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'special_contour_value'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("special_contour_value");
    tt->descr = tdrpStrDup("Specify special contour value.");
    tt->help = tdrpStrDup("Contours at this value will have a wider line.");
    tt->val_offset = (char *) &special_contour_value - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'map_bad_to_min_value'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("map_bad_to_min_value");
    tt->descr = tdrpStrDup("Contour the bad value, by setting bad cells to have min value in data.");
    tt->help = tdrpStrDup("Sometimes, for CONTOURING it is useful to make the assumption that the bad and/or missing values should be considered at the minimum of the dynamic range of the data. i.e. if you want bad contoured, set this to TRUE.");
    tt->val_offset = (char *) &map_bad_to_min_value - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'map_missing_to_min_value'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("map_missing_to_min_value");
    tt->descr = tdrpStrDup("Contour the missing value, by setting missing cells to have min value in data.");
    tt->help = tdrpStrDup("Sometimes, for CONTOURING it is useful to make the assumption that the missing and/or missing values should be considered at the minimum of the dynamic range of the data. i.e. if you want missing contoured, set this to TRUE.");
    tt->val_offset = (char *) &map_missing_to_min_value - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 36'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 36");
    tt->comment_hdr = tdrpStrDup("Overlain fields as layers.");
    tt->comment_text = tdrpStrDup("Layers are rendered in order. i.e. last layer will be on top.");
    tt++;
    
    // Parameter 'layer_fields'
    // ctype is '_layer_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("layer_fields");
    tt->descr = tdrpStrDup("Field for layers as overlays.");
    tt->help = tdrpStrDup("/nfield_name: name of field in GRIDS list. /non_at_startup: field on when app starts./n");
    tt->array_offset = (char *) &_layer_fields - &_start_;
    tt->array_n_offset = (char *) &layer_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(layer_field_t);
    tt->array_n = 5;
    tt->struct_def.name = tdrpStrDup("layer_field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_layer_fields->field_name - (char *) _layer_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("on_at_startup");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_layer_fields->on_at_startup - (char *) _layer_fields;
    tt->n_struct_vals = 10;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("KCYS-DBZ");
      tt->struct_vals[1].b = pFALSE;
      tt->struct_vals[2].s = tdrpStrDup("KPUX-DBZ");
      tt->struct_vals[3].b = pFALSE;
      tt->struct_vals[4].s = tdrpStrDup("KGJX-DBZ");
      tt->struct_vals[5].b = pFALSE;
      tt->struct_vals[6].s = tdrpStrDup("KGLD-DBZ");
      tt->struct_vals[7].b = pFALSE;
      tt->struct_vals[8].s = tdrpStrDup("KLNX-DBZ");
      tt->struct_vals[9].b = pFALSE;
    tt++;
    
    // Parameter 'Comment 37'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 37");
    tt->comment_hdr = tdrpStrDup("Overall rendering order.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'draw_main_on_top'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("draw_main_on_top");
    tt->descr = tdrpStrDup("TRUE: render main field first, then layers.");
    tt->help = tdrpStrDup("FALSE: render main field on top of layers.");
    tt->val_offset = (char *) &draw_main_on_top - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 38'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 38");
    tt->comment_hdr = tdrpStrDup("Marking click location from separate app.");
    tt->comment_text = tdrpStrDup("Lucid can cooperate with a secondary app, receiving click details via shared memo");
    tt++;
    
    // Parameter 'mark_latest_click_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("mark_latest_click_location");
    tt->descr = tdrpStrDup("Option to mark latest click location from client app.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mark_latest_click_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'latest_click_mark_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("latest_click_mark_size");
    tt->descr = tdrpStrDup("Size of marker at latest click location (pixels).");
    tt->help = tdrpStrDup("Location clicked in client app.");
    tt->val_offset = (char *) &latest_click_mark_size - &_start_;
    tt->single_val.i = 11;
    tt++;
    
    // Parameter 'image_inten'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("image_inten");
    tt->descr = tdrpStrDup("Sets the relative intensity of images, relative to the overlays.");
    tt->help = tdrpStrDup("Set between 0.2 and 1.0.");
    tt->val_offset = (char *) &image_inten - &_start_;
    tt->single_val.d = 0.8;
    tt++;
    
    // Parameter 'inten_levels'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("inten_levels");
    tt->descr = tdrpStrDup("The number of selectable intensity levels in the slider control.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &inten_levels - &_start_;
    tt->single_val.i = 32;
    tt++;
    
    // Parameter 'data_inten'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("data_inten");
    tt->descr = tdrpStrDup("Sets the relative intensity of data grid colors, relative to the overlays.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &data_inten - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'image_fill_threshold'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("image_fill_threshold");
    tt->descr = tdrpStrDup("Sets the threshold in drawable grid points where image rendering is done by a filling method on the client, rather than by rectangles on the Xserver.");
    tt->help = tdrpStrDup("Set this high if the X server is fast or the comm link to the server is slow. Set this low if the X server is slow. Typical values range from 10,000 to 100,000  Used for 'cart' style rendering.");
    tt->val_offset = (char *) &image_fill_threshold - &_start_;
    tt->single_val.i = 120000;
    tt++;
    
    // Parameter 'dynamic_contour_threshold'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("dynamic_contour_threshold");
    tt->descr = tdrpStrDup("This sets the threshold in grid cells when the the display will render a grid as contours or as filled rectangles.");
    tt->help = tdrpStrDup("Grids containing less than the threshold cells will be rendered as filled contours. Used for 'dcont' style rendering");
    tt->val_offset = (char *) &dynamic_contour_threshold - &_start_;
    tt->single_val.i = 160000;
    tt++;
    
    // Parameter 'scale_units_per_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("scale_units_per_km");
    tt->descr = tdrpStrDup("Set the scale factor and label for Range rings and Distance scales.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &scale_units_per_km - &_start_;
    tt->single_val.d = 0.539593;
    tt++;
    
    // Parameter 'scale_units_label'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("scale_units_label");
    tt->descr = tdrpStrDup("Set the units labels.");
    tt->help = tdrpStrDup("km, nm, deg");
    tt->val_offset = (char *) &scale_units_label - &_start_;
    tt->single_val.s = tdrpStrDup("km");
    tt++;
    
    // Parameter 'Comment 39'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 39");
    tt->comment_hdr = tdrpStrDup("</RENDERING>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 40'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 40");
    tt->comment_hdr = tdrpStrDup("<SYMBOLIC_PRODUCTS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'products_on'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("products_on");
    tt->descr = tdrpStrDup("Render all of the products in the overlay menu.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &products_on - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'product_line_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("product_line_width");
    tt->descr = tdrpStrDup("Line width for rendering products.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &product_line_width - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'product_font_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("product_font_size");
    tt->descr = tdrpStrDup("Default font size for products.");
    tt->help = tdrpStrDup("Starting size of fonts for symbolic products - from the fonts array.");
    tt->val_offset = (char *) &product_font_size - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'scale_constant'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("scale_constant");
    tt->descr = tdrpStrDup("Product scaling constant.");
    tt->help = tdrpStrDup("Set this constant to determine at what zoom icons and will have a scale factor of 1.0. Default = 300. Function = log10(Constant /km_across_screen) + 1.0; Set to less than 0 to disable icon scaling");
    tt->val_offset = (char *) &scale_constant - &_start_;
    tt->single_val.d = 300;
    tt++;
    
    // Parameter 'product_adjustments'
    // ctype is '_product_adjustment_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("product_adjustments");
    tt->descr = tdrpStrDup("Thresholds and adjustment for font sizes for products.");
    tt->help = tdrpStrDup("The adjustment increases or decreases the font index. This index is used to choose the font from the fonts[] array. The thresholds are computed as units of km across the image.");
    tt->array_offset = (char *) &_product_adjustments - &_start_;
    tt->array_n_offset = (char *) &product_adjustments_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(product_adjustment_t);
    tt->array_n = 3;
    tt->struct_def.name = tdrpStrDup("product_adjustment_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("threshold");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_product_adjustments->threshold - (char *) _product_adjustments;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("font_index_adj");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_product_adjustments->font_index_adj - (char *) _product_adjustments;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 50;
      tt->struct_vals[1].i = 3;
      tt->struct_vals[2].d = 200;
      tt->struct_vals[3].i = 2;
      tt->struct_vals[4].d = 400;
      tt->struct_vals[5].i = 1;
    tt++;
    
    // Parameter 'Comment 41'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 41");
    tt->comment_hdr = tdrpStrDup("<SYMBOLIC_PRODUCTS>.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'symprods_enabled_at_startup'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("symprods_enabled_at_startup");
    tt->descr = tdrpStrDup("Enable symprods at start.");
    tt->help = tdrpStrDup("If FALSE, symbolic products will not be emabled at startup. You will have to turn them on via the products menu.");
    tt->val_offset = (char *) &symprods_enabled_at_startup - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'symprod_debug'
    // ctype is '_symprod_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("symprod_debug");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Debug option.\nIf set, debug messages will be printed appropriately.\n");
    tt->val_offset = (char *) &symprod_debug - &_start_;
    tt->enum_def.name = tdrpStrDup("symprod_debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("SYMPROD_DEBUG_OFF");
      tt->enum_def.fields[0].val = SYMPROD_DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("SYMPROD_DEBUG_NORM");
      tt->enum_def.fields[1].val = SYMPROD_DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("SYMPROD_DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = SYMPROD_DEBUG_VERBOSE;
    tt->single_val.e = SYMPROD_DEBUG_OFF;
    tt++;
    
    // Parameter 'symprod_short_requests'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("symprod_short_requests");
    tt->descr = tdrpStrDup("Gather Data Frame by Frame, Otherwise by loop span");
    tt->help = tdrpStrDup("Gathers Products valid for the current frame only - Speeds up gathering of large data sets, like METAR data");
    tt->val_offset = (char *) &symprod_short_requests - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'symprod_gzip_requests'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("symprod_gzip_requests");
    tt->descr = tdrpStrDup("Request data using GZIP compression");
    tt->help = tdrpStrDup("If true, symprod data will be GZIP compressed by the server.");
    tt->val_offset = (char *) &symprod_gzip_requests - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'symprod_prod_info'
    // ctype is '_symprod_prod_info_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("symprod_prod_info");
    tt->descr = tdrpStrDup("Product Source and Rendering Information Array");
    tt->help = tdrpStrDup("The fields in the structure are as follows:\n\n  menu_label: label to be used for the product in menu.\n\n  url: for retrieving the data.\n    example: spdbp:transform_executable:[param_file]//host.dom:[port]:dir1/dir2\n\n  data_type: used when querying the SPDB data server\n    (set to 0 to retrieve all data).\n\n  render_type: Select how temporal clipping is done:\n    SYMPROD_RENDER_ALL: Do no temporal clipping.\n    SYMPROD_RENDER_ALL_VALID: Render all Valid in frame\n    SYMPROD_RENDER_VALID_IN_LAST_FRAME: Render all Valid in the last frame\n    SYMPROD_RENDER_LATEST_IN_FRAME: Render the latest product of like data_types (ID)  in the frame.\n    SYMPROD_RENDER_LATEST_IN_LOOP:  Render the latest product of like data_types (ID)  valid in the movie loop.\n    SYMPROD_RENDER_FIRST_BEFORE_FRAME_TIME:  Render the latest product of like data_types (ID) before the end of frame time\n    SYMPROD_RENDER_FIRST_BEFORE_DATA_TIME:   Render the latest product of like data_types (ID  before the data time in each frame.\n    SYMPROD_RENDER_FIRST_AFTER_DATA_TIME:    Render the earliest product after the data time in each frame.\n    SYMPROD_RENDER_ALL_BEFORE_DATA_TIME:     Render all valid products before the data time in each frame.\n    SYMPROD_RENDER_ALL_AFTER_DATA_TIME:      Render all valid products after the data time in each frame.\n    SYMPROD_RENDER_GET_VALID:      Render all valid products returned with a GetValid Spdb call.\n    SYMPROD_RENDER_GET_VALID_AT_FRAME_TIME:  Render products which have not expired at the frame time\n\nNote: all comparisons are less than or equal or greater than or equal\n\n  on_by_default: True or False\n\n  minutes_allow_before: Stretch the frame time this many minutes - prior\n  minutes_allow_after: Stretch the frame time this many minutes - after\n\n  text_off_threshold: Threshold where text disappears. Use the function:\n      log10(scaling_constant/km_distance_across_screen ) + 1.0\n      Use 0.0 to disable the off feature. (always displayed)\n\n  request_data_on_zoom: Flag indicating whether to request new data for\n      this product whenever the user changes the zoom.  Normally, this\n      should be set to false for efficiency reasons.  If the products\n      to be rendered would change with a zoom change then this should be\n      set to true.\n\n  request_data_on_vert_change: Flag indicating whether to request new data\n      for this product whenever the user changes the currently displayed\n      vertical level.  Normally, this should be set to false for efficiency\n      reasons.  If the products to be rendered would change with a zoom\n      change then this should be set to true.\n\n");
    tt->array_offset = (char *) &_symprod_prod_info - &_start_;
    tt->array_n_offset = (char *) &symprod_prod_info_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(symprod_prod_info_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("symprod_prod_info_t");
    tt->struct_def.nfields = 10;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("menu_label");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_symprod_prod_info->menu_label - (char *) _symprod_prod_info;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("url");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_symprod_prod_info->url - (char *) _symprod_prod_info;
      tt->struct_def.fields[2].ftype = tdrpStrDup("int");
      tt->struct_def.fields[2].fname = tdrpStrDup("data_type");
      tt->struct_def.fields[2].ptype = INT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_symprod_prod_info->data_type - (char *) _symprod_prod_info;
      tt->struct_def.fields[3].ftype = tdrpStrDup("symprod_render_type_t");
      tt->struct_def.fields[3].fname = tdrpStrDup("render_type");
      tt->struct_def.fields[3].ptype = ENUM_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_symprod_prod_info->render_type - (char *) _symprod_prod_info;
        tt->struct_def.fields[3].enum_def.name = tdrpStrDup("symprod_render_type_t");
        tt->struct_def.fields[3].enum_def.nfields = 12;
        tt->struct_def.fields[3].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[3].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[3].enum_def.fields[0].name = tdrpStrDup("SYMPROD_RENDER_ALL");
        tt->struct_def.fields[3].enum_def.fields[0].val = SYMPROD_RENDER_ALL;
        tt->struct_def.fields[3].enum_def.fields[1].name = tdrpStrDup("SYMPROD_RENDER_ALL_VALID");
        tt->struct_def.fields[3].enum_def.fields[1].val = SYMPROD_RENDER_ALL_VALID;
        tt->struct_def.fields[3].enum_def.fields[2].name = tdrpStrDup("SYMPROD_RENDER_VALID_IN_LAST_FRAME");
        tt->struct_def.fields[3].enum_def.fields[2].val = SYMPROD_RENDER_VALID_IN_LAST_FRAME;
        tt->struct_def.fields[3].enum_def.fields[3].name = tdrpStrDup("SYMPROD_RENDER_LATEST_IN_FRAME");
        tt->struct_def.fields[3].enum_def.fields[3].val = SYMPROD_RENDER_LATEST_IN_FRAME;
        tt->struct_def.fields[3].enum_def.fields[4].name = tdrpStrDup("SYMPROD_RENDER_LATEST_IN_LOOP");
        tt->struct_def.fields[3].enum_def.fields[4].val = SYMPROD_RENDER_LATEST_IN_LOOP;
        tt->struct_def.fields[3].enum_def.fields[5].name = tdrpStrDup("SYMPROD_RENDER_FIRST_BEFORE_FRAME_TIME");
        tt->struct_def.fields[3].enum_def.fields[5].val = SYMPROD_RENDER_FIRST_BEFORE_FRAME_TIME;
        tt->struct_def.fields[3].enum_def.fields[6].name = tdrpStrDup("SYMPROD_RENDER_FIRST_BEFORE_DATA_TIME");
        tt->struct_def.fields[3].enum_def.fields[6].val = SYMPROD_RENDER_FIRST_BEFORE_DATA_TIME;
        tt->struct_def.fields[3].enum_def.fields[7].name = tdrpStrDup("SYMPROD_RENDER_FIRST_AFTER_DATA_TIME");
        tt->struct_def.fields[3].enum_def.fields[7].val = SYMPROD_RENDER_FIRST_AFTER_DATA_TIME;
        tt->struct_def.fields[3].enum_def.fields[8].name = tdrpStrDup("SYMPROD_RENDER_ALL_BEFORE_DATA_TIME");
        tt->struct_def.fields[3].enum_def.fields[8].val = SYMPROD_RENDER_ALL_BEFORE_DATA_TIME;
        tt->struct_def.fields[3].enum_def.fields[9].name = tdrpStrDup("SYMPROD_RENDER_ALL_AFTER_DATA_TIME");
        tt->struct_def.fields[3].enum_def.fields[9].val = SYMPROD_RENDER_ALL_AFTER_DATA_TIME;
        tt->struct_def.fields[3].enum_def.fields[10].name = tdrpStrDup("SYMPROD_RENDER_GET_VALID");
        tt->struct_def.fields[3].enum_def.fields[10].val = SYMPROD_RENDER_GET_VALID;
        tt->struct_def.fields[3].enum_def.fields[11].name = tdrpStrDup("SYMPROD_RENDER_GET_VALID_AT_FRAME_TIME");
        tt->struct_def.fields[3].enum_def.fields[11].val = SYMPROD_RENDER_GET_VALID_AT_FRAME_TIME;
      tt->struct_def.fields[4].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[4].fname = tdrpStrDup("on_by_default");
      tt->struct_def.fields[4].ptype = BOOL_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_symprod_prod_info->on_by_default - (char *) _symprod_prod_info;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("minutes_allow_before");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_symprod_prod_info->minutes_allow_before - (char *) _symprod_prod_info;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("minutes_allow_after");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_symprod_prod_info->minutes_allow_after - (char *) _symprod_prod_info;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("text_off_threshold");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_symprod_prod_info->text_off_threshold - (char *) _symprod_prod_info;
      tt->struct_def.fields[8].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[8].fname = tdrpStrDup("request_data_on_zoom");
      tt->struct_def.fields[8].ptype = BOOL_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_symprod_prod_info->request_data_on_zoom - (char *) _symprod_prod_info;
      tt->struct_def.fields[9].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[9].fname = tdrpStrDup("request_data_on_vert_change");
      tt->struct_def.fields[9].ptype = BOOL_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_symprod_prod_info->request_data_on_vert_change - (char *) _symprod_prod_info;
    tt->n_struct_vals = 10;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("RHI-ticks");
      tt->struct_vals[1].s = tdrpStrDup("spdbp:Rhi2Symprod://localhost::spdb/rhi");
      tt->struct_vals[2].i = 0;
      tt->struct_vals[3].e = SYMPROD_RENDER_ALL_VALID;
      tt->struct_vals[4].b = pFALSE;
      tt->struct_vals[5].d = 20;
      tt->struct_vals[6].d = 10;
      tt->struct_vals[7].d = 0.4;
      tt->struct_vals[8].b = pFALSE;
      tt->struct_vals[9].b = pFALSE;
    tt++;
    
    // Parameter 'Comment 42'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 42");
    tt->comment_hdr = tdrpStrDup("</SYMBOLIC_PRODUCTS>.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 43'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 43");
    tt->comment_hdr = tdrpStrDup("<TERRAIN>");
    tt->comment_text = tdrpStrDup("Note: Terrain Fields must be on the same projection as the Display");
    tt++;
    
    // Parameter 'terrain_active'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("terrain_active");
    tt->descr = tdrpStrDup("Is the terrain section active?");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &terrain_active - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'terrain_id_label'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("terrain_id_label");
    tt->descr = tdrpStrDup("Label used for legends");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &terrain_id_label - &_start_;
    tt->single_val.s = tdrpStrDup("Terrain");
    tt++;
    
    // Parameter 'terrain_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("terrain_url");
    tt->descr = tdrpStrDup("Used to located gridded terrain data. Set to empty string for no terrain.");
    tt->help = tdrpStrDup("Terrain_URL \n Note example URL:\n  mdvp::static//venus::mdv/terrain&Elevation\n Field name follows the Ampersand. Use #N for field number override   Use caret: ^ as a substitute for spaces in field names");
    tt->val_offset = (char *) &terrain_url - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'terrain_height_scaler'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("terrain_height_scaler");
    tt->descr = tdrpStrDup("Conversion from terrain units to local coords");
    tt->help = tdrpStrDup("Choose a scaler which converts plane height values\nDefault is Hecto-feet (FL) per meter");
    tt->val_offset = (char *) &terrain_height_scaler - &_start_;
    tt->single_val.d = 0.0328083;
    tt++;
    
    // Parameter 'landuse_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("landuse_url");
    tt->descr = tdrpStrDup("Used to located gridded land use data");
    tt->help = tdrpStrDup("Land Use URL \n Note URL is of the form mdvp::[param_file]//host.dom::dir/dir&field_name\n Field name follows the Ampersand. Use #N for field number override   Use caret: ^ as a substitute for spaces in field names");
    tt->val_offset = (char *) &landuse_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp:://tempest:0:topo/relief/mdv&RGBA");
    tt++;
    
    // Parameter 'landuse_colorscale'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("landuse_colorscale");
    tt->descr = tdrpStrDup("Color lookup table for Land use");
    tt->help = tdrpStrDup("Land Use colorscale file name\n Note: Lucid looks in the colorscale dir, then in the current dir for this file");
    tt->val_offset = (char *) &landuse_colorscale - &_start_;
    tt->single_val.s = tdrpStrDup("terrain.colors");
    tt++;
    
    // Parameter 'landuse_render_method'
    // ctype is '_terrain_render_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("landuse_render_method");
    tt->descr = tdrpStrDup("Land Use rendering style");
    tt->help = tdrpStrDup("Use Contours only for continious data like elevation");
    tt->val_offset = (char *) &landuse_render_method - &_start_;
    tt->enum_def.name = tdrpStrDup("terrain_render_type_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("TERRAIN_RENDER_FILLED_CONT");
      tt->enum_def.fields[0].val = TERRAIN_RENDER_FILLED_CONT;
      tt->enum_def.fields[1].name = tdrpStrDup("TERRAIN_RENDER_RECTANGLES");
      tt->enum_def.fields[1].val = TERRAIN_RENDER_RECTANGLES;
      tt->enum_def.fields[2].name = tdrpStrDup("TERRAIN_RENDER_DYNAMIC_CONTOURS");
      tt->enum_def.fields[2].val = TERRAIN_RENDER_DYNAMIC_CONTOURS;
    tt->single_val.e = TERRAIN_RENDER_RECTANGLES;
    tt++;
    
    // Parameter 'landuse_active'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("landuse_active");
    tt->descr = tdrpStrDup("Default Display state of Land Use/ Basemap");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &landuse_active - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'terrain_earth_color1'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("terrain_earth_color1");
    tt->descr = tdrpStrDup("Earth's skin color");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &terrain_earth_color1 - &_start_;
    tt->single_val.s = tdrpStrDup("sienna");
    tt++;
    
    // Parameter 'terrain_earth_color2'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("terrain_earth_color2");
    tt->descr = tdrpStrDup("Earth's core color");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &terrain_earth_color2 - &_start_;
    tt->single_val.s = tdrpStrDup("red4");
    tt++;
    
    // Parameter 'Comment 44'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 44");
    tt->comment_hdr = tdrpStrDup("</TERRAIN>.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 45'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 45");
    tt->comment_hdr = tdrpStrDup("<WINDS>");
    tt->comment_text = tdrpStrDup("Plotting wind vector overlays on grids.");
    tt++;
    
    // Parameter 'winds_on_at_startup'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("winds_on_at_startup");
    tt->descr = tdrpStrDup("Enable winds at start.");
    tt->help = tdrpStrDup("If FALSE, winds will not be enabled at startup. You will have to turn them on via the winds menu.");
    tt->val_offset = (char *) &winds_on_at_startup - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'winds'
    // ctype is '_wind_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("winds");
    tt->descr = tdrpStrDup("Winds to be displayed.");
    tt->help = tdrpStrDup("button_label: appears on the GUI. \nlegend_label: appears in the plot. \nurl: location of data or data server. Form is 'protocol://host:port/dir/'\nu_field_name: U component field name. \nv_field_name: V component field name. \nw_field_name: W component field name. Set to 'none' if no W vectors.\nunits: wind speed units. \nline_width: line width to be used for wind vectors. \nmarker_type:\n  ARROW: centered on data point.\n  VECTOR: vertex at data point.\n  BARB: N hemisphere.\n  LABELEDBARB: labeled to nearest 10 degrees at the center - N.Hemisphere.\n  TUFT: like a piece of yarn - the least obtrusive - like a headless vector.\n  TICKVECTOR: Cross ticks at wind_time_scale_interval minutes.\n  METBARB: Calcs latitude. Works for both hemispheres and adds a label of the 10's digit off the end of the barb, ala winds aloft charts auto switching between cart and cont. Uses dynamic_contour_treshold.\n  BARB_SH: S Hemisphere.\n  LABELEDBARB_SH: labeled to nearest 10 degrees at the center - N. Hemisp.\n\nNOTE: When using arrow,vector,tuft,tickvector, the data must be in m/sec for the scaling to work correctly. For the others (Barbs), the units are arbitrary, but the flag units on the barbs will reflect the data's native units.\n\nExample: '-2,metbarb' --> width 2, off to start, using winds aloft chart barbs\nExample: '1'  --> Width 1, on to start, uses cidd.wind_marker_type: defined in main section\n");
    tt->array_offset = (char *) &_winds - &_start_;
    tt->array_n_offset = (char *) &winds_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(wind_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("wind_t");
    tt->struct_def.nfields = 11;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("button_label");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_winds->button_label - (char *) _winds;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("legend_label");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_winds->legend_label - (char *) _winds;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("url");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_winds->url - (char *) _winds;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("u_field_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_winds->u_field_name - (char *) _winds;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("v_field_name");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_winds->v_field_name - (char *) _winds;
      tt->struct_def.fields[5].ftype = tdrpStrDup("string");
      tt->struct_def.fields[5].fname = tdrpStrDup("w_field_name");
      tt->struct_def.fields[5].ptype = STRING_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_winds->w_field_name - (char *) _winds;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("units");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_winds->units - (char *) _winds;
      tt->struct_def.fields[7].ftype = tdrpStrDup("int");
      tt->struct_def.fields[7].fname = tdrpStrDup("line_width");
      tt->struct_def.fields[7].ptype = INT_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_winds->line_width - (char *) _winds;
      tt->struct_def.fields[8].ftype = tdrpStrDup("wind_marker_t");
      tt->struct_def.fields[8].fname = tdrpStrDup("marker_type");
      tt->struct_def.fields[8].ptype = ENUM_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_winds->marker_type - (char *) _winds;
        tt->struct_def.fields[8].enum_def.name = tdrpStrDup("wind_marker_t");
        tt->struct_def.fields[8].enum_def.nfields = 9;
        tt->struct_def.fields[8].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[8].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[8].enum_def.fields[0].name = tdrpStrDup("WIND_ARROW");
        tt->struct_def.fields[8].enum_def.fields[0].val = WIND_ARROW;
        tt->struct_def.fields[8].enum_def.fields[1].name = tdrpStrDup("WIND_VECTOR");
        tt->struct_def.fields[8].enum_def.fields[1].val = WIND_VECTOR;
        tt->struct_def.fields[8].enum_def.fields[2].name = tdrpStrDup("WIND_BARB");
        tt->struct_def.fields[8].enum_def.fields[2].val = WIND_BARB;
        tt->struct_def.fields[8].enum_def.fields[3].name = tdrpStrDup("WIND_LABELEDBARB");
        tt->struct_def.fields[8].enum_def.fields[3].val = WIND_LABELEDBARB;
        tt->struct_def.fields[8].enum_def.fields[4].name = tdrpStrDup("WIND_TUFT");
        tt->struct_def.fields[8].enum_def.fields[4].val = WIND_TUFT;
        tt->struct_def.fields[8].enum_def.fields[5].name = tdrpStrDup("WIND_TICKVECTOR");
        tt->struct_def.fields[8].enum_def.fields[5].val = WIND_TICKVECTOR;
        tt->struct_def.fields[8].enum_def.fields[6].name = tdrpStrDup("WIND_METBARB");
        tt->struct_def.fields[8].enum_def.fields[6].val = WIND_METBARB;
        tt->struct_def.fields[8].enum_def.fields[7].name = tdrpStrDup("WIND_BARB_SH");
        tt->struct_def.fields[8].enum_def.fields[7].val = WIND_BARB_SH;
        tt->struct_def.fields[8].enum_def.fields[8].name = tdrpStrDup("WIND_LABELEDBARB_SH");
        tt->struct_def.fields[8].enum_def.fields[8].val = WIND_LABELEDBARB_SH;
      tt->struct_def.fields[9].ftype = tdrpStrDup("string");
      tt->struct_def.fields[9].fname = tdrpStrDup("color");
      tt->struct_def.fields[9].ptype = STRING_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_winds->color - (char *) _winds;
      tt->struct_def.fields[10].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[10].fname = tdrpStrDup("on_at_startup");
      tt->struct_def.fields[10].ptype = BOOL_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_winds->on_at_startup - (char *) _winds;
    tt->n_struct_vals = 22;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("GFS");
      tt->struct_vals[1].s = tdrpStrDup("GFS");
      tt->struct_vals[2].s = tdrpStrDup("mdvp:://front.eol.ucar.edu:8080:relampago/mdv/gfs/relampago");
      tt->struct_vals[3].s = tdrpStrDup("U");
      tt->struct_vals[4].s = tdrpStrDup("V");
      tt->struct_vals[5].s = tdrpStrDup("W");
      tt->struct_vals[6].s = tdrpStrDup("m/s");
      tt->struct_vals[7].i = 1;
      tt->struct_vals[8].e = WIND_ARROW;
      tt->struct_vals[9].s = tdrpStrDup("white");
      tt->struct_vals[10].b = pTRUE;
      tt->struct_vals[11].s = tdrpStrDup("WRF");
      tt->struct_vals[12].s = tdrpStrDup("WRF");
      tt->struct_vals[13].s = tdrpStrDup("mdvp:://front.eol.ucar.edu:8080:relampago/mdv/wrf/relampago");
      tt->struct_vals[14].s = tdrpStrDup("U");
      tt->struct_vals[15].s = tdrpStrDup("V");
      tt->struct_vals[16].s = tdrpStrDup("W");
      tt->struct_vals[17].s = tdrpStrDup("m/s");
      tt->struct_vals[18].i = 1;
      tt->struct_vals[19].e = WIND_ARROW;
      tt->struct_vals[20].s = tdrpStrDup("yellow");
      tt->struct_vals[21].b = pTRUE;
    tt++;
    
    // Parameter 'wind_barb_shaft_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("wind_barb_shaft_len");
    tt->descr = tdrpStrDup("Wind barb shaft length (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &wind_barb_shaft_len - &_start_;
    tt->single_val.i = 33;
    tt++;
    
    // Parameter 'wind_ideal_x_vectors'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("wind_ideal_x_vectors");
    tt->descr = tdrpStrDup("Ideal number of vectors in the x dimension.");
    tt->help = tdrpStrDup("The display will space the wind vectors in x accordingly.");
    tt->val_offset = (char *) &wind_ideal_x_vectors - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'wind_ideal_y_vectors'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("wind_ideal_y_vectors");
    tt->descr = tdrpStrDup("Ideal number of vectors in the y dimension.");
    tt->help = tdrpStrDup("The display will space the wind vectors in y accordingly.");
    tt->val_offset = (char *) &wind_ideal_y_vectors - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'wind_head_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("wind_head_size");
    tt->descr = tdrpStrDup("Minimum arrow head size for wind vectors (pixels).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &wind_head_size - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'wind_head_angle'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("wind_head_angle");
    tt->descr = tdrpStrDup("Angle of arrow head for wind vectors (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &wind_head_angle - &_start_;
    tt->single_val.d = 45;
    tt++;
    
    // Parameter 'wind_scaler'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("wind_scaler");
    tt->descr = tdrpStrDup("The display will space the wind vectors in x accordingly.");
    tt->help = tdrpStrDup("Vectors will be drawn to show wind_scaler * wind_time_scale_interval minutes of motion.");
    tt->val_offset = (char *) &wind_scaler - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'wind_time_scale_interval'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("wind_time_scale_interval");
    tt->descr = tdrpStrDup("inutes between steps on the wind scaling slider.");
    tt->help = tdrpStrDup("Wind vector length = wind_scaler * wind_time_scale_interval *  wind velocity");
    tt->val_offset = (char *) &wind_time_scale_interval - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'wind_marker_type'
    // ctype is '_wind_marker_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("wind_marker_type");
    tt->descr = tdrpStrDup("Wind marker rendering style.");
    tt->help = tdrpStrDup("See WIND section for details on rendering style.");
    tt->val_offset = (char *) &wind_marker_type - &_start_;
    tt->enum_def.name = tdrpStrDup("wind_marker_t");
    tt->enum_def.nfields = 9;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("WIND_ARROW");
      tt->enum_def.fields[0].val = WIND_ARROW;
      tt->enum_def.fields[1].name = tdrpStrDup("WIND_VECTOR");
      tt->enum_def.fields[1].val = WIND_VECTOR;
      tt->enum_def.fields[2].name = tdrpStrDup("WIND_BARB");
      tt->enum_def.fields[2].val = WIND_BARB;
      tt->enum_def.fields[3].name = tdrpStrDup("WIND_LABELEDBARB");
      tt->enum_def.fields[3].val = WIND_LABELEDBARB;
      tt->enum_def.fields[4].name = tdrpStrDup("WIND_TUFT");
      tt->enum_def.fields[4].val = WIND_TUFT;
      tt->enum_def.fields[5].name = tdrpStrDup("WIND_TICKVECTOR");
      tt->enum_def.fields[5].val = WIND_TICKVECTOR;
      tt->enum_def.fields[6].name = tdrpStrDup("WIND_METBARB");
      tt->enum_def.fields[6].val = WIND_METBARB;
      tt->enum_def.fields[7].name = tdrpStrDup("WIND_BARB_SH");
      tt->enum_def.fields[7].val = WIND_BARB_SH;
      tt->enum_def.fields[8].name = tdrpStrDup("WIND_LABELEDBARB_SH");
      tt->enum_def.fields[8].val = WIND_LABELEDBARB_SH;
    tt->single_val.e = WIND_ARROW;
    tt++;
    
    // Parameter 'wind_w_scale_factor'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("wind_w_scale_factor");
    tt->descr = tdrpStrDup("Scale the vertical velocity by this factor, relative to the U/V. ");
    tt->help = tdrpStrDup("W tends to be small compared to U/V. Scaling it up makes the rendering more meaningful.");
    tt->val_offset = (char *) &wind_w_scale_factor - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'wind_units_scale_factor'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("wind_units_scale_factor");
    tt->descr = tdrpStrDup("Value to convert from the your reference speed units to m/sec. ");
    tt->help = tdrpStrDup("i.e. wind_units_scale_factor =  m/sec / chosen units.");
    tt->val_offset = (char *) &wind_units_scale_factor - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'wind_reference_speed'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("wind_reference_speed");
    tt->descr = tdrpStrDup("Sets the length of the wind vector reference legend.");
    tt->help = tdrpStrDup("The legend shows a symbos representing a wind speed of this value.");
    tt->val_offset = (char *) &wind_reference_speed - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'wind_units_label'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("wind_units_label");
    tt->descr = tdrpStrDup("Select the label to be printed next to the reference bar.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &wind_units_label - &_start_;
    tt->single_val.s = tdrpStrDup("m/sec");
    tt++;
    
    // Parameter 'Comment 46'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 46");
    tt->comment_hdr = tdrpStrDup("</WINDS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 47'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 47");
    tt->comment_hdr = tdrpStrDup("<IMAGE_GENERATION>");
    tt->comment_text = tdrpStrDup("In creating files for the field catalog, the file name is of the form:\n\n\tcategory.platform.YYYYMMDDHHmm.product_name.ext\n\nThe following parameters control the output directory, and the construction of the file name");
    tt++;
    
    // Parameter 'images_output_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_output_dir");
    tt->descr = tdrpStrDup("Output directory for images generated by this app.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &images_output_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/images/Lucid");
    tt++;
    
    // Parameter 'images_write_to_day_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_write_to_day_dir");
    tt->descr = tdrpStrDup("Option to create a subdirectory for each day.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &images_write_to_day_dir - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'images_file_name_category'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_file_name_category");
    tt->descr = tdrpStrDup("Set the category string.");
    tt->help = tdrpStrDup("If empty, no category will be included.");
    tt->val_offset = (char *) &images_file_name_category - &_start_;
    tt->single_val.s = tdrpStrDup("radar");
    tt++;
    
    // Parameter 'images_file_name_platform'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_file_name_platform");
    tt->descr = tdrpStrDup("Set the platform string.");
    tt->help = tdrpStrDup("If empty, no platform will be included.");
    tt->val_offset = (char *) &images_file_name_platform - &_start_;
    tt->single_val.s = tdrpStrDup("NSF_NCAR_GV_HCR");
    tt++;
    
    // Parameter 'images_file_name_extension'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_file_name_extension");
    tt->descr = tdrpStrDup("Set the extension string. This also governs the file format. It should be 'png', 'jpg', 'gif' etc.");
    tt->help = tdrpStrDup("An extension is always required");
    tt->val_offset = (char *) &images_file_name_extension - &_start_;
    tt->single_val.s = tdrpStrDup("png");
    tt++;
    
    // Parameter 'images_file_name_delimiter'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_file_name_delimiter");
    tt->descr = tdrpStrDup("Set the delimiter between the parts of the file name.");
    tt->help = tdrpStrDup("NOTE: before the extension the delimited is always a period: '.'.");
    tt->val_offset = (char *) &images_file_name_delimiter - &_start_;
    tt->single_val.s = tdrpStrDup(".");
    tt++;
    
    // Parameter 'images_include_time_part_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_include_time_part_in_file_name");
    tt->descr = tdrpStrDup("Normally the file name includes a time part: YYYYMMDDHHMMSS.");
    tt->help = tdrpStrDup("If FALSE, the time part will be omitted.");
    tt->val_offset = (char *) &images_include_time_part_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'images_include_seconds_in_time_part'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_include_seconds_in_time_part");
    tt->descr = tdrpStrDup("Normally the time part include the seconds: YYYYMMDDHHMMSS.");
    tt->help = tdrpStrDup("If FALSE, the SS will be excluuded from the time part.");
    tt->val_offset = (char *) &images_include_seconds_in_time_part - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'images_include_field_label_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_include_field_label_in_file_name");
    tt->descr = tdrpStrDup("Normally the file name includes the field label (product type).");
    tt->help = tdrpStrDup("If FALSE, the field label will be omitted.");
    tt->val_offset = (char *) &images_include_field_label_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'images_include_scan_type_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_include_scan_type_in_file_name");
    tt->descr = tdrpStrDup("Option to include the scan type in the image file name.");
    tt->help = tdrpStrDup("If TRUE, the scan type will be added to the image file name.");
    tt->val_offset = (char *) &images_include_scan_type_in_file_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'images_include_scan_id_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_include_scan_id_in_file_name");
    tt->descr = tdrpStrDup("Option to include the scan Id in the image file name.");
    tt->help = tdrpStrDup("If TRUE, the scan Id will be added to the image file name.");
    tt->val_offset = (char *) &images_include_scan_id_in_file_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'images_write_latest_data_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_write_latest_data_info");
    tt->descr = tdrpStrDup("Option to write latest_data_info files when an image is created.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &images_write_latest_data_info - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'images_auto_create'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_auto_create");
    tt->descr = tdrpStrDup("Option to create images automatically.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &images_auto_create - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'images_creation_mode'
    // ctype is '_images_creation_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("images_creation_mode");
    tt->descr = tdrpStrDup("Mode for controlling auto image creation.");
    tt->help = tdrpStrDup("\n\nCREATE_IMAGES_FROM_GUI: create images interactively using the GUI.\n\nCREATE_IMAGES_THEN_EXIT: for the specified start time and time span, create an output image for every field in the fields array, and then exit.\n\nCREATE_IMAGES_ON_REALTIME_SCHEDULE: wait for the scheduled time, then generate an image for each field.\n\nCREATE_IMAGES_ON_ARCHIVE_SCHEDULE: for each scheduled time between the start and end times, generate an image for each field.");
    tt->val_offset = (char *) &images_creation_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("images_creation_mode_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CREATE_IMAGES_THEN_EXIT");
      tt->enum_def.fields[0].val = CREATE_IMAGES_THEN_EXIT;
      tt->enum_def.fields[1].name = tdrpStrDup("CREATE_IMAGES_ON_REALTIME_SCHEDULE");
      tt->enum_def.fields[1].val = CREATE_IMAGES_ON_REALTIME_SCHEDULE;
      tt->enum_def.fields[2].name = tdrpStrDup("CREATE_IMAGES_ON_ARCHIVE_SCHEDULE");
      tt->enum_def.fields[2].val = CREATE_IMAGES_ON_ARCHIVE_SCHEDULE;
    tt->single_val.e = CREATE_IMAGES_THEN_EXIT;
    tt++;
    
    // Parameter 'images_schedule_interval_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("images_schedule_interval_secs");
    tt->descr = tdrpStrDup("Interval at which images are created on schedule (secs).");
    tt->help = tdrpStrDup("The application waits until the interval has passed, plus any specified delay, and then creates the images.");
    tt->val_offset = (char *) &images_schedule_interval_secs - &_start_;
    tt->single_val.i = 300;
    tt++;
    
    // Parameter 'images_schedule_delay_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("images_schedule_delay_secs");
    tt->descr = tdrpStrDup("Delay between scheduled time and image creation (secs).");
    tt->help = tdrpStrDup("In order to ensure that the data has been written, a delay may be provided. This allows for the writing application to complete writing the data before this application tries to access it.");
    tt->val_offset = (char *) &images_schedule_delay_secs - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'images_archive_start_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_archive_start_time");
    tt->descr = tdrpStrDup("Start time for image generation in archive mode.");
    tt->help = tdrpStrDup("Image generation starts with a seach at this time, and the proceeds at increments of images_schedule_interval_secs.");
    tt->val_offset = (char *) &images_archive_start_time - &_start_;
    tt->single_val.s = tdrpStrDup("1970 01 01 00 00 00");
    tt++;
    
    // Parameter 'images_archive_end_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("images_archive_end_time");
    tt->descr = tdrpStrDup("End time for image generation in archive mode.");
    tt->help = tdrpStrDup("Image generation is terminated when the search time exceeds this end time.");
    tt->val_offset = (char *) &images_archive_end_time - &_start_;
    tt->single_val.s = tdrpStrDup("1970 01 01 00 00 00");
    tt++;
    
    // Parameter 'images_scan_interval_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("images_scan_interval_secs");
    tt->descr = tdrpStrDup("Time between scans in archive mode (secs).");
    tt->help = tdrpStrDup("Only applies to POLAR (HORIZ/VERT) mode, not BSCAN mode.");
    tt->val_offset = (char *) &images_scan_interval_secs - &_start_;
    tt->single_val.i = 300;
    tt++;
    
    // Parameter 'images_set_sweep_index_list'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("images_set_sweep_index_list");
    tt->descr = tdrpStrDup("Option to specify the sweep indexes for the image generation.");
    tt->help = tdrpStrDup("If TRUE, only the specified sweeps will be processed.");
    tt->val_offset = (char *) &images_set_sweep_index_list - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'images_sweep_index_list'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("images_sweep_index_list");
    tt->descr = tdrpStrDup("List of valid sweep indexes for image generation.");
    tt->help = tdrpStrDup("See 'images_set_sweep_index_list'. Images will only be generated for the specified sweep indexes.");
    tt->array_offset = (char *) &_images_sweep_index_list - &_start_;
    tt->array_n_offset = (char *) &images_sweep_index_list_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(int);
    tt->array_n = 3;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].i = 0;
      tt->array_vals[1].i = 1;
      tt->array_vals[2].i = 2;
    tt++;
    
    // Parameter 'enable_save_image_panel'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("enable_save_image_panel");
    tt->descr = tdrpStrDup("Enable the single middle button click to save image feature.");
    tt->help = tdrpStrDup("Warning - will allow users shell access, or to write to other dirs.");
    tt->val_offset = (char *) &enable_save_image_panel - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'image_generation_active'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("image_generation_active");
    tt->descr = tdrpStrDup("Is the image generation section active?");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &image_generation_active - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'image_debug'
    // ctype is '_image_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("image_debug");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Debug option.\nIf set, debug messages will be printed appropriately.\n");
    tt->val_offset = (char *) &image_debug - &_start_;
    tt->enum_def.name = tdrpStrDup("image_debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("IMAGE_DEBUG_OFF");
      tt->enum_def.fields[0].val = IMAGE_DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("IMAGE_DEBUG_NORM");
      tt->enum_def.fields[1].val = IMAGE_DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("IMAGE_DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = IMAGE_DEBUG_VERBOSE;
    tt->single_val.e = IMAGE_DEBUG_OFF;
    tt++;
    
    // Parameter 'image_generate_vsection'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("image_generate_vsection");
    tt->descr = tdrpStrDup("Generate images for specified vertical sections.");
    tt->help = tdrpStrDup("If TRUE, and Lucid is in html_mode, it will generate vertical section images in addition to the normal plan view images.");
    tt->val_offset = (char *) &image_generate_vsection - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'image_vsection_waypts_in_latlon'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("image_vsection_waypts_in_latlon");
    tt->descr = tdrpStrDup("The specified waypts are in latlon degree units.");
    tt->help = tdrpStrDup("If TRUE, the waypts are specified in lat/lon degrees. If FALSE, they are specified in (xkm, ykm) units in the current projection.");
    tt->val_offset = (char *) &image_vsection_waypts_in_latlon - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'image_vsection_spec'
    // ctype is '_image_vsection_spec_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("image_vsection_spec");
    tt->descr = tdrpStrDup("Vertical section information array");
    tt->help = tdrpStrDup("The fields in the structure are as follows:\n\n  vsection_label: label to be used for the specified vertical section.\n\n  n_waypts: number of waypts for specifying the vert section.\n            Normally this is 2 - for a single vertical section segment.\n\n  waypt_locs: location of way points. This is a string with pairs of points in it, with the following format: (x, y) (x, y) ..... (x, y)\n\n");
    tt->array_offset = (char *) &_image_vsection_spec - &_start_;
    tt->array_n_offset = (char *) &image_vsection_spec_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(image_vsection_spec_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("image_vsection_spec_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("vsection_label");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_image_vsection_spec->vsection_label - (char *) _image_vsection_spec;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("n_waypts");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_image_vsection_spec->n_waypts - (char *) _image_vsection_spec;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("waypt_locs");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_image_vsection_spec->waypt_locs - (char *) _image_vsection_spec;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("RHI-north");
      tt->struct_vals[1].i = 2;
      tt->struct_vals[2].s = tdrpStrDup("(0, 0) (0, 150)");
    tt++;
    
    // Parameter 'Comment 48'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 48");
    tt->comment_hdr = tdrpStrDup("Orig Lucid image generation");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'html_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("html_mode");
    tt->descr = tdrpStrDup("Set this to TRUE to activate automatic HTML output mode.");
    tt->help = tdrpStrDup("Note: image_dir MUST be set.");
    tt->val_offset = (char *) &html_mode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'run_once_and_exit'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("run_once_and_exit");
    tt->descr = tdrpStrDup("After this period of inactivity, the display will reset itself to a known starting point.");
    tt->help = tdrpStrDup("Set this to FALSE to essentially turn off.");
    tt->val_offset = (char *) &run_once_and_exit - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'transparent_images'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("transparent_images");
    tt->descr = tdrpStrDup("Set transparency of generated images.");
    tt->help = tdrpStrDup("If FALSE, the normal background color is used. Set to TRUE for transparent background.");
    tt->val_offset = (char *) &transparent_images - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'image_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("image_dir");
    tt->descr = tdrpStrDup("Directory for output image plots.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &image_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/image_dir");
    tt++;
    
    // Parameter 'save_images_to_day_subdir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("save_images_to_day_subdir");
    tt->descr = tdrpStrDup("Save images to subdirs based on date.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &save_images_to_day_subdir - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'image_ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("image_ext");
    tt->descr = tdrpStrDup("Sets the output image type.");
    tt->help = tdrpStrDup("In latest version, only png type is available.");
    tt->val_offset = (char *) &image_ext - &_start_;
    tt->single_val.s = tdrpStrDup("png");
    tt++;
    
    // Parameter 'image_horiz_prefix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("image_horiz_prefix");
    tt->descr = tdrpStrDup("The prefix for the horiz (plan view) image file names.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &image_horiz_prefix - &_start_;
    tt->single_val.s = tdrpStrDup("CP");
    tt++;
    
    // Parameter 'image_vert_prefix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("image_vert_prefix");
    tt->descr = tdrpStrDup("The prefix for the vert image file names");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &image_vert_prefix - &_start_;
    tt->single_val.s = tdrpStrDup("CV");
    tt++;
    
    // Parameter 'image_name_separator'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("image_name_separator");
    tt->descr = tdrpStrDup("The separator used in the image file names.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &image_name_separator - &_start_;
    tt->single_val.s = tdrpStrDup("_");
    tt++;
    
    // Parameter 'Comment 49'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 49");
    tt->comment_hdr = tdrpStrDup("The HTML MODE Output file name is built from parts.");
    tt->comment_text = tdrpStrDup("Some of these are optional - see related parameters below. 'Prefix' + Frame_number + legend_label + zoom_level + [button_label] + [height] + frame_time + [data_generation_time] + [data_valid_time] + .'cidd.image_ext'");
    tt++;
    
    // Parameter 'add_height_to_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_height_to_filename");
    tt->descr = tdrpStrDup("Adds height to the output file name.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_height_to_filename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'add_frame_time_to_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_frame_time_to_filename");
    tt->descr = tdrpStrDup("Adds frame time to the output file name.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_frame_time_to_filename - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'add_button_name_to_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_button_name_to_filename");
    tt->descr = tdrpStrDup("Adds GUI button label to the output file name.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_button_name_to_filename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'add_frame_num_to_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_frame_num_to_filename");
    tt->descr = tdrpStrDup("Adds frame number to the output file name.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_frame_num_to_filename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'add_gen_time_to_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_gen_time_to_filename");
    tt->descr = tdrpStrDup("Adds model gen time to the output file name.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_gen_time_to_filename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'add_valid_time_to_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("add_valid_time_to_filename");
    tt->descr = tdrpStrDup("Adds data valid time to the output file name.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &add_valid_time_to_filename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 50'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 50");
    tt->comment_hdr = tdrpStrDup("Separate Horizontal and Vertical Image save resources.");
    tt->comment_text = tdrpStrDup("NOTE: we append the image name to the command string before executing.This allows the script to pull the name off the command line. It is often useful to place a 'rm' as the last command to remove the image after printing, conversion, etc.");
    tt++;
    
    // Parameter 'horiz_image_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_image_dir");
    tt->descr = tdrpStrDup("Image directory for horiz images.");
    tt->help = tdrpStrDup("Note - this is initially set to image_dir");
    tt->val_offset = (char *) &horiz_image_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/cidd_horiz_image_dir");
    tt++;
    
    // Parameter 'horiz_image_fname'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_image_fname");
    tt->descr = tdrpStrDup("The default file name until reset by the user.");
    tt->help = tdrpStrDup("Appends other info automatically.");
    tt->val_offset = (char *) &horiz_image_fname - &_start_;
    tt->single_val.s = tdrpStrDup("cidd_horiz_view.png");
    tt++;
    
    // Parameter 'horiz_image_command'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("horiz_image_command");
    tt->descr = tdrpStrDup("Command to be run after image is created.");
    tt->help = tdrpStrDup("Note that this is initially set to 'image_convert_script'.");
    tt->val_offset = (char *) &horiz_image_command - &_start_;
    tt->single_val.s = tdrpStrDup("convert_image.csh");
    tt++;
    
    // Parameter 'vert_image_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_image_dir");
    tt->descr = tdrpStrDup("Image directory for vert images.");
    tt->help = tdrpStrDup("Note - this is initially set to image_dir");
    tt->val_offset = (char *) &vert_image_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/cidd_vert_image_dir");
    tt++;
    
    // Parameter 'vert_image_fname'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_image_fname");
    tt->descr = tdrpStrDup("The default file name until reset by the user.");
    tt->help = tdrpStrDup("Appends other info automatically.");
    tt->val_offset = (char *) &vert_image_fname - &_start_;
    tt->single_val.s = tdrpStrDup("cidd_vert_view.png");
    tt++;
    
    // Parameter 'vert_image_command'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_image_command");
    tt->descr = tdrpStrDup("Command to be run after image is created.");
    tt->help = tdrpStrDup("Note that this is initially set to 'image_convert_script'.");
    tt->val_offset = (char *) &vert_image_command - &_start_;
    tt->single_val.s = tdrpStrDup("convert_image.csh");
    tt++;
    
    // Parameter 'output_geo_xml'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_geo_xml");
    tt->descr = tdrpStrDup("Output an imagename.xml file which contains geo referencing information.");
    tt->help = tdrpStrDup("If use_latlon_in_geo_xml is true, then the georeferencing information will be given in latitude/longitude values.");
    tt->val_offset = (char *) &output_geo_xml - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_latlon_in_geo_xml'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_latlon_in_geo_xml");
    tt->descr = tdrpStrDup("Georef info is in lat/lon projection.");
    tt->help = tdrpStrDup("For a lat/lon projection, information is always given in latitude/longitude. Otherwise projection information will be used.");
    tt->val_offset = (char *) &use_latlon_in_geo_xml - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'movieframe_time_format'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("movieframe_time_format");
    tt->descr = tdrpStrDup("Set the format for the time fields in the names of output xwd images.");
    tt->help = tdrpStrDup("See strftime(3) for options.  Default is: %H%M.");
    tt->val_offset = (char *) &movieframe_time_format - &_start_;
    tt->single_val.s = tdrpStrDup("%H%M");
    tt++;
    
    // Parameter 'movieframe_time_mode'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("movieframe_time_mode");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &movieframe_time_mode - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'image_convert_script'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("image_convert_script");
    tt->descr = tdrpStrDup("This script will be exec'd if set whenever an html_mode image is output.");
    tt->help = tdrpStrDup("The full path name of the xwd image will be sent as the script argument. Setting horiz_image_command or cidd.horiz_image_command will override this and allow separate scripts to be called for horiz and vert images.");
    tt->val_offset = (char *) &image_convert_script - &_start_;
    tt->single_val.s = tdrpStrDup("convert_image.csh");
    tt++;
    
    // Parameter 'print_script'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("print_script");
    tt->descr = tdrpStrDup("This script will be exec'd if set whenever a print command is issued.");
    tt->help = tdrpStrDup("The full path name of the xwd image will be sent as the script argument.");
    tt->val_offset = (char *) &print_script - &_start_;
    tt->single_val.s = tdrpStrDup("do_print.csh");
    tt++;
    
    // Parameter 'series_convert_script'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("series_convert_script");
    tt->descr = tdrpStrDup("When the user selects the OutputLoop button, this script will be exec'd after the last image in a loop has been written.");
    tt->help = tdrpStrDup("The arguments will be a list of each output file in the series. Lucid will prepend the cidd.image_dir to each file name which takes the form: cidd_field_name_zoom_name.xwd.");
    tt->val_offset = (char *) &series_convert_script - &_start_;
    tt->single_val.s = tdrpStrDup("make_anim.csh");
    tt++;
    
    // Parameter 'Comment 51'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 51");
    tt->comment_hdr = tdrpStrDup("</IMAGE_GENERATION>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 52'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 52");
    tt->comment_hdr = tdrpStrDup("<AUTO_VERT>");
    tt->comment_text = tdrpStrDup("Predefined vertical sections for image generation.");
    tt++;
    
    // Parameter 'route_winds_active'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("route_winds_active");
    tt->descr = tdrpStrDup("Activates route winds vert section.");
    tt->help = tdrpStrDup("If FALSE, no route winds functionality is available.");
    tt->val_offset = (char *) &route_winds_active - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'route_debug'
    // ctype is '_route_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("route_debug");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Set to DEBUG_NORM or DEBUG_VERBOSE for diagnostic output");
    tt->val_offset = (char *) &route_debug - &_start_;
    tt->enum_def.name = tdrpStrDup("route_debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ROUTE_DEBUG_OFF");
      tt->enum_def.fields[0].val = ROUTE_DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("ROUTE_DEBUG_NORM");
      tt->enum_def.fields[1].val = ROUTE_DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("ROUTE_DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = ROUTE_DEBUG_VERBOSE;
    tt->single_val.e = ROUTE_DEBUG_OFF;
    tt++;
    
    // Parameter 'route_font_height'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("route_font_height");
    tt->descr = tdrpStrDup(" Maximum height in Pixels of labels");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &route_font_height - &_start_;
    tt->single_val.i = 13;
    tt++;
    
    // Parameter 'route_add_waypoints_labels'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("route_add_waypoints_labels");
    tt->descr = tdrpStrDup("Default state of the add_waypoints_labels");
    tt->help = tdrpStrDup("0 = off, 1 = on");
    tt->val_offset = (char *) &route_add_waypoints_labels - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'route_add_wind_text'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("route_add_wind_text");
    tt->descr = tdrpStrDup("Default state of the add_wind_text labels");
    tt->help = tdrpStrDup("0 = off, 1 = on");
    tt->val_offset = (char *) &route_add_wind_text - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'route_label_style'
    // ctype is '_route_label_style_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("route_label_style");
    tt->descr = tdrpStrDup("How to space the labels along the route.");
    tt->help = tdrpStrDup("REGULAR_INTERVALS: use total_length / label_interval. EQUAL_DIVISIONS: use num_labels.");
    tt->val_offset = (char *) &route_label_style - &_start_;
    tt->enum_def.name = tdrpStrDup("route_label_style_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ROUTE_REGULAR_INTERVALS");
      tt->enum_def.fields[0].val = ROUTE_REGULAR_INTERVALS;
      tt->enum_def.fields[1].name = tdrpStrDup("ROUTE_EQUAL_DIVISIONS");
      tt->enum_def.fields[1].val = ROUTE_EQUAL_DIVISIONS;
    tt->single_val.e = ROUTE_REGULAR_INTERVALS;
    tt++;
    
    // Parameter 'route_label_interval'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("route_label_interval");
    tt->descr = tdrpStrDup("Distance in km between winds labels");
    tt->help = tdrpStrDup("Used if label_style is set to REGULAR_INTERVALS");
    tt->val_offset = (char *) &route_label_interval - &_start_;
    tt->single_val.d = 55.6;
    tt++;
    
    // Parameter 'route_num_labels'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("route_num_labels");
    tt->descr = tdrpStrDup("number of route wind labels to plot along the route.");
    tt->help = tdrpStrDup("Typically this should be set between 5 and 20");
    tt->val_offset = (char *) &route_num_labels - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 2;
    tt->max_val.i = 100;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'route_track_line_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("route_track_line_width");
    tt->descr = tdrpStrDup("Width in pixels of the route winds track");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &route_track_line_width - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 1;
    tt->max_val.i = 20;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'route_u_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("route_u_url");
    tt->descr = tdrpStrDup("U Wind Componet");
    tt->help = tdrpStrDup(" URL's take the form  mdvp::[paramfile]//host.dom::dir/dir&fieldname\n");
    tt->val_offset = (char *) &route_u_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp::zoom_mds//neptune::mdv/mm5&U");
    tt++;
    
    // Parameter 'route_v_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("route_v_url");
    tt->descr = tdrpStrDup("v Wind Componet");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &route_v_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp::zoom_mds//neptune::mdv/mm5&V");
    tt++;
    
    // Parameter 'route_paths'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("route_paths");
    tt->descr = tdrpStrDup(" Route path strings - Format of each string isROUTE_LABEL NPOINTS  ID_String Lat Lon ID_String LAT Lon ...\n");
    tt->help = tdrpStrDup("ROUTE_LABEL will be used in the menu, \nNPoints = Number of way points in route \n  Followed by NPoint triplets of the following:\nID_string -> usually a Airport or VOR \nLat Lon :  decimal degrees\n");
    tt->array_offset = (char *) &_route_paths - &_start_;
    tt->array_n_offset = (char *) &route_paths_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 7;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("A-1 8 BULAN 27.0917 124.0000 OSTAR 26.3317 123.0000 SHARK 25.8333 122.3583 ANNNA 25.5717 122.0217 APU 25.1767 121.5233 HLG 24.6400 120.7833 MKG 23.5583 119.6283 ELATO 22.3333 117.5000 ");
      tt->array_vals[1].s = tdrpStrDup("M-750 12 MOLKA 26.6583 124.0000 MORSU 25.9100 123.0000 LEKOS 25.5100 122.4717 ROBIN 25.4200 122.2083 NOKAS 25.1317 121.9917 SANAS 24.8967 121.6917 PILOX 24.4150 121.0250 ANLOT 23.9417 120.5233 TOROX 23.3533 119.9083 RENOT 22.5683 118.5117 DADON 22.2767 118.0033 ENVAR 21.9917 117.5000 ");
      tt->array_vals[2].s = tdrpStrDup("G-581 7 IGURU 23.9500 124.0000 TULTO 23.3233 123.0000 HCN 21.9283 120.8433 PARPA 22.0150 120.1683 CYRUS 22.2167 118.5317 DADON 22.2767 118.0033 ELATO 22.3333 117.5000 ");
      tt->array_vals[3].s = tdrpStrDup("B-591 9 APU 25.1767 121.5233 SANAS 24.8967 121.6917 TINHO 24.3533 122.0283 TITUS 23.8283 121.8517 TACLE 22.9933 121.5867 GID 22.6733 121.4867 TUNNY 22.3600 121.2150 HCN 21.9283 120.8433 DOREX 21.0000 120.7833 ");
      tt->array_vals[4].s = tdrpStrDup("R-583 5 BORDO 26.0167 124.0000 KIKIT 25.8817 123.5917 PABSO 25.6517 122.8750 LEKOS 25.5100 122.4717 APU 25.1767 121.5233 ");
      tt->array_vals[5].s = tdrpStrDup("G-86 3 HCN 21.9283 120.8433 ANDRE 21.7783 120.1683 KAPLI 21.1667 117.5000 ");
      tt->array_vals[6].s = tdrpStrDup("B-576 3 SALMI 28.3150 124.0000 BERBA 27.0783 123.0000 APU 25.1767 121.5233 ");
    tt++;
    
    // Parameter 'Comment 53'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 53");
    tt->comment_hdr = tdrpStrDup("</AUTO_VERT>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 54'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 54");
    tt->comment_hdr = tdrpStrDup("<PLUGINS>");
    tt->comment_text = tdrpStrDup("Communicating with other applications.");
    tt++;
    
    // Parameter 'click_point_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("click_point_fmq_url");
    tt->descr = tdrpStrDup("URL for click point URL.");
    tt->help = tdrpStrDup("The details of the latest click point are written to an FMQ. The format is XML. You can view the FMQ using FmqMon -mode ASCII_PRINT.");
    tt->val_offset = (char *) &click_point_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/fmq/click_point");
    tt++;
    
    // Parameter 'simple_command_timeout_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("simple_command_timeout_secs");
    tt->descr = tdrpStrDup("Length of time to wait before killing simple external commands.");
    tt->help = tdrpStrDup("Used When running single image convert scripts and driving Browsers to web pages.");
    tt->val_offset = (char *) &simple_command_timeout_secs - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'complex_command_timeout_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("complex_command_timeout_secs");
    tt->descr = tdrpStrDup("Length of time to wait before killing complex external commands.");
    tt->help = tdrpStrDup("Used when spawning animation building script.");
    tt->val_offset = (char *) &complex_command_timeout_secs - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'latest_click_mark_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("latest_click_mark_color");
    tt->descr = tdrpStrDup("Color of mark showing latest click location.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &latest_click_mark_color - &_start_;
    tt->single_val.s = tdrpStrDup("red");
    tt++;
    
    // Parameter 'click_posn_rel_to_origin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("click_posn_rel_to_origin");
    tt->descr = tdrpStrDup("Compute click posn in coords relative to display origin.");
    tt->help = tdrpStrDup("If FALSE, click posn is computed in absolute coords for the projection in use.");
    tt->val_offset = (char *) &click_posn_rel_to_origin - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'latest_client_mark_color'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("latest_client_mark_color");
    tt->descr = tdrpStrDup("Color of mark showing latest click of remote client.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &latest_client_mark_color - &_start_;
    tt->single_val.s = tdrpStrDup("yellow");
    tt++;
    
    // Parameter 'remote_ui_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("remote_ui_url");
    tt->descr = tdrpStrDup("FMQ Type URL for Receiving Remote commands.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &remote_ui_url - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/remoteUI");
    tt++;
    
    // Parameter 'draw_export_active'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("draw_export_active");
    tt->descr = tdrpStrDup("Is drawing for export active?");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &draw_export_active - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'draw_export_info'
    // ctype is '_draw_export_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("draw_export_info");
    tt->descr = tdrpStrDup("Human Drawn Products for Export Parameters.");
    tt->help = tdrpStrDup(" Each Entry needs:\nID_Label FMQ_URL Valid_Minutes Default_ID_no    ID_LABEL - This is used to designate Product types\n    FMQ_URL: example: fmqp:://host::dir/file \n   Valid_Minutes: How many minutes the product is valid by default\n   Default_ID_no: Default Data Type (Enumerated ID)\n   Default_label: Test to place into Label field by default\n\n");
    tt->array_offset = (char *) &_draw_export_info - &_start_;
    tt->array_n_offset = (char *) &draw_export_info_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(draw_export_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("draw_export_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("id_label");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_draw_export_info->id_label - (char *) _draw_export_info;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("url");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_draw_export_info->url - (char *) _draw_export_info;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("valid_minutes");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_draw_export_info->valid_minutes - (char *) _draw_export_info;
      tt->struct_def.fields[3].ftype = tdrpStrDup("int");
      tt->struct_def.fields[3].fname = tdrpStrDup("default_id_no");
      tt->struct_def.fields[3].ptype = INT_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_draw_export_info->default_id_no - (char *) _draw_export_info;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("default_label");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_draw_export_info->default_label - (char *) _draw_export_info;
    tt->n_struct_vals = 10;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("Boundry");
      tt->struct_vals[1].s = tdrpStrDup("/tmp/cidd.fmq");
      tt->struct_vals[2].d = 60;
      tt->struct_vals[3].i = 0;
      tt->struct_vals[4].s = tdrpStrDup("A");
      tt->struct_vals[5].s = tdrpStrDup("Boundry-b");
      tt->struct_vals[6].s = tdrpStrDup("/tmp/cidd.fmq");
      tt->struct_vals[7].d = 60;
      tt->struct_vals[8].i = 0;
      tt->struct_vals[9].s = tdrpStrDup("B");
    tt++;
    
    // Parameter 'Comment 55'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 55");
    tt->comment_hdr = tdrpStrDup("</PLUGINS>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 56'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 56");
    tt->comment_hdr = tdrpStrDup("<HELP>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'help_command'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("help_command");
    tt->descr = tdrpStrDup("Main command to run to get help.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &help_command - &_start_;
    tt->single_val.s = tdrpStrDup("chrome http://front.eol.ucar.edu/displayParams/Lucid'");
    tt++;
    
    // Parameter 'canvas_help'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("canvas_help");
    tt->descr = tdrpStrDup("Help text links.");
    tt->help = tdrpStrDup("These take the form:\nwidget_name_help: file_name:file_index_key_string.\nThe HELPPATH environment variable must be set or the help file must be located in /usr/lib/help.\nNote the file name gets expanded to file_name.info.");
    tt->val_offset = (char *) &canvas_help - &_start_;
    tt->single_val.s = tdrpStrDup("cidd_help::canvas");
    tt++;
    
    // Parameter 'frame_message_help'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("frame_message_help");
    tt->descr = tdrpStrDup("Help text links.");
    tt->help = tdrpStrDup("These take the form:\nwidget_name_help: file_name:file_index_key_string.\nThe HELPPATH environment variable must be set or the help file must be located in /usr/lib/help.\nNote the file name gets expanded to file_name.info.");
    tt->val_offset = (char *) &frame_message_help - &_start_;
    tt->single_val.s = tdrpStrDup("cidd_help:frame_message");
    tt++;
    
    // Parameter 'Comment 57'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 57");
    tt->comment_hdr = tdrpStrDup("</HELP>");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
