/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program CartSim
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("CartSim");
    tt->comment_text = tdrpStrDup("This program reads a configuration for simulation, and an example data file (MDV format or CFRADIAL format) to use as a template.  It then replaces the data with simulated fields specified by configuration parameters");
    tt++;
    
    // Parameter 'num_threads'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("num_threads");
    tt->descr = tdrpStrDup("Number of threads.");
    tt->help = tdrpStrDup("One thread is started up per processing time step.");
    tt->val_offset = (char *) &num_threads - &_start_;
    tt->single_val.i = 4;
    tt++;
    
    // Parameter 'thread_debug'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("thread_debug");
    tt->descr = tdrpStrDup("Thread debug");
    tt->help = tdrpStrDup("TRUE to see more details about threads");
    tt->val_offset = (char *) &thread_debug - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'format'
    // ctype is '_Format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("format");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Format of template data");
    tt->val_offset = (char *) &format - &_start_;
    tt->enum_def.name = tdrpStrDup("Format_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("MDV");
      tt->enum_def.fields[0].val = MDV;
      tt->enum_def.fields[1].name = tdrpStrDup("CFRADIAL");
      tt->enum_def.fields[1].val = CFRADIAL;
    tt->single_val.e = MDV;
    tt++;
    
    // Parameter 'template_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("template_url");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Location of MDV or Radx template data");
    tt->val_offset = (char *) &template_url - &_start_;
    tt->single_val.s = tdrpStrDup("unknown");
    tt++;
    
    // Parameter 'template_url_field'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("template_url_field");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Field name");
    tt->val_offset = (char *) &template_url_field - &_start_;
    tt->single_val.s = tdrpStrDup("unknown");
    tt++;
    
    // Parameter 'template_time'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("template_time");
    tt->descr = tdrpStrDup("Template data approximate time");
    tt->help = tdrpStrDup("y m d h m s");
    tt->array_offset = (char *) &_template_time - &_start_;
    tt->array_n_offset = (char *) &template_time_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(int);
    tt->array_n = 6;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].i = 2009;
      tt->array_vals[1].i = 10;
      tt->array_vals[2].i = 27;
      tt->array_vals[3].i = 23;
      tt->array_vals[4].i = 29;
      tt->array_vals[5].i = 23;
    tt++;
    
    // Parameter 'change_grid'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("change_grid");
    tt->descr = tdrpStrDup("TRUE to change grid dimensions (shrink)");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &change_grid - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vlevel_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("vlevel_range");
    tt->descr = tdrpStrDup("min/max vlevel degrees, when change_grid=TRUE");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_vlevel_range - &_start_;
    tt->array_n_offset = (char *) &vlevel_range_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = -1;
      tt->array_vals[1].d = -1;
    tt++;
    
    // Parameter 'azimuth_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("azimuth_range");
    tt->descr = tdrpStrDup("min/max azimuth degrees, when change_grid=TRUE");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_azimuth_range - &_start_;
    tt->array_n_offset = (char *) &azimuth_range_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = -1;
      tt->array_vals[1].d = -1;
    tt++;
    
    // Parameter 'output_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_url");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Location of MDV or Radx simulation output");
    tt->val_offset = (char *) &output_url - &_start_;
    tt->single_val.s = tdrpStrDup("unknown");
    tt++;
    
    // Parameter 'fields'
    // ctype is '_Field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("fields");
    tt->descr = tdrpStrDup("Fields");
    tt->help = tdrpStrDup("Fields written to MDV output. Units of motion are meters/second");
    tt->array_offset = (char *) &_fields - &_start_;
    tt->array_n_offset = (char *) &fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Field_t);
    tt->array_n = 0;
    tt->enum_def.name = tdrpStrDup("Field_t");
    tt->enum_def.nfields = 8;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("RADIAL_VEL");
      tt->enum_def.fields[0].val = RADIAL_VEL;
      tt->enum_def.fields[1].name = tdrpStrDup("VX");
      tt->enum_def.fields[1].val = VX;
      tt->enum_def.fields[2].name = tdrpStrDup("VY");
      tt->enum_def.fields[2].val = VY;
      tt->enum_def.fields[3].name = tdrpStrDup("VZ");
      tt->enum_def.fields[3].val = VZ;
      tt->enum_def.fields[4].name = tdrpStrDup("DBZ");
      tt->enum_def.fields[4].val = DBZ;
      tt->enum_def.fields[5].name = tdrpStrDup("SNR");
      tt->enum_def.fields[5].val = SNR;
      tt->enum_def.fields[6].name = tdrpStrDup("SW");
      tt->enum_def.fields[6].val = SW;
      tt->enum_def.fields[7].name = tdrpStrDup("CLUTTER");
      tt->enum_def.fields[7].val = CLUTTER;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'start_time'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("start_time");
    tt->descr = tdrpStrDup("Starting time for simulation output");
    tt->help = tdrpStrDup("y m d h m s");
    tt->array_offset = (char *) &_start_time - &_start_;
    tt->array_n_offset = (char *) &start_time_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(int);
    tt->array_n = 6;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].i = 2013;
      tt->array_vals[1].i = 10;
      tt->array_vals[2].i = 23;
      tt->array_vals[3].i = 0;
      tt->array_vals[4].i = 0;
      tt->array_vals[5].i = 0;
    tt++;
    
    // Parameter 'simulation_length_minutes'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("simulation_length_minutes");
    tt->descr = tdrpStrDup("Length of sim");
    tt->help = tdrpStrDup("Length (minutes) of the simulated output");
    tt->val_offset = (char *) &simulation_length_minutes - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'simulation_step_minutes'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("simulation_step_minutes");
    tt->descr = tdrpStrDup("Step size (minutes)");
    tt->help = tdrpStrDup("Time between simulation steps (minutes)");
    tt->val_offset = (char *) &simulation_step_minutes - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'microburst'
    // ctype is '_Microburst_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("microburst");
    tt->descr = tdrpStrDup("Microbursts, modelled");
    tt->help = tdrpStrDup("endpoint_index = index to endpoints (should have one endpoint for a regular microburst or two endpoints for a microburst line\nradius_km = kilometers\nzmax_km = km\nmagnitude_knots = windshear (knots)\ndbz_core = dBZ value for the microburst core\nxmotion_knots = knots motion of event\nymotion_knots = knots motion of event\ngain = TRUE for a convergent event, FALSE for divergent\nminutes_to_intensity_fuzzy_index = fuzzy index, minutes->intensity[0,1]\nminutes_to_size_fuzzy_index = fuzzy index, minutes->size(km)\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_microburst - &_start_;
    tt->array_n_offset = (char *) &microburst_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Microburst_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Microburst_t");
    tt->struct_def.nfields = 12;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("endpoint_index");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_microburst->endpoint_index - (char *) _microburst;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("radius_km");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_microburst->radius_km - (char *) _microburst;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("zmax_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_microburst->zmax_km - (char *) _microburst;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("magnitude_knots");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_microburst->magnitude_knots - (char *) _microburst;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dbz_core");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_microburst->dbz_core - (char *) _microburst;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("xmotion_knots");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_microburst->xmotion_knots - (char *) _microburst;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("ymotion_knots");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_microburst->ymotion_knots - (char *) _microburst;
      tt->struct_def.fields[7].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[7].fname = tdrpStrDup("gain");
      tt->struct_def.fields[7].ptype = BOOL_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_microburst->gain - (char *) _microburst;
      tt->struct_def.fields[8].ftype = tdrpStrDup("int");
      tt->struct_def.fields[8].fname = tdrpStrDup("minutes_to_intensity_fuzzy_index");
      tt->struct_def.fields[8].ptype = INT_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_microburst->minutes_to_intensity_fuzzy_index - (char *) _microburst;
      tt->struct_def.fields[9].ftype = tdrpStrDup("int");
      tt->struct_def.fields[9].fname = tdrpStrDup("minutes_to_size_fuzzy_index");
      tt->struct_def.fields[9].ptype = INT_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_microburst->minutes_to_size_fuzzy_index - (char *) _microburst;
      tt->struct_def.fields[10].ftype = tdrpStrDup("double");
      tt->struct_def.fields[10].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[10].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_microburst->start_minutes - (char *) _microburst;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_microburst->lifetime_minutes - (char *) _microburst;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'storm'
    // ctype is '_Storm_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("storm");
    tt->descr = tdrpStrDup("Storms, simple spherical objects with reflectivity within");
    tt->help = tdrpStrDup("endpoint_index = index to endpoints\nradius_km = radius of storm (km)\nmin_z_km = minimum height (km)\nxmotion_knots = motion of storm (knots)\nymotion_knots = motion of storm (knots)\nzmotion_knots = motion of storm (knots)\noverride = true to replace dbz no matter what, false to use max of storm and existing value\nnoise = amount of noise\nkm_from_center_to_dbz_fuzzy_index = fuzzy index, km -> dbz\nminutes_to_intensity_fuzzy_index = fuzzy index, minutes->intensity[0,1]\nminutes_to_size_fuzzy_index = fuzzy index, minutes->size(km)\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_storm - &_start_;
    tt->array_n_offset = (char *) &storm_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Storm_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Storm_t");
    tt->struct_def.nfields = 13;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("endpoint_index");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_storm->endpoint_index - (char *) _storm;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("radius_km");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_storm->radius_km - (char *) _storm;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("min_z_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_storm->min_z_km - (char *) _storm;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("xmotion_knots");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_storm->xmotion_knots - (char *) _storm;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("ymotion_knots");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_storm->ymotion_knots - (char *) _storm;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("zmotion_knots");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_storm->zmotion_knots - (char *) _storm;
      tt->struct_def.fields[6].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[6].fname = tdrpStrDup("override");
      tt->struct_def.fields[6].ptype = BOOL_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_storm->override - (char *) _storm;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("noise");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_storm->noise - (char *) _storm;
      tt->struct_def.fields[8].ftype = tdrpStrDup("int");
      tt->struct_def.fields[8].fname = tdrpStrDup("km_from_center_to_dbz_fuzzy_index");
      tt->struct_def.fields[8].ptype = INT_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_storm->km_from_center_to_dbz_fuzzy_index - (char *) _storm;
      tt->struct_def.fields[9].ftype = tdrpStrDup("int");
      tt->struct_def.fields[9].fname = tdrpStrDup("minutes_to_intensity_fuzzy_index");
      tt->struct_def.fields[9].ptype = INT_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_storm->minutes_to_intensity_fuzzy_index - (char *) _storm;
      tt->struct_def.fields[10].ftype = tdrpStrDup("int");
      tt->struct_def.fields[10].fname = tdrpStrDup("minutes_to_size_fuzzy_index");
      tt->struct_def.fields[10].ptype = INT_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_storm->minutes_to_size_fuzzy_index - (char *) _storm;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_storm->start_minutes - (char *) _storm;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_storm->lifetime_minutes - (char *) _storm;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'turbulence'
    // ctype is '_Turbulence_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("turbulence");
    tt->descr = tdrpStrDup("Turbulence, simple spherical objects with turbulent winds");
    tt->help = tdrpStrDup("x_km = center (km)\ny_km = center (km)\nz_km = center (km)\nradius_km = radius of event (km)\nnoise = amount of noise\nsw = spectrum width\nxmotion_knots = motion of event (knots)\nymotion_knots = motion of event (knots)\nzmotion_knots = motion of event (knots)\nminutes_to_intensity_fuzzy_index = fuzzy index, minutes->intensity[0,1]\nminutes_to_size_fuzzy_index = fuzzy index, minutes->size(km)\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_turbulence - &_start_;
    tt->array_n_offset = (char *) &turbulence_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Turbulence_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Turbulence_t");
    tt->struct_def.nfields = 13;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x_km");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_turbulence->x_km - (char *) _turbulence;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y_km");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_turbulence->y_km - (char *) _turbulence;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("z_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_turbulence->z_km - (char *) _turbulence;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("radius_km");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_turbulence->radius_km - (char *) _turbulence;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("noise");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_turbulence->noise - (char *) _turbulence;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("sw");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_turbulence->sw - (char *) _turbulence;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("xmotion_knots");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_turbulence->xmotion_knots - (char *) _turbulence;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("ymotion_knots");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_turbulence->ymotion_knots - (char *) _turbulence;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("zmotion_knots");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_turbulence->zmotion_knots - (char *) _turbulence;
      tt->struct_def.fields[9].ftype = tdrpStrDup("int");
      tt->struct_def.fields[9].fname = tdrpStrDup("minutes_to_intensity_fuzzy_index");
      tt->struct_def.fields[9].ptype = INT_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_turbulence->minutes_to_intensity_fuzzy_index - (char *) _turbulence;
      tt->struct_def.fields[10].ftype = tdrpStrDup("int");
      tt->struct_def.fields[10].fname = tdrpStrDup("minutes_to_size_fuzzy_index");
      tt->struct_def.fields[10].ptype = INT_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_turbulence->minutes_to_size_fuzzy_index - (char *) _turbulence;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_turbulence->start_minutes - (char *) _turbulence;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_turbulence->lifetime_minutes - (char *) _turbulence;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'gust_front'
    // ctype is '_GustFront_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("gust_front");
    tt->descr = tdrpStrDup("Gust Fronts, modelled");
    tt->help = tdrpStrDup("endpts_index = index to the endpoints for this front, (at least 2)\nthin_line_z_km = param for thin line (km)\nthin_line_x_km = param for thin line (km)\nthin_line_r_km = param for thin line (km)\nz1_km = param for front (km)\nz2_km = param for front (km)\nz3_km = param for front (km)\nx1_km = param for front (km)\nx2_km = param for front (km)\nxb_km = param for front (km)\nwbehind_knots = max wind behind the front (knots)\nthin_line_dbz = reflectivity of the thin line\nxmotion_knots = motion of front (knots)\nymotion_knots = motion of front (knots)\nside_decay = scale factor for decay on sides of front\nwave = true for a 'wave' front\nminutes_to_intensity_fuzzy_index = fuzzy index, minutes->intensity[0,1]\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_gust_front - &_start_;
    tt->array_n_offset = (char *) &gust_front_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(GustFront_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("GustFront_t");
    tt->struct_def.nfields = 19;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("endpts_index");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_gust_front->endpts_index - (char *) _gust_front;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("thin_line_z_km");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_gust_front->thin_line_z_km - (char *) _gust_front;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("thin_line_x_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_gust_front->thin_line_x_km - (char *) _gust_front;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("thin_line_r_km");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_gust_front->thin_line_r_km - (char *) _gust_front;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("z1_km");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_gust_front->z1_km - (char *) _gust_front;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("z2_km");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_gust_front->z2_km - (char *) _gust_front;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("z3_km");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_gust_front->z3_km - (char *) _gust_front;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("x1_km");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_gust_front->x1_km - (char *) _gust_front;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("x2_km");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_gust_front->x2_km - (char *) _gust_front;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("xb_km");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_gust_front->xb_km - (char *) _gust_front;
      tt->struct_def.fields[10].ftype = tdrpStrDup("double");
      tt->struct_def.fields[10].fname = tdrpStrDup("wbehind_knots");
      tt->struct_def.fields[10].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_gust_front->wbehind_knots - (char *) _gust_front;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("thin_line_dbz");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_gust_front->thin_line_dbz - (char *) _gust_front;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("xmotion_knots");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_gust_front->xmotion_knots - (char *) _gust_front;
      tt->struct_def.fields[13].ftype = tdrpStrDup("double");
      tt->struct_def.fields[13].fname = tdrpStrDup("ymotion_knots");
      tt->struct_def.fields[13].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_gust_front->ymotion_knots - (char *) _gust_front;
      tt->struct_def.fields[14].ftype = tdrpStrDup("double");
      tt->struct_def.fields[14].fname = tdrpStrDup("side_decay");
      tt->struct_def.fields[14].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[14].rel_offset = 
        (char *) &_gust_front->side_decay - (char *) _gust_front;
      tt->struct_def.fields[15].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[15].fname = tdrpStrDup("wave");
      tt->struct_def.fields[15].ptype = BOOL_TYPE;
      tt->struct_def.fields[15].rel_offset = 
        (char *) &_gust_front->wave - (char *) _gust_front;
      tt->struct_def.fields[16].ftype = tdrpStrDup("int");
      tt->struct_def.fields[16].fname = tdrpStrDup("minutes_to_intensity_fuzzy_index");
      tt->struct_def.fields[16].ptype = INT_TYPE;
      tt->struct_def.fields[16].rel_offset = 
        (char *) &_gust_front->minutes_to_intensity_fuzzy_index - (char *) _gust_front;
      tt->struct_def.fields[17].ftype = tdrpStrDup("double");
      tt->struct_def.fields[17].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[17].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[17].rel_offset = 
        (char *) &_gust_front->start_minutes - (char *) _gust_front;
      tt->struct_def.fields[18].ftype = tdrpStrDup("double");
      tt->struct_def.fields[18].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[18].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[18].rel_offset = 
        (char *) &_gust_front->lifetime_minutes - (char *) _gust_front;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'deviant_ray'
    // ctype is '_DeviantRay_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("deviant_ray");
    tt->descr = tdrpStrDup("Deviant Rays, particular orientation range with 'different' values from origin out to farthest point in domain\n");
    tt->help = tdrpStrDup("angle0_degrees = smallest (math) angle of ray\nangle1_degrees = largest (math) angle of ray\nxvel_knots = velocity value (knots) within ray\nyvel_knots = velocity value (knots) within ray\nzvel_knots = velocity value (knots) within ray\ndbz = value within ray\nnoise = noise level within the ray\nclutter = clutter value within the ray\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_deviant_ray - &_start_;
    tt->array_n_offset = (char *) &deviant_ray_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(DeviantRay_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("DeviantRay_t");
    tt->struct_def.nfields = 10;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("angle0_degrees");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_deviant_ray->angle0_degrees - (char *) _deviant_ray;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("angle1_degrees");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_deviant_ray->angle1_degrees - (char *) _deviant_ray;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("xvel_knots");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_deviant_ray->xvel_knots - (char *) _deviant_ray;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("yvel_knots");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_deviant_ray->yvel_knots - (char *) _deviant_ray;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("zvel_knots");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_deviant_ray->zvel_knots - (char *) _deviant_ray;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dbz");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_deviant_ray->dbz - (char *) _deviant_ray;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("noise");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_deviant_ray->noise - (char *) _deviant_ray;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("clutter");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_deviant_ray->clutter - (char *) _deviant_ray;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_deviant_ray->start_minutes - (char *) _deviant_ray;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_deviant_ray->lifetime_minutes - (char *) _deviant_ray;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'polar_speck'
    // ctype is '_PolarSpeck_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("polar_speck");
    tt->descr = tdrpStrDup("Polar Specks = small specks where values are 'different', polar coordinates");
    tt->help = tdrpStrDup("theta_degrees = center of speck azimuthally (math degrees)\nphi_degrees = center of speck elevation angle (math degrees)\nr_km = center of speck radially (km)\ndtheta_degrees = total width of speck azimuthally (math degrees)\ndphi_degrees = total width of speck elevation angle (math degrees)\ndr_km = total width of speck radially (km)\ndbz = value within speck\nxvel_knots = velocity value (knots) within speck\nyvel_knots = velocity value (knots) within speck\nzvel_knots = velocity value (knots) within speck\nnoise = noise level within the speck\nclutter = clutter value within the speck\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_polar_speck - &_start_;
    tt->array_n_offset = (char *) &polar_speck_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(PolarSpeck_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("PolarSpeck_t");
    tt->struct_def.nfields = 14;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("theta_degrees");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_polar_speck->theta_degrees - (char *) _polar_speck;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("phi_degrees");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_polar_speck->phi_degrees - (char *) _polar_speck;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("r_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_polar_speck->r_km - (char *) _polar_speck;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("dtheta_degrees");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_polar_speck->dtheta_degrees - (char *) _polar_speck;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dphi_degrees");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_polar_speck->dphi_degrees - (char *) _polar_speck;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dr_km");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_polar_speck->dr_km - (char *) _polar_speck;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("dbz");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_polar_speck->dbz - (char *) _polar_speck;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("xvel_knots");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_polar_speck->xvel_knots - (char *) _polar_speck;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("yvel_knots");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_polar_speck->yvel_knots - (char *) _polar_speck;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("zvel_knots");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_polar_speck->zvel_knots - (char *) _polar_speck;
      tt->struct_def.fields[10].ftype = tdrpStrDup("double");
      tt->struct_def.fields[10].fname = tdrpStrDup("noise");
      tt->struct_def.fields[10].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_polar_speck->noise - (char *) _polar_speck;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("clutter");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_polar_speck->clutter - (char *) _polar_speck;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_polar_speck->start_minutes - (char *) _polar_speck;
      tt->struct_def.fields[13].ftype = tdrpStrDup("double");
      tt->struct_def.fields[13].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[13].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_polar_speck->lifetime_minutes - (char *) _polar_speck;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'cartesian_speck'
    // ctype is '_CartesianSpeck_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("cartesian_speck");
    tt->descr = tdrpStrDup("Cartesian Specks = small specks where values are 'different', cartesian coordinates");
    tt->help = tdrpStrDup("x_km = center of speck (km)\ny_km = center of speck (km)\nz_km = center of speck (km)\ndx_km = width of speck (km)\ndy_km = width of speck (km)\ndz_km = width of speck (km)\ndbz = value within speck\nxvel_knots = velocity value (knots) within speck\nyvel_knots = velocity value (knots) within speck\nzvel_knots = velocity value (knots) within speck\nnoise = noise level within the speck\nclutter = clutter value within the speck\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_cartesian_speck - &_start_;
    tt->array_n_offset = (char *) &cartesian_speck_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(CartesianSpeck_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("CartesianSpeck_t");
    tt->struct_def.nfields = 14;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x_km");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_cartesian_speck->x_km - (char *) _cartesian_speck;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y_km");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_cartesian_speck->y_km - (char *) _cartesian_speck;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("z_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_cartesian_speck->z_km - (char *) _cartesian_speck;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("dx_km");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_cartesian_speck->dx_km - (char *) _cartesian_speck;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dy_km");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_cartesian_speck->dy_km - (char *) _cartesian_speck;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dz_km");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_cartesian_speck->dz_km - (char *) _cartesian_speck;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("dbz");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_cartesian_speck->dbz - (char *) _cartesian_speck;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("xvel_knots");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_cartesian_speck->xvel_knots - (char *) _cartesian_speck;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("yvel_knots");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_cartesian_speck->yvel_knots - (char *) _cartesian_speck;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("zvel_knots");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_cartesian_speck->zvel_knots - (char *) _cartesian_speck;
      tt->struct_def.fields[10].ftype = tdrpStrDup("double");
      tt->struct_def.fields[10].fname = tdrpStrDup("noise");
      tt->struct_def.fields[10].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_cartesian_speck->noise - (char *) _cartesian_speck;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("clutter");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_cartesian_speck->clutter - (char *) _cartesian_speck;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_cartesian_speck->start_minutes - (char *) _cartesian_speck;
      tt->struct_def.fields[13].ftype = tdrpStrDup("double");
      tt->struct_def.fields[13].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[13].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_cartesian_speck->lifetime_minutes - (char *) _cartesian_speck;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'vel_circle'
    // ctype is '_VelCircle_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("vel_circle");
    tt->descr = tdrpStrDup("Velocity Circles, spherical region where velocity values are different than surroundings");
    tt->help = tdrpStrDup("x_km = center of object km\ny_km = center of object km\nz_km = center of object km\nradius_km = radius (km)\nnoise = noise level inside object\nxvel_knots = velocity value (knots) within object\nyvel_knots = velocity value (knots) within object\nzvel_knots = velocity value (knots) within object\nxmotion_knots = motion of object (knots)\nymotion_knots = motion of object (knots)\nzmotion_knots = motion of object (knots)\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_vel_circle - &_start_;
    tt->array_n_offset = (char *) &vel_circle_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(VelCircle_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("VelCircle_t");
    tt->struct_def.nfields = 13;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x_km");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_vel_circle->x_km - (char *) _vel_circle;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y_km");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_vel_circle->y_km - (char *) _vel_circle;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("z_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_vel_circle->z_km - (char *) _vel_circle;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("radius_km");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_vel_circle->radius_km - (char *) _vel_circle;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("noise");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_vel_circle->noise - (char *) _vel_circle;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("xvel_knots");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_vel_circle->xvel_knots - (char *) _vel_circle;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("yvel_knots");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_vel_circle->yvel_knots - (char *) _vel_circle;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("zvel_knots");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_vel_circle->zvel_knots - (char *) _vel_circle;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("xmotion_knots");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_vel_circle->xmotion_knots - (char *) _vel_circle;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("ymotion_knots");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_vel_circle->ymotion_knots - (char *) _vel_circle;
      tt->struct_def.fields[10].ftype = tdrpStrDup("double");
      tt->struct_def.fields[10].fname = tdrpStrDup("zmotion_knots");
      tt->struct_def.fields[10].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_vel_circle->zmotion_knots - (char *) _vel_circle;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_vel_circle->start_minutes - (char *) _vel_circle;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_vel_circle->lifetime_minutes - (char *) _vel_circle;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'clutter_region'
    // ctype is '_ClutterRegion_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("clutter_region");
    tt->descr = tdrpStrDup("ClutterRegion = region in polar space with random clutter. Points either have clutter or not, and if they do the reflectivity is high and the velocity is 0.");
    tt->help = tdrpStrDup("theta_degrees = center azimuthally (math degrees)\nphi_degrees = center elevation angle (math degrees)\nr_km = center radially (km)\ndtheta_degrees = total width azimuthally (math degrees)\ndphi_degrees = total width elevation angle (math degrees)\ndr_km = total width radially (km)\ndbz = high dbz value where there is clutter\nvel = high |vel| knots value where there is clutter, and values_random=true\nvalues_random = TRUE for random data values up to high value, FALSE for vel=0 and dbz=the dbz param value\nclutter = clutter value to use\npercent = percent of points in region to be given dbz/vel clutter values\npercent_correct = percent of the clutter points correctly flagged as clutter\nstart_minutes = minutes after simulation start for event start\nlifetime_minutes = minutes the event will live\n");
    tt->array_offset = (char *) &_clutter_region - &_start_;
    tt->array_n_offset = (char *) &clutter_region_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(ClutterRegion_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("ClutterRegion_t");
    tt->struct_def.nfields = 14;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("theta_degrees");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_clutter_region->theta_degrees - (char *) _clutter_region;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("phi_degrees");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_clutter_region->phi_degrees - (char *) _clutter_region;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("r_km");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_clutter_region->r_km - (char *) _clutter_region;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("dtheta_degrees");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_clutter_region->dtheta_degrees - (char *) _clutter_region;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dphi_degrees");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_clutter_region->dphi_degrees - (char *) _clutter_region;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dr_km");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_clutter_region->dr_km - (char *) _clutter_region;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("dbz");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_clutter_region->dbz - (char *) _clutter_region;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("vel");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_clutter_region->vel - (char *) _clutter_region;
      tt->struct_def.fields[8].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[8].fname = tdrpStrDup("values_random");
      tt->struct_def.fields[8].ptype = BOOL_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_clutter_region->values_random - (char *) _clutter_region;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("clutter");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_clutter_region->clutter - (char *) _clutter_region;
      tt->struct_def.fields[10].ftype = tdrpStrDup("double");
      tt->struct_def.fields[10].fname = tdrpStrDup("percent");
      tt->struct_def.fields[10].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_clutter_region->percent - (char *) _clutter_region;
      tt->struct_def.fields[11].ftype = tdrpStrDup("double");
      tt->struct_def.fields[11].fname = tdrpStrDup("percent_correct");
      tt->struct_def.fields[11].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_clutter_region->percent_correct - (char *) _clutter_region;
      tt->struct_def.fields[12].ftype = tdrpStrDup("double");
      tt->struct_def.fields[12].fname = tdrpStrDup("start_minutes");
      tt->struct_def.fields[12].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_clutter_region->start_minutes - (char *) _clutter_region;
      tt->struct_def.fields[13].ftype = tdrpStrDup("double");
      tt->struct_def.fields[13].fname = tdrpStrDup("lifetime_minutes");
      tt->struct_def.fields[13].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_clutter_region->lifetime_minutes - (char *) _clutter_region;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'ambient_vel_knots'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ambient_vel_knots");
    tt->descr = tdrpStrDup("wind field ambient value (knots) (x,y,z)");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_ambient_vel_knots - &_start_;
    tt->array_n_offset = (char *) &ambient_vel_knots_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 3;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = 1;
      tt->array_vals[1].d = 1;
      tt->array_vals[2].d = 0;
    tt++;
    
    // Parameter 'ambient_dbz'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ambient_dbz");
    tt->descr = tdrpStrDup("ambient reflectivity (dbz)");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ambient_dbz - &_start_;
    tt->single_val.d = 5;
    tt++;
    
    // Parameter 'ambient_noise'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ambient_noise");
    tt->descr = tdrpStrDup("ambient noise, added to fields");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ambient_noise - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'ambient_sw'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ambient_sw");
    tt->descr = tdrpStrDup("ambient spectrum width");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ambient_sw - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'ambient_snr'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ambient_snr");
    tt->descr = tdrpStrDup("ambient snr");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ambient_snr - &_start_;
    tt->single_val.d = 20;
    tt++;
    
    // Parameter 'ambient_clutter'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ambient_clutter");
    tt->descr = tdrpStrDup("ambient clutter");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ambient_clutter - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'utilda'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("utilda");
    tt->descr = tdrpStrDup("Utilda");
    tt->help = tdrpStrDup("Mapping from r/rmax to scale used by microburst model");
    tt->array_offset = (char *) &_utilda - &_start_;
    tt->array_n_offset = (char *) &utilda_n - &_start_;
    tt->is_private = TRUE;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 26;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_utilda->x - (char *) _utilda;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_utilda->y - (char *) _utilda;
    tt->n_struct_vals = 52;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0.1;
      tt->struct_vals[3].d = 0.094702;
      tt->struct_vals[4].d = 0.2;
      tt->struct_vals[5].d = 0.184107;
      tt->struct_vals[6].d = 0.3;
      tt->struct_vals[7].d = 0.276161;
      tt->struct_vals[8].d = 0.4;
      tt->struct_vals[9].d = 0.37881;
      tt->struct_vals[10].d = 0.5;
      tt->struct_vals[11].d = 0.5;
      tt->struct_vals[12].d = 0.6;
      tt->struct_vals[13].d = 0.642381;
      tt->struct_vals[14].d = 0.7;
      tt->struct_vals[15].d = 0.787411;
      tt->struct_vals[16].d = 0.8;
      tt->struct_vals[17].d = 0.91125;
      tt->struct_vals[18].d = 0.9;
      tt->struct_vals[19].d = 0.990059;
      tt->struct_vals[20].d = 1;
      tt->struct_vals[21].d = 1;
      tt->struct_vals[22].d = 1.1;
      tt->struct_vals[23].d = 0.926174;
      tt->struct_vals[24].d = 1.2;
      tt->struct_vals[25].d = 0.789451;
      tt->struct_vals[26].d = 1.3;
      tt->struct_vals[27].d = 0.61964;
      tt->struct_vals[28].d = 1.4;
      tt->struct_vals[29].d = 0.446553;
      tt->struct_vals[30].d = 1.5;
      tt->struct_vals[31].d = 0.3;
      tt->struct_vals[32].d = 1.6;
      tt->struct_vals[33].d = 0.202522;
      tt->struct_vals[34].d = 1.7;
      tt->struct_vals[35].d = 0.147587;
      tt->struct_vals[36].d = 1.8;
      tt->struct_vals[37].d = 0.121389;
      tt->struct_vals[38].d = 1.9;
      tt->struct_vals[39].d = 0.110128;
      tt->struct_vals[40].d = 2;
      tt->struct_vals[41].d = 0.1;
      tt->struct_vals[42].d = 2.1;
      tt->struct_vals[43].d = 0.080536;
      tt->struct_vals[44].d = 2.2;
      tt->struct_vals[45].d = 0.054603;
      tt->struct_vals[46].d = 2.3;
      tt->struct_vals[47].d = 0.028402;
      tt->struct_vals[48].d = 2.4;
      tt->struct_vals[49].d = 0.008134;
      tt->struct_vals[50].d = 2.5;
      tt->struct_vals[51].d = 0;
    tt++;
    
    // Parameter 'stilda'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("stilda");
    tt->descr = tdrpStrDup("Stilda");
    tt->help = tdrpStrDup("Mapping from z/zmax to scale used by microburst model");
    tt->array_offset = (char *) &_stilda - &_start_;
    tt->array_n_offset = (char *) &stilda_n - &_start_;
    tt->is_private = TRUE;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 50;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_stilda->x - (char *) _stilda;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_stilda->y - (char *) _stilda;
    tt->n_struct_vals = 100;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0.5;
      tt->struct_vals[2].d = 0.1;
      tt->struct_vals[3].d = 0.672609;
      tt->struct_vals[4].d = 0.2;
      tt->struct_vals[5].d = 0.8;
      tt->struct_vals[6].d = 0.3;
      tt->struct_vals[7].d = 0.894738;
      tt->struct_vals[8].d = 0.4;
      tt->struct_vals[9].d = 0.962255;
      tt->struct_vals[10].d = 0.5;
      tt->struct_vals[11].d = 1.0062;
      tt->struct_vals[12].d = 0.6;
      tt->struct_vals[13].d = 1.03022;
      tt->struct_vals[14].d = 0.7;
      tt->struct_vals[15].d = 1.03796;
      tt->struct_vals[16].d = 0.8;
      tt->struct_vals[17].d = 1.03307;
      tt->struct_vals[18].d = 0.9;
      tt->struct_vals[19].d = 1.0192;
      tt->struct_vals[20].d = 1;
      tt->struct_vals[21].d = 1;
      tt->struct_vals[22].d = 1.1;
      tt->struct_vals[23].d = 0.978524;
      tt->struct_vals[24].d = 1.2;
      tt->struct_vals[25].d = 0.955473;
      tt->struct_vals[26].d = 1.3;
      tt->struct_vals[27].d = 0.930957;
      tt->struct_vals[28].d = 1.4;
      tt->struct_vals[29].d = 0.905087;
      tt->struct_vals[30].d = 1.5;
      tt->struct_vals[31].d = 0.877972;
      tt->struct_vals[32].d = 1.6;
      tt->struct_vals[33].d = 0.849723;
      tt->struct_vals[34].d = 1.7;
      tt->struct_vals[35].d = 0.820449;
      tt->struct_vals[36].d = 1.8;
      tt->struct_vals[37].d = 0.790261;
      tt->struct_vals[38].d = 1.9;
      tt->struct_vals[39].d = 0.759268;
      tt->struct_vals[40].d = 2;
      tt->struct_vals[41].d = 0.727582;
      tt->struct_vals[42].d = 2.1;
      tt->struct_vals[43].d = 0.69531;
      tt->struct_vals[44].d = 2.2;
      tt->struct_vals[45].d = 0.662565;
      tt->struct_vals[46].d = 2.3;
      tt->struct_vals[47].d = 0.629456;
      tt->struct_vals[48].d = 2.4;
      tt->struct_vals[49].d = 0.596092;
      tt->struct_vals[50].d = 2.5;
      tt->struct_vals[51].d = 0.562585;
      tt->struct_vals[52].d = 2.6;
      tt->struct_vals[53].d = 0.529043;
      tt->struct_vals[54].d = 2.7;
      tt->struct_vals[55].d = 0.495578;
      tt->struct_vals[56].d = 2.8;
      tt->struct_vals[57].d = 0.462299;
      tt->struct_vals[58].d = 2.9;
      tt->struct_vals[59].d = 0.429316;
      tt->struct_vals[60].d = 3;
      tt->struct_vals[61].d = 0.396739;
      tt->struct_vals[62].d = 3.1;
      tt->struct_vals[63].d = 0.364679;
      tt->struct_vals[64].d = 3.2;
      tt->struct_vals[65].d = 0.333245;
      tt->struct_vals[66].d = 3.3;
      tt->struct_vals[67].d = 0.302547;
      tt->struct_vals[68].d = 3.4;
      tt->struct_vals[69].d = 0.272696;
      tt->struct_vals[70].d = 3.5;
      tt->struct_vals[71].d = 0.243801;
      tt->struct_vals[72].d = 3.6;
      tt->struct_vals[73].d = 0.215973;
      tt->struct_vals[74].d = 3.7;
      tt->struct_vals[75].d = 0.189321;
      tt->struct_vals[76].d = 3.8;
      tt->struct_vals[77].d = 0.163957;
      tt->struct_vals[78].d = 3.9;
      tt->struct_vals[79].d = 0.139988;
      tt->struct_vals[80].d = 4;
      tt->struct_vals[81].d = 0.117527;
      tt->struct_vals[82].d = 4.1;
      tt->struct_vals[83].d = 0.096683;
      tt->struct_vals[84].d = 4.2;
      tt->struct_vals[85].d = 0.077565;
      tt->struct_vals[86].d = 4.3;
      tt->struct_vals[87].d = 0.060285;
      tt->struct_vals[88].d = 4.4;
      tt->struct_vals[89].d = 0.044951;
      tt->struct_vals[90].d = 4.5;
      tt->struct_vals[91].d = 0.031675;
      tt->struct_vals[92].d = 4.6;
      tt->struct_vals[93].d = 0.020565;
      tt->struct_vals[94].d = 4.7;
      tt->struct_vals[95].d = 0.011733;
      tt->struct_vals[96].d = 4.8;
      tt->struct_vals[97].d = 0.005288;
      tt->struct_vals[98].d = 4.9;
      tt->struct_vals[99].d = 0.00134;
    tt++;
    
    // Parameter 'wtilda'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("wtilda");
    tt->descr = tdrpStrDup("Wtilda");
    tt->help = tdrpStrDup("Mapping from z/zmax to scale used by microburst model");
    tt->array_offset = (char *) &_wtilda - &_start_;
    tt->array_n_offset = (char *) &wtilda_n - &_start_;
    tt->is_private = TRUE;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 81;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_wtilda->x - (char *) _wtilda;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_wtilda->y - (char *) _wtilda;
    tt->n_struct_vals = 162;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0.1;
      tt->struct_vals[3].d = 0.0032;
      tt->struct_vals[4].d = 0.2;
      tt->struct_vals[5].d = 0.012267;
      tt->struct_vals[6].d = 0.3;
      tt->struct_vals[7].d = 0.0264;
      tt->struct_vals[8].d = 0.4;
      tt->struct_vals[9].d = 0.0448;
      tt->struct_vals[10].d = 0.5;
      tt->struct_vals[11].d = 0.066667;
      tt->struct_vals[12].d = 0.6;
      tt->struct_vals[13].d = 0.0912;
      tt->struct_vals[14].d = 0.7;
      tt->struct_vals[15].d = 0.1176;
      tt->struct_vals[16].d = 0.8;
      tt->struct_vals[17].d = 0.145067;
      tt->struct_vals[18].d = 0.9;
      tt->struct_vals[19].d = 0.1728;
      tt->struct_vals[20].d = 1;
      tt->struct_vals[21].d = 0.2;
      tt->struct_vals[22].d = 1.1;
      tt->struct_vals[23].d = 0.226089;
      tt->struct_vals[24].d = 1.2;
      tt->struct_vals[25].d = 0.251378;
      tt->struct_vals[26].d = 1.3;
      tt->struct_vals[27].d = 0.2764;
      tt->struct_vals[28].d = 1.4;
      tt->struct_vals[29].d = 0.301689;
      tt->struct_vals[30].d = 1.5;
      tt->struct_vals[31].d = 0.327778;
      tt->struct_vals[32].d = 1.6;
      tt->struct_vals[33].d = 0.3552;
      tt->struct_vals[34].d = 1.7;
      tt->struct_vals[35].d = 0.384489;
      tt->struct_vals[36].d = 1.8;
      tt->struct_vals[37].d = 0.416178;
      tt->struct_vals[38].d = 1.9;
      tt->struct_vals[39].d = 0.4508;
      tt->struct_vals[40].d = 2;
      tt->struct_vals[41].d = 0.488889;
      tt->struct_vals[42].d = 2.1;
      tt->struct_vals[43].d = 0.530978;
      tt->struct_vals[44].d = 2.2;
      tt->struct_vals[45].d = 0.5776;
      tt->struct_vals[46].d = 2.3;
      tt->struct_vals[47].d = 0.629289;
      tt->struct_vals[48].d = 2.4;
      tt->struct_vals[49].d = 0.686578;
      tt->struct_vals[50].d = 2.5;
      tt->struct_vals[51].d = 0.75;
      tt->struct_vals[52].d = 2.6;
      tt->struct_vals[53].d = 0.818667;
      tt->struct_vals[54].d = 2.7;
      tt->struct_vals[55].d = 0.886;
      tt->struct_vals[56].d = 2.8;
      tt->struct_vals[57].d = 0.944;
      tt->struct_vals[58].d = 2.9;
      tt->struct_vals[59].d = 0.984667;
      tt->struct_vals[60].d = 3;
      tt->struct_vals[61].d = 1;
      tt->struct_vals[62].d = 5;
      tt->struct_vals[63].d = 1;
      tt->struct_vals[64].d = 5.1;
      tt->struct_vals[65].d = 0.996403;
      tt->struct_vals[66].d = 5.2;
      tt->struct_vals[67].d = 0.985975;
      tt->struct_vals[68].d = 5.3;
      tt->struct_vals[69].d = 0.969259;
      tt->struct_vals[70].d = 5.4;
      tt->struct_vals[71].d = 0.9468;
      tt->struct_vals[72].d = 5.5;
      tt->struct_vals[73].d = 0.919141;
      tt->struct_vals[74].d = 5.6;
      tt->struct_vals[75].d = 0.886825;
      tt->struct_vals[76].d = 5.7;
      tt->struct_vals[77].d = 0.850397;
      tt->struct_vals[78].d = 5.8;
      tt->struct_vals[79].d = 0.8104;
      tt->struct_vals[80].d = 5.9;
      tt->struct_vals[81].d = 0.767378;
      tt->struct_vals[82].d = 6;
      tt->struct_vals[83].d = 0.721875;
      tt->struct_vals[84].d = 6.1;
      tt->struct_vals[85].d = 0.674434;
      tt->struct_vals[86].d = 6.2;
      tt->struct_vals[87].d = 0.6256;
      tt->struct_vals[88].d = 6.3;
      tt->struct_vals[89].d = 0.575916;
      tt->struct_vals[90].d = 6.4;
      tt->struct_vals[91].d = 0.525925;
      tt->struct_vals[92].d = 6.5;
      tt->struct_vals[93].d = 0.476172;
      tt->struct_vals[94].d = 6.6;
      tt->struct_vals[95].d = 0.4272;
      tt->struct_vals[96].d = 6.7;
      tt->struct_vals[97].d = 0.379553;
      tt->struct_vals[98].d = 6.8;
      tt->struct_vals[99].d = 0.333775;
      tt->struct_vals[100].d = 6.9;
      tt->struct_vals[101].d = 0.290409;
      tt->struct_vals[102].d = 7;
      tt->struct_vals[103].d = 0.25;
      tt->struct_vals[104].d = 7.1;
      tt->struct_vals[105].d = 0.212975;
      tt->struct_vals[106].d = 7.2;
      tt->struct_vals[107].d = 0.179304;
      tt->struct_vals[108].d = 7.3;
      tt->struct_vals[109].d = 0.148838;
      tt->struct_vals[110].d = 7.4;
      tt->struct_vals[111].d = 0.12143;
      tt->struct_vals[112].d = 7.5;
      tt->struct_vals[113].d = 0.096933;
      tt->struct_vals[114].d = 7.6;
      tt->struct_vals[115].d = 0.0752;
      tt->struct_vals[116].d = 7.7;
      tt->struct_vals[117].d = 0.056084;
      tt->struct_vals[118].d = 7.8;
      tt->struct_vals[119].d = 0.039437;
      tt->struct_vals[120].d = 7.9;
      tt->struct_vals[121].d = 0.025113;
      tt->struct_vals[122].d = 8;
      tt->struct_vals[123].d = 0.012963;
      tt->struct_vals[124].d = 8.1;
      tt->struct_vals[125].d = 0.002841;
      tt->struct_vals[126].d = 8.2;
      tt->struct_vals[127].d = -0.0054;
      tt->struct_vals[128].d = 8.3;
      tt->struct_vals[129].d = -0.011908;
      tt->struct_vals[130].d = 8.4;
      tt->struct_vals[131].d = -0.01683;
      tt->struct_vals[132].d = 8.5;
      tt->struct_vals[133].d = -0.020312;
      tt->struct_vals[134].d = 8.6;
      tt->struct_vals[135].d = -0.022504;
      tt->struct_vals[136].d = 8.7;
      tt->struct_vals[137].d = -0.02355;
      tt->struct_vals[138].d = 8.8;
      tt->struct_vals[139].d = -0.0236;
      tt->struct_vals[140].d = 8.9;
      tt->struct_vals[141].d = -0.0228;
      tt->struct_vals[142].d = 9;
      tt->struct_vals[143].d = -0.021296;
      tt->struct_vals[144].d = 9.1;
      tt->struct_vals[145].d = -0.019238;
      tt->struct_vals[146].d = 9.2;
      tt->struct_vals[147].d = -0.01677;
      tt->struct_vals[148].d = 9.3;
      tt->struct_vals[149].d = -0.014042;
      tt->struct_vals[150].d = 9.4;
      tt->struct_vals[151].d = -0.0112;
      tt->struct_vals[152].d = 9.5;
      tt->struct_vals[153].d = -0.008391;
      tt->struct_vals[154].d = 9.6;
      tt->struct_vals[155].d = -0.005763;
      tt->struct_vals[156].d = 9.7;
      tt->struct_vals[157].d = -0.003463;
      tt->struct_vals[158].d = 9.8;
      tt->struct_vals[159].d = -0.001637;
      tt->struct_vals[160].d = 9.9;
      tt->struct_vals[161].d = -0.000434;
    tt++;
    
    // Parameter 'wrmax'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("wrmax");
    tt->descr = tdrpStrDup("Wrmax");
    tt->help = tdrpStrDup("Mapping from r/rmax to scale used by microburst model");
    tt->array_offset = (char *) &_wrmax - &_start_;
    tt->array_n_offset = (char *) &wrmax_n - &_start_;
    tt->is_private = TRUE;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 50;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_wrmax->x - (char *) _wrmax;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_wrmax->y - (char *) _wrmax;
    tt->n_struct_vals = 100;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 2.5;
      tt->struct_vals[2].d = 0.1;
      tt->struct_vals[3].d = 2.05285;
      tt->struct_vals[4].d = 0.2;
      tt->struct_vals[5].d = 1.70345;
      tt->struct_vals[6].d = 0.3;
      tt->struct_vals[7].d = 1.43991;
      tt->struct_vals[8].d = 0.4;
      tt->struct_vals[9].d = 1.25035;
      tt->struct_vals[10].d = 0.5;
      tt->struct_vals[11].d = 1.12285;
      tt->struct_vals[12].d = 0.6;
      tt->struct_vals[13].d = 1.04552;
      tt->struct_vals[14].d = 0.7;
      tt->struct_vals[15].d = 1.00647;
      tt->struct_vals[16].d = 0.8;
      tt->struct_vals[17].d = 0.993793;
      tt->struct_vals[18].d = 0.9;
      tt->struct_vals[19].d = 0.995603;
      tt->struct_vals[20].d = 1;
      tt->struct_vals[21].d = 1;
      tt->struct_vals[22].d = 1.1;
      tt->struct_vals[23].d = 0.997267;
      tt->struct_vals[24].d = 1.2;
      tt->struct_vals[25].d = 0.986414;
      tt->struct_vals[26].d = 1.3;
      tt->struct_vals[27].d = 0.968629;
      tt->struct_vals[28].d = 1.4;
      tt->struct_vals[29].d = 0.945103;
      tt->struct_vals[30].d = 1.5;
      tt->struct_vals[31].d = 0.917026;
      tt->struct_vals[32].d = 1.6;
      tt->struct_vals[33].d = 0.885586;
      tt->struct_vals[34].d = 1.7;
      tt->struct_vals[35].d = 0.851974;
      tt->struct_vals[36].d = 1.8;
      tt->struct_vals[37].d = 0.817379;
      tt->struct_vals[38].d = 1.9;
      tt->struct_vals[39].d = 0.782991;
      tt->struct_vals[40].d = 2;
      tt->struct_vals[41].d = 0.75;
      tt->struct_vals[42].d = 2.1;
      tt->struct_vals[43].d = 0.71938;
      tt->struct_vals[44].d = 2.2;
      tt->struct_vals[45].d = 0.691244;
      tt->struct_vals[46].d = 2.3;
      tt->struct_vals[47].d = 0.665491;
      tt->struct_vals[48].d = 2.4;
      tt->struct_vals[49].d = 0.64202;
      tt->struct_vals[50].d = 2.5;
      tt->struct_vals[51].d = 0.62073;
      tt->struct_vals[52].d = 2.6;
      tt->struct_vals[53].d = 0.601517;
      tt->struct_vals[54].d = 2.7;
      tt->struct_vals[55].d = 0.584282;
      tt->struct_vals[56].d = 2.8;
      tt->struct_vals[57].d = 0.568922;
      tt->struct_vals[58].d = 2.9;
      tt->struct_vals[59].d = 0.555336;
      tt->struct_vals[60].d = 3;
      tt->struct_vals[61].d = 0.543423;
      tt->struct_vals[62].d = 3.1;
      tt->struct_vals[63].d = 0.53308;
      tt->struct_vals[64].d = 3.2;
      tt->struct_vals[65].d = 0.524207;
      tt->struct_vals[66].d = 3.3;
      tt->struct_vals[67].d = 0.516701;
      tt->struct_vals[68].d = 3.4;
      tt->struct_vals[69].d = 0.510462;
      tt->struct_vals[70].d = 3.5;
      tt->struct_vals[71].d = 0.505388;
      tt->struct_vals[72].d = 3.6;
      tt->struct_vals[73].d = 0.501377;
      tt->struct_vals[74].d = 3.7;
      tt->struct_vals[75].d = 0.498327;
      tt->struct_vals[76].d = 3.8;
      tt->struct_vals[77].d = 0.496138;
      tt->struct_vals[78].d = 3.9;
      tt->struct_vals[79].d = 0.494707;
      tt->struct_vals[80].d = 4;
      tt->struct_vals[81].d = 0.493934;
      tt->struct_vals[82].d = 4.1;
      tt->struct_vals[83].d = 0.493716;
      tt->struct_vals[84].d = 4.2;
      tt->struct_vals[85].d = 0.493951;
      tt->struct_vals[86].d = 4.3;
      tt->struct_vals[87].d = 0.49454;
      tt->struct_vals[88].d = 4.4;
      tt->struct_vals[89].d = 0.495379;
      tt->struct_vals[90].d = 4.5;
      tt->struct_vals[91].d = 0.496368;
      tt->struct_vals[92].d = 4.6;
      tt->struct_vals[93].d = 0.497405;
      tt->struct_vals[94].d = 4.7;
      tt->struct_vals[95].d = 0.498388;
      tt->struct_vals[96].d = 4.8;
      tt->struct_vals[97].d = 0.499216;
      tt->struct_vals[98].d = 4.9;
      tt->struct_vals[99].d = 0.499787;
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("Fuzzy Function params");
    tt->comment_text = tdrpStrDup(" Used internally for fuzzy mappings\n index 0 up to 11, each one has any number of :\n   x = fuzzy x value\n   y = fuzzy y value\n");
    tt++;
    
    // Parameter 'fuzzy0'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy0");
    tt->descr = tdrpStrDup("0 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy0 - &_start_;
    tt->array_n_offset = (char *) &fuzzy0_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy0->x - (char *) _fuzzy0;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy0->y - (char *) _fuzzy0;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy1'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy1");
    tt->descr = tdrpStrDup("1 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy1 - &_start_;
    tt->array_n_offset = (char *) &fuzzy1_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy1->x - (char *) _fuzzy1;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy1->y - (char *) _fuzzy1;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy2'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy2");
    tt->descr = tdrpStrDup("2 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy2 - &_start_;
    tt->array_n_offset = (char *) &fuzzy2_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy2->x - (char *) _fuzzy2;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy2->y - (char *) _fuzzy2;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy3'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy3");
    tt->descr = tdrpStrDup("3 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy3 - &_start_;
    tt->array_n_offset = (char *) &fuzzy3_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy3->x - (char *) _fuzzy3;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy3->y - (char *) _fuzzy3;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy4'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy4");
    tt->descr = tdrpStrDup("4 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy4 - &_start_;
    tt->array_n_offset = (char *) &fuzzy4_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy4->x - (char *) _fuzzy4;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy4->y - (char *) _fuzzy4;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy5'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy5");
    tt->descr = tdrpStrDup("5 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy5 - &_start_;
    tt->array_n_offset = (char *) &fuzzy5_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy5->x - (char *) _fuzzy5;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy5->y - (char *) _fuzzy5;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy6'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy6");
    tt->descr = tdrpStrDup("6 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy6 - &_start_;
    tt->array_n_offset = (char *) &fuzzy6_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy6->x - (char *) _fuzzy6;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy6->y - (char *) _fuzzy6;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy7'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy7");
    tt->descr = tdrpStrDup("7 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy7 - &_start_;
    tt->array_n_offset = (char *) &fuzzy7_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy7->x - (char *) _fuzzy7;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy7->y - (char *) _fuzzy7;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy8'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy8");
    tt->descr = tdrpStrDup("8 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy8 - &_start_;
    tt->array_n_offset = (char *) &fuzzy8_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy8->x - (char *) _fuzzy8;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy8->y - (char *) _fuzzy8;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy9'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy9");
    tt->descr = tdrpStrDup("9 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy9 - &_start_;
    tt->array_n_offset = (char *) &fuzzy9_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy9->x - (char *) _fuzzy9;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy9->y - (char *) _fuzzy9;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy10'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy10");
    tt->descr = tdrpStrDup("10 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy10 - &_start_;
    tt->array_n_offset = (char *) &fuzzy10_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy10->x - (char *) _fuzzy10;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy10->y - (char *) _fuzzy10;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'fuzzy11'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fuzzy11");
    tt->descr = tdrpStrDup("11 fuzzy f");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_fuzzy11 - &_start_;
    tt->array_n_offset = (char *) &fuzzy11_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fuzzy11->x - (char *) _fuzzy11;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fuzzy11->y - (char *) _fuzzy11;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("Endpoint params");
    tt->comment_text = tdrpStrDup(" Used internally to specify a set of points\n index 0 up to 11, each one has any number of :\n   x = X value (km)\n   y = Y value (km)");
    tt++;
    
    // Parameter 'endpoint0'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint0");
    tt->descr = tdrpStrDup("0 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint0 - &_start_;
    tt->array_n_offset = (char *) &endpoint0_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint0->x - (char *) _endpoint0;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint0->y - (char *) _endpoint0;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint1'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint1");
    tt->descr = tdrpStrDup("1 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint1 - &_start_;
    tt->array_n_offset = (char *) &endpoint1_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint1->x - (char *) _endpoint1;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint1->y - (char *) _endpoint1;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint2'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint2");
    tt->descr = tdrpStrDup("2 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint2 - &_start_;
    tt->array_n_offset = (char *) &endpoint2_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint2->x - (char *) _endpoint2;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint2->y - (char *) _endpoint2;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint3'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint3");
    tt->descr = tdrpStrDup("3 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint3 - &_start_;
    tt->array_n_offset = (char *) &endpoint3_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint3->x - (char *) _endpoint3;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint3->y - (char *) _endpoint3;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint4'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint4");
    tt->descr = tdrpStrDup("4 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint4 - &_start_;
    tt->array_n_offset = (char *) &endpoint4_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint4->x - (char *) _endpoint4;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint4->y - (char *) _endpoint4;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint5'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint5");
    tt->descr = tdrpStrDup("5 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint5 - &_start_;
    tt->array_n_offset = (char *) &endpoint5_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint5->x - (char *) _endpoint5;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint5->y - (char *) _endpoint5;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint6'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint6");
    tt->descr = tdrpStrDup("6 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint6 - &_start_;
    tt->array_n_offset = (char *) &endpoint6_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint6->x - (char *) _endpoint6;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint6->y - (char *) _endpoint6;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint7'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint7");
    tt->descr = tdrpStrDup("7 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint7 - &_start_;
    tt->array_n_offset = (char *) &endpoint7_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint7->x - (char *) _endpoint7;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint7->y - (char *) _endpoint7;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint8'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint8");
    tt->descr = tdrpStrDup("8 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint8 - &_start_;
    tt->array_n_offset = (char *) &endpoint8_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint8->x - (char *) _endpoint8;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint8->y - (char *) _endpoint8;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint9'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint9");
    tt->descr = tdrpStrDup("9 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint9 - &_start_;
    tt->array_n_offset = (char *) &endpoint9_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint9->x - (char *) _endpoint9;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint9->y - (char *) _endpoint9;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint10'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint10");
    tt->descr = tdrpStrDup("10 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint10 - &_start_;
    tt->array_n_offset = (char *) &endpoint10_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint10->x - (char *) _endpoint10;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint10->y - (char *) _endpoint10;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // Parameter 'endpoint11'
    // ctype is '_Xy_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("endpoint11");
    tt->descr = tdrpStrDup("11 endpoints");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_endpoint11 - &_start_;
    tt->array_n_offset = (char *) &endpoint11_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(Xy_t);
    tt->array_n = 0;
    tt->struct_def.name = tdrpStrDup("Xy_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("x");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_endpoint11->x - (char *) _endpoint11;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("y");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_endpoint11->y - (char *) _endpoint11;
    tt->n_struct_vals = 0;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
