//////////////////////////////////////////////////////////////////////
// parameter definitions AparTsSim
//
// EOL, NCAR,
// P.O.Box 3000, Boulder, CO, USA, 80307-3000
//
// Aug 2019
//
//////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "AparTsSim simulates APAR time series data. It IWRF time series files, converts to APAR TS data, and writes the results to files to a UDP stream. Optionally it reads the UDP stream as a check, and converts to APAR time series.";
}

commentdef {
  p_header = "DEBUGGING AND PROCESS CONTROL.";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

commentdef {
  p_header = "SPECIFY APAR TIME-SERIES DETAILS";
};

paramdef int {
  p_default = 5;
  p_descr = "Number of samples taken each time we revisit the beam location.";
  p_help = "We take this number of samples for an az/el, then move to sampling for other locations, before coming back to visit this beam again.";
} n_samples_per_visit;

paramdef int {
  p_default = 6;
  p_descr = "Number of visits for each beam.";
  p_help = "During a dwell, we come back to a specific beam location this number of times.";
} n_visits_per_beam;

paramdef int {
  p_default = 4;
  p_descr = "Number of beams sampled in a dwell.";
  p_help = "During a dwell, we create this number of beams. Then repeat for the next dwell.";
} n_beams_per_dwell;

paramdef boolean {
  p_default = false;
  p_descr = "Add 1 cross-pol sample at end of visit.";
  p_help = "APAR can receive in co-polar or cross-polar mode. This option allows us to test the cross-polar mode, by including a cross-polar sample at the end of each visit. This option effectively increases n_samples_per_visit by 1.";
} add_cross_pol_sample_at_end_of_visit;

commentdef {
  p_header = "RUN MODES";
};

typedef enum {
  WRITE_FILES, WRITE_UDP
} run_mode_t;

paramdef enum run_mode_t {
  p_default = WRITE_FILES;
  p_descr = "Control write or read processing.";
  p_help = "WRITE_FILES - generates time series files in APAR format. WRITE_UDP - writes out simulated data to the DREX FPGA, via UDP.";
} run_mode;

commentdef {
  p_header = "WRITE FILES MODE";
};

paramdef string {
  p_default = "./output";
  p_descr = "Directory for output files.";
  p_help = "For run_mode = WRITE_FILES.";
} output_dir;

commentdef {
  p_header = "WRITE UDP MODE";
};

paramdef int {
  p_default = 50000;
  p_descr = "Port for source of UDP data - i.e. this app.";
  p_help = "For run_mode = WRITE_UDP.";
} udp_source_port;

paramdef string {
  p_default = "192.168.1.255";
  p_descr = "Destination address for UDP.";
  p_help = "For run_mode = WRITE_UDP.";
} udp_dest_address;

paramdef int {
  p_default = 50000;
  p_descr = "Port for destination of UDP data.";
  p_help = "For run_mode = WRITE_UDP.";
} udp_dest_port;

paramdef int {
  p_default = 4096;
  p_descr = "Ideal UDP packet size (bytes).";
  p_help = "We will split a pulse into packets that do not exceed this size.";
} udp_max_packet_size;

paramdef int {
  p_default = 2500;
  p_descr = "Number of gates for UDP simulation mode.";
  p_help = "If the input files contain fewer gates than this, the input gates will be sampled multiple times to create the output data.";
} udp_n_gates;

paramdef int {
  p_default = 1;
  p_descr = "Number of channels for UDP simulation mode.";
  p_help = "If this is 1, then that represents the signals from the entire array combined into a single channel.If this is more than 1, each channel represents a single row from the array, which will be combined using beam forming on the FPGA.";
} udp_n_channels;

