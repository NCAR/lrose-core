// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
////////////////////////////////////////////
// Params.hh
//
// TDRP header file for 'Params' class.
//
// Code for program TsArchive2Dsr
//
// This header file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.hh
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @author automatically generated
 *
 */

#ifndef Params_hh
#define Params_hh

using namespace std;

#include <tdrp/tdrp.h>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <cfloat>

// Class definition

class Params {

public:

  // enum typedefs

  typedef enum {
    DEBUG_OFF = 0,
    DEBUG_NORM = 1,
    DEBUG_VERBOSE = 2,
    DEBUG_EXTRA_VERBOSE = 3
  } debug_t;

  typedef enum {
    ARCHIVE = 0,
    REALTIME = 1,
    SIMULATE = 2
  } mode_t;

  typedef enum {
    ALG_PP = 0,
    ALG_FFT = 1
  } algorithm_t;

  typedef enum {
    WINDOW_HANNING = 0,
    WINDOW_BLACKMAN = 1,
    WINDOW_RECT = 2
  } window_t;

  // struct typedefs

  typedef struct {
    double altitude;
    double latitude;
    double longitude;
    double horiz_beam_width;
    double vert_beam_width;
    double radar_constant;
    double xmit_peak_pwr;
    double receiver_mds;
    double receiver_gain;
    double antenna_gain;
    double system_gain;
  } radar_params_t;

  typedef struct {
    double noise_db;
    double gain;
    double radar_constant;
  } receiver_t;

  typedef struct {
    double lower_prf;
    double upper_prf;
    double pulse_width;
    algorithm_t algorithm;
    window_t window;
    tdrp_bool_t apply_sz;
    tdrp_bool_t dual_pol;
    int n_samples;
  } moments_params_t;

  typedef struct {
    double value;
    double interest;
  } interest_map_point_t;

  typedef struct {
    tdrp_bool_t snr;
    tdrp_bool_t dbm;
    tdrp_bool_t dbz;
    tdrp_bool_t vel;
    tdrp_bool_t width;
    tdrp_bool_t clut;
    tdrp_bool_t dbzf;
    tdrp_bool_t velf;
    tdrp_bool_t widthf;
    tdrp_bool_t zdr;
    tdrp_bool_t zdrm;
    tdrp_bool_t ldrh;
    tdrp_bool_t ldrv;
    tdrp_bool_t rhohv;
    tdrp_bool_t phidp;
    tdrp_bool_t kdp;
    tdrp_bool_t snrhc;
    tdrp_bool_t snrhx;
    tdrp_bool_t snrvc;
    tdrp_bool_t snrvx;
    tdrp_bool_t dbmhc;
    tdrp_bool_t dbmhx;
    tdrp_bool_t dbmvc;
    tdrp_bool_t dbmvx;
    tdrp_bool_t dbzhc;
    tdrp_bool_t dbzhx;
    tdrp_bool_t dbzvc;
    tdrp_bool_t dbzvx;
    tdrp_bool_t sz_trip_flag;
    tdrp_bool_t sz_leakage;
    tdrp_bool_t sz_dbzt;
    tdrp_bool_t sz_zinfill;
    tdrp_bool_t sz_itexture;
    tdrp_bool_t sz_dbzi;
    tdrp_bool_t sz_veli;
    tdrp_bool_t sz_widthi;
    tdrp_bool_t cmd;
    tdrp_bool_t cmd_flag;
    tdrp_bool_t cmd_dbz_diff_sq;
    tdrp_bool_t cmd_spin_change;
    tdrp_bool_t cmd_tdbz;
    tdrp_bool_t cmd_sqrt_tdbz;
    tdrp_bool_t cmd_spin;
    tdrp_bool_t interest_min_tdbz_spin;
    tdrp_bool_t interest_max_tdbz_spin;
    tdrp_bool_t cmd_vel_sdev;
    tdrp_bool_t cmd_power_ratio;
    tdrp_bool_t cmd_dbz_narrow;
    tdrp_bool_t cmd_ratio_narrow;
    tdrp_bool_t cmd_pr_narrow;
    tdrp_bool_t cmd_ratio_wide;
    tdrp_bool_t cmd_pr_wide;
    tdrp_bool_t cmd_clut2wx_sep;
    tdrp_bool_t cmd_clut2wx_ratio;
    tdrp_bool_t cmd_clut_width;
    tdrp_bool_t interest_max_clut_width_sep;
    tdrp_bool_t cmd_wx2noise_ratio;
    tdrp_bool_t cmd_zdr_sdev;
    tdrp_bool_t cmd_rhohv_sdev;
    tdrp_bool_t cmd_phidp_sdev;
    tdrp_bool_t cpa;
    tdrp_bool_t aiq;
    tdrp_bool_t niq;
    tdrp_bool_t meani;
    tdrp_bool_t meanq;
    tdrp_bool_t test;
  } output_fields_t;

  typedef struct {
    double min_el;
    double max_el;
    double min_az;
    double max_az;
    double min_range;
    double max_range;
  } selected_region_t;

  ///////////////////////////
  // Member functions
  //

  ////////////////////////////////////////////
  // Default constructor
  //

  Params ();

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params (const Params&);

  ////////////////////////////////////////////
  // Destructor
  //

  ~Params ();

  ////////////////////////////////////////////
  // Assignment
  //

  void operator=(const Params&);

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadFromArgs(int argc, char **argv,
                   char **override_list,
                   char **params_path_p,
                   bool defer_exit = false);

  bool exitDeferred() { return (_exitDeferred); }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadApplyArgs(const char *params_path,
                    int argc, char **argv,
                    char **override_list,
                    bool defer_exit = false);

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  static bool isArgValid(const char *arg);

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int load(const char *param_file_path,
           char **override_list,
           int expand_env, int debug);

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadFromBuf(const char *param_source_str,
                  char **override_list,
                  const char *inbuf, int inlen,
                  int start_line_num,
                  int expand_env, int debug);

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadDefaults(int expand_env);

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void sync() const;

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void print(FILE *out, tdrp_print_mode_t mode = PRINT_NORM);

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int checkAllSet(FILE *out);

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int checkIsSet(const char *param_name);

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int arrayRealloc(const char *param_name,
                   int new_array_n);

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int array2DRealloc(const char *param_name,
                     int new_array_n1,
                     int new_array_n2);

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void freeAll(void);

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  static void usage(ostream &out);

  ///////////////////////////
  // Data Members
  //

  char _start_; // start of data region
                // needed for zeroing out data
                // and computing offsets

  debug_t debug;

  char* instance;

  mode_t mode;

  char* input_dir;

  tdrp_bool_t use_ldata_info_file;

  int max_realtime_valid_age;

  tdrp_bool_t invert_hv_flag;

  radar_params_t radar;

  int scan_type_id;

  char* scan_type_name;

  double atmos_attenuation;

  double dbz_calib_correction;

  tdrp_bool_t override_ts_cal;

  receiver_t hc_receiver;

  receiver_t hx_receiver;

  receiver_t vc_receiver;

  receiver_t vx_receiver;

  tdrp_bool_t index_beams_in_azimuth;

  double azimuth_resolution;

  tdrp_bool_t correct_for_system_phidp;

  double system_phidp;

  moments_params_t *_moments_params;
  int moments_params_n;

  double moments_snr_threshold;

  tdrp_bool_t change_aiq_sign;

  tdrp_bool_t negate_phase_codes;

  double sz_strong_to_weak_power_ratio_threshold;

  double sz_out_of_trip_power_ratio_threshold;

  int sz_out_of_trip_power_n_replicas;

  window_t sz_window;

  double zdr_correction;

  tdrp_bool_t apply_cmd;

  window_t clutter_filter_window;

  int cmd_kernel_ngates_tdbz;

  int cmd_kernel_ngates_spin;

  int cmd_kernel_ngates_vel_sdev;

  int cmd_kernel_ngates_dual_pol;

  int cmd_kernel_nbeams;

  double cmd_spin_dbz_threshold;

  double cmd_snr_threshold;

  int clutter_ratio_inner_index;

  int clutter_ratio_outer_index;

  double cmd_min_clutter_ratio_narrow;

  int cpa_median_filter_len;

  double cmd_min_cpa;

  double cmd_threshold_for_clutter;

  tdrp_bool_t apply_db_for_db_correction;

  double db_for_db_ratio;

  double db_for_db_threshold;

  tdrp_bool_t apply_cmd_speckle_filter;

  int cmd_speckle_max_ngates_infilled;

  int cmd_speckle_max_ngates_removed;

  double cmd_speckle_dbz_margin;

  tdrp_bool_t apply_nexrad_spike_filter_after_cmd;

  tdrp_bool_t use_dbz_narrow_for_tdbz_and_spin;

  interest_map_point_t *_tdbz_interest_map;
  int tdbz_interest_map_n;

  double tdbz_interest_weight;

  interest_map_point_t *_sqrt_tdbz_interest_map;
  int sqrt_tdbz_interest_map_n;

  double sqrt_tdbz_interest_weight;

  interest_map_point_t *_spin_interest_map;
  int spin_interest_map_n;

  double spin_interest_weight;

  double min_of_tdbz_and_spin_interest_weight;

  double max_of_tdbz_and_spin_interest_weight;

  interest_map_point_t *_cpa_interest_map;
  int cpa_interest_map_n;

  double cpa_interest_weight;

  interest_map_point_t *_dbz_interest_map;
  int dbz_interest_map_n;

  double dbz_interest_weight;

  interest_map_point_t *_vel_interest_map;
  int vel_interest_map_n;

  double vel_interest_weight;

  interest_map_point_t *_width_interest_map;
  int width_interest_map_n;

  double width_interest_weight;

  interest_map_point_t *_vel_sdev_interest_map;
  int vel_sdev_interest_map_n;

  double vel_sdev_interest_weight;

  interest_map_point_t *_zdr_sdev_interest_map;
  int zdr_sdev_interest_map_n;

  double zdr_sdev_interest_weight;

  interest_map_point_t *_rhohv_interest_map;
  int rhohv_interest_map_n;

  double rhohv_interest_weight;

  interest_map_point_t *_rhohv_sdev_interest_map;
  int rhohv_sdev_interest_map_n;

  double rhohv_sdev_interest_weight;

  interest_map_point_t *_phidp_sdev_interest_map;
  int phidp_sdev_interest_map_n;

  double phidp_sdev_interest_weight;

  interest_map_point_t *_clut_ratio_narrow_interest_map;
  int clut_ratio_narrow_interest_map_n;

  double clut_ratio_narrow_interest_weight;

  interest_map_point_t *_clut_ratio_wide_interest_map;
  int clut_ratio_wide_interest_map_n;

  double clut_ratio_wide_interest_weight;

  interest_map_point_t *_clut_wx_peak_sep_interest_map;
  int clut_wx_peak_sep_interest_map_n;

  double clut_wx_peak_sep_interest_weight;

  interest_map_point_t *_clut_width_interest_map;
  int clut_width_interest_map_n;

  double clut_width_interest_weight;

  double max_of_clut_width_and_peak_sep_interest_weight;

  interest_map_point_t *_wx_to_noise_ratio_interest_map;
  int wx_to_noise_ratio_interest_map_n;

  double wx_to_noise_ratio_interest_weight;

  char* output_fmq_url;

  int output_fmq_size;

  int output_fmq_nslots;

  tdrp_bool_t output_fmq_compress;

  tdrp_bool_t write_blocking;

  int beam_wait_msecs;

  tdrp_bool_t set_end_of_vol_from_elev_angle;

  tdrp_bool_t vol_starts_at_bottom;

  double elev_change_for_end_of_vol;

  int min_beams_per_vol;

  tdrp_bool_t set_end_of_vol_on_prf_change;

  output_fields_t output_fields;

  tdrp_bool_t read_sweep_info_from_spdb;

  char* sweep_url;

  int sweep_search_margin;

  int sweep_info_wait_secs;

  tdrp_bool_t strict_sweep_times;

  selected_region_t selected_region;

  tdrp_bool_t do_selected_print;

  char* spectra_dir;

  tdrp_bool_t write_individual_spectra_files;

  tdrp_bool_t write_combined_spectra_file;

  double min_snr_for_combined_spectra_file;

  char _end_; // end of data region
              // needed for zeroing out data

private:

  void _init();

  mutable TDRPtable _table[129];

  const char *_className;

  bool _exitDeferred;

};

#endif

