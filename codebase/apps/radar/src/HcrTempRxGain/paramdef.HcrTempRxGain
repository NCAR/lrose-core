/*********************************************************
 * parameter definitions for HcrTempRxGain
 *
 * Mike Dixon, EOL, NCAR, Boulder, CO, USA, 80307-3000
 *
 * Aug 2018
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "HcrTempRxGain reads in HCR monitoring data from SPDB, computes the gain correction from the temperatures, and writes out the results to SPDB. The HCR monitoring data is generated by TsStatusMonitor, which reads in time series and writes out the status XML to SPDB.";
}

commentdef {
  p_header = "DEBUGGING";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

commentdef {
  p_header = "RUN MODE";
}

typedef enum {
  REALTIME, ARCHIVE
} mode_t;

paramdef enum mode_t {
  p_default = ARCHIVE;
  p_descr = "Operating mode";
  p_help = "\n\nREALTIME: trigger based on a time interval.  "
  "\n\nARCHIVE: process data between start time and end time.";
} mode;

paramdef string {
  p_default = "test";
  p_descr = "Program instance for process registration.";
  p_help = "In REALTIME mode, this application registers with procmap. This is the instance used for registration.";
} instance;

commentdef {
  p_header = "DATA INPUT";
  p_text = "Input is status metadata in XML, stored by time in SPDB";
}

paramdef string {
  p_default = "spdbp://localhost:0:/tmp/hcr/spdb/monitoring";
  p_descr = "Input URL for monitoring data in SPDB. This is in XML format.";
} input_spdb_url;

paramdef int {
  p_default = 1;
  p_descr = "REALTIME mode - interval between processing (secs)";
  p_help =  "The app wakes up at this interval and processes the latest data.";
} realtime_wait_interval_secs;

paramdef string {
  p_default = "2018 01 15 00 00 00";
  p_descr = "Start time for archive mode.";
  p_help = "In ARCHIVE mode, data retrieval starts at this time.";
} archive_start_time;

paramdef string {
  p_default = "2018 02 25 00 00 00";
  p_descr = "End time for archive mode.";
  p_help = "In ARCHIVE mode, data retrieval ends at this time.";
} archive_end_time;

paramdef int {
  p_default = 900;
  p_descr = "ARCHIVE mode - time span for processing data (secs)";
  p_help =  "In archive mode, we read in this length of data at a time, and process it as a block. This value can be changed to optimize efficiency.";
} archive_processing_interval_secs;

commentdef {
  p_header = "DATA OUTPUT";
  p_text = "Output is gain correction in XML, stored by time in SPDB";
}

paramdef string {
  p_default = "spdbp://localhost:0:/tmp/hcr/spdb/gain_correction";
  p_descr = "Output URL for gain correction data in SPDB. This is in XML format.";
} output_spdb_url;

commentdef {
  p_header = "PROCESSING DETAILS";
}

paramdef string {
  p_default = "HcrReceiverStatus";
  p_descr = "Tag for receiver status block in XML.";
  p_help = "The status XML is formatted with multiple blocks, one of which is for the receiver.";
} receiver_status_tag;

paramdef string {
  p_default = "VLnaTemp";
  p_descr = "Tag for LNA temp in XML.";
  p_help = "The LNA is temperature controlled, but the temperature oscillates as the heater cycles on and off.";
} v_lna_temperature_tag;

paramdef string {
  p_default = {
    "EikTemp",
    "PolarizationSwitchTemp",
    "RfDetectorTemp",
    "NoiseSourceTemp"
  };
  p_descr = "Tags for POD temperatures.";
  p_help = "The pod temperature is computed as the mean of these temperatures.";
} pod_temperature_tags[];

paramdef double {
  p_default = 29.739;
  p_descr = "Reference temperature for the LNA (degC).";
  p_help = "This is the estimated LNA temperature during the calibration in the lab. The LNA gain change is dependent on the difference between this reference temperature and the measured temperature during operations.";
} v_lna_reference_temperature_c;

paramdef double {
  p_default = 0.16436;
  p_descr = "Slope of LNA gain against LNA temperature (dB/degC).";
  p_help = "We use this slope, and the difference between the measured temperature and calibrated temperature, to estimate the LNA gain change from the temperature.";
} v_lna_gain_change_per_c;

paramdef double {
  p_default = 19.390;
  p_descr = "Reference temperature for the POD (degC).";
  p_help = "This is the estimated POD temperature during the calibration in the lab. The receiver gain change is dependent on the difference between this reference temperature and the measured temperature during operations.";
} pod_reference_temperature_c;

paramdef double {
  p_default = -0.10850;
  p_descr = "Slope of receiver gain against POD temperature (dB/degC).";
  p_help = "We use this slope, and the difference between the measured temperature and calibrated temperature, to estimate the receiver gain change from the temperature.";
} v_rx_gain_change_per_c;

paramdef int {
  p_default = -7;
  p_descr = "Time lag between the LNA power curve and the LNA temperature curve (secs).";
  p_help = "A positive number means that the measured temperature lags the measured power in a noise source calibration. A negative number means that the power lags the temperature.";
} v_lna_temperature_time_lag_secs;

paramdef int {
  p_default = 10;
  p_descr = "Interval over which temperatures are smoothed before use (secs).";
  p_help = "We compute the mean for each temperature, over this interval, centered on the time of interest.";
} temperature_smoothing_interval_secs;

