/*********************************************************
 * parameter definitions for Sprite
 *
 * Spectral Plot for Radar Iq Time sEries
 *
 * Mike Dixon, EOL, NCAR, Boulder, CO, USA, 80307-3000
 *
 * March 2019
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "Sprite is the spectral display for time series data";
  p_text = "This is a C++ application based on the QT GUI toolkit.";
}

commentdef {
  p_header = "DEBUGGING AND PROCESS CONTROL";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to register this process with the process mapper (procmap).";
  p_help = "If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.";
} register_with_procmap;

paramdef string {
  p_default = "test";
  p_descr = "Process instance";
  p_help = "Used for registration with procmap.";
} instance;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to check memory allocations.";
  p_help = "For debugging memory usage.";
} check_alloc;

commentdef {
  p_header = "DATA INPUT MODE";
}

typedef enum {
  REALTIME_FMQ_MODE, 
  REALTIME_TCP_MODE, 
  ARCHIVE_TIME_MODE,
  FILE_LIST_MODE,
  FOLLOW_DISPLAY_MODE
} input_mode_t;

paramdef enum input_mode_t {
  p_default = REALTIME_FMQ_MODE;
  p_descr = "Method for reading the input time series data";
  p_help = "\n\nREALTIME_FMQ_MODE: read a real-time IWRF data stream from an FMQ.\n\nREALTIME_TCP_MODE: read a real-time IWRF data stream from a TCP server.\n\nARCHIVE_TIME_MODE: given a time span and data directory, identify the list of files within that time span and read those files.\n\nFILE_LIST_MODE: the list of time series files is specified on the command line.\n\nFOLLOW_DISPLAY_MODE: the user is running a moments display (e.g. HawkEye or CIDD) and clicks on locations of interest. Sprite polls a shared memory segment for information on the user's clicks, and reads in the data for the time and location specified in the latest click.";
} input_mode;

paramdef string {
  p_default = "/tmp/fmq/ts";
  p_descr = "REALTIME_FMQ_MODE: input URL for moments data from an FMQ";
  p_help = "A fully-qualified url is of the form fmqp:://hostname:port:path. The path does not include the file extension.";
} input_fmq_url;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to seek to the start of the input FMQ.";
  p_help = "If TRUE, the program will seek to the start of the fmq and read the entire contents at startup. If FALSE, it will read only new data as it arrives.";
} seek_to_start_of_fmq;

paramdef string {
  p_default = "localhost";
  p_descr = "REALTIME_TCP_MODE: ip address of host running IWRF moments server.";
} input_tcp_address;

paramdef int {
  p_default = 11000;
  p_descr = "REALTIME_TCP_MODE: TCP port for IWRF moments server.";
} input_tcp_port;

paramdef string {
  p_default = "/data/time_series/spol";
  p_descr = "ARCHIVE_TIME_MODE: directory path for time series files.";
  p_help = "This should point to the top dir of a time series data set. Below this will be date directories - i.e. yyyymmdd.";
} archive_data_dir;

paramdef string {
  p_default = "2019 03 01 00 00 00";
  p_descr = "ARCHIVE_TIME_MODE: start time (yyyy mm dd hh mm ss).";
  p_help = "Data retrieval starts at this time.";
} archive_start_time;

paramdef double {
  p_default = 200;
  p_descr = "ARCHIVE_TIME_MODE: time span (secs).";
  p_help = "archive_end_time = archive_start_time + archive_time_span.";
} archive_time_span_secs;

paramdef double {
  p_default = 0.0;
  p_descr = "Min time between rendering (secs).";
  p_help = "Setting this higher makes the display less smooth, but prevents the display from taking up too much CPU.";
} min_secs_between_rendering;

commentdef {
  p_header = "INITIAL location";
}

paramdef double {
  p_default = 0.5;
  p_descr = "Initial elevation for selecting a radar gate (deg).";
  p_help = "The display begins using this elevation. The user can then change the elevation either by selecting a point in HawkEye, or by clicking in the ascope plots.";
} start_elevation;

paramdef double {
  p_default = 0.5;
  p_descr = "Initial azimuth for selecting a radar gate (deg).";
  p_help = "The display begins using this azimuth. The user can then change the azimuth either by selecting a point in HawkEye, or by clicking in the ascope plots.";
} start_azimuth;

paramdef double {
  p_default = 50.0;
  p_descr = "Initial range for selecting a radar gate (km).";
  p_help = "The display begins using this range. The user can then change the range either by selecting a point in CIDD or HawkEye, or by clicking in the ascope plots.";
} start_range_km;

commentdef {
  p_header = "STATUS TO BE SHOWN IN GUI";
}

typedef struct {

  boolean azimuth;
  boolean elevation;
  boolean fixed_angle;
  boolean volume_number;
  boolean sweep_number;
  boolean n_samples;
  boolean n_gates;
  boolean gate_length;
  boolean pulse_width;
  boolean prf_mode;
  boolean prf;
  boolean nyquist;
  boolean max_range;
  boolean unambiguous_range;
  boolean measured_power_h;
  boolean measured_power_v;
  boolean scan_name;
  boolean scan_mode;
  boolean polarization_mode;
  boolean latitude;
  boolean longitude;
  boolean altitude;
  boolean sun_elevation;
  boolean sun_azimuth;

} show_status_t;

paramdef struct show_status_t {

  p_default = {
    azimuth = true,
    elevation = true,
    fixed_angle = true,
    volume_number = true,
    sweep_number = true,
    n_samples = true,
    n_gates = true,
    gate_length = true,
    pulse_width = true,
    prf_mode = true,
    prf = true,
    nyquist = true,
    max_range = true,
    unambiguous_range = true,
    measured_power_h = true,
    measured_power_v = true,
    scan_name = true,
    scan_mode = true,
    polarization_mode = true,
    latitude = true,
    longitude = true,
    altitude = true,
    sun_elevation = true,
    sun_azimuth = true

  };

  p_descr = "Indicate which status items to show in GUI.";

  p_help = "These items are shown in the left panel in the GUI. Setting an item to false will hide it in the GUI.";

} show_status_in_gui;

commentdef {
  p_header = "SET MAX RANGE";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to set the max range to be used for plotting.";
  p_help = "If FALSE, the max range of the data will be used. If TRUE, max_range_km will override the max range in the data.";
} set_max_range;

paramdef double {
  p_default = 120.0;
  p_descr = "Max range for the display (km).";
} max_range_km;

commentdef {
  p_header = "MAIN WINDOW DIMENSIONS AND PLOTTING DETAILS";
}

paramdef int {
  p_default = 1500;
  p_descr = "Startup width of main window (pixels).";
} main_window_width;

paramdef int {
  p_default = 800;
  p_descr = "Startup height of main window (pixels).";
} main_window_height;

paramdef int {
  p_default = 0;
  p_descr = "Startup X for main window (pixels).";
} main_window_start_x;

paramdef int {
  p_default = 0;
  p_descr = "Startup Y for main window (pixels).";
} main_window_start_y;

paramdef int {
  p_default = 24;
  p_descr = "Height of top title margin, main window (pixels).";
} main_window_title_margin;

paramdef int {1
  p_default = 10;
  p_descr = "Font size of main title (pixels).";
} main_title_font_size;

paramdef string {
  p_default = "white";
  p_descr = "Text color for main title.";
} main_title_color;

paramdef int {
  p_default = 10;
  p_descr = "Basic font size for labels (pixels).";
  p_help = "Some of the labels are scaled relative to this size.";
} main_label_font_size;

paramdef string {
  p_default = "darkslateblue";
  p_descr = "Color of main display background.";
} main_background_color;

paramdef int {
  p_default = 1;
  p_descr = "Width for lines dividing up the main window into panels.";
} main_window_panel_divider_line_width;

paramdef string {
  p_default = "yellow";
  p_descr = "Color for lines dividing up the main window into panels.";
} main_window_panel_divider_color;

paramdef int {
  p_default = 11;
  p_descr = "Size of cross at click point (pixels).";
  p_help = "Size of cross drawn at click point, to select data.";
} click_cross_size;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw grid lines in the X direction.";
} x_grid_lines_on;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw grid lines in the Y direction.";
} y_grid_lines_on;

paramdef boolean {
  p_default = true;
  p_descr = "Option to add legends to the plots.";
} legends_on;

commentdef {
  p_header = "ASCOPE DISPLAY PANEL";
  p_text = "The ascope panel shows the power plotted against range. It can be configured for both the spectra plot and the waterfall plot.";
}

paramdef int {
  p_default = 1;
  p_descr = "Number of ascope panels in spectra window (pixels).";
  p_help = "The ascopes will be on the left of the plot. Set to 0 for no ASCOPE panel.";
} ascope_n_panels;

typedef enum {
  DBZ,
  VEL,
  WIDTH,
  NCP,
  SNR,
  DBM,
  ZDR,
  LDR,
  RHOHV,
  PHIDP,
  KDP
} moment_type_t;

paramdef enum moment_type_t {
  p_default = { DBZ };
  p_descr = "Moments to be displaed on ascope panels.";
  p_help = "The number of specified moments must match the number of ascope panels.";
} ascope_moments[];

paramdef int {
  p_default = 150;
  p_descr = "Width of ASCOPE panel in spectra window (pixels).";
  p_help = "The ASCOPE will be on the left of the plot. Set to 0 for no ASCOPE panel.";
} ascope_width;

paramdef int {
  p_default = 10;
  p_descr = "Font size of center title (pixels).";
} ascope_title_font_size;

paramdef int {
  p_default = 8;
  p_descr = "Font size of axis labels in ascope (pixels).";
} ascope_axis_label_font_size;

paramdef int {
  p_default = 6;
  p_descr = "Font size of axis tick values (pixels).";
} ascope_tick_values_font_size;

paramdef int {
  p_default = 6;
  p_descr = "Font size for plot legends (pixels).";
} ascope_legend_font_size;

paramdef int {
  p_default = 3;
  p_descr = "Margin around title text (pixels).";
} ascope_title_text_margin;

paramdef int {
  p_default = 3;
  p_descr = "Margin around legend text (pixels).";
} ascope_legend_text_margin;

paramdef int {
  p_default = 2;
  p_descr = "Margin around axis text (pixels).";
} ascope_axis_text_margin;

paramdef int {
  p_default = 4;
  p_descr = "Length of ticks on axes (pixels).";
} ascope_axis_tick_len;

paramdef int {
  p_default = 5;
  p_descr = "Ideal number of ticks on axes.";
} ascope_n_ticks_ideal;

paramdef int {
  p_default = 18;
  p_descr = "Width of left margin for ascope plot (pixels).";
  p_help = "The Y axis labels are plotted here.";
} ascope_left_margin;

paramdef int {
  p_default = 18;
  p_descr = "Height of bottom margin for ascope plot (pixels).";
  p_help = "The X axis labels are plotted here.";
} ascope_bottom_margin;

paramdef string {
  p_default = "white";
  p_descr = "Color of ascope axis labels.";
} ascope_axis_label_color;

paramdef string {
  p_default = "green";
  p_descr = "Color of axes in ascope.";
} ascope_axes_color;

paramdef string {
  p_default = "gray";
  p_descr = "Color of grid lines on ascope.";
} ascope_grid_color;

paramdef string {
  p_default = "lightgray";
  p_descr = "Color of ascope line.";
} ascope_line_color;

paramdef string {
  p_default = "cyan";
  p_descr = "Color of line showing currently selected range.";
  p_help = "The user can double click in the ascope to move this line.";
} ascope_selected_range_color;

paramdef string {
  p_default = "darkgreen";
  p_descr = "Color of ascope fill.";
} ascope_fill_color;

paramdef string {
  p_default = "yellow";
  p_descr = "Color of ascope title.";
} ascope_title_color;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Location of tick labels, relative to x axis.";
  p_help = "These can either be outside the axes, or inside - i.e. within the data area of the plot.";
} ascope_x_axis_labels_inside;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Location of tick labels, relative to y axis.";
  p_help = "These can either be outside the axes, or inside - i.e. within the data area of the plot.";
} ascope_y_axis_labels_inside;

commentdef {
  p_header = "WATERFALL DISPLAY PANEL";
  p_text = "The waterfall plots show spectra plotted against range.";
}

paramdef int {
  p_default = 1;
  p_descr = "Number of waterfall panels in spectra window (pixels).";
  p_help = "The waterfalls will be on the left of the plot. Set to 0 for no WATERFALL panel.";
} waterfall_n_panels;

typedef enum {
  FFT_WINDOW_RECT,
  FFT_WINDOW_VONHANN,
  FFT_WINDOW_BLACKMAN,
  FFT_WINDOW_BLACKMAN_NUTTALL,
  FFT_WINDOW_TUKEY_10,
  FFT_WINDOW_TUKEY_20,
  FFT_WINDOW_TUKEY_30,
  FFT_WINDOW_TUKEY_50
} fft_window_t;

typedef enum {
  INTERP_METHOD_NONE,
  INTERP_METHOD_LINEAR,
  INTERP_METHOD_GAUSSIAN
} notch_interp_method_t;

typedef enum {
  CLUTTER_FILTER_ADAPTIVE,
  CLUTTER_FILTER_REGRESSION,
  CLUTTER_FILTER_NOTCH,
  CLUTTER_FILTER_NONE
} clutter_filter_type_t;

typedef enum {
  WATERFALL_HC,
  WATERFALL_VC,
  WATERFALL_HX,
  WATERFALL_VX,
  WATERFALL_ZDR,
  WATERFALL_PHIDP,
  WATERFALL_SDEV_ZDR,
  WATERFALL_SDEV_PHIDP,
  WATERFALL_CMD
} waterfall_type_t;

typedef struct {
  waterfall_type_t plot_type;
  fft_window_t fft_window;
  int median_filter_len;
  clutter_filter_type_t clutter_filter_type;
  double clutter_model_width_mps;
  boolean use_regression_filter;
  int regression_order;
  notch_interp_method_t regression_filter_notch_interp_method;
} waterfall_plot_t;

paramdef struct waterfall_plot_t {
  p_default = {
  { WATERFALL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_NONE, 0.75, false, -1, INTERP_METHOD_GAUSSIAN },
  { WATERFALL_ZDR, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, 0.75, false, -1, INTERP_METHOD_GAUSSIAN }
  };
  p_descr = "Details of waterfall plots for each sub panel.";
  p_help = "HC: H-Co power spectrum vs range.\nVC: V-Co power spectrum vs range.\nHX: H-cross power spectrum vs range.\nVX: V-cross power spectrum vs range.\nZDR: zdr spectrum vs range.\nPHIDP: phidp spectrum vs. range.\nSDEV_ZDR: standard deviation of ZDR.\nSDEV_PHIDP: standard deviation of PHIDP.\nCMD: interest field for clutter likelihood. For the regression filter, set the order to -1 to compute the order automatically in the filter.";
} waterfall_plots[];

paramdef int {
  p_default = 200;
  p_descr = "Width of WATERFALL panel in spectra window (pixels).";
  p_help = "The WATERFALL will be on the left of the plot. Set to 0 for no WATERFALL panel.";
} waterfall_width;

paramdef int {
  p_default = 30;
  p_descr = "Width of color scale in waterfall plots (pixels).";
  p_help = "The color scale sits to the right of the data.";
} waterfall_color_scale_width;

paramdef int {
  p_default = 5;
  p_descr = "Kernal size in range for computing sdev of zdr";
  p_help = "The standard deviation of ZDR is computed over a rectangular kernel. This is the size of that kernel in range.";
} waterfall_sdev_zdr_kernel_ngates;

paramdef int {
  p_default = 3;
  p_descr = "Kernal size in samples for computing sdev of zdr";
  p_help = "The standard deviation of ZDR is computed over a rectangular kernel. This is the number of samples in that kernel.";
} waterfall_sdev_zdr_kernel_nsamples;

paramdef int {
  p_default = 5;
  p_descr = "Kernal size in range for computing sdev of phidp";
  p_help = "The standard deviation of PHIDP is computed over a rectangular kernel. This is the size of that kernel in range.";
} waterfall_sdev_phidp_kernel_ngates;

paramdef int {
  p_default = 3;
  p_descr = "Kernal size in samples for computing sdev of phidp";
  p_help = "The standard deviation of PHIDP is computed over a rectangular kernel. This is the number of samples in that kernel.";
} waterfall_sdev_phidp_kernel_nsamples;

paramdef string {
  p_default = "../share/color_scales";
  p_descr = "Directory for color scales";
  p_help = "You can set this in 2 ways:\n\n(a) Set to the absolute path\n\n(b)Set as a path relative to the location of the application binary executable.";
} color_scale_dir;

paramdef string {
  p_default = "dbm_spectra.colors";
  p_descr = "Color scale name for dbm";
} waterfall_dbm_color_scale_name;

paramdef string {
  p_default = "zdr.colors";
  p_descr = "Color scale name for zdr";
} waterfall_zdr_color_scale_name;

paramdef string {
  p_default = "phidp.colors";
  p_descr = "Color scale name for phidp";
} waterfall_phidp_color_scale_name;

paramdef string {
  p_default = "sdzdr_spectra.colors";
  p_descr = "Color scale name for sdev of zdr";
} waterfall_sdev_zdr_color_scale_name;

paramdef string {
  p_default = "sdphidp_spectra.colors";
  p_descr = "Color scale name for sdev of phidp";
} waterfall_sdev_phidp_color_scale_name;

paramdef string {
  p_default = "cmd_spectra.colors";
  p_descr = "Color scale name for CMD";
} waterfall_cmd_color_scale_name;

paramdef int {
  p_default = 10;
  p_descr = "Font size of center title (pixels).";
} waterfall_title_font_size;

paramdef int {
  p_default = 8;
  p_descr = "Font size of axis labels in waterfall (pixels).";
} waterfall_axis_label_font_size;

paramdef int {
  p_default = 6;
  p_descr = "Font size of axis tick values (pixels).";
} waterfall_tick_values_font_size;

paramdef int {
  p_default = 6;
  p_descr = "Font size for plot legends (pixels).";
} waterfall_legend_font_size;

paramdef int {
  p_default = 6;
  p_descr = "Font size for labels in color scales (pixels).";
} waterfall_color_scale_font_size;

paramdef int {
  p_default = 3;
  p_descr = "Margin around title text (pixels).";
} waterfall_title_text_margin;

paramdef int {
  p_default = 3;
  p_descr = "Margin around legend text (pixels).";
} waterfall_legend_text_margin;

paramdef int {
  p_default = 2;
  p_descr = "Margin around axis text (pixels).";
} waterfall_axis_text_margin;

paramdef int {
  p_default = 4;
  p_descr = "Length of ticks on axes (pixels).";
} waterfall_axis_tick_len;

paramdef int {
  p_default = 5;
  p_descr = "Ideal number of ticks on axes.";
} waterfall_n_ticks_ideal;

paramdef int {
  p_default = 18;
  p_descr = "Width of left margin for waterfall plot (pixels).";
  p_help = "The Y axis labels are plotted here.";
} waterfall_left_margin;

paramdef int {
  p_default = 18;
  p_descr = "Height of bottom margin for waterfall plot (pixels).";
  p_help = "The X axis labels are plotted here.";
} waterfall_bottom_margin;

paramdef string {
  p_default = "white";
  p_descr = "Color of waterfall axis labels.";
} waterfall_axis_label_color;

paramdef string {
  p_default = "green";
  p_descr = "Color of axes in waterfall.";
} waterfall_axes_color;

paramdef string {
  p_default = "gray";
  p_descr = "Color of grid lines on waterfall.";
} waterfall_grid_color;

paramdef string {
  p_default = "lightgray";
  p_descr = "Color of waterfall line.";
} waterfall_line_color;

paramdef string {
  p_default = "cyan";
  p_descr = "Color of line showing currently selected range.";
  p_help = "The user can double click in the waterfall to move this line.";
} waterfall_selected_range_color;

paramdef string {
  p_default = "darkgreen";
  p_descr = "Color of waterfall fill.";
} waterfall_fill_color;

paramdef string {
  p_default = "yellow";
  p_descr = "Color of waterfall title.";
} waterfall_title_color;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Location of tick labels, relative to x axis.";
  p_help = "These can either be outside the axes, or inside - i.e. within the data area of the plot.";
} waterfall_x_axis_labels_inside;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Location of tick labels, relative to y axis.";
  p_help = "These can either be outside the axes, or inside - i.e. within the data area of the plot.";
} waterfall_y_axis_labels_inside;

commentdef {
  p_header = "IQ PLOTS";
}

paramdef int {
  p_default = 2;
  p_descr = "Number of rows of plots in iq plots.";
  p_help = "The iq plots are made up of a matrix of plots, n_rows by n_colums. This is the starting value for the number of rows.";
} iqplots_n_rows;

paramdef int {
  p_default = 4;
  p_descr = "Number of columns of plots in iq plots.";
  p_help = "The iq plots are made up of a matrix of plots, n_rows by n_colums. This is the starting value for the number of columns.";
} iqplots_n_columns;

typedef enum {
  SPECTRAL_POWER,
  SPECTRAL_PHASE,
  SPECTRAL_ZDR,
  SPECTRAL_PHIDP,
  SPECTRAL_SZ864,
  TS_POWER,
  TS_PHASE,
  I_VALS,
  Q_VALS,
  I_VS_Q,
  PHASOR
} iq_plot_type_t;

typedef enum {
  CHANNEL_HC,
  CHANNEL_VC,
  CHANNEL_HX,
  CHANNEL_VX
} rx_channel_t;

typedef struct {
  iq_plot_type_t plot_type;
  rx_channel_t rx_channel;
  fft_window_t fft_window;
  int median_filter_len;
  clutter_filter_type_t clutter_filter_type;
  boolean plot_clutter_model;
  double clutter_model_width_mps;
  int regression_order;
  notch_interp_method_t regression_filter_notch_interp_method;
  boolean compute_plot_range_dynamically;
} iq_plot_t;

paramdef struct iq_plot_t {
  p_default = {
    { SPECTRAL_POWER, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { SPECTRAL_PHASE, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { TS_POWER, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { TS_PHASE, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { I_VALS, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { Q_VALS, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { I_VS_Q, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true },
    { PHASOR, CHANNEL_HC, FFT_WINDOW_VONHANN, 1, CLUTTER_FILTER_ADAPTIVE, false, 0.75, -1, INTERP_METHOD_GAUSSIAN, true }
  };
  p_descr = "Details of IQ plots for each sub panel.";
  p_help = "SPECTRAL_POWER: power spectrum, log.\nSPECTRAL_PHASE: phase in the spectral domain.\nSPECTRAL_ZDR: (H/V) power ratio of the spectrum.\nSPECTRAL_PHIDP: H/V phase difference in the spectrum.\nTS_POWER: time domain power, log.\nTS_PHASE: time domain phase.\nI_VALS: I vals of time series.\nQ_VALS: Q vals of time series.\nI_VS_Q: I on x axis, Q on y axis.\nPHASE: sum of I vs sum of Q. I on x axis.\n\nmedian_filter_len: median filter for spectra. For the regression filter, set the order to -1 to compute the order automatically in the filter";
} iq_plots[];

typedef struct {
  iq_plot_type_t plot_type;
  double min_val;
  double max_val;
} iq_plot_static_range_t;

paramdef struct iq_plot_static_range_t {
  p_default = {
    { SPECTRAL_POWER, -120.0, +10.0 },
    { SPECTRAL_PHASE, -180.0, +180.0 },
    { SPECTRAL_ZDR, -10.0, +20.0 },
    { SPECTRAL_PHIDP, -180.0, +180.0 },
    { TS_POWER, -80, +10.0 },
    { TS_PHASE, -180.0, +180.0 },
    { I_VALS, -1.0, +1.0 },
    { Q_VALS, -1.0, +1.0 },
    { I_VS_Q, -1.0, +1.0 },
    { PHASOR, -20.0, +20.0 }
  };
  p_descr = "Static plot ranges for the IQ plot types.";
  p_help = "These are used if compute_plot_range_dynamically is false. Otherwise the plot range is computed from the data. There must be 1 entry for each plot type.";
} iq_plot_static_ranges[10];

paramdef int {
  p_default = 0;
  p_descr = "Height of top margin in IQPLOT mode (pixels).";
  p_help = "Titles go in the top margin.";
} iqplot_top_margin;

paramdef int {
  p_default = 18;
  p_descr = "Height of bottom margin in IQPLOT mode (pixels).";
  p_help = "Time scale goes in the bottom margin.";
} iqplot_bottom_margin;

paramdef int {
  p_default = 30;
  p_descr = "Width of left margin in IQPLOT mode (pixels).";
  p_help = "Height scale goes in the left margin.";
} iqplot_left_margin;

paramdef int {
  p_default = 0;
  p_descr = "Width of right margin in IQPLOT mode (pixels).";
  p_help = "Height scale goes in the right margin.";
} iqplot_right_margin;

paramdef int {
  p_default = 4;
  p_descr = "Length of ticks on axes (pixels).";
} iqplot_axis_tick_len;

paramdef int {
  p_default = 5;
  p_descr = "Ideal number of ticks on axes.";
} iqplot_n_ticks_ideal;

paramdef int {
  p_default = 3;
  p_descr = "Margin around title text (pixels).";
} iqplot_title_text_margin;

paramdef int {
  p_default = 3;
  p_descr = "Margin around legend text (pixels).";
} iqplot_legend_text_margin;

paramdef int {
  p_default = 2;
  p_descr = "Margin around axis text (pixels).";
} iqplot_axis_text_margin;

commentdef {
  p_header = "IQPLOT TITLES, LABELS AND AXES";
}

paramdef int {
  p_default = 10;
  p_descr = "Font size of center title (pixels).";
} iqplot_title_font_size;

paramdef int {
  p_default = 8;
  p_descr = "Font size of axis labels in iq plots (pixels).";
} iqplot_axis_label_font_size;

paramdef int {
  p_default = 6;
  p_descr = "Font size of axis tick values (pixels).";
} iqplot_tick_values_font_size;

paramdef int {
  p_default = 8;
  p_descr = "Font size for plot legends (pixels).";
} iqplot_legend_font_size;

paramdef string {
  p_default = "white";
  p_descr = "Color of iqplot axis labels.";
} iqplot_axis_label_color;

paramdef string {
  p_default = "orange";
  p_descr = "Color of plot title.";
} iqplot_title_color;

paramdef string {
  p_default = "green";
  p_descr = "Color of axes in iq plots.";
} iqplot_axes_color;

paramdef string {
  p_default = "gray";
  p_descr = "Color of grid lines on iq plots.";
} iqplot_grid_color;

paramdef string {
  p_default = "pink";
  p_descr = "Color of area fill for IQ plots.";
} iqplot_fill_color;

paramdef string {
  p_default = "red";
  p_descr = "Color of labels in iq plots.";
} iqplot_labels_color;

paramdef string {
  p_default = "yellow";
  p_descr = "Color of data lines in iq plots.";
} iqplot_line_color;

paramdef int {
  p_default = 1;
  p_descr = "Width of data lines in iq plots.";
} iqplot_line_width;

paramdef string {
  p_default = "pink";
  p_descr = "Color of adaptive filtered lines in spectra plots.";
} iqplot_adaptive_filtered_color;

paramdef string {
  p_default = "red";
  p_descr = "Color of clutter model iq plots.";
} iqplot_clutter_model_color;

paramdef string {
  p_default = "orange";
  p_descr = "Color of regression filtered lines in spectra plots.";
} iqplot_regression_filtered_color;

paramdef string {
  p_default = "orange";
  p_descr = "Color of polynomial fit in time series.";
} iqplot_polynomial_fit_color;

paramdef string {
  p_default = "red";
  p_descr = "Color of polynomial residuals in time series.";
} iqplot_polynomial_residual_color;

paramdef int {
  p_default = 2;
  p_descr = "Width of data lines in polynomial plots.";
} iqplot_polynomial_line_width;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw a line for the instrument location.";
  p_descr = "Applies to RANGE_AXIS_SCALE_ALTITUDE option only.";
} iqplot_draw_instrument_height_line;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Location of tick labels, relative to x axis.";
  p_help = "These can either be outside the axes, or inside - i.e. within the data area of the plot.";
} iqplot_x_axis_labels_inside;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Location of tick labels, relative to y axis.";
  p_help = "These can either be outside the axes, or inside - i.e. within the data area of the plot.";
} iqplot_y_axis_labels_inside;

commentdef {
  p_header = "IQPLOT LEGENDS";
}

typedef enum {
  LEGEND_TOP_LEFT, LEGEND_TOP_RIGHT, LEGEND_BOTTOM_LEFT, LEGEND_BOTTOM_RIGHT
} legend_pos_t;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of main legend in the IQPLOT plot window";
  p_help = "This include time, field name and elevation angle.";
} iqplot_main_legend_pos;

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot the starting lat/lon position as a legend.";
  p_help = "This helps in geolocating the data from a mobile system.";
} iqplot_plot_legend1;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of lat/lon legend in plot";
  p_help = "The starting latitude/longitude will be plotted as a legend in the location specified. See 'iqplot_plot_starting_latlon_as_legend'.";
} iqplot_legend1_pos;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of lat/lon legend in plot";
  p_help = "The starting latitude/longitude will be plotted as a legend in the location specified. See 'iqplot_plot_starting_latlon_as_legend'.";
} iqplot_legend2_pos;

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot the starting lat/lon position as a legend.";
  p_help = "This helps in geolocating the data from a mobile system.";
} iqplot_plot_legend2;

commentdef {
  p_header = "CLUTTER FILTERING";
  p_text = "The default clutter filtering method is the Adaptive Filter, with residue correction activated.";
}

paramdef enum clutter_filter_type_t {
  p_default = CLUTTER_FILTER_ADAPTIVE;
  p_descr = "Type of clutter filter to use.";
  p_help = "ADAPTIVE: spectral filter with gaussian interpolation. REGRESSION: polynomial filter with specified interpolation. NOTCH: simple notch filter of specified width. NONE: cancels clutter filtering.";
} ascope_clutter_filter_type;

paramdef boolean {
  p_default = true;
  p_descr = "Option to apply residue correction to adaptive filter.";
  p_help = "At some gates, the spectral noise floor may be high. If this correction is applied, the spectral noise floor will be reduced to the measured noise value.";
} apply_residue_correction_in_adaptive_filter;

paramdef double {
  p_default = 75;
  p_descr = "Min SNR for applying the residue correction (dB).";
  p_help = "Spectral residue seems to occur at high powers, when the receiver is close to saturated. This is probably related to increased phase noise. Only apply residue correction if SNR exceeds this value. Otherwise, do not apply a correction.";
} min_snr_db_for_residue_correction;

paramdef boolean {
  p_default = true;
  p_descr = "Option to determine the polynomial order from the Clutter-to-Noise-Ratio (CNR).";
  p_help = "If TRUE, we compute the CNR from the 3 central spectral points. Then, we compute the order using CNR, antenna speed etc.";
} regression_filter_determine_order_from_cnr;

paramdef int {
  p_default = 5;
  p_descr = "Order of the polynomial fit for the regression filter.";
  p_help = "Used if regression_filter_determine_order_from_cnr is false";
} regression_filter_specified_polynomial_order;

paramdef double {
  p_default = 1.0;
  p_descr = "Width factor used when automatically computing polynomial order.";
  p_help = "Applies if regression_filter_determine_order_from_cnr it true. Default is 1. If less than 1, order will decrease. If more than 1, order will increase.";
} regression_filter_clutter_width_factor;

paramdef double {
  p_default = 0.666666667;
  p_descr = "CNR exponent used when automatically computing polynomial order.";
  p_help = "Applies if regression_filter_determine_order_from_cnr it true. Default is 2/3. If less than 2/3, order will decrease. If more than 2/3, order will increase.";
} regression_filter_cnr_exponent;

paramdef double {
  p_default  = -5;
  p_descr = "Min valid CNR - Clutter-to-Signal-Ratio - for applying the filter (dB).";
  p_help = "As a first step, we compute the CNR the central 3 spectral points. If the CNR is below this threshold, we do not apply the filter at all, and simply return the unfiltered spectrum.";
} regression_filter_min_cnr_db;

paramdef boolean {
  p_default = false;
  p_descr = "Option to use a simple notch for clutter filtering.";
  p_help = "If false, spectral adaptive clutter filtering is used. If true, a simple notch is used instead. The width is specified in notch_filter_width_mps. The depth of the notch is down to the calibrated noise floor.";
} use_simple_notch_clutter_filter;

paramdef double {
  p_default = 3.0;
  p_descr = "Width of simple clutter notch (m/s).";
  p_help = "See use_simple_notch_clutter_filter";
} simple_notch_filter_width_mps;

paramdef int {
  p_default = 1;
  p_descr = "Length of median filter applied to unfolding interval for staggered PRT.";
  p_help = "If less than 3, no filtering will be performed.";
} staggered_prt_median_filter_len;

commentdef {
  p_header = "SPECTRUM WIDTH METHOD";
}

typedef enum {
  WIDTH_METHOD_R0R1,
  WIDTH_METHOD_R1R2,
  WIDTH_METHOD_HYBRID
} spectrum_width_method_t;

paramdef enum spectrum_width_method_t {
  p_default = WIDTH_METHOD_R0R1;
  p_descr = "Method for computing spectrum width.";
  p_help = "R0R1 is the default. For staggered we use R0Rm in this case. Otherwise we use R1R2 if applicable. For staggered, we use the hybrid if R0R1 is not selected.";
} spectrum_width_method;

commentdef {
  p_header = "COMPUTING KDP USING ADAPTIVE FILTER METHOD";
  p_text = "Parameters for computing KDP.";
}

typedef enum {
  FIR_LEN_125, FIR_LEN_60, FIR_LEN_40, FIR_LEN_30, FIR_LEN_20, FIR_LEN_10
} fir_filter_len_t;
  
paramdef enum fir_filter_len_t {
  p_default = FIR_LEN_20;
  p_descr = "Filter length for the FIR filter for PHIDP (gates)";
  p_help = "When computing KDP, an FIR filter is first applied to PHIDP to smooth it. This is the length of that filter, in gates.";
} KDP_fir_filter_len;

paramdef int {
  p_default = 2;
  p_descr = "Sets the number of iterations for the initial FIR filter for unfolded PHIDP.";
  p_help = "After unfolding PHIDP, the FIR filter is applied to the unfolded phidp, a number of times, to smooth it. The effect of the filter is a combination of the filter length and the number of iterations.";
} KDP_n_filt_iterations_unfolded;

paramdef int {
  p_default = 2;
  p_descr = "Sets the number of iterations for the final FIR filter for conditioned PHIDP.";
  p_help = "In order to identify phase shift on backscatter (PSOB), we condition the PHIDP to keep it generally increasing with range. The FIR filter is applied to the conditioned phidp a number of times, to smooth it. The effect of the filter is a combination of the filter length and the number of iterations.";
} KDP_n_filt_iterations_conditioned;

paramdef boolean {
  p_default = false;
  p_descr = "Perform iterative filtering to locate backscatter phase shift.";
  p_descr = "This is the Hubbert-Bringi method.";
} KDP_use_iterative_filtering;

paramdef double {
  p_default = 4.0;
  p_descr = "Difference threshold for the iterative filtering method.";
  p_help = "The FIR filter is applied successively, KDP_n_filt_iterations_conditioned times. After each iteration the result is checked against the original. If the difference is less than this parameter, the original value at that gate is retained. If the difference exceeds this parameter, the new filtered value is retained.";
} KDP_phidp_difference_threshold;

paramdef int {
  p_default = 9;
  p_descr = "Number of gates over which the phidp mean, sdev and jitter are computed.";
  p_help = "The mean, sdev and jitter of phidp are computed over a consecutive number of gates in range, centered on the current gate of interest. This parameter is the number of gates over which these statistics are computed.";
} KDP_ngates_for_stats;

paramdef double {
  p_default = 20.0;
  p_descr = "Sets the threshold for the standard deviation of phidp in range.";
  p_help = "The sdev of phidp is a good test for valid phidp. The sdev is computed in the circle, so that it takes account of folding if present. If the sdev is less than this value, it is assumed we are in weather. Applies to computation of KDP only.";
} KDP_phidp_sdev_max;

paramdef double {
  p_default = 25.0;
  p_descr = "Sets the threshold for the jitter of phidp in range.";
  p_help = "The jitter of phidp is defined as the mean absolute change in angle between successive phidp measurements in range. It is computed on the circle to take account of folding. If the jitter is less than this value, it is assumed we are in weather. Applies to computation of KDP only.";
} KDP_phidp_jitter_max;

paramdef boolean {
  p_default = false;
  p_descr = "Check the SNR.";
  p_descr = "This test can help identify regions of good PHIDP.";
} KDP_check_snr;

paramdef double {
  p_default = -6.0;
  p_descr = "Sets the threshold for checking SNR (dB).";
  p_help = "If the SNR drops below this value, KDP will not be computed at this gate.";
} KDP_snr_threshold;

paramdef boolean {
  p_default = true;
  p_descr = "Check the RHOHV.";
  p_descr = "This test can help identify regions of good PHIDP.";
} KDP_check_rhohv;

paramdef double {
  p_default = 0.95;
  p_descr = "Sets the threshold for checking RHOHV.";
  p_help = "If the RHOHV drops below this value, KDP will not be computed at this gate.";
} KDP_rhohv_threshold;

paramdef boolean {
  p_default = true;
  p_descr = "Check the standard deviation of ZDR in range?";
  p_descr = "This test can help identify regions of clutter, and hence noisy PHIDP.";
} KDP_check_zdr_sdev;

paramdef double {
  p_default = 2.0;
  p_descr = "Sets the threshold for the standard deviation of zdr in range.";
  p_help = "The sdev of zdr is a good test for clutter. If the sdev is less than this value, it is assumed we are in weather. Applies to computation of KDP only.";
} KDP_zdr_sdev_max;

paramdef double {
  p_default = 0.025;
  p_descr = "Sets the min valid KDP value.";
  p_help = "Values less than this are set to 0.";
} KDP_min_valid_abs_kdp;

paramdef boolean {
  p_default = false;
  p_descr = "Option to print debug messages in KDP computation.";
} KDP_debug;

commentdef {
  p_header = "BEAM SAMPLING";
};

paramdef int {
  p_default = 256;
  p_descr = "Number of samples (pulses) per dwell.";
} n_samples;

paramdef boolean {
  p_default = TRUE;
  p_descr = "Index the beams on even centers?";
  p_help = "If false, the pulses are formed into beams sequentially, with no overlap.";
} indexed_beams;

paramdef double {
  p_default = 1.0;
  p_descr = "Dwell width in azimuth (deg).";
  p_help = "Applies to PPI mode.";
} indexed_resolution_ppi;

paramdef double {
  p_default = 0.5;
  p_descr = "Dwell width in elevation (deg).";
  p_help = "Applies to RHI mode.";
} indexed_resolution_rhi;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to invert the sense of the HV flag in alternating mode.";
  p_help = "In alternating dual-pol mode, the HV flag indicates whether the pulse is horizontally or vertically polarized. Normally 1 indicates H and 0 V. This parameter allows you to invert the sense of the flag, so that 1 is interpreted as V and 0 as H.";
} invert_hv_flag;

paramdef boolean {
  p_default = TRUE;
  p_descr = "Does the PRT in the pulse header refer to the previous time interval?.";
  p_help = "If TRUE, the PRT in the pulse header refers to the time from the PREVIOUS pulse to THIS pulse. If FALSE, the PRT in the header refers to the time from THIS pulse to the NEXT pulse.";
} prt_is_for_previous_interval;

paramdef boolean {
  p_default = true;
  p_descr = "Option to check for missing pulses in the time series.";
  p_help = "If missing pulses are found, the beam formed by those pulses will be discarded.";
} check_for_missing_pulses;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to swap the H and V channels for IQ data from the receiver.";
  p_help = "It is possible that the receiver was incorrectly connected and the channels (H and V for example) are swapped. If this flag is set to TRUE, the channels in the data will be swapped before computing the moments.";
} swap_receiver_channels;

commentdef {
  p_header = "OVERRIDING RADAR PARAMETERS";
  p_text = "Some radar parameters may be included in the time series data. This section allows you to optionally override some of those values.";
};

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar name.";
  p_help = "If true, the name in this file will be used. If not, the name in the time series data will be used.";
} override_radar_name;

paramdef string {
  p_default = "SPOL";
  p_descr = "Name of the radar.";
  p_help = "See 'override_radar_name'.";
} radar_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar location.";
  p_help = "If true, the location in this file will be used. If not, the location in the time series data will be used.";
} override_radar_location;

paramdef double {
  p_default = 39.93208;
  p_descr = "Radar latitude (deg).";
  p_help = "See override_radar_location.";
} radar_latitude_deg;

paramdef double {
  p_default = -105.18175;
  p_descr = "Radar longitude (deg).";
  p_help = "See override_radar_location.";
} radar_longitude_deg;

paramdef double {
  p_default = 1742;
  p_descr = "Radar altitude (meters).";
  p_help = "See override_radar_location.";
} radar_altitude_meters;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the gate geometry.";
  p_help = "If true, the gate_spacing and start_range in the time series data is overridden by the parameters in this file.";
} override_gate_geometry;

paramdef double {
  p_default = 150;
  p_descr = "Gate spacing (meters).";
  p_help = "See override_gate_geometry.";
} gate_spacing_meters;

paramdef double {
  p_default = 150;
  p_descr = "Start range (meters).";
  p_help = "See override_gate_geometry.";
} start_range_meters;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar wavelength.";
  p_help = "If true, the radar wavelength in this file will be used. If not, the wavelength in the time series data will be used if available.";
} override_radar_wavelength;

paramdef double {
  p_default = 10.0;
  p_descr = "Radar wavelength (cm).";
  p_help = "See override_radar_wavelength.";
} radar_wavelength_cm;

commentdef {
  p_header = "FFT WINDOWING";
  p_text = "Applies to the general case.";
}

paramdef enum fft_window_t {
  p_default = FFT_WINDOW_VONHANN;
  p_descr = "Window to be applied to time series before computing spectra.";
} fft_window;

commentdef {
  p_header = "RADAR CALIBRATION";
}

paramdef string {
  p_default = "./sband_cal.xml";
  p_descr = "File name for XML calibration file.";
} cal_file_path;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override cal in time series data.";
  p_help = "If false, the cal information in the time series data will be used. If true, the cal info in the param file will be used.";
} use_cal_from_time_series;

commentdef {
  p_header = "CLICK POINT DATA MESSAGING from display (HawkEye or CIDD)";
  p_text = "Reading and writing the click point location to an FMQ in XML format.";
}

paramdef string {
  p_default = "/tmp/fmq/click_point";
  p_descr = "URL for click point URL.";
  p_help = "If the user clicks on a point in HawkEye, the details of the latest click point are read from the FMQ. The format is XML. You can view the FMQ using FmqMon -mode ASCII_PRINT. Also, if the user changes the time or range in Sprite, this change will be written to the FMQ.";
} click_point_fmq_url;

paramdef double {
  p_default = 10.0;
  p_descr = "Max angular error when searching for dwell close to the click point (deg).";
  p_help = "When the user clicks in HawkEye, the (x,y) location is saved. From this, the elevation, azimuth and range of the click point can be determined. This parameter gives the max angular error allowable in this search.";
} click_point_search_angle_error;

paramdef double {
  p_default = 1.0;
  p_descr = "Change in azimuth when clicking left or right keys in follow mode (deg).";
  p_help = "In display follow mode, you can navigate left and right in azimuth using the arrow keys. This is the requested change in azimuth when navigating.";
} click_point_delta_azimuth_deg;

