/*********************************************************
 * parameter definitions for Sprite
 *
 * Mike Dixon, EOL, NCAR, Boulder, CO, USA, 80307-3000
 *
 * March 2019
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "Sprite is the spectral display for time series data";
  p_text = "This is a C++ application based on the QT GUI toolkit.";
}

commentdef {
  p_header = "DEBUGGING AND PROCESS CONTROL";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to register this process with the process mapper (procmap).";
  p_help = "If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.";
} register_with_procmap;

paramdef string {
  p_default = "test";
  p_descr = "Process instance";
  p_help = "Used for registration with procmap.";
} instance;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to check memory allocations.";
  p_help = "For debugging memory usage.";
} check_alloc;

commentdef {
  p_header = "DATA INPUT MODE";
}

typedef enum {
  REALTIME_FMQ_MODE, 
  REALTIME_TCP_MODE, 
  ARCHIVE_TIME_MODE,
  FILE_LIST_MODE,
  FOLLOW_MOMENTS_MODE
} input_mode_t;

paramdef enum input_mode_t {
  p_default = REALTIME_FMQ_MODE;
  p_descr = "Method for reading the input time series data";
  p_help = "\n\nREALTIME_FMQ_MODE: read a real-time IWRF data stream from an FMQ.\n\nREALTIME_TCP_MODE: read a real-time IWRF data stream from a TCP server.\n\nARCHIVE_TIME_MODE: given a time span and data directory, identify the list of files within that time span and read those files.\n\nFILE_LIST_MODE: the list of time series files is specified on the command line.\n\nFOLLOW_MOMENTS_MODE: the user is running a moments display (e.g. HawkEye or CIDD) and clicks on locations of interest. Sprite polls a shared memory segment for information on the user's clicks, and reads in the data for the time and location specified in the latest click.";
} input_mode;

paramdef string {
  p_default = "/tmp/fmq/ts";
  p_descr = "REALTIME_FMQ_MODE: input URL for moments data from an FMQ";
  p_help = "A fully-qualified url is of the form fmqp:://hostname:port:path. The path does not include the file extension.";
} input_fmq_url;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to seek to the start of the input FMQ.";
  p_help = "If TRUE, the program will seek to the start of the fmq and read the entire contents at startup. If FALSE, it will read only new data as it arrives.";
} seek_to_start_of_fmq;

paramdef string {
  p_default = "localhost";
  p_descr = "REALTIME_TCP_MODE: ip address of host running IWRF moments server.";
} input_tcp_address;

paramdef int {
  p_default = 11000;
  p_descr = "REALTIME_TCP_MODE: TCP port for IWRF moments server.";
} input_tcp_port;

paramdef string {
  p_default = "/data/time_series/spol";
  p_descr = "ARCHIVE_TIME_MODE: directory path for time series files.";
  p_help = "This should point to the top dir of a time series data set. Below this will be date directories - i.e. yyyymmdd.";
} archive_data_dir;

paramdef string {
  p_default = "2019 03 01 00 00 00";
  p_descr = "ARCHIVE_TIME_MODE: start time (yyyy mm dd hh mm ss).";
  p_help = "Data retrieval starts at this time.";
} archive_start_time;

paramdef double {
  p_default = 600;
  p_descr = "ARCHIVE_TIME_MODE: time span (secs).";
  p_help = "archive_end_time = archive_start_time + archive_time_span.";
} archive_time_span_secs;

commentdef {
  p_header = "GETTING CLICK-POINT INFO FROM MOMENTS DISPLAY (CIDD or HawkEye)";
}

paramdef int {
  p_default = 61500;
  p_descr = "The shared memory key for the moments display coordinate struct.";
  p_help = "When the user clicks in the moments main window, the coordinate struct is updated with the location and time.";
} moments_shmem_key;

paramdef double {
  p_default = 10.0;
  p_descr = "Max angular error when searching for spectra close to the click point (deg).";
  p_help = "When the user clicks in CIDD, the (x) location is saved. From this, the elevation, elevation and range of the click point can be determined. The data base is then searched for spectra from a beam close to this. This parameter gives the max angular error allowable in this search.";
} moments_max_search_angle_error;

commentdef {
  p_header = "BEAM SAMPLING";
};

paramdef int {
  p_default = 64;
  p_descr = "Number of samples (pulses) per dwell.";
} n_samples;

paramdef boolean {
  p_default = TRUE;
  p_descr = "Index the beams on even centers?";
  p_help = "If false, the pulses are formed into beams sequentially, with no overlap.";
} indexed_beams;

paramdef double {
  p_default = 1.0;
  p_descr = "Dwell width in azimuth (deg).";
  p_help = "Applies to PPI mode.";
} indexed_resolution_ppi;

paramdef double {
  p_default = 0.5;
  p_descr = "Dwell width in elevation (deg).";
  p_help = "Applies to RHI mode.";
} indexed_resolution_rhi;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to invert the sense of the HV flag in alternating mode.";
  p_help = "In alternating dual-pol mode, the HV flag indicates whether the pulse is horizontally or vertically polarized. Normally 1 indicates H and 0 V. This parameter allows you to invert the sense of the flag, so that 1 is interpreted as V and 0 as H.";
} invert_hv_flag;

paramdef boolean {
  p_default = TRUE;
  p_descr = "Does the PRT in the pulse header refer to the previous time interval?.";
  p_help = "If TRUE, the PRT in the pulse header refers to the time from the PREVIOUS pulse to THIS pulse. If FALSE, the PRT in the header refers to the time from THIS pulse to the NEXT pulse.";
} prt_is_for_previous_interval;

paramdef boolean {
  p_default = true;
  p_descr = "Option to check for missing pulses in the time series.";
  p_help = "If missing pulses are found, the beam formed by those pulses will be discarded.";
} check_for_missing_pulses;

commentdef {
  p_header = "OVERRIDING RADAR PARAMETERS";
  p_text = "Some radar parameters may be included in the time series data. This section allows you to optionally override some of those values.";
};

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar name.";
  p_help = "If true, the name in this file will be used. If not, the name in the time series data will be used.";
} override_radar_name;

paramdef string {
  p_default = "SPOL";
  p_descr = "Name of the radar.";
  p_help = "See 'override_radar_name'.";
} radar_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar location.";
  p_help = "If true, the location in this file will be used. If not, the location in the time series data will be used.";
} override_radar_location;

paramdef double {
  p_default = 39.93208;
  p_descr = "Radar latitude (deg).";
  p_help = "See override_radar_location.";
} radar_latitude_deg;

paramdef double {
  p_default = -105.18175;
  p_descr = "Radar longitude (deg).";
  p_help = "See override_radar_location.";
} radar_longitude_deg;

paramdef double {
  p_default = 1742;
  p_descr = "Radar altitude (meters).";
  p_help = "See override_radar_location.";
} radar_altitude_meters;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the gate geometry.";
  p_help = "If true, the gate_spacing and start_range in the time series data is overridden by the parameters in this file.";
} override_gate_geometry;

paramdef double {
  p_default = 150;
  p_descr = "Gate spacing (meters).";
  p_help = "See override_gate_geometry.";
} gate_spacing_meters;

paramdef double {
  p_default = 150;
  p_descr = "Start range (meters).";
  p_help = "See override_gate_geometry.";
} start_range_meters;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar wavelength.";
  p_help = "If true, the radar wavelength in this file will be used. If not, the wavelength in the time series data will be used if available.";
} override_radar_wavelength;

paramdef double {
  p_default = 10.0;
  p_descr = "Radar wavelength (cm).";
  p_help = "See override_radar_wavelength.";
} radar_wavelength_cm;

commentdef {
  p_header = "FFT WINDOW";
}

typedef enum {
  WINDOW_RECT,
  WINDOW_VONHANN,
  WINDOW_BLACKMAN
} window_t;

paramdef enum window_t {
  p_default = WINDOW_VONHANN;
  p_descr = "Window to be applied to time series before computing spectra.";
} window;

commentdef {
  p_header = "RADAR CALIBRATION";
}

paramdef string {
  p_default = "./radar_cal.xml";
  p_descr = "File name for XML calibration file.";
} cal_file_path;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override cal in time series data.";
  p_help = "If false, the cal information in the time series data will be used. If true, the cal info in the param file will be used.";
} use_cal_from_time_series;

commentdef {
  p_header = "STATUS TO BE SHOWN IN GUI";
}

typedef struct {

  boolean azimuth;
  boolean elevation;
  boolean fixed_angle;
  boolean volume_number;
  boolean sweep_number;
  boolean n_samples;
  boolean n_gates;
  boolean gate_length;
  boolean pulse_width;
  boolean prf_mode;
  boolean prf;
  boolean nyquist;
  boolean max_range;
  boolean unambiguous_range;
  boolean measured_power_h;
  boolean measured_power_v;
  boolean scan_name;
  boolean scan_mode;
  boolean polarization_mode;
  boolean latitude;
  boolean longitude;
  boolean altitude;
  boolean altitude_rate;
  boolean sun_elevation;
  boolean sun_azimuth;
  boolean speed;
  boolean heading;
  boolean track;

} show_status_t;

paramdef struct show_status_t {

  p_default = {
    azimuth = true,
    elevation = true,
    fixed_angle = true,
    volume_number = false,
    sweep_number = true,
    n_samples = true,
    n_gates = true,
    gate_length = true,
    pulse_width = true,
    prf_mode = true,
    prf = true,
    nyquist = true,
    max_range = true,
    unambiguous_range = true,
    measured_power_h = false,
    measured_power_v = false,
    scan_name = false,
    scan_mode = true,
    polarization_mode = true,
    latitude = true,
    longitude = true,
    altitude = true,
    altitude_rate = false,
    sun_elevation = true,
    sun_azimuth = true,
    speed = false,
    heading = false,
    track = false
  };

  p_descr = "Indicate which status items to show in GUI.";

  p_help = "These items are shown in the left panel in the GUI. Setting an item to false will hide it in the GUI.";

} show_status_in_gui;

commentdef {
  p_header = "INITIAL MAX RANGE";
}

paramdef double {
  p_default = 225.0;
  p_descr = "Max range for the display (km).";
} max_range_km;

commentdef {
  p_header = "WINDOW DIMENSIONS AND PLOTTING DETAILS";
}

paramdef int {
  p_default = 1050;
  p_descr = "Startup width of main window (pixels).";
} main_window_width;

paramdef int {
  p_default = 635;
  p_descr = "Startup height of main window (pixels).";
} main_window_height;

paramdef int {
  p_default = 0;
  p_descr = "Startup X for main window (pixels).";
} main_window_start_x;

paramdef int {
  p_default = 0;
  p_descr = "Startup Y for main window (pixels).";
} main_window_start_y;

paramdef int {
  p_default = 40;
  p_descr = "Width of color scale (pixels).";
} color_scale_width;

paramdef int {
  p_default = 12;
  p_descr = "Basic font size for labels (pixels).";
  p_help = "Some of the labels are scaled relative to this size.";
} label_font_size;

paramdef string {
  p_default = "black";
  p_descr = "Color of main display background.";
} background_color;

paramdef string {
  p_default = "white";
  p_descr = "Color of overlays.";
} overlay_color;

paramdef int {
  p_default = 8;
  p_descr = "Font size for labels on overlays (pixels).";
} overlay_font_size;

paramdef int {
  p_default = 11;
  p_descr = "Size of cross at click point (pixels).";
  p_help = "Size of cross drawn at click point, to select data.";
} click_cross_size;

commentdef {
  p_header = "ASCOPE MODE DISPLAY";
}

paramdef double {
  p_default = 1.0;
  p_descr = "Aspect ratio (width/height) of ASCOPE window.";
  p_descr = "Set to -1 to allow aspect ratio to vary as the main window is resized.";
} ascope_aspect_ratio;

paramdef boolean {
  p_default = false;
  p_descr = "Set ASCOPE grids overlay on at startup.";
} ascope_grids_on_at_startup;

commentdef {
  p_header = "ASCOPE MARGINS";
}

paramdef int {
  p_default = 40;
  p_descr = "Height of top margin in ASCOPE mode (pixels).";
  p_help = "Titles go in the top margin.";
} ascope_top_margin;

paramdef int {
  p_default = 45;
  p_descr = "Height of bottom margin in ASCOPE mode (pixels).";
  p_help = "Time scale goes in the bottom margin.";
} ascope_bottom_margin;

paramdef int {
  p_default = 50;
  p_descr = "Width of left margin in ASCOPE mode (pixels).";
  p_help = "Height scale goes in the left margin.";
} ascope_left_margin;

paramdef int {
  p_default = 40;
  p_descr = "Width of right margin in ASCOPE mode (pixels).";
  p_help = "Height scale goes in the right margin.";
} ascope_right_margin;

paramdef int {
  p_default = 6;
  p_descr = "Length of ticks on axes (pixels).";
} ascope_axis_tick_len;

paramdef int {
  p_default = 10;
  p_descr = "Ideal number of ticks on axes.";
} ascope_n_ticks_ideal;

paramdef int {
  p_default = 5;
  p_descr = "Margin around some text (pixels).";
} ascope_text_margin;

paramdef double {
  p_default = 3600;
  p_descr = "Time span for ASCOPE (secs).";
} ascope_time_span_secs;

paramdef double {
  p_default = 0;
  p_descr = "Min amplitude for ascope.";
} ascope_min_amplitude;

paramdef double {
  p_default = 1;
  p_descr = "Max amplitude for ascope.";
} ascope_max_amplitude;

paramdef double {
  p_default = 0.0;
  p_descr = "Min time between rendering (secs).";
  p_help = "Setting this higher makes the display less smooth, but prevents the display from taking up too much CPU.";
} ascope_min_secs_between_rendering;

commentdef {
  p_header = "ASCOPE TITLES, LABELS AND AXES";
}

paramdef int {
  p_default = 12;
  p_descr = "Font size of center title (pixels).";
} ascope_title_font_size;

paramdef int {
  p_default = 10;
  p_descr = "Font size of axis labels in ascope (pixels).";
} ascope_axis_label_font_size;

paramdef int {
  p_default = 8;
  p_descr = "Font size of axis values (pixels).";
} ascope_axis_values_font_size;

paramdef string {
  p_default = "white";
  p_descr = "Color of axes in ascope.";
} ascope_axes_color;

paramdef string {
  p_default = "gray";
  p_descr = "Color of grid lines on ascope.";
} ascope_grid_color;

paramdef string {
  p_default = "white";
  p_descr = "Color of labels in ascope.";
} ascope_labels_color;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw grid lines across plot at regular time intervals.";
} ascope_draw_time_grid_lines;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw grid lines across plot at regular range intervals.";
} ascope_draw_x_grid_lines;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw a line for the instrument location.";
  p_descr = "Applies to RANGE_AXIS_SCALE_ALTITUDE option only.";
} ascope_draw_instrument_height_line;

paramdef string {
  p_default = "white";
  p_descr = "Color of instrument height line in ALTITUDE plot.";
} ascope_instrument_height_color;

commentdef {
  p_header = "ASCOPE LEGENDS";
}

typedef enum {
  LEGEND_TOP_LEFT, LEGEND_TOP_RIGHT, LEGEND_BOTTOM_LEFT, LEGEND_BOTTOM_RIGHT
} legend_pos_t;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of main legend in the ASCOPE plot window";
  p_help = "This include time, field name and elevation angle.";
} ascope_main_legend_pos;

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot the starting lat/lon position as a legend.";
  p_help = "This helps in geolocating the data from a mobile system.";
} ascope_plot_legend1;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of lat/lon legend in plot";
  p_help = "The starting latitude/longitude will be plotted as a legend in the location specified. See 'ascope_plot_starting_latlon_as_legend'.";
} ascope_legend1_pos;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of lat/lon legend in plot";
  p_help = "The starting latitude/longitude will be plotted as a legend in the location specified. See 'ascope_plot_starting_latlon_as_legend'.";
} ascope_legend2_pos;

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot the starting lat/lon position as a legend.";
  p_help = "This helps in geolocating the data from a mobile system.";
} ascope_plot_legend2;

