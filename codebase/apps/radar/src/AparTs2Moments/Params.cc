/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program AparTs2Moments
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("AparTs2Moments reads raw time-series data, computes the moments and writes the contents into a DsRadar FMQ.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'beam_count_for_debug_print'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("beam_count_for_debug_print");
    tt->descr = tdrpStrDup("Interval at which beam data is printed in debug mode.");
    tt->help = tdrpStrDup("We print out beam details in debug mode - this is the number of beams between each print.");
    tt->val_offset = (char *) &beam_count_for_debug_print - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("THREADING FOR SPEED.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_multiple_threads'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_multiple_threads");
    tt->descr = tdrpStrDup("Option to use multiple threads to improve performance.");
    tt->help = tdrpStrDup("The read, compute and write stages can overlap in time, to improve performance. Also, the compute stage can be split into multiple threads, with each thread working on a discrete number of gates.");
    tt->val_offset = (char *) &use_multiple_threads - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'n_compute_threads'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_compute_threads");
    tt->descr = tdrpStrDup("The number of compute threads.");
    tt->help = tdrpStrDup("The moments are computed in a 'pipe-line' a beam at a time. The pipe line contains the number of compute threads specified.");
    tt->val_offset = (char *) &n_compute_threads - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("TIME-SERIES DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("In REALTIME mode, the program waits for a new input file. In ARCHIVE mode, it moves through the files between the start and end times specified on the command line. In FILELIST mode, it moves through the list of file names specified on the command line. In SIMULATE mode, the program moves repeatedly through the file list, creating output files with times set to now. This is useful for simulating an operational radar. In FMQ mode, the program opens the input_fmq, and reads time series data from the queue.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 5;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FILELIST");
      tt->enum_def.fields[0].val = FILELIST;
      tt->enum_def.fields[1].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[1].val = ARCHIVE;
      tt->enum_def.fields[2].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[2].val = REALTIME;
      tt->enum_def.fields[3].name = tdrpStrDup("SIMULATE");
      tt->enum_def.fields[3].val = SIMULATE;
      tt->enum_def.fields[4].name = tdrpStrDup("FMQ");
      tt->enum_def.fields[4].val = FMQ;
    tt->single_val.e = FMQ;
    tt++;
    
    // Parameter 'input_fmq'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq");
    tt->descr = tdrpStrDup("FMQ name for time series data.");
    tt->help = tdrpStrDup("This is used in FMQ mode only.");
    tt->val_offset = (char *) &input_fmq - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/fmq/ts");
    tt++;
    
    // Parameter 'position_fmq_at_start'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("position_fmq_at_start");
    tt->descr = tdrpStrDup("Option to position the input FMQ at the start of the queue.");
    tt->help = tdrpStrDup("FMQ mode only. If false, we start reading at the end of the queue. This is the default behavior. If true, we position the read pointer at the start of the queue, and read all data available in the queue before starting to read new data.");
    tt->val_offset = (char *) &position_fmq_at_start - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'input_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir");
    tt->descr = tdrpStrDup("Dir for input data files.");
    tt->help = tdrpStrDup("This is used in REALTIME and ARCHIVE modes. In FILELIST and SIMULATE modes, the file paths are specified on the command line.");
    tt->val_offset = (char *) &input_dir - &_start_;
    tt->single_val.s = tdrpStrDup("./input");
    tt++;
    
    // Parameter 'use_ldata_info_file'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_ldata_info_file");
    tt->descr = tdrpStrDup("Option to use _latest_data_info file as input trigger.");
    tt->help = tdrpStrDup("REALTIME mode only. If true, waits on _latest_data_info file. If false, scans the directory for new file.");
    tt->val_offset = (char *) &use_ldata_info_file - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_realtime_valid_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_realtime_valid_age");
    tt->descr = tdrpStrDup("Max valid age of rdata input files in realtime mode (secs)");
    tt->help = tdrpStrDup("This the max valid age for an incoming file. The program will wait for a data file more recent than this age.");
    tt->val_offset = (char *) &max_realtime_valid_age - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 360;
    tt++;
    
    // Parameter 'max_pulses_per_dwell'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_pulses_per_dwell");
    tt->descr = tdrpStrDup("Max number of pulses per dwell");
    tt->help = tdrpStrDup("If the pulse count exceeds this, the current set of pulses is discarded and a new dwell starts.");
    tt->val_offset = (char *) &max_pulses_per_dwell - &_start_;
    tt->single_val.i = 5000;
    tt++;
    
    // Parameter 'invert_hv_flag'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("invert_hv_flag");
    tt->descr = tdrpStrDup("Option to invert the sense of the HV flag in alternating mode.");
    tt->help = tdrpStrDup("In alternating dual-pol mode, the HV flag indicates whether the pulse is horizontally or vertically polarized. Normally 1 indicates H and 0 V. This parameter allows you to invert the sense of the flag, so that 1 is interpreted as V and 0 as H.");
    tt->val_offset = (char *) &invert_hv_flag - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'change_velocity_sign'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("change_velocity_sign");
    tt->descr = tdrpStrDup("Option to change the sign of the velocity.");
    tt->help = tdrpStrDup("If true, the sign of the velocity will be changed.");
    tt->val_offset = (char *) &change_velocity_sign - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'change_velocity_sign_staggered'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("change_velocity_sign_staggered");
    tt->descr = tdrpStrDup("Option to change the sign of the velocity in staggered mode.");
    tt->help = tdrpStrDup("If true, the sign of the velocity will be changed in staggered mode. Both this and the 'change_velocity_sign' parameter above will be applied, so if both are true they will cancel out in staggered mode.");
    tt->val_offset = (char *) &change_velocity_sign_staggered - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'georef_time_margin_secs'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("georef_time_margin_secs");
    tt->descr = tdrpStrDup("Margin for matching platform goeref with pulses (secs).");
    tt->help = tdrpStrDup("The platform georeference objects, if they are included in the data stream, are asynchronous with the pulse objects. Therefore we need to match a georeference object with a pulse object. If the times of the two objects differ by less than this specified margin, the georeference is attached to the pulse. If the time difference exceeds this margin, no georeference is attached to the pulse.");
    tt->val_offset = (char *) &georef_time_margin_secs - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'use_secondary_georeference'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_secondary_georeference");
    tt->descr = tdrpStrDup("If true, use the secondary georeference packet.");
    tt->help = tdrpStrDup("By default, we use the primary georeference packet. And most mobile radars only have one georeference. For those radars that have 2 georef devices, set this to true to use the secondary reference.");
    tt->val_offset = (char *) &use_secondary_georeference - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'check_radar_id'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_radar_id");
    tt->descr = tdrpStrDup("Option to check the radar ID in the time series data stream.");
    tt->help = tdrpStrDup("If TRUE, we will check that the radar_id in the header packet info is either the specified radar_id, or is 0. This allows us to filter out unwanted data from the time series stream. Mostly this is not applicable. However, in some cases time series data from multiple sources is included in a single stream, in which case we need to filter it accordingly.");
    tt->val_offset = (char *) &check_radar_id - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_id'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("radar_id");
    tt->descr = tdrpStrDup("radar_id to be used for filtering incoming data.");
    tt->help = tdrpStrDup("See 'check_radar_id' above.");
    tt->val_offset = (char *) &radar_id - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("RADAR PARAMETERS");
    tt->comment_text = tdrpStrDup("Some radar parameters may be included in the time series data. This section allows you to optionally override some of those values.");
    tt++;
    
    // Parameter 'override_radar_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_name");
    tt->descr = tdrpStrDup("Option to override the radar name.");
    tt->help = tdrpStrDup("If true, the name in this file will be used. If not, the name in the time series data will be used.");
    tt->val_offset = (char *) &override_radar_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_name");
    tt->descr = tdrpStrDup("Name of the radar.");
    tt->help = tdrpStrDup("See 'override_radar_name'.");
    tt->val_offset = (char *) &radar_name - &_start_;
    tt->single_val.s = tdrpStrDup("APAR");
    tt++;
    
    // Parameter 'override_radar_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_location");
    tt->descr = tdrpStrDup("Option to override the radar location.");
    tt->help = tdrpStrDup("If true, the location in this file will be used. If not, the location in the time series data will be used.");
    tt->val_offset = (char *) &override_radar_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_latitude_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_latitude_deg");
    tt->descr = tdrpStrDup("Radar latitude (deg).");
    tt->help = tdrpStrDup("See override_radar_location.");
    tt->val_offset = (char *) &radar_latitude_deg - &_start_;
    tt->single_val.d = 40;
    tt++;
    
    // Parameter 'radar_longitude_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_longitude_deg");
    tt->descr = tdrpStrDup("Radar longitude (deg).");
    tt->help = tdrpStrDup("See override_radar_location.");
    tt->val_offset = (char *) &radar_longitude_deg - &_start_;
    tt->single_val.d = -105;
    tt++;
    
    // Parameter 'radar_altitude_meters'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_altitude_meters");
    tt->descr = tdrpStrDup("Radar altitude msl (meters).");
    tt->help = tdrpStrDup("See override_radar_location.");
    tt->val_offset = (char *) &radar_altitude_meters - &_start_;
    tt->single_val.d = 1700;
    tt++;
    
    // Parameter 'override_gate_geometry'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_gate_geometry");
    tt->descr = tdrpStrDup("Option to override the gate geometry.");
    tt->help = tdrpStrDup("If true, the gate_spacing and start_range in the time series data is overridden by the parameters in this file.");
    tt->val_offset = (char *) &override_gate_geometry - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'gate_spacing_meters'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("gate_spacing_meters");
    tt->descr = tdrpStrDup("Gate spacing (meters).");
    tt->help = tdrpStrDup("See override_gate_geometry.");
    tt->val_offset = (char *) &gate_spacing_meters - &_start_;
    tt->single_val.d = 150;
    tt++;
    
    // Parameter 'start_range_meters'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("start_range_meters");
    tt->descr = tdrpStrDup("Start range (meters).");
    tt->help = tdrpStrDup("See override_gate_geometry.");
    tt->val_offset = (char *) &start_range_meters - &_start_;
    tt->single_val.d = 150;
    tt++;
    
    // Parameter 'override_radar_wavelength'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_wavelength");
    tt->descr = tdrpStrDup("Option to override the radar wavelength.");
    tt->help = tdrpStrDup("If true, the radar wavelength in this file will be used. If not, the wavelength in the time series data will be used if available.");
    tt->val_offset = (char *) &override_radar_wavelength - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_wavelength_cm'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_wavelength_cm");
    tt->descr = tdrpStrDup("Radar wavelength (cm).");
    tt->help = tdrpStrDup("See override_radar_wavelength.");
    tt->val_offset = (char *) &radar_wavelength_cm - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("MOMENTS COMPUTATIONS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'compute_zdr_using_snr'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_zdr_using_snr");
    tt->descr = tdrpStrDup("Option to compute ZDR using SNR instead of power.");
    tt->help = tdrpStrDup("If true, we compute ZDR as SNRHC/SNRVC. This has the effect of taking into account a difference in noise floor in each channel. The ZDR correction applied must therefore be computed relatrive to SNR, not power.");
    tt->val_offset = (char *) &compute_zdr_using_snr - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'check_for_missing_pulses'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_for_missing_pulses");
    tt->descr = tdrpStrDup("Option to check for missing pulses in the time series.");
    tt->help = tdrpStrDup("If missing pulses are found, the beam formed by those pulses will be flagged and a message printed.");
    tt->val_offset = (char *) &check_for_missing_pulses - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'correct_for_system_phidp'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("correct_for_system_phidp");
    tt->descr = tdrpStrDup("Option to correct for system phidp.");
    tt->help = tdrpStrDup("If true, the H and V correlation phases will be corrected by adding/subtracting the system phidp value as appropriate. This avoids premature wrapping of the phased from which phidp and velocity are computed. If false, this correction will not be applied. To find the system phidp, set this to false and compute phidp for vertically-pointing data.");
    tt->val_offset = (char *) &correct_for_system_phidp - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'zdr_median_filter_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("zdr_median_filter_len");
    tt->descr = tdrpStrDup("Length of median filter applied to ZDR field in range (gates).");
    tt->help = tdrpStrDup("Set to 1 if you do not want a median filter applied.");
    tt->val_offset = (char *) &zdr_median_filter_len - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'rhohv_median_filter_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("rhohv_median_filter_len");
    tt->descr = tdrpStrDup("Length of median filter applied to RHOHV field in range (gates).");
    tt->help = tdrpStrDup("Set to 1 if you do not want a median filter applied.");
    tt->val_offset = (char *) &rhohv_median_filter_len - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'staggered_prt_median_filter_len'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("staggered_prt_median_filter_len");
    tt->descr = tdrpStrDup("Length of median filter applied to unfolding interval for staggered PRT.");
    tt->help = tdrpStrDup("If less than 3, no filtering will be performed.");
    tt->val_offset = (char *) &staggered_prt_median_filter_len - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'spectrum_width_method'
    // ctype is '_spectrum_width_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("spectrum_width_method");
    tt->descr = tdrpStrDup("Method for computing spectrum width.");
    tt->help = tdrpStrDup("R0R1 is the default. For staggered we use R0Rm in this case. Otherwise we use R1R2 if applicable. For staggered, we use the hybrid if R0R1 is not selected.");
    tt->val_offset = (char *) &spectrum_width_method - &_start_;
    tt->enum_def.name = tdrpStrDup("spectrum_width_method_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("WIDTH_METHOD_R0R1");
      tt->enum_def.fields[0].val = WIDTH_METHOD_R0R1;
      tt->enum_def.fields[1].name = tdrpStrDup("WIDTH_METHOD_R1R2");
      tt->enum_def.fields[1].val = WIDTH_METHOD_R1R2;
      tt->enum_def.fields[2].name = tdrpStrDup("WIDTH_METHOD_HYBRID");
      tt->enum_def.fields[2].val = WIDTH_METHOD_HYBRID;
    tt->single_val.e = WIDTH_METHOD_R0R1;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("RADAR CALIBRATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'startup_cal_file'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("startup_cal_file");
    tt->descr = tdrpStrDup("File name for calibration to be read at startup. Required.");
    tt->help = tdrpStrDup("The startup calibration file is required. The startup cal will be overridden if set_cal_by_pulse_width is true, or if use_cal_from_time_series is true.");
    tt->val_offset = (char *) &startup_cal_file - &_start_;
    tt->single_val.s = tdrpStrDup("./startup_cal.xml");
    tt++;
    
    // Parameter 'set_cal_by_pulse_width'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_cal_by_pulse_width");
    tt->descr = tdrpStrDup("Option to read different cal file depending on the pulse width in the data.");
    tt->help = tdrpStrDup("The calibration changes with pulse width. Therefore, if the radar supports variable pulse widths, you need to specify the location of the calibration files for each pulse width.\nYou can also optionally specify that we use different directories for different XMIT_RCV_MODEs. These are the same as those used in moments_params above.");
    tt->val_offset = (char *) &set_cal_by_pulse_width - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'pulse_width_cals'
    // ctype is '_pulse_width_cal_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("pulse_width_cals");
    tt->descr = tdrpStrDup("Specify the directories in which the calibration files for each pulse width will be stored.");
    tt->help = tdrpStrDup("See 'set_cal_by_pulse_width'. First, the app will determine which of the specified pulse widths best matches the pulse width in the data. The closest available pulse width will be used. The corresponding directory will then be searched. The cal file in that directory which is closest in time to the beam time will be used.\nYou can optionally specify that we check the xmit_rcv_mode and use different cal directories for different modes.\nNOTE - the pulse width is specified in micro-seconds. In addition, (a) if override_cal_zdr_correction is true, and zdr_correction_db != -9999, then the specified zdr_correction_db is applied, and (b) if override_cal_system_phidp is true, and system_phidp_deg != -9999, then the specified system phidp is used.");
    tt->array_offset = (char *) &_pulse_width_cals - &_start_;
    tt->array_n_offset = (char *) &pulse_width_cals_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(pulse_width_cal_t);
    tt->array_n = 3;
    tt->struct_def.name = tdrpStrDup("pulse_width_cal_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("pulse_width_us");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_pulse_width_cals->pulse_width_us - (char *) _pulse_width_cals;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("cal_dir");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_pulse_width_cals->cal_dir - (char *) _pulse_width_cals;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("zdr_correction_db");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_pulse_width_cals->zdr_correction_db - (char *) _pulse_width_cals;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("system_phidp_deg");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_pulse_width_cals->system_phidp_deg - (char *) _pulse_width_cals;
    tt->n_struct_vals = 12;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0.5;
      tt->struct_vals[1].s = tdrpStrDup("/tmp/cal_pw_0.5");
      tt->struct_vals[2].d = -9999;
      tt->struct_vals[3].d = -9999;
      tt->struct_vals[4].d = 1;
      tt->struct_vals[5].s = tdrpStrDup("/tmp/cal_pw_1.0");
      tt->struct_vals[6].d = -9999;
      tt->struct_vals[7].d = -9999;
      tt->struct_vals[8].d = 2;
      tt->struct_vals[9].s = tdrpStrDup("/tmp/cal_pw_2.0");
      tt->struct_vals[10].d = -9999;
      tt->struct_vals[11].d = -9999;
    tt++;
    
    // Parameter 'cal_recheck_period'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("cal_recheck_period");
    tt->descr = tdrpStrDup("Frequency at which to check for new cal (secs).");
    tt->help = tdrpStrDup("The program will scan the calibration directory structure once every period, to check for new calibration files.");
    tt->val_offset = (char *) &cal_recheck_period - &_start_;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'use_cal_from_time_series'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_cal_from_time_series");
    tt->descr = tdrpStrDup("Option to use cal information from time series data.");
    tt->help = tdrpStrDup("If true, the cal information in the time series data will be used, if available. If false, the cal info in the param file will be used.");
    tt->val_offset = (char *) &use_cal_from_time_series - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'override_cal_dbz_correction'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_cal_dbz_correction");
    tt->descr = tdrpStrDup("Option to override the DBZ correction in the calibration data.");
    tt->help = tdrpStrDup("If true, we will override the DBZ correction in the calibration files. See 'dbz_correction'.");
    tt->val_offset = (char *) &override_cal_dbz_correction - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'dbz_correction'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dbz_correction");
    tt->descr = tdrpStrDup("DBZ correction to be applied to all calibrations (dB).");
    tt->help = tdrpStrDup("See 'override_cal_dbz_correction'.");
    tt->val_offset = (char *) &dbz_correction - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'override_cal_zdr_correction'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_cal_zdr_correction");
    tt->descr = tdrpStrDup("Option to override the ZDR correction in the calibration data.");
    tt->help = tdrpStrDup("If true, the parameter 'zdr_correction_db' will override the zdr correction in the calibration data.");
    tt->val_offset = (char *) &override_cal_zdr_correction - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'zdr_correction_db'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("zdr_correction_db");
    tt->descr = tdrpStrDup("ZDR correction to be applied to all calibrations (dB).");
    tt->help = tdrpStrDup("See 'override_cal_zdr_correction'.");
    tt->val_offset = (char *) &zdr_correction_db - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'threshold_zdr_using_snr'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("threshold_zdr_using_snr");
    tt->descr = tdrpStrDup("Option to threshold ZDR using SNR.");
    tt->help = tdrpStrDup("If true, we will only compute ZDR if the SNR in both the H and V co-polar channels exceeds this value. See 'min_snr_db_for_zdr'.");
    tt->val_offset = (char *) &threshold_zdr_using_snr - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_snr_db_for_zdr'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_snr_db_for_zdr");
    tt->descr = tdrpStrDup("Min SNR for computing ZDR (dB).");
    tt->help = tdrpStrDup("If the SNR is below this threshold for either the H or V co-polar channels, ZDR will be set to missing. See 'threshold_zdr_using_snr'.");
    tt->val_offset = (char *) &min_snr_db_for_zdr - &_start_;
    tt->single_val.d = -7;
    tt++;
    
    // Parameter 'override_cal_ldr_corrections'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_cal_ldr_corrections");
    tt->descr = tdrpStrDup("Option to override the LDR corrections in the calibration data.");
    tt->help = tdrpStrDup("If true, the parameters 'ldrh_correction_db' and 'ldrv_correction_db' will override the ldr corrections in the calibration data.");
    tt->val_offset = (char *) &override_cal_ldr_corrections - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ldr_correction_db_h'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ldr_correction_db_h");
    tt->descr = tdrpStrDup("LDRH correction to be applied to all calibrations (dB).");
    tt->help = tdrpStrDup("See 'override_cal_ldr_corrections'.");
    tt->val_offset = (char *) &ldr_correction_db_h - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'ldr_correction_db_v'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("ldr_correction_db_v");
    tt->descr = tdrpStrDup("LDRV correction to be applied to all calibrations (dB).");
    tt->help = tdrpStrDup("See 'override_cal_ldr_corrections'.");
    tt->val_offset = (char *) &ldr_correction_db_v - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'threshold_ldr_using_snr'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("threshold_ldr_using_snr");
    tt->descr = tdrpStrDup("Option to threshold LDR using SNR.");
    tt->help = tdrpStrDup("If true, we will only compute LDR if the SNR in both the co- and cross-polar channels exceeds this value. Since the cross-polar channel is generally the weaker channel, it is the SNR on the cross-polar channel that will be limiting. See 'min_snr_db_for_ldr'.");
    tt->val_offset = (char *) &threshold_ldr_using_snr - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_snr_db_for_ldr'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_snr_db_for_ldr");
    tt->descr = tdrpStrDup("Min SNR for computing LDR (dB).");
    tt->help = tdrpStrDup("For LDR, the cross polar channel is the weaker return. Therefore effectively this threshold will be applied to the cross channel. If the SNR is below this threshold for either the co- or cross-polar channels, LDR will be set to missing. See 'threshold_ldr_using_snr'.");
    tt->val_offset = (char *) &min_snr_db_for_ldr - &_start_;
    tt->single_val.d = -7;
    tt++;
    
    // Parameter 'override_cal_system_phidp'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_cal_system_phidp");
    tt->descr = tdrpStrDup("Option to override the system PHIDP in the calibration data.");
    tt->help = tdrpStrDup("If true, the parameter 'system_phidp_deg' will override the system phidp in the calibration data.");
    tt->val_offset = (char *) &override_cal_system_phidp - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'system_phidp_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("system_phidp_deg");
    tt->descr = tdrpStrDup("System PHIDP to be applied to all calibrations (deg).");
    tt->help = tdrpStrDup("See 'override_cal_system_phidp'.");
    tt->val_offset = (char *) &system_phidp_deg - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'change_phidp_sign'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("change_phidp_sign");
    tt->descr = tdrpStrDup("Option to change the sign of PHIDP.");
    tt->help = tdrpStrDup("This should not be necessary - using for testing.");
    tt->val_offset = (char *) &change_phidp_sign - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("PRECIP-INDUCED ATTENUATION CORRECTION FOR DBZ AND ZDR");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'apply_precip_attenuation_correction'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_precip_attenuation_correction");
    tt->descr = tdrpStrDup("Option to apply precip attenuation correction for DBZ and ZDR.");
    tt->help = tdrpStrDup("The following extra fields will be computed:\n\tDBZ_ATTEN_CORRECTION - correction in dB\n\tZDR_ATTEN_CORRECTION - correction in dB\n\tDBZ_ATTEN_CORRECTED - DBZHC corrected\n\tZDR_ATTEN_CORRECTED - ZDR corrected\n");
    tt->val_offset = (char *) &apply_precip_attenuation_correction - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specify_coefficients_for_attenuation_correction'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("specify_coefficients_for_attenuation_correction");
    tt->descr = tdrpStrDup("Option to specify the coefficients and exponents - see below.");
    tt->help = tdrpStrDup("If false, the default coefficients will be determined for the radar wavelength.");
    tt->val_offset = (char *) &specify_coefficients_for_attenuation_correction - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'dbz_attenuation_coefficient'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dbz_attenuation_coefficient");
    tt->descr = tdrpStrDup("Coefficient for computing DBZ attenuation correction.");
    tt->help = tdrpStrDup("See Bringi and Chandrasekar, Table 7.1, page 494.");
    tt->val_offset = (char *) &dbz_attenuation_coefficient - &_start_;
    tt->single_val.d = 0.017;
    tt++;
    
    // Parameter 'dbz_attenuation_exponent'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dbz_attenuation_exponent");
    tt->descr = tdrpStrDup("Exponent for computing DBZ attenuation correction.");
    tt->help = tdrpStrDup("See Bringi and Chandrasekar, Table 7.1, page 494.");
    tt->val_offset = (char *) &dbz_attenuation_exponent - &_start_;
    tt->single_val.d = 0.84;
    tt++;
    
    // Parameter 'zdr_attenuation_coefficient'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("zdr_attenuation_coefficient");
    tt->descr = tdrpStrDup("Coefficient for computing ZDR attenuation correction.");
    tt->help = tdrpStrDup("See Bringi and Chandrasekar, Table 7.1, page 494.");
    tt->val_offset = (char *) &zdr_attenuation_coefficient - &_start_;
    tt->single_val.d = 0.017;
    tt++;
    
    // Parameter 'zdr_attenuation_exponent'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("zdr_attenuation_exponent");
    tt->descr = tdrpStrDup("Exponent for computing ZDR attenuation correction.");
    tt->help = tdrpStrDup("See Bringi and Chandrasekar, Table 7.1, page 494.");
    tt->val_offset = (char *) &zdr_attenuation_exponent - &_start_;
    tt->single_val.d = 0.84;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("ATMOSPHERIC ATTENUATION CORRECTION METHOD");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'atmos_atten_method'
    // ctype is '_atmos_atten_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("atmos_atten_method");
    tt->descr = tdrpStrDup("Method for computing atmospheric attenuation.");
    tt->help = tdrpStrDup("This is applied to the DBZ fields only.\n\tATMOS_ATTEN_NONE:\n\t\tNo correction is applied\n\tATMOS_ATTEN_CONSTANT:\n\t\tA constant correction in dB/km is applied\n\t\tSee atmos_atten_db_per_km\n\tATMOS_ATTEN_CRPL:\n\t\tUses the method based on the Central Radio Propagation Laboratory\n\t\tmeasurements.\n\t\tSee Doviak and Zrnic, page 44\n");
    tt->val_offset = (char *) &atmos_atten_method - &_start_;
    tt->enum_def.name = tdrpStrDup("atmos_atten_method_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ATMOS_ATTEN_NONE");
      tt->enum_def.fields[0].val = ATMOS_ATTEN_NONE;
      tt->enum_def.fields[1].name = tdrpStrDup("ATMOS_ATTEN_CONSTANT");
      tt->enum_def.fields[1].val = ATMOS_ATTEN_CONSTANT;
      tt->enum_def.fields[2].name = tdrpStrDup("ATMOS_ATTEN_CRPL");
      tt->enum_def.fields[2].val = ATMOS_ATTEN_CRPL;
    tt->single_val.e = ATMOS_ATTEN_CRPL;
    tt++;
    
    // Parameter 'atmos_atten_db_per_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("atmos_atten_db_per_km");
    tt->descr = tdrpStrDup("Constant atmospheric attenuation (dB/km).");
    tt->help = tdrpStrDup("DBZ is corrected for this.");
    tt->val_offset = (char *) &atmos_atten_db_per_km - &_start_;
    tt->single_val.d = 0.012;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("COMPUTING KDP USING ADAPTIVE FILTER METHOD");
    tt->comment_text = tdrpStrDup("Parameters for computing KDP.");
    tt++;
    
    // Parameter 'KDP_fir_filter_len'
    // ctype is '_fir_filter_len_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("KDP_fir_filter_len");
    tt->descr = tdrpStrDup("Filter length for the FIR filter for PHIDP (gates)");
    tt->help = tdrpStrDup("When computing KDP, an FIR filter is first applied to PHIDP to smooth it. This is the length of that filter, in gates.");
    tt->val_offset = (char *) &KDP_fir_filter_len - &_start_;
    tt->enum_def.name = tdrpStrDup("fir_filter_len_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FIR_LEN_125");
      tt->enum_def.fields[0].val = FIR_LEN_125;
      tt->enum_def.fields[1].name = tdrpStrDup("FIR_LEN_60");
      tt->enum_def.fields[1].val = FIR_LEN_60;
      tt->enum_def.fields[2].name = tdrpStrDup("FIR_LEN_40");
      tt->enum_def.fields[2].val = FIR_LEN_40;
      tt->enum_def.fields[3].name = tdrpStrDup("FIR_LEN_30");
      tt->enum_def.fields[3].val = FIR_LEN_30;
      tt->enum_def.fields[4].name = tdrpStrDup("FIR_LEN_20");
      tt->enum_def.fields[4].val = FIR_LEN_20;
      tt->enum_def.fields[5].name = tdrpStrDup("FIR_LEN_10");
      tt->enum_def.fields[5].val = FIR_LEN_10;
    tt->single_val.e = FIR_LEN_20;
    tt++;
    
    // Parameter 'KDP_n_filt_iterations_unfolded'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("KDP_n_filt_iterations_unfolded");
    tt->descr = tdrpStrDup("Sets the number of iterations for the initial FIR filter for unfolded PHIDP.");
    tt->help = tdrpStrDup("After unfolding PHIDP, the FIR filter is applied to the unfolded phidp, a number of times, to smooth it. The effect of the filter is a combination of the filter length and the number of iterations.");
    tt->val_offset = (char *) &KDP_n_filt_iterations_unfolded - &_start_;
    tt->single_val.i = 2;
    tt++;
    
    // Parameter 'KDP_n_filt_iterations_conditioned'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("KDP_n_filt_iterations_conditioned");
    tt->descr = tdrpStrDup("Sets the number of iterations for the final FIR filter for conditioned PHIDP.");
    tt->help = tdrpStrDup("In order to identify phase shift on backscatter (PSOB), we condition the PHIDP to keep it generally increasing with range. The FIR filter is applied to the conditioned phidp a number of times, to smooth it. The effect of the filter is a combination of the filter length and the number of iterations.");
    tt->val_offset = (char *) &KDP_n_filt_iterations_conditioned - &_start_;
    tt->single_val.i = 2;
    tt++;
    
    // Parameter 'KDP_use_iterative_filtering'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_use_iterative_filtering");
    tt->descr = tdrpStrDup("Perform iterative filtering to locate backscatter phase shift.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_use_iterative_filtering - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'KDP_phidp_difference_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_phidp_difference_threshold");
    tt->descr = tdrpStrDup("Difference threshold for the iterative filtering method.");
    tt->help = tdrpStrDup("The FIR filter is applied successively, KDP_n_filt_iterations_conditioned times. After each iteration the result is checked against the original. If the difference is less than this parameter, the original value at that gate is retained. If the difference exceeds this parameter, the new filtered value is retained.");
    tt->val_offset = (char *) &KDP_phidp_difference_threshold - &_start_;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'KDP_ngates_for_stats'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("KDP_ngates_for_stats");
    tt->descr = tdrpStrDup("Number of gates over which the phidp mean, sdev and jitter are computed.");
    tt->help = tdrpStrDup("The mean, sdev and jitter of phidp are computed over a consecutive number of gates in range, centered on the current gate of interest. This parameter is the number of gates over which these statistics are computed.");
    tt->val_offset = (char *) &KDP_ngates_for_stats - &_start_;
    tt->single_val.i = 9;
    tt++;
    
    // Parameter 'KDP_phidp_sdev_max'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_phidp_sdev_max");
    tt->descr = tdrpStrDup("Sets the threshold for the standard deviation of phidp in range.");
    tt->help = tdrpStrDup("The sdev of phidp is a good test for valid phidp. The sdev is computed in the circle, so that it takes account of folding if present. If the sdev is less than this value, it is assumed we are in weather. Applies to computation of KDP only.");
    tt->val_offset = (char *) &KDP_phidp_sdev_max - &_start_;
    tt->single_val.d = 20;
    tt++;
    
    // Parameter 'KDP_phidp_jitter_max'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_phidp_jitter_max");
    tt->descr = tdrpStrDup("Sets the threshold for the jitter of phidp in range.");
    tt->help = tdrpStrDup("The jitter of phidp is defined as the mean absolute change in angle between successive phidp measurements in range. It is computed on the circle to take account of folding. If the jitter is less than this value, it is assumed we are in weather. Applies to computation of KDP only.");
    tt->val_offset = (char *) &KDP_phidp_jitter_max - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'KDP_check_snr'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_check_snr");
    tt->descr = tdrpStrDup("Check the SNR.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_check_snr - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'KDP_snr_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_snr_threshold");
    tt->descr = tdrpStrDup("Sets the threshold for checking SNR (dB).");
    tt->help = tdrpStrDup("If the SNR drops below this value, KDP will not be computed at this gate.");
    tt->val_offset = (char *) &KDP_snr_threshold - &_start_;
    tt->single_val.d = -6;
    tt++;
    
    // Parameter 'KDP_check_rhohv'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_check_rhohv");
    tt->descr = tdrpStrDup("Check the RHOHV.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_check_rhohv - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'KDP_rhohv_threshold'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_rhohv_threshold");
    tt->descr = tdrpStrDup("Sets the threshold for checking RHOHV.");
    tt->help = tdrpStrDup("If the RHOHV drops below this value, KDP will not be computed at this gate.");
    tt->val_offset = (char *) &KDP_rhohv_threshold - &_start_;
    tt->single_val.d = 0.95;
    tt++;
    
    // Parameter 'KDP_check_zdr_sdev'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_check_zdr_sdev");
    tt->descr = tdrpStrDup("Check the standard deviation of ZDR in range?");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_check_zdr_sdev - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'KDP_zdr_sdev_max'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_zdr_sdev_max");
    tt->descr = tdrpStrDup("Sets the threshold for the standard deviation of zdr in range.");
    tt->help = tdrpStrDup("The sdev of zdr is a good test for clutter. If the sdev is less than this value, it is assumed we are in weather. Applies to computation of KDP only.");
    tt->val_offset = (char *) &KDP_zdr_sdev_max - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'KDP_min_valid_abs_kdp'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("KDP_min_valid_abs_kdp");
    tt->descr = tdrpStrDup("Sets the min valid KDP value.");
    tt->help = tdrpStrDup("Values less than this are set to 0.");
    tt->val_offset = (char *) &KDP_min_valid_abs_kdp - &_start_;
    tt->single_val.d = 0.025;
    tt++;
    
    // Parameter 'KDP_debug'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_debug");
    tt->descr = tdrpStrDup("Option to print debug messages in KDP computation.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_debug - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'KDP_write_ray_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_write_ray_files");
    tt->descr = tdrpStrDup("Option to write ray files to debug KDP computation.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_write_ray_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'KDP_ray_files_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("KDP_ray_files_dir");
    tt->descr = tdrpStrDup("Directory for KDP ray files.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &KDP_ray_files_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/kdp_ray_files");
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("OUTPUT TO DSRADAR FMQ");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_url");
    tt->descr = tdrpStrDup("Output URL for DsRadar data via FMQ");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::fmq/lirp");
    tt++;
    
    // Parameter 'output_fmq_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_size");
    tt->descr = tdrpStrDup("Size of output FMQ, in bytes.");
    tt->help = tdrpStrDup("This is the total size of the output FMQ buffer. Some of this buffer will be used for control bytes (12 bytes per message).");
    tt->val_offset = (char *) &output_fmq_size - &_start_;
    tt->single_val.i = 50000000;
    tt++;
    
    // Parameter 'output_fmq_nslots'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_nslots");
    tt->descr = tdrpStrDup("Number of slots in output FMQ.");
    tt->help = tdrpStrDup("The number of slots corresponds to the maximum number of messages which may be written to the buffer before overwrites occur. However, overwrites may occur sooner if the size is not set large enough.");
    tt->val_offset = (char *) &output_fmq_nslots - &_start_;
    tt->single_val.i = 7200;
    tt++;
    
    // Parameter 'output_fmq_compress'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_compress");
    tt->descr = tdrpStrDup("FMQ compression option.");
    tt->help = tdrpStrDup("If TRUE FMQ messages are compressed.");
    tt->val_offset = (char *) &output_fmq_compress - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nbeams_for_params_and_calib'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nbeams_for_params_and_calib");
    tt->descr = tdrpStrDup("Number of beams between sending params and calibration.");
    tt->help = tdrpStrDup("The params and calibration data is sent when the radar operation changes, as well as once every tilt. However, if none of these triggers a change, the params will be sent regardless when this number of beams have been written.");
    tt->val_offset = (char *) &nbeams_for_params_and_calib - &_start_;
    tt->single_val.i = 360;
    tt++;
    
    // Parameter 'write_blocking'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_blocking");
    tt->descr = tdrpStrDup("Option to set up the FMQ as blocking.");
    tt->help = tdrpStrDup("If TRUE, FMQ will be set up FMQ for blocking operation. If the FMQ becomes full, Test2Dsr will then block until there is space for more data.");
    tt->val_offset = (char *) &write_blocking - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'beam_wait_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("beam_wait_msecs");
    tt->descr = tdrpStrDup("Wait per beam (milli-secs)");
    tt->help = tdrpStrDup("FILELIST, ARCHIVE and SIMULATE modes only.");
    tt->val_offset = (char *) &beam_wait_msecs - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_output_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("Indicate which fields should be written to the Dsr FMQ.");
    tt->help = tdrpStrDup("Choose the ID from the list. The name and units can be set however the user prefers. The scale and bias are applied to the floating point value to compute the 16-bit output value for the FMQ.");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(output_field_t);
    tt->array_n = 50;
    tt->struct_def.name = tdrpStrDup("output_field_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("field_id_t");
      tt->struct_def.fields[0].fname = tdrpStrDup("id");
      tt->struct_def.fields[0].ptype = ENUM_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_fields->id - (char *) _output_fields;
        tt->struct_def.fields[0].enum_def.name = tdrpStrDup("field_id_t");
        tt->struct_def.fields[0].enum_def.nfields = 142;
        tt->struct_def.fields[0].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[0].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[0].enum_def.fields[0].name = tdrpStrDup("DBZ");
        tt->struct_def.fields[0].enum_def.fields[0].val = DBZ;
        tt->struct_def.fields[0].enum_def.fields[1].name = tdrpStrDup("DBZ_NO_ATMOS_ATTEN");
        tt->struct_def.fields[0].enum_def.fields[1].val = DBZ_NO_ATMOS_ATTEN;
        tt->struct_def.fields[0].enum_def.fields[2].name = tdrpStrDup("DBZHC");
        tt->struct_def.fields[0].enum_def.fields[2].val = DBZHC;
        tt->struct_def.fields[0].enum_def.fields[3].name = tdrpStrDup("DBZVC");
        tt->struct_def.fields[0].enum_def.fields[3].val = DBZVC;
        tt->struct_def.fields[0].enum_def.fields[4].name = tdrpStrDup("DBZHX");
        tt->struct_def.fields[0].enum_def.fields[4].val = DBZHX;
        tt->struct_def.fields[0].enum_def.fields[5].name = tdrpStrDup("DBZVX");
        tt->struct_def.fields[0].enum_def.fields[5].val = DBZVX;
        tt->struct_def.fields[0].enum_def.fields[6].name = tdrpStrDup("VEL");
        tt->struct_def.fields[0].enum_def.fields[6].val = VEL;
        tt->struct_def.fields[0].enum_def.fields[7].name = tdrpStrDup("VEL_ALT");
        tt->struct_def.fields[0].enum_def.fields[7].val = VEL_ALT;
        tt->struct_def.fields[0].enum_def.fields[8].name = tdrpStrDup("VEL_HV");
        tt->struct_def.fields[0].enum_def.fields[8].val = VEL_HV;
        tt->struct_def.fields[0].enum_def.fields[9].name = tdrpStrDup("VEL_H_ONLY");
        tt->struct_def.fields[0].enum_def.fields[9].val = VEL_H_ONLY;
        tt->struct_def.fields[0].enum_def.fields[10].name = tdrpStrDup("VEL_V_ONLY");
        tt->struct_def.fields[0].enum_def.fields[10].val = VEL_V_ONLY;
        tt->struct_def.fields[0].enum_def.fields[11].name = tdrpStrDup("VEL_ALT_FOLD_INTERVAL");
        tt->struct_def.fields[0].enum_def.fields[11].val = VEL_ALT_FOLD_INTERVAL;
        tt->struct_def.fields[0].enum_def.fields[12].name = tdrpStrDup("VEL_ALT_FOLD_CONFIDENCE");
        tt->struct_def.fields[0].enum_def.fields[12].val = VEL_ALT_FOLD_CONFIDENCE;
        tt->struct_def.fields[0].enum_def.fields[13].name = tdrpStrDup("VEL_CORRECTED");
        tt->struct_def.fields[0].enum_def.fields[13].val = VEL_CORRECTED;
        tt->struct_def.fields[0].enum_def.fields[14].name = tdrpStrDup("VEL_PRT_SHORT");
        tt->struct_def.fields[0].enum_def.fields[14].val = VEL_PRT_SHORT;
        tt->struct_def.fields[0].enum_def.fields[15].name = tdrpStrDup("VEL_PRT_LONG");
        tt->struct_def.fields[0].enum_def.fields[15].val = VEL_PRT_LONG;
        tt->struct_def.fields[0].enum_def.fields[16].name = tdrpStrDup("VEL_DIFF");
        tt->struct_def.fields[0].enum_def.fields[16].val = VEL_DIFF;
        tt->struct_def.fields[0].enum_def.fields[17].name = tdrpStrDup("VEL_UNFOLD_INTERVAL");
        tt->struct_def.fields[0].enum_def.fields[17].val = VEL_UNFOLD_INTERVAL;
        tt->struct_def.fields[0].enum_def.fields[18].name = tdrpStrDup("WIDTH");
        tt->struct_def.fields[0].enum_def.fields[18].val = WIDTH;
        tt->struct_def.fields[0].enum_def.fields[19].name = tdrpStrDup("WIDTH_R0R1");
        tt->struct_def.fields[0].enum_def.fields[19].val = WIDTH_R0R1;
        tt->struct_def.fields[0].enum_def.fields[20].name = tdrpStrDup("WIDTH_R1R2");
        tt->struct_def.fields[0].enum_def.fields[20].val = WIDTH_R1R2;
        tt->struct_def.fields[0].enum_def.fields[21].name = tdrpStrDup("WIDTH_R1R3");
        tt->struct_def.fields[0].enum_def.fields[21].val = WIDTH_R1R3;
        tt->struct_def.fields[0].enum_def.fields[22].name = tdrpStrDup("WIDTH_PPLS");
        tt->struct_def.fields[0].enum_def.fields[22].val = WIDTH_PPLS;
        tt->struct_def.fields[0].enum_def.fields[23].name = tdrpStrDup("WIDTH_H_ONLY");
        tt->struct_def.fields[0].enum_def.fields[23].val = WIDTH_H_ONLY;
        tt->struct_def.fields[0].enum_def.fields[24].name = tdrpStrDup("WIDTH_V_ONLY");
        tt->struct_def.fields[0].enum_def.fields[24].val = WIDTH_V_ONLY;
        tt->struct_def.fields[0].enum_def.fields[25].name = tdrpStrDup("WIDTH_PRT_LONG");
        tt->struct_def.fields[0].enum_def.fields[25].val = WIDTH_PRT_LONG;
        tt->struct_def.fields[0].enum_def.fields[26].name = tdrpStrDup("WIDTH_PRT_SHORT");
        tt->struct_def.fields[0].enum_def.fields[26].val = WIDTH_PRT_SHORT;
        tt->struct_def.fields[0].enum_def.fields[27].name = tdrpStrDup("NCP");
        tt->struct_def.fields[0].enum_def.fields[27].val = NCP;
        tt->struct_def.fields[0].enum_def.fields[28].name = tdrpStrDup("NCP_H_ONLY");
        tt->struct_def.fields[0].enum_def.fields[28].val = NCP_H_ONLY;
        tt->struct_def.fields[0].enum_def.fields[29].name = tdrpStrDup("NCP_V_ONLY");
        tt->struct_def.fields[0].enum_def.fields[29].val = NCP_V_ONLY;
        tt->struct_def.fields[0].enum_def.fields[30].name = tdrpStrDup("NCP_H_MINUS_V");
        tt->struct_def.fields[0].enum_def.fields[30].val = NCP_H_MINUS_V;
        tt->struct_def.fields[0].enum_def.fields[31].name = tdrpStrDup("NCP_PRT_LONG");
        tt->struct_def.fields[0].enum_def.fields[31].val = NCP_PRT_LONG;
        tt->struct_def.fields[0].enum_def.fields[32].name = tdrpStrDup("NCP_PRT_SHORT");
        tt->struct_def.fields[0].enum_def.fields[32].val = NCP_PRT_SHORT;
        tt->struct_def.fields[0].enum_def.fields[33].name = tdrpStrDup("NCP_TRIP_FLAG");
        tt->struct_def.fields[0].enum_def.fields[33].val = NCP_TRIP_FLAG;
        tt->struct_def.fields[0].enum_def.fields[34].name = tdrpStrDup("NOISE_BIAS_DB_HC");
        tt->struct_def.fields[0].enum_def.fields[34].val = NOISE_BIAS_DB_HC;
        tt->struct_def.fields[0].enum_def.fields[35].name = tdrpStrDup("NOISE_BIAS_DB_HX");
        tt->struct_def.fields[0].enum_def.fields[35].val = NOISE_BIAS_DB_HX;
        tt->struct_def.fields[0].enum_def.fields[36].name = tdrpStrDup("NOISE_BIAS_DB_VC");
        tt->struct_def.fields[0].enum_def.fields[36].val = NOISE_BIAS_DB_VC;
        tt->struct_def.fields[0].enum_def.fields[37].name = tdrpStrDup("NOISE_BIAS_DB_VX");
        tt->struct_def.fields[0].enum_def.fields[37].val = NOISE_BIAS_DB_VX;
        tt->struct_def.fields[0].enum_def.fields[38].name = tdrpStrDup("SNR");
        tt->struct_def.fields[0].enum_def.fields[38].val = SNR;
        tt->struct_def.fields[0].enum_def.fields[39].name = tdrpStrDup("SNRHC");
        tt->struct_def.fields[0].enum_def.fields[39].val = SNRHC;
        tt->struct_def.fields[0].enum_def.fields[40].name = tdrpStrDup("SNRHX");
        tt->struct_def.fields[0].enum_def.fields[40].val = SNRHX;
        tt->struct_def.fields[0].enum_def.fields[41].name = tdrpStrDup("SNRVC");
        tt->struct_def.fields[0].enum_def.fields[41].val = SNRVC;
        tt->struct_def.fields[0].enum_def.fields[42].name = tdrpStrDup("SNRVX");
        tt->struct_def.fields[0].enum_def.fields[42].val = SNRVX;
        tt->struct_def.fields[0].enum_def.fields[43].name = tdrpStrDup("DBM");
        tt->struct_def.fields[0].enum_def.fields[43].val = DBM;
        tt->struct_def.fields[0].enum_def.fields[44].name = tdrpStrDup("DBMHC");
        tt->struct_def.fields[0].enum_def.fields[44].val = DBMHC;
        tt->struct_def.fields[0].enum_def.fields[45].name = tdrpStrDup("DBMHX");
        tt->struct_def.fields[0].enum_def.fields[45].val = DBMHX;
        tt->struct_def.fields[0].enum_def.fields[46].name = tdrpStrDup("DBMVC");
        tt->struct_def.fields[0].enum_def.fields[46].val = DBMVC;
        tt->struct_def.fields[0].enum_def.fields[47].name = tdrpStrDup("DBMVX");
        tt->struct_def.fields[0].enum_def.fields[47].val = DBMVX;
        tt->struct_def.fields[0].enum_def.fields[48].name = tdrpStrDup("DBMHC_NS");
        tt->struct_def.fields[0].enum_def.fields[48].val = DBMHC_NS;
        tt->struct_def.fields[0].enum_def.fields[49].name = tdrpStrDup("DBMHX_NS");
        tt->struct_def.fields[0].enum_def.fields[49].val = DBMHX_NS;
        tt->struct_def.fields[0].enum_def.fields[50].name = tdrpStrDup("DBMVC_NS");
        tt->struct_def.fields[0].enum_def.fields[50].val = DBMVC_NS;
        tt->struct_def.fields[0].enum_def.fields[51].name = tdrpStrDup("DBMVX_NS");
        tt->struct_def.fields[0].enum_def.fields[51].val = DBMVX_NS;
        tt->struct_def.fields[0].enum_def.fields[52].name = tdrpStrDup("ZDRM");
        tt->struct_def.fields[0].enum_def.fields[52].val = ZDRM;
        tt->struct_def.fields[0].enum_def.fields[53].name = tdrpStrDup("ZDR");
        tt->struct_def.fields[0].enum_def.fields[53].val = ZDR;
        tt->struct_def.fields[0].enum_def.fields[54].name = tdrpStrDup("ZDR_BIAS");
        tt->struct_def.fields[0].enum_def.fields[54].val = ZDR_BIAS;
        tt->struct_def.fields[0].enum_def.fields[55].name = tdrpStrDup("LDR");
        tt->struct_def.fields[0].enum_def.fields[55].val = LDR;
        tt->struct_def.fields[0].enum_def.fields[56].name = tdrpStrDup("LDRHM");
        tt->struct_def.fields[0].enum_def.fields[56].val = LDRHM;
        tt->struct_def.fields[0].enum_def.fields[57].name = tdrpStrDup("LDRH");
        tt->struct_def.fields[0].enum_def.fields[57].val = LDRH;
        tt->struct_def.fields[0].enum_def.fields[58].name = tdrpStrDup("LDRVM");
        tt->struct_def.fields[0].enum_def.fields[58].val = LDRVM;
        tt->struct_def.fields[0].enum_def.fields[59].name = tdrpStrDup("LDRV");
        tt->struct_def.fields[0].enum_def.fields[59].val = LDRV;
        tt->struct_def.fields[0].enum_def.fields[60].name = tdrpStrDup("LDR_DIFF");
        tt->struct_def.fields[0].enum_def.fields[60].val = LDR_DIFF;
        tt->struct_def.fields[0].enum_def.fields[61].name = tdrpStrDup("LDR_MEAN");
        tt->struct_def.fields[0].enum_def.fields[61].val = LDR_MEAN;
        tt->struct_def.fields[0].enum_def.fields[62].name = tdrpStrDup("RHOHV");
        tt->struct_def.fields[0].enum_def.fields[62].val = RHOHV;
        tt->struct_def.fields[0].enum_def.fields[63].name = tdrpStrDup("RHOHV_NNC");
        tt->struct_def.fields[0].enum_def.fields[63].val = RHOHV_NNC;
        tt->struct_def.fields[0].enum_def.fields[64].name = tdrpStrDup("PHIDP0");
        tt->struct_def.fields[0].enum_def.fields[64].val = PHIDP0;
        tt->struct_def.fields[0].enum_def.fields[65].name = tdrpStrDup("PHIDP");
        tt->struct_def.fields[0].enum_def.fields[65].val = PHIDP;
        tt->struct_def.fields[0].enum_def.fields[66].name = tdrpStrDup("PHIDP_COND");
        tt->struct_def.fields[0].enum_def.fields[66].val = PHIDP_COND;
        tt->struct_def.fields[0].enum_def.fields[67].name = tdrpStrDup("PHIDP_FILT");
        tt->struct_def.fields[0].enum_def.fields[67].val = PHIDP_FILT;
        tt->struct_def.fields[0].enum_def.fields[68].name = tdrpStrDup("PHIDP_SDEV_4KDP");
        tt->struct_def.fields[0].enum_def.fields[68].val = PHIDP_SDEV_4KDP;
        tt->struct_def.fields[0].enum_def.fields[69].name = tdrpStrDup("PHIDP_JITTER_4KDP");
        tt->struct_def.fields[0].enum_def.fields[69].val = PHIDP_JITTER_4KDP;
        tt->struct_def.fields[0].enum_def.fields[70].name = tdrpStrDup("ZDR_SDEV_4KDP");
        tt->struct_def.fields[0].enum_def.fields[70].val = ZDR_SDEV_4KDP;
        tt->struct_def.fields[0].enum_def.fields[71].name = tdrpStrDup("KDP");
        tt->struct_def.fields[0].enum_def.fields[71].val = KDP;
        tt->struct_def.fields[0].enum_def.fields[72].name = tdrpStrDup("PSOB");
        tt->struct_def.fields[0].enum_def.fields[72].val = PSOB;
        tt->struct_def.fields[0].enum_def.fields[73].name = tdrpStrDup("KDP_HB");
        tt->struct_def.fields[0].enum_def.fields[73].val = KDP_HB;
        tt->struct_def.fields[0].enum_def.fields[74].name = tdrpStrDup("RHO_HC_VX");
        tt->struct_def.fields[0].enum_def.fields[74].val = RHO_HC_VX;
        tt->struct_def.fields[0].enum_def.fields[75].name = tdrpStrDup("RHO_VC_HX");
        tt->struct_def.fields[0].enum_def.fields[75].val = RHO_VC_HX;
        tt->struct_def.fields[0].enum_def.fields[76].name = tdrpStrDup("RHO_VX_HX");
        tt->struct_def.fields[0].enum_def.fields[76].val = RHO_VX_HX;
        tt->struct_def.fields[0].enum_def.fields[77].name = tdrpStrDup("RHO_PHIDP");
        tt->struct_def.fields[0].enum_def.fields[77].val = RHO_PHIDP;
        tt->struct_def.fields[0].enum_def.fields[78].name = tdrpStrDup("DBZ_ATTEN_CORRECTION");
        tt->struct_def.fields[0].enum_def.fields[78].val = DBZ_ATTEN_CORRECTION;
        tt->struct_def.fields[0].enum_def.fields[79].name = tdrpStrDup("ZDR_ATTEN_CORRECTION");
        tt->struct_def.fields[0].enum_def.fields[79].val = ZDR_ATTEN_CORRECTION;
        tt->struct_def.fields[0].enum_def.fields[80].name = tdrpStrDup("DBZ_ATTEN_CORRECTED");
        tt->struct_def.fields[0].enum_def.fields[80].val = DBZ_ATTEN_CORRECTED;
        tt->struct_def.fields[0].enum_def.fields[81].name = tdrpStrDup("ZDR_ATTEN_CORRECTED");
        tt->struct_def.fields[0].enum_def.fields[81].val = ZDR_ATTEN_CORRECTED;
        tt->struct_def.fields[0].enum_def.fields[82].name = tdrpStrDup("LAG0_HC_DB");
        tt->struct_def.fields[0].enum_def.fields[82].val = LAG0_HC_DB;
        tt->struct_def.fields[0].enum_def.fields[83].name = tdrpStrDup("LAG0_HX_DB");
        tt->struct_def.fields[0].enum_def.fields[83].val = LAG0_HX_DB;
        tt->struct_def.fields[0].enum_def.fields[84].name = tdrpStrDup("LAG0_VC_DB");
        tt->struct_def.fields[0].enum_def.fields[84].val = LAG0_VC_DB;
        tt->struct_def.fields[0].enum_def.fields[85].name = tdrpStrDup("LAG0_VX_DB");
        tt->struct_def.fields[0].enum_def.fields[85].val = LAG0_VX_DB;
        tt->struct_def.fields[0].enum_def.fields[86].name = tdrpStrDup("LAG0_HC_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[86].val = LAG0_HC_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[87].name = tdrpStrDup("LAG0_VC_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[87].val = LAG0_VC_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[88].name = tdrpStrDup("LAG0_HC_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[88].val = LAG0_HC_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[89].name = tdrpStrDup("LAG0_VC_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[89].val = LAG0_VC_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[90].name = tdrpStrDup("LAG0_VCHX_DB");
        tt->struct_def.fields[0].enum_def.fields[90].val = LAG0_VCHX_DB;
        tt->struct_def.fields[0].enum_def.fields[91].name = tdrpStrDup("LAG0_VCHX_PHASE");
        tt->struct_def.fields[0].enum_def.fields[91].val = LAG0_VCHX_PHASE;
        tt->struct_def.fields[0].enum_def.fields[92].name = tdrpStrDup("LAG0_HCVX_DB");
        tt->struct_def.fields[0].enum_def.fields[92].val = LAG0_HCVX_DB;
        tt->struct_def.fields[0].enum_def.fields[93].name = tdrpStrDup("LAG0_HCVX_PHASE");
        tt->struct_def.fields[0].enum_def.fields[93].val = LAG0_HCVX_PHASE;
        tt->struct_def.fields[0].enum_def.fields[94].name = tdrpStrDup("LAG1_HC_DB");
        tt->struct_def.fields[0].enum_def.fields[94].val = LAG1_HC_DB;
        tt->struct_def.fields[0].enum_def.fields[95].name = tdrpStrDup("LAG1_HC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[95].val = LAG1_HC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[96].name = tdrpStrDup("LAG1_VC_DB");
        tt->struct_def.fields[0].enum_def.fields[96].val = LAG1_VC_DB;
        tt->struct_def.fields[0].enum_def.fields[97].name = tdrpStrDup("LAG1_VC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[97].val = LAG1_VC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[98].name = tdrpStrDup("LAG1_HCVC_DB");
        tt->struct_def.fields[0].enum_def.fields[98].val = LAG1_HCVC_DB;
        tt->struct_def.fields[0].enum_def.fields[99].name = tdrpStrDup("LAG1_HCVC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[99].val = LAG1_HCVC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[100].name = tdrpStrDup("LAG1_VCHC_DB");
        tt->struct_def.fields[0].enum_def.fields[100].val = LAG1_VCHC_DB;
        tt->struct_def.fields[0].enum_def.fields[101].name = tdrpStrDup("LAG1_VCHC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[101].val = LAG1_VCHC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[102].name = tdrpStrDup("LAG1_VXHX_DB");
        tt->struct_def.fields[0].enum_def.fields[102].val = LAG1_VXHX_DB;
        tt->struct_def.fields[0].enum_def.fields[103].name = tdrpStrDup("LAG1_VXHX_PHASE");
        tt->struct_def.fields[0].enum_def.fields[103].val = LAG1_VXHX_PHASE;
        tt->struct_def.fields[0].enum_def.fields[104].name = tdrpStrDup("LAG1_HC_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[104].val = LAG1_HC_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[105].name = tdrpStrDup("LAG1_HC_LONG_PHASE");
        tt->struct_def.fields[0].enum_def.fields[105].val = LAG1_HC_LONG_PHASE;
        tt->struct_def.fields[0].enum_def.fields[106].name = tdrpStrDup("LAG1_VC_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[106].val = LAG1_VC_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[107].name = tdrpStrDup("LAG1_VC_LONG_PHASE");
        tt->struct_def.fields[0].enum_def.fields[107].val = LAG1_VC_LONG_PHASE;
        tt->struct_def.fields[0].enum_def.fields[108].name = tdrpStrDup("LAG1_HC_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[108].val = LAG1_HC_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[109].name = tdrpStrDup("LAG1_HC_SHORT_PHASE");
        tt->struct_def.fields[0].enum_def.fields[109].val = LAG1_HC_SHORT_PHASE;
        tt->struct_def.fields[0].enum_def.fields[110].name = tdrpStrDup("LAG1_VC_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[110].val = LAG1_VC_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[111].name = tdrpStrDup("LAG1_VC_SHORT_PHASE");
        tt->struct_def.fields[0].enum_def.fields[111].val = LAG1_VC_SHORT_PHASE;
        tt->struct_def.fields[0].enum_def.fields[112].name = tdrpStrDup("LAG1_HC_LONG_TO_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[112].val = LAG1_HC_LONG_TO_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[113].name = tdrpStrDup("LAG1_HC_LONG_TO_SHORT_PHASE");
        tt->struct_def.fields[0].enum_def.fields[113].val = LAG1_HC_LONG_TO_SHORT_PHASE;
        tt->struct_def.fields[0].enum_def.fields[114].name = tdrpStrDup("LAG1_VC_LONG_TO_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[114].val = LAG1_VC_LONG_TO_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[115].name = tdrpStrDup("LAG1_VC_LONG_TO_SHORT_PHASE");
        tt->struct_def.fields[0].enum_def.fields[115].val = LAG1_VC_LONG_TO_SHORT_PHASE;
        tt->struct_def.fields[0].enum_def.fields[116].name = tdrpStrDup("LAG1_HC_SHORT_TO_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[116].val = LAG1_HC_SHORT_TO_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[117].name = tdrpStrDup("LAG1_HC_SHORT_TO_LONG_PHASE");
        tt->struct_def.fields[0].enum_def.fields[117].val = LAG1_HC_SHORT_TO_LONG_PHASE;
        tt->struct_def.fields[0].enum_def.fields[118].name = tdrpStrDup("LAG1_VC_SHORT_TO_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[118].val = LAG1_VC_SHORT_TO_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[119].name = tdrpStrDup("LAG1_VC_SHORT_TO_LONG_PHASE");
        tt->struct_def.fields[0].enum_def.fields[119].val = LAG1_VC_SHORT_TO_LONG_PHASE;
        tt->struct_def.fields[0].enum_def.fields[120].name = tdrpStrDup("LAG2_HC_DB");
        tt->struct_def.fields[0].enum_def.fields[120].val = LAG2_HC_DB;
        tt->struct_def.fields[0].enum_def.fields[121].name = tdrpStrDup("LAG2_HC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[121].val = LAG2_HC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[122].name = tdrpStrDup("LAG2_VC_DB");
        tt->struct_def.fields[0].enum_def.fields[122].val = LAG2_VC_DB;
        tt->struct_def.fields[0].enum_def.fields[123].name = tdrpStrDup("LAG2_VC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[123].val = LAG2_VC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[124].name = tdrpStrDup("LAG3_HC_DB");
        tt->struct_def.fields[0].enum_def.fields[124].val = LAG3_HC_DB;
        tt->struct_def.fields[0].enum_def.fields[125].name = tdrpStrDup("LAG3_HC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[125].val = LAG3_HC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[126].name = tdrpStrDup("LAG3_VC_DB");
        tt->struct_def.fields[0].enum_def.fields[126].val = LAG3_VC_DB;
        tt->struct_def.fields[0].enum_def.fields[127].name = tdrpStrDup("LAG3_VC_PHASE");
        tt->struct_def.fields[0].enum_def.fields[127].val = LAG3_VC_PHASE;
        tt->struct_def.fields[0].enum_def.fields[128].name = tdrpStrDup("RVVHH0_DB");
        tt->struct_def.fields[0].enum_def.fields[128].val = RVVHH0_DB;
        tt->struct_def.fields[0].enum_def.fields[129].name = tdrpStrDup("RVVHH0_PHASE");
        tt->struct_def.fields[0].enum_def.fields[129].val = RVVHH0_PHASE;
        tt->struct_def.fields[0].enum_def.fields[130].name = tdrpStrDup("RVVHH0_LONG_DB");
        tt->struct_def.fields[0].enum_def.fields[130].val = RVVHH0_LONG_DB;
        tt->struct_def.fields[0].enum_def.fields[131].name = tdrpStrDup("RVVHH0_LONG_PHASE");
        tt->struct_def.fields[0].enum_def.fields[131].val = RVVHH0_LONG_PHASE;
        tt->struct_def.fields[0].enum_def.fields[132].name = tdrpStrDup("RVVHH0_SHORT_DB");
        tt->struct_def.fields[0].enum_def.fields[132].val = RVVHH0_SHORT_DB;
        tt->struct_def.fields[0].enum_def.fields[133].name = tdrpStrDup("RVVHH0_SHORT_PHASE");
        tt->struct_def.fields[0].enum_def.fields[133].val = RVVHH0_SHORT_PHASE;
        tt->struct_def.fields[0].enum_def.fields[134].name = tdrpStrDup("SDEV_VV");
        tt->struct_def.fields[0].enum_def.fields[134].val = SDEV_VV;
        tt->struct_def.fields[0].enum_def.fields[135].name = tdrpStrDup("PRT");
        tt->struct_def.fields[0].enum_def.fields[135].val = PRT;
        tt->struct_def.fields[0].enum_def.fields[136].name = tdrpStrDup("NUM_PULSES");
        tt->struct_def.fields[0].enum_def.fields[136].val = NUM_PULSES;
        tt->struct_def.fields[0].enum_def.fields[137].name = tdrpStrDup("TEST");
        tt->struct_def.fields[0].enum_def.fields[137].val = TEST;
        tt->struct_def.fields[0].enum_def.fields[138].name = tdrpStrDup("TEST2");
        tt->struct_def.fields[0].enum_def.fields[138].val = TEST2;
        tt->struct_def.fields[0].enum_def.fields[139].name = tdrpStrDup("TEST3");
        tt->struct_def.fields[0].enum_def.fields[139].val = TEST3;
        tt->struct_def.fields[0].enum_def.fields[140].name = tdrpStrDup("TEST4");
        tt->struct_def.fields[0].enum_def.fields[140].val = TEST4;
        tt->struct_def.fields[0].enum_def.fields[141].name = tdrpStrDup("TEST5");
        tt->struct_def.fields[0].enum_def.fields[141].val = TEST5;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_fields->name - (char *) _output_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("units");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_output_fields->units - (char *) _output_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("scale");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_output_fields->scale - (char *) _output_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("bias");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_output_fields->bias - (char *) _output_fields;
    tt->n_struct_vals = 250;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].e = NCP;
      tt->struct_vals[1].s = tdrpStrDup("NCP");
      tt->struct_vals[2].s = tdrpStrDup("");
      tt->struct_vals[3].d = 0.0001;
      tt->struct_vals[4].d = -0.01;
      tt->struct_vals[5].e = SNR;
      tt->struct_vals[6].s = tdrpStrDup("SNR");
      tt->struct_vals[7].s = tdrpStrDup("dB");
      tt->struct_vals[8].d = 0.01;
      tt->struct_vals[9].d = -320;
      tt->struct_vals[10].e = DBM;
      tt->struct_vals[11].s = tdrpStrDup("DBM");
      tt->struct_vals[12].s = tdrpStrDup("dBm");
      tt->struct_vals[13].d = 0.01;
      tt->struct_vals[14].d = -320;
      tt->struct_vals[15].e = DBZ;
      tt->struct_vals[16].s = tdrpStrDup("DBZ");
      tt->struct_vals[17].s = tdrpStrDup("dBZ");
      tt->struct_vals[18].d = 0.01;
      tt->struct_vals[19].d = -320;
      tt->struct_vals[20].e = VEL;
      tt->struct_vals[21].s = tdrpStrDup("VEL");
      tt->struct_vals[22].s = tdrpStrDup("m/s");
      tt->struct_vals[23].d = 0.01;
      tt->struct_vals[24].d = -320;
      tt->struct_vals[25].e = WIDTH;
      tt->struct_vals[26].s = tdrpStrDup("WIDTH");
      tt->struct_vals[27].s = tdrpStrDup("m/s");
      tt->struct_vals[28].d = 0.001;
      tt->struct_vals[29].d = -0.01;
      tt->struct_vals[30].e = ZDR;
      tt->struct_vals[31].s = tdrpStrDup("ZDR");
      tt->struct_vals[32].s = tdrpStrDup("dB");
      tt->struct_vals[33].d = 0.001;
      tt->struct_vals[34].d = -32;
      tt->struct_vals[35].e = ZDRM;
      tt->struct_vals[36].s = tdrpStrDup("ZDRM");
      tt->struct_vals[37].s = tdrpStrDup("dB");
      tt->struct_vals[38].d = 0.001;
      tt->struct_vals[39].d = -32;
      tt->struct_vals[40].e = LDRH;
      tt->struct_vals[41].s = tdrpStrDup("LDRH");
      tt->struct_vals[42].s = tdrpStrDup("dB");
      tt->struct_vals[43].d = 0.005;
      tt->struct_vals[44].d = -160;
      tt->struct_vals[45].e = RHOHV;
      tt->struct_vals[46].s = tdrpStrDup("RHOHV");
      tt->struct_vals[47].s = tdrpStrDup("");
      tt->struct_vals[48].d = 0.0001;
      tt->struct_vals[49].d = -1;
      tt->struct_vals[50].e = PHIDP0;
      tt->struct_vals[51].s = tdrpStrDup("PHIDP0");
      tt->struct_vals[52].s = tdrpStrDup("deg");
      tt->struct_vals[53].d = 0.06;
      tt->struct_vals[54].d = -200;
      tt->struct_vals[55].e = PHIDP;
      tt->struct_vals[56].s = tdrpStrDup("PHIDP");
      tt->struct_vals[57].s = tdrpStrDup("deg");
      tt->struct_vals[58].d = 0.06;
      tt->struct_vals[59].d = -200;
      tt->struct_vals[60].e = KDP;
      tt->struct_vals[61].s = tdrpStrDup("KDP");
      tt->struct_vals[62].s = tdrpStrDup("deg/km");
      tt->struct_vals[63].d = 0.001;
      tt->struct_vals[64].d = -32;
      tt->struct_vals[65].e = SNRHC;
      tt->struct_vals[66].s = tdrpStrDup("SNRHC");
      tt->struct_vals[67].s = tdrpStrDup("dB");
      tt->struct_vals[68].d = 0.01;
      tt->struct_vals[69].d = -320;
      tt->struct_vals[70].e = SNRHX;
      tt->struct_vals[71].s = tdrpStrDup("SNRHX");
      tt->struct_vals[72].s = tdrpStrDup("dB");
      tt->struct_vals[73].d = 0.01;
      tt->struct_vals[74].d = -320;
      tt->struct_vals[75].e = SNRVC;
      tt->struct_vals[76].s = tdrpStrDup("SNRVC");
      tt->struct_vals[77].s = tdrpStrDup("dB");
      tt->struct_vals[78].d = 0.01;
      tt->struct_vals[79].d = -320;
      tt->struct_vals[80].e = SNRVX;
      tt->struct_vals[81].s = tdrpStrDup("SNRVX");
      tt->struct_vals[82].s = tdrpStrDup("dB");
      tt->struct_vals[83].d = 0.01;
      tt->struct_vals[84].d = -320;
      tt->struct_vals[85].e = DBMHC;
      tt->struct_vals[86].s = tdrpStrDup("DBMHC");
      tt->struct_vals[87].s = tdrpStrDup("dBm");
      tt->struct_vals[88].d = 0.01;
      tt->struct_vals[89].d = -320;
      tt->struct_vals[90].e = DBMHX;
      tt->struct_vals[91].s = tdrpStrDup("DBMHX");
      tt->struct_vals[92].s = tdrpStrDup("dBm");
      tt->struct_vals[93].d = 0.01;
      tt->struct_vals[94].d = -320;
      tt->struct_vals[95].e = DBMVC;
      tt->struct_vals[96].s = tdrpStrDup("DBMVC");
      tt->struct_vals[97].s = tdrpStrDup("dBm");
      tt->struct_vals[98].d = 0.01;
      tt->struct_vals[99].d = -320;
      tt->struct_vals[100].e = DBMVX;
      tt->struct_vals[101].s = tdrpStrDup("DBMVX");
      tt->struct_vals[102].s = tdrpStrDup("dBm");
      tt->struct_vals[103].d = 0.01;
      tt->struct_vals[104].d = -320;
      tt->struct_vals[105].e = LAG0_HC_DB;
      tt->struct_vals[106].s = tdrpStrDup("LAG0_HC_DB");
      tt->struct_vals[107].s = tdrpStrDup("dBm");
      tt->struct_vals[108].d = 0.005;
      tt->struct_vals[109].d = -160;
      tt->struct_vals[110].e = LAG0_HX_DB;
      tt->struct_vals[111].s = tdrpStrDup("LAG0_HX_DB");
      tt->struct_vals[112].s = tdrpStrDup("dBm");
      tt->struct_vals[113].d = 0.005;
      tt->struct_vals[114].d = -160;
      tt->struct_vals[115].e = LAG0_VC_DB;
      tt->struct_vals[116].s = tdrpStrDup("LAG0_VC_DB");
      tt->struct_vals[117].s = tdrpStrDup("dBm");
      tt->struct_vals[118].d = 0.005;
      tt->struct_vals[119].d = -160;
      tt->struct_vals[120].e = LAG0_VX_DB;
      tt->struct_vals[121].s = tdrpStrDup("LAG0_VX_DB");
      tt->struct_vals[122].s = tdrpStrDup("dBm");
      tt->struct_vals[123].d = 0.005;
      tt->struct_vals[124].d = -160;
      tt->struct_vals[125].e = LAG0_HCVX_DB;
      tt->struct_vals[126].s = tdrpStrDup("LAG0_HCVX_DB");
      tt->struct_vals[127].s = tdrpStrDup("dBm");
      tt->struct_vals[128].d = 0.005;
      tt->struct_vals[129].d = -160;
      tt->struct_vals[130].e = LAG0_HCVX_PHASE;
      tt->struct_vals[131].s = tdrpStrDup("LAG0_HCVX_PHASE");
      tt->struct_vals[132].s = tdrpStrDup("deg");
      tt->struct_vals[133].d = 0.006;
      tt->struct_vals[134].d = -190;
      tt->struct_vals[135].e = LAG0_VCHX_DB;
      tt->struct_vals[136].s = tdrpStrDup("LAG0_VCHX_DB");
      tt->struct_vals[137].s = tdrpStrDup("dBm");
      tt->struct_vals[138].d = 0.005;
      tt->struct_vals[139].d = -160;
      tt->struct_vals[140].e = LAG0_VCHX_PHASE;
      tt->struct_vals[141].s = tdrpStrDup("LAG0_VCHX_PHASE");
      tt->struct_vals[142].s = tdrpStrDup("deg");
      tt->struct_vals[143].d = 0.006;
      tt->struct_vals[144].d = -190;
      tt->struct_vals[145].e = LAG1_HC_DB;
      tt->struct_vals[146].s = tdrpStrDup("LAG1_HC_DB");
      tt->struct_vals[147].s = tdrpStrDup("dBm");
      tt->struct_vals[148].d = 0.005;
      tt->struct_vals[149].d = -160;
      tt->struct_vals[150].e = LAG1_HC_PHASE;
      tt->struct_vals[151].s = tdrpStrDup("LAG1_HC_PHASE");
      tt->struct_vals[152].s = tdrpStrDup("deg");
      tt->struct_vals[153].d = 0.006;
      tt->struct_vals[154].d = -190;
      tt->struct_vals[155].e = LAG1_VC_DB;
      tt->struct_vals[156].s = tdrpStrDup("LAG1_VC_DB");
      tt->struct_vals[157].s = tdrpStrDup("dBm");
      tt->struct_vals[158].d = 0.005;
      tt->struct_vals[159].d = -160;
      tt->struct_vals[160].e = LAG1_VC_PHASE;
      tt->struct_vals[161].s = tdrpStrDup("LAG1_VC_PHASE");
      tt->struct_vals[162].s = tdrpStrDup("deg");
      tt->struct_vals[163].d = 0.006;
      tt->struct_vals[164].d = -190;
      tt->struct_vals[165].e = LAG1_HCVC_DB;
      tt->struct_vals[166].s = tdrpStrDup("LAG1_HCVC_DB");
      tt->struct_vals[167].s = tdrpStrDup("dBm");
      tt->struct_vals[168].d = 0.005;
      tt->struct_vals[169].d = -160;
      tt->struct_vals[170].e = LAG1_HCVC_PHASE;
      tt->struct_vals[171].s = tdrpStrDup("LAG1_HCVC_PHASE");
      tt->struct_vals[172].s = tdrpStrDup("deg");
      tt->struct_vals[173].d = 0.006;
      tt->struct_vals[174].d = -190;
      tt->struct_vals[175].e = LAG1_VCHC_DB;
      tt->struct_vals[176].s = tdrpStrDup("LAG1_VCHC_DB");
      tt->struct_vals[177].s = tdrpStrDup("dBm");
      tt->struct_vals[178].d = 0.005;
      tt->struct_vals[179].d = -160;
      tt->struct_vals[180].e = LAG1_VCHC_PHASE;
      tt->struct_vals[181].s = tdrpStrDup("LAG1_VCHC_PHASE");
      tt->struct_vals[182].s = tdrpStrDup("deg");
      tt->struct_vals[183].d = 0.006;
      tt->struct_vals[184].d = -190;
      tt->struct_vals[185].e = LAG1_VXHX_DB;
      tt->struct_vals[186].s = tdrpStrDup("LAG1_VXHX_DB");
      tt->struct_vals[187].s = tdrpStrDup("dBm");
      tt->struct_vals[188].d = 0.005;
      tt->struct_vals[189].d = -160;
      tt->struct_vals[190].e = LAG1_VXHX_PHASE;
      tt->struct_vals[191].s = tdrpStrDup("LAG1_VXHX_PHASE");
      tt->struct_vals[192].s = tdrpStrDup("deg");
      tt->struct_vals[193].d = 0.006;
      tt->struct_vals[194].d = -190;
      tt->struct_vals[195].e = LAG2_HC_DB;
      tt->struct_vals[196].s = tdrpStrDup("LAG2_HC_DB");
      tt->struct_vals[197].s = tdrpStrDup("dBm");
      tt->struct_vals[198].d = 0.005;
      tt->struct_vals[199].d = -160;
      tt->struct_vals[200].e = LAG2_HC_PHASE;
      tt->struct_vals[201].s = tdrpStrDup("LAG2_HC_PHASE");
      tt->struct_vals[202].s = tdrpStrDup("deg");
      tt->struct_vals[203].d = 0.006;
      tt->struct_vals[204].d = -190;
      tt->struct_vals[205].e = LAG2_VC_DB;
      tt->struct_vals[206].s = tdrpStrDup("LAG2_VC_DB");
      tt->struct_vals[207].s = tdrpStrDup("dBm");
      tt->struct_vals[208].d = 0.005;
      tt->struct_vals[209].d = -160;
      tt->struct_vals[210].e = LAG2_VC_PHASE;
      tt->struct_vals[211].s = tdrpStrDup("LAG2_VC_PHASE");
      tt->struct_vals[212].s = tdrpStrDup("deg");
      tt->struct_vals[213].d = 0.006;
      tt->struct_vals[214].d = -190;
      tt->struct_vals[215].e = LAG3_HC_DB;
      tt->struct_vals[216].s = tdrpStrDup("LAG3_HC_DB");
      tt->struct_vals[217].s = tdrpStrDup("dBm");
      tt->struct_vals[218].d = 0.005;
      tt->struct_vals[219].d = -160;
      tt->struct_vals[220].e = LAG3_HC_PHASE;
      tt->struct_vals[221].s = tdrpStrDup("LAG3_HC_PHASE");
      tt->struct_vals[222].s = tdrpStrDup("deg");
      tt->struct_vals[223].d = 0.006;
      tt->struct_vals[224].d = -190;
      tt->struct_vals[225].e = LAG3_VC_DB;
      tt->struct_vals[226].s = tdrpStrDup("LAG3_VC_DB");
      tt->struct_vals[227].s = tdrpStrDup("dBm");
      tt->struct_vals[228].d = 0.005;
      tt->struct_vals[229].d = -160;
      tt->struct_vals[230].e = LAG3_VC_PHASE;
      tt->struct_vals[231].s = tdrpStrDup("LAG3_VC_PHASE");
      tt->struct_vals[232].s = tdrpStrDup("deg");
      tt->struct_vals[233].d = 0.006;
      tt->struct_vals[234].d = -190;
      tt->struct_vals[235].e = RVVHH0_DB;
      tt->struct_vals[236].s = tdrpStrDup("RVVHH0_DB");
      tt->struct_vals[237].s = tdrpStrDup("dBm");
      tt->struct_vals[238].d = 0.005;
      tt->struct_vals[239].d = -160;
      tt->struct_vals[240].e = RVVHH0_PHASE;
      tt->struct_vals[241].s = tdrpStrDup("RVVHH0_PHASE");
      tt->struct_vals[242].s = tdrpStrDup("deg");
      tt->struct_vals[243].d = 0.006;
      tt->struct_vals[244].d = -190;
      tt->struct_vals[245].e = SDEV_VV;
      tt->struct_vals[246].s = tdrpStrDup("SDEV_VV");
      tt->struct_vals[247].s = tdrpStrDup("dBm");
      tt->struct_vals[248].d = 0.01;
      tt->struct_vals[249].d = -320;
    tt++;
    
    // Parameter 'data_mapper_report_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("data_mapper_report_interval");
    tt->descr = tdrpStrDup("Number of seconds between reports to DataMapper.");
    tt->help = tdrpStrDup("If > 0, the program will register with the DataMapper when the output FMQ is written to. If <= 0, registration will not be performed.");
    tt->val_offset = (char *) &data_mapper_report_interval - &_start_;
    tt->is_private = TRUE;
    tt->single_val.i = 5;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
