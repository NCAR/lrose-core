//////////////////////////////////////////////////////////////////////
// parameter definitions ConvStrat
//
// Mike Dixon, EOL, NCAR,
// P.O.Box 3000, Boulder, CO, USA, 80307-3000
//
// June 2014
//////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "Program name: ConvStrat";
  p_text = "ConvStrat finds convective and stratiform regions within a Cartesian radar volume.";
}

commentdef {
  p_header = "PROCESS CONTROL";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef string {
  p_default = "test";
  p_descr = "Process instance";
  p_help = "Used for registration with procmap.";
} instance;

typedef enum {
  ARCHIVE, REALTIME, FILELIST
} mode_t;

paramdef enum mode_t {
  p_default = ARCHIVE;
  p_descr = "Operating mode";
  p_help = "In REALTIME mode, the program waits for a new input file. In ARCHIVE mode, it moves through the data between the start and end times set on the command line. In FILELIST mode, it moves through the list of file names specified on the command line.";
} mode;

commentdef {
  p_header = "DATA INPUT";
}

paramdef string {
  p_default = "mdv/input";
  p_descr = "URL for input data.";
  p_help = "This is used in REALTIME and ARCHIVE modes only. In FILELIST mode, the file paths are specified on the command line.";
} input_url;

paramdef string {
  p_default = "DBZ";
  p_descr = "dBZ field name in input MDV files.";
} dbz_field_name;

commentdef {
  p_header = "SPECIFYING VERTICAL LEVELS - TEMPERAURE or HEIGHT?";
  p_text = "We need to specify the vertical separation between shallow, mid-level and high clouds. We use the freezing level to separate warm clouds and cold clouds. And we use the divergence level to separate the mid-level clouds from high-level clouds such as anvil. These vertical limits can be specified as heights MSL (in km), or as temperatures. If temperatures are used, we read in the temperature profile from a model.";
}

typedef enum {
  VERT_LEVELS_BY_TEMP,
  VERT_LEVELS_BY_HT
} vert_levels_type_t;

paramdef enum vert_levels_type_t {
  p_default = VERT_LEVELS_BY_HT;
  p_descr = "How we specify the vertical levels.";
  p_help = "If temperatures are used, we need to read in the temperature profile from a model.";
} vert_levels_type;

paramdef string {
  p_default = "mdv/model";
  p_descr = "URL for temperature profile data, in MDV/Netcdf-CF format.";
  p_help = "We read in the model data that is closest in time to the reflectivity data.";
} temp_profile_url;

paramdef string {
  p_default = "Temp";
  p_descr = "Name of temperature field in the model data. This should be in degrees C.";
} temp_profile_field_name;

paramdef int {
  p_default = 21600;
  p_descr = "Search margin for finding the temp profile data (secs).";	
  p_help = "The temp profile must be within this number of seconds of the dbz data.";
} temp_profile_search_margin;

paramdef double {
  p_default = 4.5;
  p_descr = "Shallow cloud height threshold (km).";	
  p_help = "Shallow cloud tops are below this height. Used if vert_levels_type = VERT_LEVELS_BY_HT.";
} shallow_threshold_ht;

paramdef double {
  p_default = 0.0;
  p_descr = "Shallow cloud temperature threshold (degC).";	
  p_help = "Shallow cloud tops are below this temperature. Used if vert_levels_type = VERT_LEVELS_BY_TEMP.";
} shallow_threshold_temp;

paramdef double {
  p_default = 8.0;
  p_descr = "Deep cloud height threshold (km).";	
  p_help = "Deep clouds extend above this height. Used if vert_levels_type = VERT_LEVELS_BY_HT.";
} deep_threshold_ht;

paramdef double {
  p_default = -12.0;
  p_descr = "Deep cloud temperature threshold (degC).";	
  p_help = "Deep clouds extend above this height. Used if vert_levels_type = VERT_LEVELS_BY_TEMP.";
} deep_threshold_temp;

commentdef {
  p_header = "ALGORITHM PARAMETERS";
}

paramdef double {
  p_default = 0.0;
  p_descr = "Min height used in analysis (km).";	
  p_help = "Only data at or above this altitude is used.";
} min_valid_height;

paramdef double {
  p_default = 25.0;
  p_descr = "Max height used in analysis (km).";	
  p_help = "Only data at or below this altitude is used.";
} max_valid_height;

paramdef double {
  p_default = 0.0;
  p_descr = "Minimum reflectivity threshold for this analysis (dBZ).";
  p_help = "Reflectivity below this threshold is set to missing.";
} min_valid_dbz;

paramdef double {
  p_default = 30.0;
  p_descr = "Min volume of a convective region (km3).";	
  p_help = "Regions of smaller volume will be labeled SMALL.";
} min_valid_volume_for_convective;

paramdef double {
  p_default = 1.0;
  p_descr = "Min vertical echo extent of a convective region (km).";	
  p_help = "The vertical extent is computed as the mid height of the top layer in the echo minus the mid height of the bottom layer. For an echo that exists in only one layer, the vertical extent would therefore be zero. This parameter lets us require that a valid convective echo exist in multiple layers, which is desirable and helps to remove spurious echoes as candidates for convection.";
} min_vert_extent_for_convective;

paramdef double {
  p_default = 18;
  p_descr = "Reflectivity for determing echo tops.";
  p_help = "Echo tops are defined as the max ht with reflectivity at or above this value.";
} dbz_for_echo_tops;

commentdef {
  p_header = "COMPUTING REFLECTIVITY TEXTURE";
}

paramdef double {
  p_default = 7.0;
  p_descr = "Radius for texture analysis (km).";
  p_help = "We determine the reflectivity 'texture' at a point by computing the standard deviation of the square of the reflectivity, for all grid points within this radius of the central point. We then compute the square root of that sdev.";
} texture_radius_km;

paramdef double {
  p_default = 0.25;
  p_descr = "Minimum fraction of surrounding points for texture computations.";
  p_help = "For a valid computation of texture, we require at least this fraction of points around the central point to have valid reflectivity.";
} min_valid_fraction_for_texture;

paramdef double {
  p_default = 0.67;
  p_descr = "Minimum fraction of surrounding points for 2D fit to DBZ.";
  p_help = "We compute a 2D fit to the reflectivity around a grid point, to remove any systematic gradient. For a valid fit, we require at least this fraction of points around the central point to have valid reflectivity.";
} min_valid_fraction_for_fit;

commentdef {
  p_header = "CONVERTING REFLECTIVITY TEXTURE TO CONVECTIVITY";
  p_text = "Convectivity ranges from 0 to 1. To convert texture to convectivity, we apply a piece-wise linear transfer function. This section defines the lower texture limit and the upper texture limit. At or below the lower limit convectivity is set to 0. At or above the upper limit convectivity is set to 1. Between these two limits convectivity varies linearly with texture.";
}

paramdef double {
  p_default = 0.0;
  p_descr = "Lower limit for texture.";
  p_help = "Below this texture the convectivity is set to 0.";
} texture_limit_low;

paramdef double {
  p_default = 30.0;
  p_descr = "Upper limit for texture.";
  p_help = "Above this texture the convectivity is set to 1. Between the limits convectivity varies linearly with texture.";
} texture_limit_high;

commentdef {
  p_header = "SETTING CONVECTIVE OR STRATIFORM FLAGS BASED ON CONVECTIVITY";
  p_text = "If neither is set, we flag the point as MIXED.";
}

paramdef double {
  p_default = 0.5;
  p_descr = "Minimum convectivity for convective at a point.";
  p_help = "If the convectivity at a point exceeds this value, we set the convective flag at this point.";
} min_convectivity_for_convective;

paramdef double {
  p_default = 0.4;
  p_descr = "Maximum convectivity for stratiform at a point.";
  p_help = "If the convectivity at a point is less than this value, we set the stratiform flag at this point. If it is above this but less than min_convectivity_for_convective we flag the point as MIXED.";
} max_convectivity_for_stratiform;

paramdef int {
  p_default = 1;
  p_descr = "Minimum grid overlap in convective regions.";
  p_help = "A convective region is identified as a series of adjacent 'runs' of grid cells data in the EW direction. When testing for overlap, some minimum number of overlap grids must be used. This is that minimum overlap in grid units.";
} min_overlap_for_convective_clumps;

commentdef {
  p_header = "OPTIONS TO USE DUAL THRESHOLDS.";
}

paramdef boolean {
  p_default = TRUE;
  p_descr = "Option to use dual thresholds to identify convective clumps.";
  p_help = "NOTE: this step is performed in 2D. If set, the identification is performed in multiple stages. First, an outer convectivity envelope is computed, using min_convectivity_for_convective. This is the default method. Then, using the dual_threshold parameters, a search is performed for clumps within the envelope exceeding the min convectivity threshold. If there is only one region at the higher convectivity, the entire outer envelope is used. If there are two or more regions which meet or exceed the required characteristics, these regions are grown back out to the original envelope, but stop growing where they meet between the higher-convectivity areas. The final clumps are computed by breaking the original clump into regions based upon these secondary areas.";
} use_dual_thresholds;

typedef struct {
  double secondary_threshold;
  double min_fraction_all_parts;
  double min_fraction_each_part;
  double min_size_each_part;
} dual_threshold_t;

paramdef struct dual_threshold_t {
  p_default = { 0.65, 0.33, 0.02, 2.0 };
  p_descr = "Parameters for dual threshold identification. Performed in 2D.";
  p_help = "See 'use_dual_thresholds'. secondary_threshold: convectivity threshold for this stage. A number of regions may be identified at the higher threshold. min_fraction_all_parts: we sum the sizes of the parts at the higher threshold, and the sum divided by the original size of the envelope must exceed this fraction. If it does not the original envelope is used. min_fraction_each_part: for any part to be valid its size as a fraction of all of the parts must exceed this value. min_size_each_part: for any part to be valid its area must exceed this value. If it does not the part is ignored. If only 1 part is valid, the entire envelope is used.";
} dual_threshold;

commentdef {
  p_header = "DATA OUTPUT";
}

paramdef string {
  p_default = "mdv/stratiform";
  p_descr = "Output URL.";
  p_help = "Output files are written to this URL.";
} output_url;

paramdef boolean {
  p_default = true;
  p_descr = "Write out partition fields.";
  p_help = "This will write out the 3D, 2D and column-max partition.";
} write_partition;

paramdef boolean {
  p_default = true;
  p_descr = "Write out texture fields.";
  p_help = "This will write out the 3D and column-max texture.";
} write_texture;

paramdef boolean {
  p_default = true;
  p_descr = "Write out convectivity fields.";
  p_help = "This will write out the 3D and column-max convectivity.";
} write_convectivity;

paramdef boolean {
  p_default = true;
  p_descr = "Write out 3D dbz field.";
  p_help = "This will be an echo of the input field.";
} write_3D_dbz;

paramdef boolean {
  p_default = true;
  p_descr = "Write out convective dbz field.";
  p_help = "This will write out the 3D convective DBZ field.";
} write_convective_dbz;

paramdef boolean {
  p_default = true;
  p_descr = "Write out column maximum dbz field.";
  p_help = "This is the max reflectivity at any height.";
} write_col_max_dbz;

paramdef boolean {
  p_default = true;
  p_descr = "Write out echo, convective and stratiform tops.";
  p_help = "These are 2D fields.";
} write_tops;

paramdef boolean {
  p_default = true;
  p_descr = "Write out 2D field showing fraction active.";
  p_help = "This the active fraction in the computational circle.";
} write_fraction_active;

paramdef boolean {
  p_default = true;
  p_descr = "Write out 2D field showing shallow and deep heights.";
  p_help = "These are based on model temperature.";
} write_height_grids;

paramdef boolean {
  p_default = true;
  p_descr = "Write out 3D temperature field.";
  p_help = "This comes from a model, remapped onto the reflectivity grid.";
} write_temperature;

