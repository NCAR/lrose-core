// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 1992 - 2016
// ** University Corporation for Atmospheric Research(UCAR)
// ** National Center for Atmospheric Research(NCAR)
// ** Boulder, Colorado, USA
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program SunCal
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("SunCal analyses data from tsarchive time series files taken during sun scans.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'register_with_procmap'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("register_with_procmap");
    tt->descr = tdrpStrDup("Option to register with the process mapper.");
    tt->help = tdrpStrDup("If true, this application will try to register with procmap once per minute. (If unable to do so, no error occurs.)");
    tt->val_offset = (char *) &register_with_procmap - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_mode'
    // ctype is '_input_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("input_mode");
    tt->descr = tdrpStrDup("Input mode - files or time series API.");
    tt->help = tdrpStrDup("\n\nTS_FMQ_INPUT: the application will read the time series from a file message queue and process the pulses as they come in. \n\nTS_FILE_INPUT: the application will process all the files specified on the command line. \n\nTS_REALTIME_DIR_INPUT: the application will watch the input directory for new files, and will process those files as they arrive. This mode is suitable for automated operation. \n\nMOMENTS_REALTIME_INPUT: watch the input directory for new moments files, and process each volume as it arrives. \n\nMOMENTS_ARCHIVE_INPUT: will process the moments files in the input directory, between the start and end times. \n\nMOMENTS_FILELIST_INPUT: will process the moments files listed on the command line. ");
    tt->val_offset = (char *) &input_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("input_mode_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("TS_FILELIST_INPUT");
      tt->enum_def.fields[0].val = TS_FILELIST_INPUT;
      tt->enum_def.fields[1].name = tdrpStrDup("TS_FMQ_INPUT");
      tt->enum_def.fields[1].val = TS_FMQ_INPUT;
      tt->enum_def.fields[2].name = tdrpStrDup("TS_REALTIME_DIR_INPUT");
      tt->enum_def.fields[2].val = TS_REALTIME_DIR_INPUT;
      tt->enum_def.fields[3].name = tdrpStrDup("MOMENTS_REALTIME_INPUT");
      tt->enum_def.fields[3].val = MOMENTS_REALTIME_INPUT;
      tt->enum_def.fields[4].name = tdrpStrDup("MOMENTS_ARCHIVE_INPUT");
      tt->enum_def.fields[4].val = MOMENTS_ARCHIVE_INPUT;
      tt->enum_def.fields[5].name = tdrpStrDup("MOMENTS_FILELIST_INPUT");
      tt->enum_def.fields[5].val = MOMENTS_FILELIST_INPUT;
    tt->single_val.e = TS_FILELIST_INPUT;
    tt++;
    
    // Parameter 'input_fmq_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_name");
    tt->descr = tdrpStrDup("FMQ name. For TS_FMQ_INPUT only.");
    tt->help = tdrpStrDup("Path to FMQ files. There are 2 files, one with a .buf extension and one with a .stat extention. This path does not include the extensions.");
    tt->val_offset = (char *) &input_fmq_name - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/fmq/ts");
    tt++;
    
    // Parameter 'input_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir");
    tt->descr = tdrpStrDup("Directory to watch for incoming files.");
    tt->help = tdrpStrDup("Applies to TS_REALTIME_DIR_INPUT mode only. This is the directory path for sunscan time series files. As files arrive in the directory, the application will read them in and process them.");
    tt->val_offset = (char *) &input_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/data/time_series/suncal");
    tt++;
    
    // Parameter 'archive_start_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("archive_start_time");
    tt->descr = tdrpStrDup("Specify the start time for the files in archive mode.");
    tt->help = tdrpStrDup("Format is 'yyyy mm dd hh mm ss'. Applies to MOMENTS_ARCHIVE_INPUT mode.");
    tt->val_offset = (char *) &archive_start_time - &_start_;
    tt->single_val.s = tdrpStrDup("2012 06 01 00 00 00");
    tt++;
    
    // Parameter 'archive_end_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("archive_end_time");
    tt->descr = tdrpStrDup("Specify the end time for the files in archive mode.");
    tt->help = tdrpStrDup("Format is 'yyyy mm dd hh mm ss'. Applies to MOMENTS_ARCHIVE_INPUT mode.");
    tt->val_offset = (char *) &archive_end_time - &_start_;
    tt->single_val.s = tdrpStrDup("2012 06 02 00 00 00");
    tt++;
    
    // Parameter 'n_samples'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_samples");
    tt->descr = tdrpStrDup("Number of pulse samples in a beam.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &n_samples - &_start_;
    tt->single_val.i = 128;
    tt++;
    
    // Parameter 'start_gate'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("start_gate");
    tt->descr = tdrpStrDup("Start gate for analysis.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &start_gate - &_start_;
    tt->single_val.i = 50;
    tt++;
    
    // Parameter 'n_gates'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_gates");
    tt->descr = tdrpStrDup("Number of gates for analysis.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &n_gates - &_start_;
    tt->single_val.i = 500;
    tt++;
    
    // Parameter 'alternating_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("alternating_mode");
    tt->descr = tdrpStrDup("Does this system transmit alternating H and V pulses.");
    tt->help = tdrpStrDup("In some dual-polarization radars, the transmitter toggles between H and V transmit. Although this does not affect sun measurements directly, it does affect how the data is handled in the receiver chain.");
    tt->val_offset = (char *) &alternating_mode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'switching_receiver'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("switching_receiver");
    tt->descr = tdrpStrDup("Does the receiver path switch between each pulse.");
    tt->help = tdrpStrDup("In some alternating mode radars, the receiver chain switches between pulses. This is done to create a co-polar and cross-polar receiver system which is more stable for ZDR. If this is set to TRUE, then the receiver is assumed to switch and the data for each channel is gathered accordingly. NOTE - this only applies in alternating mode.");
    tt->val_offset = (char *) &switching_receiver - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'invert_hv_flag'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("invert_hv_flag");
    tt->descr = tdrpStrDup("Option to invert H/V flag in pulse data.");
    tt->help = tdrpStrDup("Only applies to alternating dual polarization mode. Normally, the HV flag is set to 1 for H, 0 for V. If the flag in the data has the opposite sense, set this to true.");
    tt->val_offset = (char *) &invert_hv_flag - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'print_missing_pulses'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("print_missing_pulses");
    tt->descr = tdrpStrDup("Option to print message about missing pulses.");
    tt->help = tdrpStrDup("Only applies to time series data input. If true, a message will be printed to stderr if a missing pulse is noted in the time series.");
    tt->val_offset = (char *) &print_missing_pulses - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("FIELD NAMES FOR MOMENTS FILES");
    tt->comment_text = tdrpStrDup("Names of specified fields in the moments files.");
    tt++;
    
    // Parameter 'moments_field_names'
    // ctype is '_moments_field_names_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("moments_field_names");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &moments_field_names - &_start_;
    tt->struct_def.name = tdrpStrDup("moments_field_names_t");
    tt->struct_def.nfields = 14;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("DBMHC");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &moments_field_names.DBMHC - (char *) &moments_field_names;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("DBMVC");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &moments_field_names.DBMVC - (char *) &moments_field_names;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("DBMHX");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &moments_field_names.DBMHX - (char *) &moments_field_names;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("DBMVX");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &moments_field_names.DBMVX - (char *) &moments_field_names;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("ZDR");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &moments_field_names.ZDR - (char *) &moments_field_names;
      tt->struct_def.fields[5].ftype = tdrpStrDup("string");
      tt->struct_def.fields[5].fname = tdrpStrDup("PHIDP");
      tt->struct_def.fields[5].ptype = STRING_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &moments_field_names.PHIDP - (char *) &moments_field_names;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("RHOHV");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &moments_field_names.RHOHV - (char *) &moments_field_names;
      tt->struct_def.fields[7].ftype = tdrpStrDup("string");
      tt->struct_def.fields[7].fname = tdrpStrDup("NCP");
      tt->struct_def.fields[7].ptype = STRING_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &moments_field_names.NCP - (char *) &moments_field_names;
      tt->struct_def.fields[8].ftype = tdrpStrDup("string");
      tt->struct_def.fields[8].fname = tdrpStrDup("LAG1_HC_DB");
      tt->struct_def.fields[8].ptype = STRING_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &moments_field_names.LAG1_HC_DB - (char *) &moments_field_names;
      tt->struct_def.fields[9].ftype = tdrpStrDup("string");
      tt->struct_def.fields[9].fname = tdrpStrDup("LAG1_HC_PHASE");
      tt->struct_def.fields[9].ptype = STRING_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &moments_field_names.LAG1_HC_PHASE - (char *) &moments_field_names;
      tt->struct_def.fields[10].ftype = tdrpStrDup("string");
      tt->struct_def.fields[10].fname = tdrpStrDup("LAG1_VC_DB");
      tt->struct_def.fields[10].ptype = STRING_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &moments_field_names.LAG1_VC_DB - (char *) &moments_field_names;
      tt->struct_def.fields[11].ftype = tdrpStrDup("string");
      tt->struct_def.fields[11].fname = tdrpStrDup("LAG1_VC_PHASE");
      tt->struct_def.fields[11].ptype = STRING_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &moments_field_names.LAG1_VC_PHASE - (char *) &moments_field_names;
      tt->struct_def.fields[12].ftype = tdrpStrDup("string");
      tt->struct_def.fields[12].fname = tdrpStrDup("RVVHH0_DB");
      tt->struct_def.fields[12].ptype = STRING_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &moments_field_names.RVVHH0_DB - (char *) &moments_field_names;
      tt->struct_def.fields[13].ftype = tdrpStrDup("string");
      tt->struct_def.fields[13].fname = tdrpStrDup("RVVHH0_PHASE");
      tt->struct_def.fields[13].ptype = STRING_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &moments_field_names.RVVHH0_PHASE - (char *) &moments_field_names;
    tt->n_struct_vals = 14;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBMHC");
      tt->struct_vals[1].s = tdrpStrDup("DBMVC");
      tt->struct_vals[2].s = tdrpStrDup("DBMHX");
      tt->struct_vals[3].s = tdrpStrDup("DBMVX");
      tt->struct_vals[4].s = tdrpStrDup("ZDR");
      tt->struct_vals[5].s = tdrpStrDup("PHIDP");
      tt->struct_vals[6].s = tdrpStrDup("RHOHV");
      tt->struct_vals[7].s = tdrpStrDup("NCP");
      tt->struct_vals[8].s = tdrpStrDup("LAG1_HC_DB");
      tt->struct_vals[9].s = tdrpStrDup("LAG1_HC_PHASE");
      tt->struct_vals[10].s = tdrpStrDup("LAG1_VC_DB");
      tt->struct_vals[11].s = tdrpStrDup("LAG1_VC_PHASE");
      tt->struct_vals[12].s = tdrpStrDup("RVVHH0_DB");
      tt->struct_vals[13].s = tdrpStrDup("RVVHH0_PHASE");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("VOLUME IDENTIFICATION OPTIONS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'scan_mode_rhi'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("scan_mode_rhi");
    tt->descr = tdrpStrDup("Scan mode is RHI instead of SECTOR.");
    tt->help = tdrpStrDup("Set to TRUE if the scan is in RHI mode and the RHI flag is not set in the pulse headers.");
    tt->val_offset = (char *) &scan_mode_rhi - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'analyze_individual_volumes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("analyze_individual_volumes");
    tt->descr = tdrpStrDup("Option to identify individual sun volumes for the analysis.");
    tt->help = tdrpStrDup("If false, all of the input data will be analyzed together. If true, the program will identify individual sun scans for analysis by monitoring the antenna elevation angle for a decrease which indicates that the volume is restarting. You have the option of including more than 1 volume in the analysis - see n_volumes_for_analysis.");
    tt->val_offset = (char *) &analyze_individual_volumes - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'n_volumes_for_analysis'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_volumes_for_analysis");
    tt->descr = tdrpStrDup("Number of consecutive volumes to be combined for each analysis. The program will go through all of the data grouping the volumes accordingly.");
    tt->help = tdrpStrDup("Applies if analyze_individual_volumes is true.");
    tt->val_offset = (char *) &n_volumes_for_analysis - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'min_n_volumes_for_analysis'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_n_volumes_for_analysis");
    tt->descr = tdrpStrDup("Minimum number of consecutive volumes to be included in the analysis.");
    tt->help = tdrpStrDup("The program checks for the number of available volumes. If it exceeds this number, the analysis is performed. If not, the data will be ignored.");
    tt->val_offset = (char *) &min_n_volumes_for_analysis - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'min_beams_per_volume'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_beams_per_volume");
    tt->descr = tdrpStrDup("Min number of beams per volume volume.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &min_beams_per_volume - &_start_;
    tt->single_val.i = 100;
    tt++;
    
    // Parameter 'max_beams_per_volume'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_beams_per_volume");
    tt->descr = tdrpStrDup("Max number of beams per volume volume.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &max_beams_per_volume - &_start_;
    tt->single_val.i = 20000;
    tt++;
    
    // Parameter 'check_for_elevation_change'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_for_elevation_change");
    tt->descr = tdrpStrDup("Option to identify end of volumes by elevation change.");
    tt->help = tdrpStrDup("If true, the antenna elevation will be checked. If it changes by a significant amount, an end of volume is likely. See 'elev_change_for_end_of_volume'. If false, the volume number will be checked for changes.");
    tt->val_offset = (char *) &check_for_elevation_change - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'elev_change_for_end_of_volume'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_change_for_end_of_volume");
    tt->descr = tdrpStrDup("Minimum delta elevation to indicate end of volume (deg).");
    tt->help = tdrpStrDup("At the end of a volume, the elevation angle will be reset to the starting angle. When this happens the program can detect the end of volume by the rapid change in elevation angle. This is the minimum angular change to signal and end of volume.");
    tt->val_offset = (char *) &elev_change_for_end_of_volume - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'volume_starts_at_bottom'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("volume_starts_at_bottom");
    tt->descr = tdrpStrDup("Volume starts at lowest elevation angle and moves upwards.");
    tt->help = tdrpStrDup("If false, volume starts at top and moves downwards.");
    tt->val_offset = (char *) &volume_starts_at_bottom - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'max_time_gap_within_volume'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_time_gap_within_volume");
    tt->descr = tdrpStrDup("Max time gap within a volume (secs).");
    tt->help = tdrpStrDup("If the time between pulses exceeds this value, the current analysis will be terminated and a new analysis begun.");
    tt->val_offset = (char *) &max_time_gap_within_volume - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'max_pointing_angle_error_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_pointing_angle_error_deg");
    tt->descr = tdrpStrDup("Max error in pointing angle for valid data (deg).");
    tt->help = tdrpStrDup("We discard data when the pointing angle differs from the commanded fixed angle by greater than this amount.");
    tt->val_offset = (char *) &max_pointing_angle_error_deg - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("RADAR NAME AND LOCATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'radar_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_name");
    tt->descr = tdrpStrDup("Name of radar");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_name - &_start_;
    tt->single_val.s = tdrpStrDup("SPOL");
    tt++;
    
    // Parameter 'radar_site'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_site");
    tt->descr = tdrpStrDup("Site of radar");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_site - &_start_;
    tt->single_val.s = tdrpStrDup("MARSHALL");
    tt++;
    
    // Parameter 'get_location_from_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("get_location_from_data");
    tt->descr = tdrpStrDup("Option to read the latitude and longitude from the time series data.");
    tt->help = tdrpStrDup("If false, the values specified in this file will be used.");
    tt->val_offset = (char *) &get_location_from_data - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_lat");
    tt->descr = tdrpStrDup("Latitude of radar location (deg).");
    tt->help = tdrpStrDup("North is positive, South is negative.");
    tt->val_offset = (char *) &radar_lat - &_start_;
    tt->single_val.d = 39.9502;
    tt++;
    
    // Parameter 'radar_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_lon");
    tt->descr = tdrpStrDup("Longitude of radar location (deg).");
    tt->help = tdrpStrDup("East is positive, West is negative.");
    tt->val_offset = (char *) &radar_lon - &_start_;
    tt->single_val.d = -105.195;
    tt++;
    
    // Parameter 'radar_alt_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_alt_km");
    tt->descr = tdrpStrDup("Altitude of radar (km).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_alt_km - &_start_;
    tt->single_val.d = 1.742;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("FIXED TARGET LOCATION");
    tt->comment_text = tdrpStrDup("Optionally you can perform the analysis for a fixed target location, instead of the moving sun.");
    tt++;
    
    // Parameter 'specify_fixed_target_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("specify_fixed_target_location");
    tt->descr = tdrpStrDup("Option to analyze the grid based on a fixed target location.");
    tt->help = tdrpStrDup("This location is used instead of computing the location of the sun. This is useful for calibration using a target such as a sphere.");
    tt->val_offset = (char *) &specify_fixed_target_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'target_elevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("target_elevation");
    tt->descr = tdrpStrDup("Elevation angle for target (deg).");
    tt->help = tdrpStrDup("See 'specify_fixed_target_location'.");
    tt->val_offset = (char *) &target_elevation - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'target_azimuth'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("target_azimuth");
    tt->descr = tdrpStrDup("Azimuth angle for target (deg).");
    tt->help = tdrpStrDup("See 'specify_fixed_target_location'.");
    tt->val_offset = (char *) &target_azimuth - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("GRID DETAILS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'grid_min_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_min_az");
    tt->descr = tdrpStrDup("Min azimiuth for the grid (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &grid_min_az - &_start_;
    tt->single_val.d = -5;
    tt++;
    
    // Parameter 'grid_max_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_max_az");
    tt->descr = tdrpStrDup("Max azimiuth for the grid (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &grid_max_az - &_start_;
    tt->single_val.d = 5;
    tt++;
    
    // Parameter 'grid_delta_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_delta_az");
    tt->descr = tdrpStrDup("Resolution of regular grid in azimuth (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &grid_delta_az - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'grid_min_el'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_min_el");
    tt->descr = tdrpStrDup("Min elevation for the grid (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &grid_min_el - &_start_;
    tt->single_val.d = -2;
    tt++;
    
    // Parameter 'grid_max_el'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_max_el");
    tt->descr = tdrpStrDup("Max elevation for the grid (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &grid_max_el - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'grid_delta_el'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_delta_el");
    tt->descr = tdrpStrDup("Resolution of regular grid in elevation (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &grid_delta_el - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("NOISE CORRECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'correct_powers_for_noise'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("correct_powers_for_noise");
    tt->descr = tdrpStrDup("Option to subtract noise from powers.");
    tt->help = tdrpStrDup("If true, the noise power is subtracted from the received power.");
    tt->val_offset = (char *) &correct_powers_for_noise - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'noise_method'
    // ctype is '_noise_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("noise_method");
    tt->descr = tdrpStrDup("Method for determining the noise, if noise correction is needed.");
    tt->help = tdrpStrDup("GET_NOISE_FROM_CAL_FILE: read the noise values from the XML file specified in the parameter 'cal_xml_file_path'. GET_NOISE_FROM_TIME_SERIES: some data streams have noise values in the time series. - e.g. SIGMET tsarchive. COMPUTE_MEAN_NOISE: compute the mean noise from data which is away from the sun. See 'min_angle_offset_for_noise_power. COMPUTE_MN_NOISE: compute the minimum noise from data which is away from the sun. See 'min_angle_offset_for_noise_power. ");
    tt->val_offset = (char *) &noise_method - &_start_;
    tt->enum_def.name = tdrpStrDup("noise_method_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("GET_NOISE_FROM_CAL_FILE");
      tt->enum_def.fields[0].val = GET_NOISE_FROM_CAL_FILE;
      tt->enum_def.fields[1].name = tdrpStrDup("GET_NOISE_FROM_TIME_SERIES");
      tt->enum_def.fields[1].val = GET_NOISE_FROM_TIME_SERIES;
      tt->enum_def.fields[2].name = tdrpStrDup("COMPUTE_MEAN_NOISE");
      tt->enum_def.fields[2].val = COMPUTE_MEAN_NOISE;
      tt->enum_def.fields[3].name = tdrpStrDup("COMPUTE_MIN_NOISE");
      tt->enum_def.fields[3].val = COMPUTE_MIN_NOISE;
    tt->single_val.e = GET_NOISE_FROM_CAL_FILE;
    tt++;
    
    // Parameter 'min_angle_offset_for_noise_power'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_angle_offset_for_noise_power");
    tt->descr = tdrpStrDup("Min angle from sun center for noise power (deg).");
    tt->help = tdrpStrDup("The noise will be computed as the mean of power from beams outside this angular offset.");
    tt->val_offset = (char *) &min_angle_offset_for_noise_power - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'cal_xml_file_path'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("cal_xml_file_path");
    tt->descr = tdrpStrDup("Path for XML calibration file.");
    tt->help = tdrpStrDup("At a minimum, the calibration file should contain noiseDbm values for each channel.");
    tt->val_offset = (char *) &cal_xml_file_path - &_start_;
    tt->single_val.s = tdrpStrDup("./spol_cal.xml");
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("INTERFERENCE REMOVAL FOR SUN CENTROID");
    tt->comment_text = tdrpStrDup("Option to set a maximum sun power, so that we can filter out high power values which affect the computation of the sun centroid.");
    tt++;
    
    // Parameter 'set_max_sun_power'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_max_sun_power");
    tt->descr = tdrpStrDup("Option to set a maximum acceptable power value.");
    tt->help = tdrpStrDup("If true, powers above this value will be set to -120 dBm.");
    tt->val_offset = (char *) &set_max_sun_power - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_valid_sun_power_dbm'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_valid_sun_power_dbm");
    tt->descr = tdrpStrDup("Max valid sun power value (dBm).");
    tt->help = tdrpStrDup("See 'set_max_power'.");
    tt->val_offset = (char *) &max_valid_sun_power_dbm - &_start_;
    tt->single_val.d = -60;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("COMPUTING CORRELATION OVER THE SUN DISK");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'max_solid_angle_for_mean_correlation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_solid_angle_for_mean_correlation");
    tt->descr = tdrpStrDup("Solid angle for computing mean correlation over sun disk (deg).");
    tt->help = tdrpStrDup("The mean correlation will be computed using grid points within this angle.");
    tt->val_offset = (char *) &max_solid_angle_for_mean_correlation - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("COMPUTING DIFFERENCE IN ELLIPSE POWER PATTERN BETWEEN H and V");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'compute_ellipse_hv_power_diffs'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_ellipse_hv_power_diffs");
    tt->descr = tdrpStrDup("Option to compute the power differences for the H and V ellipses.");
    tt->help = tdrpStrDup("The differences are computed along the centroid axes, covering the specified solid angle.");
    tt->val_offset = (char *) &compute_ellipse_hv_power_diffs - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'solid_angle_for_ellipse_power_diffs'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("solid_angle_for_ellipse_power_diffs");
    tt->descr = tdrpStrDup("Solid angle for computing ellipse power pattern diffs (deg).");
    tt->help = tdrpStrDup("We compute the mean power ratio between H and V, along the centroid-centered axes in elevation and azimuth. The difference between these gives a measure of the distortion in the ellipse shapes between H and V.");
    tt->val_offset = (char *) &solid_angle_for_ellipse_power_diffs - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("CROSS-POLAR POWER ANALYSIS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'sun_edge_below_peak_db'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sun_edge_below_peak_db");
    tt->descr = tdrpStrDup("Power of sun edge relative to the peak (dB).");
    tt->help = tdrpStrDup("The sun position is computed using the power at each point. Only powers within this margin of the peak power are used in the computations.");
    tt->val_offset = (char *) &sun_edge_below_peak_db - &_start_;
    tt->single_val.d = 8;
    tt++;
    
    // Parameter 'n_s1s2_ratios_computed'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_s1s2_ratios_computed");
    tt->descr = tdrpStrDup("Number of ratios computed for S1S2.");
    tt->help = tdrpStrDup("Each ratio is computed for a different solid angle.");
    tt->val_offset = (char *) &n_s1s2_ratios_computed - &_start_;
    tt->single_val.i = 4;
    tt++;
    
    // Parameter 'min_solid_angle_for_s1s2'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_solid_angle_for_s1s2");
    tt->descr = tdrpStrDup("Min solid angle over which to compute S1S2 mean (deg).");
    tt->help = tdrpStrDup("This is the min angle for computing S1S2. The angle is centered on the sun, and the mean ratio is computed over the entire angle. For example, if set to 1.0, all points in the grid within 0.5 degrees of the sun centroid will be used.");
    tt->val_offset = (char *) &min_solid_angle_for_s1s2 - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'delta_solid_angle_for_s1s2'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("delta_solid_angle_for_s1s2");
    tt->descr = tdrpStrDup("Delta solid angle over which to compute S1S2 mean (deg).");
    tt->help = tdrpStrDup("A number of ratios are computed for a range of solid angles. This is the delta between each solid angle.");
    tt->val_offset = (char *) &delta_solid_angle_for_s1s2 - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'solid_angle_for_zdr_bias'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("solid_angle_for_zdr_bias");
    tt->descr = tdrpStrDup("Solid angle for computing ZDR bias (deg).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &solid_angle_for_zdr_bias - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'npoints_power_ranking'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("npoints_power_ranking");
    tt->descr = tdrpStrDup("Number of grid points used to compute ratios using ranked powers.");
    tt->help = tdrpStrDup("In this method, the points in the grids are ranked, and a mean is computed using the top npoints_power_ranking points, after dropping the tops few points. See npoints_dropped_ranking");
    tt->val_offset = (char *) &npoints_power_ranking - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'compute_cross_polar_power_ratio'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_cross_polar_power_ratio");
    tt->descr = tdrpStrDup("Option to compute cross polar power ratio from side-lobe clutter.");
    tt->help = tdrpStrDup("If true, xpol ratio will be computed using data from specified gates. This is only applicable in alternating mode with the transmitter running.");
    tt->val_offset = (char *) &compute_cross_polar_power_ratio - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'cross_polar_start_gate'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_start_gate");
    tt->descr = tdrpStrDup("Start gate for cross-polar analysis.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cross_polar_start_gate - &_start_;
    tt->single_val.i = 50;
    tt++;
    
    // Parameter 'cross_polar_n_gates'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_n_gates");
    tt->descr = tdrpStrDup("Number of gates for cross-polar analysis.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cross_polar_n_gates - &_start_;
    tt->single_val.i = 500;
    tt++;
    
    // Parameter 'cross_polar_min_snr'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_min_snr");
    tt->descr = tdrpStrDup("Minimum SNR for cross-polar analysis (dB).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cross_polar_min_snr - &_start_;
    tt->single_val.d = 20;
    tt++;
    
    // Parameter 'cross_polar_max_snr'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_max_snr");
    tt->descr = tdrpStrDup("Maximum SNR for cross-polar analysis (dB).");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &cross_polar_max_snr - &_start_;
    tt->single_val.d = 60;
    tt++;
    
    // Parameter 'cross_polar_min_valid_ratio_db'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_min_valid_ratio_db");
    tt->descr = tdrpStrDup("Minimum valid Vx/Hx ratio (dB).");
    tt->help = tdrpStrDup("Sometimes, odd data leads to inappropriate ratios. This puts limits on the ratios to be used in the analysis.");
    tt->val_offset = (char *) &cross_polar_min_valid_ratio_db - &_start_;
    tt->single_val.d = -10;
    tt++;
    
    // Parameter 'cross_polar_max_valid_ratio_db'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_max_valid_ratio_db");
    tt->descr = tdrpStrDup("Maximum valid Vx/Hx ratio (dB).");
    tt->help = tdrpStrDup("Sometimes, odd data leads to inappropriate ratios. This puts limits on the ratios to be used in the analysis.");
    tt->val_offset = (char *) &cross_polar_max_valid_ratio_db - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'cross_polar_min_rho_vx_hx'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("cross_polar_min_rho_vx_hx");
    tt->descr = tdrpStrDup("Minimum valid Vx-Hx correlation (dB).");
    tt->help = tdrpStrDup("Sometimes, odd data leads to inappropriate ratios. This sets a minimum value for the correlation between vx and hx.");
    tt->val_offset = (char *) &cross_polar_min_rho_vx_hx - &_start_;
    tt->single_val.d = 0.97;
    tt++;
    
    // Parameter 'min_angle_offset_for_cross_pol_ratio'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_angle_offset_for_cross_pol_ratio");
    tt->descr = tdrpStrDup("Min angle offset from sun center for cross polar ratio (deg).");
    tt->help = tdrpStrDup("The ratio will be computed from beams outside this anglular offset.");
    tt->val_offset = (char *) &min_angle_offset_for_cross_pol_ratio - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("OPTION TO RETRIEVE XPOL RATIO from SPDB");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'read_xpol_ratio_from_spdb'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("read_xpol_ratio_from_spdb");
    tt->descr = tdrpStrDup("Option to read the cross-polar ratio from SPDB.");
    tt->help = tdrpStrDup("We can compute the x-polar ratio using the AltCpCompute app, which stores the results in SPDB. So, in addition to computing it from the sun scan data itself, we can retrieve the results from AltCpCompute and add that to the output for comparison purposes.");
    tt->val_offset = (char *) &read_xpol_ratio_from_spdb - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_xpol_ratio_from_spdb'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_xpol_ratio_from_spdb");
    tt->descr = tdrpStrDup("Option to use the the cross-polar ratio from SPDB instead of that computed from the solar.");
    tt->help = tdrpStrDup("With S1S2 from the solar, and the xpol ratio, we can compute ZDR bias. This option allows us to use the ratio retrieved from SPDB instead of the value computed from the solar scan itself.");
    tt->val_offset = (char *) &use_xpol_ratio_from_spdb - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'xpol_ratio_spdb_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("xpol_ratio_spdb_url");
    tt->descr = tdrpStrDup("URL for reading x-polar ratio from SPDB.");
    tt->help = tdrpStrDup("See 'get_xpol_ratio_from_spdb'.");
    tt->val_offset = (char *) &xpol_ratio_spdb_url - &_start_;
    tt->single_val.s = tdrpStrDup("spdb/xpol_ratio");
    tt++;
    
    // Parameter 'xpol_ratio_radar_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("xpol_ratio_radar_name");
    tt->descr = tdrpStrDup("Name of station for xpol ratio data.");
    tt->help = tdrpStrDup("If empty, we will use the closest data in time.");
    tt->val_offset = (char *) &xpol_ratio_radar_name - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'xpol_ratio_search_margin_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("xpol_ratio_search_margin_secs");
    tt->descr = tdrpStrDup("Search margin when finding xpol ratio (secs).");
    tt->help = tdrpStrDup("We search for the xpol ratio result closest in time to the radar volume. This is the search margin on either side of the sunscan time.");
    tt->val_offset = (char *) &xpol_ratio_search_margin_secs - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("OPTION TO RETRIEVE SITE TEMP from SPDB");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'read_site_temp_from_spdb'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("read_site_temp_from_spdb");
    tt->descr = tdrpStrDup("Option to read the site ambient temperature from SPDB.");
    tt->help = tdrpStrDup("It can be useful to check for dependency between the solar data, xpol ratio and temperature. This gives you the option of retrieving the temperature from SPDB and including it in the analysis.");
    tt->val_offset = (char *) &read_site_temp_from_spdb - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'site_temp_spdb_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("site_temp_spdb_url");
    tt->descr = tdrpStrDup("URL for reading temperature data from SPDB.");
    tt->help = tdrpStrDup("See 'get_temperature_from_spdb'.");
    tt->val_offset = (char *) &site_temp_spdb_url - &_start_;
    tt->single_val.s = tdrpStrDup("spdb/temperature");
    tt++;
    
    // Parameter 'site_temp_station_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("site_temp_station_name");
    tt->descr = tdrpStrDup("Name of station for site temp data.");
    tt->help = tdrpStrDup("If empty, we will use the closest data in time.");
    tt->val_offset = (char *) &site_temp_station_name - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'site_temp_data_type'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("site_temp_data_type");
    tt->descr = tdrpStrDup("Data type instead of station name.");
    tt->help = tdrpStrDup("If this is -1, site_temp_station_name is used. If not -1, this value is used instead of specifying the station name");
    tt->val_offset = (char *) &site_temp_data_type - &_start_;
    tt->single_val.i = -1;
    tt++;
    
    // Parameter 'site_temp_search_margin_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("site_temp_search_margin_secs");
    tt->descr = tdrpStrDup("Search margin when finding site temp data (secs).");
    tt->help = tdrpStrDup("We search for the temperature closest in time to the radar volume. This is the search margin on either side of the sunscan time.");
    tt->val_offset = (char *) &site_temp_search_margin_secs - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("TEST PULSE ANALYSIS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'compute_test_pulse_powers'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_test_pulse_powers");
    tt->descr = tdrpStrDup("Option to analyze the test pulse powers.");
    tt->help = tdrpStrDup("If true, we will compute the test pulse for each channel, and write out results.");
    tt->val_offset = (char *) &compute_test_pulse_powers - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'test_pulse_min_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("test_pulse_min_range_km");
    tt->descr = tdrpStrDup("Range to start of test pulse (km).");
    tt->help = tdrpStrDup("This delimits the test pulse gates in the moments.");
    tt->val_offset = (char *) &test_pulse_min_range_km - &_start_;
    tt->single_val.d = 147.5;
    tt++;
    
    // Parameter 'test_pulse_max_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("test_pulse_max_range_km");
    tt->descr = tdrpStrDup("Range to end of test pulse (km).");
    tt->help = tdrpStrDup("This delimits the test pulse gates in the moments.");
    tt->val_offset = (char *) &test_pulse_max_range_km - &_start_;
    tt->single_val.d = 147.8;
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("TRANSMITTER POWERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'compute_mean_transmit_powers'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_mean_transmit_powers");
    tt->descr = tdrpStrDup("Option to compute the mean xmit power for each channel.");
    tt->help = tdrpStrDup("This depends on having the measured transmitter power in the time series.");
    tt->val_offset = (char *) &compute_mean_transmit_powers - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("WRITE RESULTS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'only_write_for_valid_centroid'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("only_write_for_valid_centroid");
    tt->descr = tdrpStrDup("Only write out data if the computed centroid position is valid.");
    tt->help = tdrpStrDup("If the parabolic fit in el and az is not valid, do not write out the data.");
    tt->val_offset = (char *) &only_write_for_valid_centroid - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_text_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_text_files");
    tt->descr = tdrpStrDup("Option to write out text files.");
    tt->help = tdrpStrDup("If false, the output fill be written to stdout.");
    tt->val_offset = (char *) &write_text_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'text_output_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("text_output_dir");
    tt->descr = tdrpStrDup("Dir for output text files.");
    tt->help = tdrpStrDup("The results will be written to sub-directories named from the cal time.");
    tt->val_offset = (char *) &text_output_dir - &_start_;
    tt->single_val.s = tdrpStrDup("./output");
    tt++;
    
    // Parameter 'append_to_global_results_file'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("append_to_global_results_file");
    tt->descr = tdrpStrDup("Option to append results to global file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &append_to_global_results_file - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'global_file_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("global_file_name");
    tt->descr = tdrpStrDup("Name for global output file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &global_file_name - &_start_;
    tt->single_val.s = tdrpStrDup("SunCal.global_results.txt");
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("OUTPUT RESULTS TO MDV FILES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_mdv_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_mdv_files");
    tt->descr = tdrpStrDup("Option to write out grids to MDV files.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &write_mdv_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'mdv_output_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("mdv_output_url");
    tt->descr = tdrpStrDup("URL for output MDV files.");
    tt->help = tdrpStrDup("For local writes, specify the directory. For remote writes, specify the full url: mdvp:://host::dir.");
    tt->val_offset = (char *) &mdv_output_url - &_start_;
    tt->single_val.s = tdrpStrDup("./mdv");
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("OUTPUT SUMMARY RESULTS TO SPDB XML");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_summary_to_spdb'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_summary_to_spdb");
    tt->descr = tdrpStrDup("Option to write out summary results to SPDB.");
    tt->help = tdrpStrDup("The summary will be in XML, stored in SPDB. It can then be retrieved for plotting or other purposes.");
    tt->val_offset = (char *) &write_summary_to_spdb - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'spdb_output_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("spdb_output_url");
    tt->descr = tdrpStrDup("URL for SPDB XML.");
    tt->help = tdrpStrDup("For local writes, specify the directory. For remote writes, specify the full url: spdbp:://host::dir");
    tt->val_offset = (char *) &spdb_output_url - &_start_;
    tt->single_val.s = tdrpStrDup("./spdb");
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
