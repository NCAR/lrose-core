// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
/*****************************************************************
 * GUI_DESTROY: GUI related functions for clean error  exits
 */

#define GUI_DESTROY 1

#include "cidd.h"

#ifdef NOTNOW

/*****************************************************************
 * X_ERROR_PROC: Handle errors generated by the X server
 */
 
Notify_value x_error_proc( Display *disp, XErrorEvent *event)
{
    char    text[256];
 
    XGetErrorText(disp, event->error_code, text, 256);
    fprintf(stderr,"ERROR - x_error_proc, X error\n");
    fprintf(stderr,"  error_code: %d\n", event->error_code);
    fprintf(stderr,"  error_text: %s\n", text);
    fprintf(stderr,"  X resource ID: %lu\n", event->resourceid);
    if (event->resourceid == 0) {
      exit(-1);
    }
    
    switch(event->error_code) {
        default :
          return  (Notify_value) 0; // XV_OK;
        break;
 
        case BadAlloc :
          return  (Notify_value) 0; // XV_OK;
        break;
    }
    return (Notify_value) 0; // XV_OK;
}
 
/*****************************************************************
 * BASE_WIN_DESTROY: Interposition for base frame destroys
 */

Notify_value base_win_destroy( Notify_client client, Destroy_status status)
{
    int i;
    char    fname[MAX_PATH_LEN];
    static int once_only = 0;

    switch(status) {
 
        case DESTROY_CLEANUP:
        case DESTROY_PROCESS_DEATH:
	     once_only++;
	     if(once_only != 1) exit(-0);

            if(gd.debug) fprintf(stderr,"Removing Movie Frame Files \n");
            /* destroy movie frames  */
            for(i=0; i < MAX_FRAMES ; i++) {
                /* Build the complete filename */
                STRcopy(fname,gd.movie.frame[i].fname,MAX_PATH_LEN-2);
                strcat(fname,"h");
                unlink(fname);    
            
                /* Build the complete filename */
                STRcopy(fname,gd.movie.frame[i].fname,MAX_PATH_LEN-2);
                strcat(fname,"v");
                unlink(fname);    
            }    

            if(gd.debug) fprintf(stderr,"Removing Movie Pixmaps \n");
            manage_h_pixmaps(3);
            manage_v_pixmaps(3);

            /* Remove Exported coordinate shared memory */
	    if(gd.coord_expt != NULL) {
                if(gd.debug) fprintf(stderr,"Removing Exported Coordinate shared memory\n");
		gd.coord_expt->shmem_ready = 0;
	        ushm_detach((void *)gd.coord_expt);
	    }

            if(gd.debug) fprintf(stderr,"De-Registering from Procmap\n");
            if(!gd.run_once_and_exit)  PMU_auto_unregister();

            if(!gd.quiet_mode) fprintf(stderr,"\nStandard Clean Exit from Cidd\n\n");
	    if(!gd.run_once_and_exit)  PMU_unregister(gd.app_name, gd.app_instance);
            return notify_next_destroy_func(client,status);
        break;
 
        case DESTROY_CHECKING:
        break;
 
        case DESTROY_SAVE_YOURSELF:
            return NOTIFY_DONE;
        break;
    }
    return NOTIFY_DONE;
}
#endif
