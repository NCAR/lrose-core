// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
////////////////////////////////////////////////////////////
// LegacyParams.hh
//
// Read legacy params, write out tdrp-compatible param file
//
// Mike Dixon, EOL, NCAR, Boulder, CO, USA
// Dec 2023
//
/////////////////////////////////////////////////////////////

#include "LegacyParams.hh"
#include "cidd.h"
#include <cerrno>
#include <iostream>
#include <cstdio>
#include <toolsa/umisc.h>
#include <toolsa/str.h>
#include <toolsa/TaStr.hh>
#include <toolsa/utim.h>

// constructor

LegacyParams::LegacyParams()
{
  _printTdrp = false;
  _paramsBuf = NULL;
  _paramsBufLen = 0;
  _tdrpFile = NULL;
}

// destructor

LegacyParams::~LegacyParams()
{
  clear();
  if (_tdrpFile != NULL) {
    fclose(_tdrpFile);
  }
}

// Clear the data base

void LegacyParams::clear()
{
  _plist.clear();
  _paramsBuf = NULL;
  _paramsBufLen = 0;
}

///////////////////////////////////////////////////////////////
// read in the legacy params
// write out tdrp params file
///////////////////////////////////////////////////////////////

int LegacyParams::translateToTdrp(const string &legacyParamsPath,
                                  const string &tdrpParamsPath)
  
{

  // int i,j;
  // int num_fields;
  long param_text_len;
  long param_text_line_no;
  const char *param_text;
  // const char *field_str;
  // char str_buf[128];   /* Space to build resource strings */
  // char *cfield[3];     /* Space to collect sub strings */

  // load up the params buffer from file or http
  
  if (_loadKeyValPairs(legacyParamsPath)) {
    fprintf(stderr,"LegacyParams::translateToTdrp()\n");
    fprintf(stderr,"  Could not load params from file\n");
    return -1;
  }
  
  // Retrieve the parameters from text file
  // read params in from buffer
  
  if (_readFromBuf(_paramsBuf, _paramsBufLen, "cidd")) {
    fprintf(stderr,"LegacyParams::translateToTdrp()\n");
    fprintf(stderr,"  Could not read params buffer\n");
    return -1;
  }

  // setPrintTdrp(true);

  // open the tdrp params file

  _tdrpFile = fopen(tdrpParamsPath.c_str(), "w");
  if (_tdrpFile == NULL) {
    fprintf(stderr,"ERROR - LegacyParams::translateToTdrp\n");
    fprintf(stderr,"  Cannot open tdrp file for writing\n");
    perror(tdrpParamsPath.c_str());
    return -1;
  }
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "//\n");
  fprintf(_tdrpFile, "// TDRP params file, generated by Qucid\n");
  fprintf(_tdrpFile, "// Legacy params path: %s\n", legacyParamsPath.c_str());
  fprintf(_tdrpFile, "//\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  
  // get field params
  
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <GRIDS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  param_text = find_tag_text(_paramsBuf,"GRIDS",
                             &param_text_len, &param_text_line_no);
  
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Couldn't Find GRIDS Section\n");
    return -1;
  }
  // establish and initialize sources of data 
  if (_initDataFields(param_text, param_text_len, param_text_line_no)) {
    return -1;
  }

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </GRIDS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  // Load the Main parameters

  param_text_line_no = 0;
  param_text_len = 0;
  param_text = _findTagText(_paramsBuf,"MAIN_PARAMS",
                            &param_text_len, &param_text_line_no);
    
  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Could'nt Find MAIN_PARAMS SECTION\n");
    return -1;
  }

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// <MAIN_PARAMS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

  _getBoolean("cidd.debug_flag", 0);
  _getBoolean("cidd.debug1_flag", 0);
  _getBoolean("cidd.debug2_flag", 0);

  // IF demo_time is set in the params
  // Set into Archive Mode at the indicated time.

  _getString("cidd.demo_time", "");

  _getLong("cidd.temporal_rounding", 300);
  
  _getString("cidd.climo_mode", "regular");

  /* Toggle for displaying the analog clock */
  _getLong("cidd.max_time_list_span", 365);

  // movies
  
  _getLong("cidd.starting_movie_frames", 12);
  _getDouble("cidd.time_interval",10.0);
  _getDouble("cidd.frame_span", 10.0);
  _getDouble("cidd.forecast_interval", 2.0);
  _getDouble("cidd.past_interval", 0.0);
  _getDouble("cidd.movie_magnify_factor",1.0);
  _getBoolean("cidd.check_data_times", 0);

  // clipping for rendering
  _getBoolean("cidd.check_clipping", 0);
  
  _getDouble("cidd.stretch_factor", 1.5);
  _getLong("cidd.gather_data_mode", CLOSEST_TO_FRAME_CENTER);
  _getLong("cidd.redraw_interval", REDRAW_INTERVAL);
  _getLong("cidd.update_interval", UPDATE_INTERVAL);

  _getString("cidd.datamap_host", "");
  _getLong("cidd.data_timeout_secs", 10);
  _getLong("cidd.simple_command_timeout_secs",30);
  _getLong("cidd.complex_command_timeout_secs",180);
  
  _getBoolean("cidd.movie_on", 0);
  _getLong("cidd.movie_delay",3000);
  _getLong("cidd.movie_speed_msec", 75);
  _getBoolean("cidd.reset_frames", 0);

  _getLong("cidd.model_run_list_hours",24);

  // How many idle seconds can elapse before resetting the display
  _getLong("cidd.idle_reset_seconds",0);

  _getBoolean("cidd.html_mode", 0);
  _getBoolean("cidd.run_once_and_exit",0);

  _getBoolean("cidd.transparent_images", 0);
  
  // Image dir - for output images
  _getString("cidd.image_dir", "/tmp/image_dir");
  
  _getBoolean("cidd.save_images_to_day_subdir", 0);
  
  // Set up our default image type.
  // force png for now
  _getString("cidd.image_ext", "png");

  _getString("cidd.image_horiz_prefix", "CP");
  _getString("cidd.image_vert_prefix", "CV");
  _getString("cidd.image_name_separator", "_");

  // output image file names
  
  _getBoolean("cidd.add_height_to_filename",0);
     
  _getBoolean("cidd.add_frame_time_to_filename",1);
     
  _getBoolean("cidd.add_button_name_to_filename",0);

  _getBoolean("cidd.add_frame_num_to_filename",1);

  _getBoolean("cidd.add_gen_time_to_filename",0);
  
  _getBoolean("cidd.add_valid_time_to_filename",0);
     
  _getString("cidd.horiz_image_dir", "/tmp/cidd_horiz_image_dir");
  _getString("cidd.horiz_image_fname", "cidd_horiz_view.png");
  _getString("cidd.horiz_image_command", "");
  
  _getString("cidd.vert_image_dir", "/tmp/cidd_vert_image_dir");
  _getString("cidd.vert_image_fname", "cidd_vert_view.png");
  _getString("cidd.vert_image_command", "");
  
  _getBoolean("cidd.output_geo_xml", 0);
  _getBoolean("cidd.use_latlon_in_geo_xml", 0);

  _getString("cidd.movieframe_time_format", "%H%M");

  _getLong("cidd.movieframe_time_mode", 0);

  // script to run after generating image
  
  _getString("cidd.image_convert_script", "convert_image.csh");
  
  _getString("cidd.print_script", "");

  _getString("cidd.series_convert_script", "make_anim.csh");

  // data compression from server
  
  _getBoolean("cidd.request_compressed_data",0);
  _getBoolean("cidd.request_gzip_vol_compression",0);

  /* Establish the projection type */

  _getString("cidd.projection_type", "CARTESIAN");

  // projections
  
  _getDouble("cidd.lambert_lat1",20.0);
  _getDouble("cidd.lambert_lat2",60.0);
  _getDouble("cidd.tangent_lat",90.0);
  _getDouble("cidd.tangent_lon",0.0);
  _getDouble("cidd.central_scale",1.0);

  _getDouble("cidd.north_angle",0.0);
  _getBoolean("cidd.use_cosine", 1); // legacy
  _getLong("cidd.use_cosine_correction", 1);

  _getDouble("cidd.scale_units_per_km",1.0);
  _getString("cidd.scale_units_label", "km");
  
  _getBoolean("cidd.always_get_full_domain", 0);
  _getBoolean("cidd.do_not_clip_on_mdv_request", 0);
  _getBoolean("cidd.do_not_decimate_on_mdv_request", 0);
     
  // zoom
  
  _getDouble("cidd.min_zoom_threshold", 5.0);

  _getDouble("cidd.aspect_ratio", 1.0);

  /* Toggle for enabling a status report window */
  _getBoolean("cidd.enable_status_window", 0);

  _getBoolean("cidd.report_clicks_in_status_window", 0);
  _getBoolean("cidd.report_clicks_in_degM_and_nm", 0);
  _getDouble("cidd.magnetic_variation_deg", 0);
  
  /* Toggle for enabling a Save Image Panel */
  // WARNING - ALLOWS USERS SHELL ACCESS
  _getBoolean("cidd.enable_save_image_panel", 0);
  
  _getDouble("cidd.domain_limit_min_x",-10000);
  _getDouble("cidd.domain_limit_max_x",10000);
  _getDouble("cidd.domain_limit_min_y",-10000);
  _getDouble("cidd.domain_limit_max_y",10000);
  
  // origin latitude and longitude
  
  _getDouble("cidd.origin_latitude", 0.0);
  _getDouble("cidd.origin_longitude", 0.0);

  // click location on reset
  
  _getDouble("cidd.reset_click_latitude", gd.origin_latitude);
  _getDouble("cidd.reset_click_longitude", gd.origin_longitude);

  _getLong("cidd.planview_start_page", 1); // subtract 1
  _getLong("cidd.xsect_start_page", 1); // subtract 1
  
  _getLong("cidd.num_zoom_levels",1);
  _getLong("cidd.start_zoom_level",1);
  _getBoolean("cidd.zoom_limits_in_latlon",0);
  _getLong("cidd.num_cache_zooms",1);

  _getDouble("cidd.min_ht", 0.0);
  _getDouble("cidd.max_ht", 30.0);
  _getDouble("cidd.start_ht", 0.0);

  _getString("cidd.map_file_subdir", "maps");
  _getDouble("cidd.locator_margin_km", 50.0);
  _getString("cidd.station_loc_url", "");

  _getString("cidd.remote_ui_url", "");

  _getString("cidd.http_tunnel_url", "");
  _getString("cidd.http_proxy_url", "");
  
  _getString("cidd.foreground_color", "White");
  _getString("cidd.background_color", "Black");
  _getString("cidd.margin_color", "Black");
  _getString("cidd.out_of_range_color", "transparent");
  _getString("cidd.route_path_color", "yellow");
  _getString("cidd.time_axis_color", "cyan");
  _getString("cidd.time_frame_color", "yellow");
  _getString("cidd.height_axis_color", "cyan");
  _getString("cidd.height_indicator_color", "red");
  _getString("cidd.range_ring_color", "grey");
  _getString("cidd.missing_data_color","transparent");
  _getString("cidd.bad_data_color","transparent");
  _getString("cidd.epoch_indicator_color", "yellow");
  _getString("cidd.now_time_color", "red");

  // need multiple time ticks - i.e. array
  
  _getString("cidd.time_tick_color", "yellow");
  _getString("cidd.latest_click_mark_color", "red");
  _getString( "cidd.latest_client_mark_color", "yellow");
  
  /* Toggle for displaying the height Selector in Right Margin */
  _getBoolean("cidd.show_height_sel", 1);

  /* Toggle for displaying data access and rendering messages */
  _getBoolean("cidd.show_data_messages", 1);

  _getLong("cidd.latlon_mode",0);

  _getString("cidd.label_time_format", "%m/%d/%y %H:%M:%S");

  _getString("cidd.moviestart_time_format", "%H:%M %m/%d/%Y");

  _getString("cidd.frame_range_time_format", "%H:%M");

  // Get the on/off state of the extra legend plotting - Force to either 0 or 1

  _getBoolean("cidd.layer_legends_on", 1);
  _getBoolean("cidd.cont_legends_on", 1);
  _getBoolean("cidd.wind_legends_on", 1);

  /* Toggle for displaying data labels */
  _getBoolean("cidd.display_labels", 1);

  /* Toggle for displaying the analog clock */
  _getBoolean("cidd.display_ref_lines", 1);

  // margins
  
  _getLong("cidd.top_margin_render_style", 1);
  
  _getLong("cidd.bot_margin_render_style", 1);
  
  // h_win_proc
  
  _getLong("cidd.horiz_default_y_pos",0);
  _getLong("cidd.horiz_default_x_pos",0);

  _getLong("cidd.horiz_default_height", 600);
  _getLong("cidd.horiz_default_width", 800);

  _getLong("cidd.horiz_min_height", 400);
  _getLong("cidd.horiz_min_width", 600);

  _getLong("cidd.horiz_top_margin", 20);
  _getLong("cidd.horiz_bot_margin", 20);
  _getLong("cidd.horiz_left_margin", 20);
  _getLong("cidd.horiz_right_margin", 80);
  
  _getLong("cidd.horiz_legends_start_x", 0);
  _getLong("cidd.horiz_legends_start_y", 0);
  _getLong("cidd.horiz_legends_delta_y", 0);
  
  // h_win_proc
  
  _getLong("cidd.vert_default_x_pos", 0);
  _getLong("cidd.vert_default_y_pos", 0);
  
  _getLong("cidd.vert_default_height", 400);
  _getLong("cidd.vert_default_width", 600);

  _getLong("cidd.vert_min_height", 400);
  _getLong("cidd.vert_min_width", 600);
  
  _getLong("cidd.vert_top_margin", 20);
  _getLong("cidd.vert_bot_margin", 20);
  _getLong("cidd.vert_left_margin", 20);
  _getLong("cidd.vert_right_margin", 80);
  
  _getLong("cidd.vert_legends_start_x", 0);
  _getLong("cidd.vert_legends_start_y", 0);
  _getLong("cidd.vert_legends_delta_y", 0);

  // range rings
  
  _getDouble("cidd.range_ring_spacing", -1.0);
  _getDouble("cidd.max_ring_range", 1000.0);
  
  // Toggle for displaying range rings at the data's origin - Useful for mobile units.
  _getBoolean("cidd.range_ring_follows_data", 0);
  _getBoolean("cidd.range_ring_for_radar_only", 0);

  // Toggle for shifting the display origin - Useful for mobile units.
  _getBoolean("cidd.domain_follows_data", 0);

  _getBoolean("cidd.range_rings", 0);
  _getLong("cidd.range_ring_x_space", 50);
  _getLong("cidd.range_ring_y_space", 15);
  _getBoolean("cidd.range_ring_labels", 1);
  
  _getDouble("cidd.azmith_interval", 30.0);
  _getDouble("cidd.azmith_radius", 200.0);
  _getBoolean("cidd.azmith_lines", 0);
  
  _getBoolean("cidd.all_winds_on", 1);

  // Load Wind Rendering preferences.
  _getLong("cidd.barb_shaft_len", 33);
  _getLong("cidd.ideal_x_vectors", 20);
  _getLong("cidd.ideal_y_vectors", 20);
  _getLong("cidd.wind_head_size", 5);
  _getDouble("cidd.wind_head_angle", 45.0);
  
  _getLong("cidd.wind_scaler", 3);
  _getDouble("cidd.wind_time_scale_interval", 10.0);

  _getString("cidd.wind_marker_type", "arrow");
  _getDouble("cidd.wind_w_scale_factor", 10.0);
  _getDouble("cidd.wind_units_scale_factor", 1.0);
  _getDouble("cidd.wind_reference_speed", 10.0);
  _getString("cidd.wind_units_label", "m/sec");

  _getBoolean("cidd.label_contours",1);
  _getLong("cidd.contour_line_width", 1);
  _getLong("cidd.smooth_contours", 0);
  _getBoolean("cidd.use_alt_contours", 0);
  _getBoolean("cidd.add_noise", 0);
  _getDouble("cidd.special_contour_value", 0.0);

  _getBoolean("cidd.map_bad_to_min_value", 0);
  _getBoolean("cidd.map_missing_to_min_value", 0);

  // main field on top?
  
  // gd.draw_main_on_top = (_getBoolean("cidd.draw_main_on_top", 0) & 1);
  _getBoolean("cidd.draw_main_on_top", 0);

  // latest click location
  
  _getBoolean("cidd.mark_latest_click_location", 0);

  _getLong("cidd.latest_click_mark_size", 11);
  _getBoolean("cidd.click_posn_rel_to_origin", 0);


  _getLong("cidd.num_fonts", 1);
  _getLong("cidd.font_display_mode",1);

  
  /* Toggle for displaying the analog clock */
  _getBoolean("cidd.show_clock", 0);

  /* Set the time to display on the analog clock */
  _getBoolean("cidd.draw_clock_local", 0);
  
  /* Use local times for Product timestamps and user input widgets. */
  _getBoolean("cidd.use_local_timestamps", 0);
  
  // field menu - number of columns
  
  _getLong("cidd.num_field_menu_cols",0);
  
  
  _getBoolean("cidd.wsddm_mode", 0);
  _getBoolean("cidd.one_click_rhi", 0);

  // canvas events

  _getDouble("cidd.rotate_coarse_adjust",6.0);
  _getDouble("cidd.rotate_medium_adjust",2.0);
  _getDouble("cidd.rotate_fine_adjust", 0.5);

  _getBoolean("cidd.disable_pick_mode", 1);
  _getBoolean("cidd.replace_underscores", 1);
  _getBoolean("cidd.close_popups", 0);
  _getBoolean("cidd.clip_overlay_fields", 0);
  
  _getString("cidd.horiz_frame_label", "Qucid");

  _getString("cidd.no_data_message", "NO DATA FOUND (in this area at the selected time)");
  
  _getString("cidd.status_info_file", "");

  _getString("cidd.help_command", "");

  // Bookmarks for a menu of URLS - Index starts at 1
  _getString("cidd.bookmark_command", "");
  _getLong("cidd.num_bookmarks", 0);
  
  _getDouble("cidd.image_inten", 0.8);
  _getLong("cidd.inten_levels", 32);
  _getDouble("cidd.data_inten", 1.0);

  _getLong("cidd.image_fill_threshold", 120000);

  _getLong("cidd.dynamic_contour_threshold", 160000);

  // shmem
  
  _getLong("cidd.coord_key", 63500);

  _getBoolean("cidd.products_on", 1);
  _getLong("cidd.product_line_width", 1);
  _getLong("cidd.product_font_size", 1);

  // symprods
  
  _getDouble("cidd.scale_constant", 300.0);

  // drawing
  
  gd.drawing_mode = 0;

  /* Establish the native projection type */
  
  _getString("cidd.projection_type", "CARTESIAN");

  _getBoolean("cidd.wind_mode", 0);

  fprintf(_tdrpFile, "//////////////////////////////////////////\n");
  fprintf(_tdrpFile, "// </MAIN_PARAMS>\n");
  fprintf(_tdrpFile, "//////////////////////////////////////////\n");

#ifdef JUNK

  // products

  gd.prod.products_on = gd.products_on;
  gd.prod.prod_line_width = gd.product_line_width;
  gd.prod.prod_font_num = gd.product_font_size;
  
  for(i=0; i < NUM_PRODUCT_DETAIL_THRESHOLDS; i++) {

    sprintf(str_buf,"cidd.product_detail_threshold%d",i+1);
    gd.product_detail_threshold[i] = _getDouble(str_buf,0.0);
    gd.prod.detail[i].threshold = gd.product_detail_threshold[i];
    
    sprintf(str_buf,"cidd.product_detail_adjustment%d",i+1);
    gd.product_detail_adjustment[i] = _getLong(str_buf,0);
    gd.prod.detail[i].adjustment = gd.product_detail_adjustment[i];

  }

#endif

#ifdef JUNK

  if(gd.num_bookmarks > 0) {
    gd.bookmark = (bookmark_t *)  calloc(sizeof(bookmark_t),gd.num_bookmarks);
  }
  
  err_flag = 0;
  for(i=0; i < gd.num_bookmarks; i++) {
    sprintf(str_buf,"cidd.bookmark%d",i+1);
    gd.bookmark[i].url = _getString(str_buf,"");

    if(strlen(gd.bookmark[i].url) < 4) {
      fprintf(stderr,"Error: Parameter %s undefined\n",str_buf);
      err_flag++;
    }

    sprintf(str_buf,"cidd.bookmark_label%d",i+1);
    gd.bookmark[i].label = _getString(str_buf,"");

    if(strlen(gd.bookmark[i].label) < 1) {
      fprintf(stderr,"Error: Parameter %s undefined\n",str_buf);
      err_flag++;
    }

  }
  if(err_flag) {
    fprintf(stderr,"Correct the cidd.bookmark section of the parameter file\n");
    return -1;
  }

#endif

#ifdef JUNK
  // movies
  
  pid = getpid();
  for(i=0; i < MAX_FRAMES; i++) {
    sprintf(gd.movie.frame[i].fname,
            "%s/cidd_im%d_%d.",
            gd.image_dir, pid, i);
    gd.movie.frame[i].h_xid = 0;
    gd.movie.frame[i].v_xid = 0;
    gd.movie.frame[i].redraw_horiz = 1;
    gd.movie.frame[i].redraw_vert = 1;
  }
#endif

  // zooms

#ifdef JUNK
  for(i=0; i < gd.h_win.num_zoom_levels; i++) {
    
    sprintf(str_buf, "cidd.level%d_min_xkm", i+1);
    double minx = _getDouble(str_buf,-200.0/(i+1));

    sprintf(str_buf, "cidd.level%d_min_ykm", i+1);
    double miny = _getDouble(str_buf,-200.0/(i+1));

    sprintf(str_buf, "cidd.level%d_max_xkm", i+1);
    double maxx = _getDouble(str_buf,200.0/(i+1));

    sprintf(str_buf, "cidd.level%d_max_ykm", i+1);
    double maxy = _getDouble(str_buf,200.0/(i+1));
    
  } // i
  
#endif

  // menu bar
  

#ifdef JUNK
  // Establish what each Menu Bar Cell Does.
  _getLong("cidd.num_menu_bar_cells",0);
  if(gd.menu_bar.num_menu_bar_cells > 0) {
    for(i=1; i <= gd.menu_bar.num_menu_bar_cells; i++) {
      sprintf(str_buf,"cidd.menu_bar_funct%d",i);
      resource = _getString(str_buf,"Not Defined");
      if(strcmp("LOOP_ONOFF",resource) == 0) {
        gd.menu_bar.loop_onoff_bit = 1 << (i-1) ;
      } else if( strcmp("WINDS_ONOFF",resource) == 0) {
        gd.menu_bar.winds_onoff_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_FORECAST_MENU",resource) == 0) {
        gd.menu_bar.show_forecast_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_PAST_MENU",resource) == 0) {
        gd.menu_bar.show_past_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_GENTIME_MENU",resource) == 0) {
        gd.menu_bar.show_gen_time_win_bit = 1 << (i-1) ;
      } else if( strcmp("SYMPRODS_ONOFF",resource) == 0) {
        gd.menu_bar.symprods_onoff_bit = 1 << (i-1) ;
      } else if( strcmp("PRINT_BUTTON",resource) == 0) {
        gd.menu_bar.print_button_bit = 1 << (i-1) ;
      } else if( strcmp("HELP_BUTTON",resource) == 0) {
        gd.menu_bar.help_button_bit = 1 << (i-1) ;
      } else if( strcmp("CLONE_CIDD",resource) == 0) {
        gd.menu_bar.clone_button_bit = 1 << (i-1) ;
      } else if( strcmp("EXIT_BUTTON",resource) == 0) {
        gd.menu_bar.exit_button_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_VIEW_MENU",resource) == 0) {
        gd.menu_bar.show_view_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_PRODUCT_MENU",resource) == 0) {
        gd.menu_bar.show_prod_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_MAP_MENU",resource) == 0) {
        gd.menu_bar.show_map_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_BOOKMARK_MENU",resource) == 0) {
        gd.menu_bar.show_bookmark_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_STATUS_PANEL",resource) == 0) {
        gd.menu_bar.show_status_win_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_TIME_PANEL",resource) == 0) {
        gd.menu_bar.show_time_panel_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_DPD_MENU",resource) == 0) {
        gd.menu_bar.show_dpd_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_DPD_PANEL",resource) == 0) {
        gd.menu_bar.show_dpd_panel_bit = 1 << (i-1) ;
      } else if( strcmp("SET_DRAW_MODE",resource) == 0) {
        gd.menu_bar.set_draw_mode_bit = 1 << (i-1) ;
      } else if( strcmp("SET_PICK_MODE",resource) == 0) {
        gd.menu_bar.set_pick_mode_bit = 1 << (i-1) ;
      } else if( strcmp("SET_ROUTE_MODE",resource) == 0) {
        gd.menu_bar.set_route_mode_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_XSECT_PANEL",resource) == 0) {
        gd.menu_bar.show_xsect_panel_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_GRID_PANEL",resource) == 0) {
        gd.menu_bar.show_grid_panel_bit = 1 << (i-1) ;
      } else if( strcmp("RELOAD",resource) == 0) {
        gd.menu_bar.reload_bit = 1 << (i-1) ;
      } else if( strcmp("RESET",resource) == 0) {
        gd.menu_bar.reset_bit = 1 << (i-1) ;
      } else if( strcmp("SET_TO_NOW",resource) == 0) {
        gd.menu_bar.set_to_now_bit = 1 << (i-1) ;
      } else if( strcmp("CLOSE_POPUPS",resource) == 0) {
        gd.menu_bar.close_popups_bit = 1 << (i-1) ;
      } else if( strcmp("REPORT_MODE_ONOFF",resource) == 0) {
        gd.menu_bar.report_mode_bit = 1 << (i-1) ;
      } else if( strcmp("LANDUSE_ONOFF",resource) == 0) {
        gd.menu_bar.landuse_onoff_bit = 1 << (i-1) ;
      } else if( strcmp("SHOW_CMD_MENU",resource) == 0) {
        gd.menu_bar.show_cmd_menu_bit = 1 << (i-1) ;
      } else if( strcmp("SNAP_IMAGE",resource) == 0) {
        gd.menu_bar.snapshot_bit = 1 << (i-1) ;
      } else if( strcmp("ZOOM_BACK",resource) == 0) {
        gd.menu_bar.zoom_back_bit = 1 << (i-1) ;
      } else {
        fprintf(stderr,"Unrecognized Menu Bar Cell Function %d: %s\n",i,resource);
        return -1;
      }
    }
  } else {
    fprintf(stderr,"Menu Bar cells must be defined in this version\n");
    return -1;
  }
#endif
  
#ifdef JUNK

  // copy legacy params to tdrp

  // Load the Wind Data Field  parameters
  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"WINDS",
                             &param_text_len, &param_text_line_no);


  if(param_text == NULL || param_text_len <=0 ) {
    if(gd.debug)fprintf(stderr,"Couldn't Find WINDS Section\n");
  } else {
    /* Establish and initialize connections to wind fields */
    if (_initWindFields(param_text, param_text_len, param_text_line_no)) {
      return -1;
    }
  }
    
  if(gd.layers.num_wind_sets == 0) gd.layers.wind_vectors = 0;

  // Instantiate and load the SYMPROD TDRP Parameter section
  gd.syprod_P = new Csyprod_P();

  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"SYMPRODS",
                             &param_text_len, &param_text_line_no); 
  if(param_text == NULL || param_text_len <=0 ) {
    if(gd.debug) fprintf(stderr," Warning: No SYMPRODS Section in params\n");
  } else {
    /* Establish and initialize params */

    if(gd.syprod_P->loadFromBuf("SYMPRODS TDRP Section",
                                NULL,param_text,
                                param_text_len,
                                param_text_line_no,
                                TRUE,gd.debug2) < 0) {
      fprintf(stderr,"Please fix the <SYMPRODS> parameter section\n");
      return -1;
    }
  }

  // Instantiate and load the TERRAIN TDRP Parameter 
  gd.layers.earth._P = new Cterrain_P();

  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"TERRAIN",
                             &param_text_len, &param_text_line_no); 
  if(param_text == NULL || param_text_len <=0 ) {
    if(gd.debug) fprintf(stderr," Warning: No TERRAIN Section in params\n");
  } else {
    if(gd.layers.earth._P->loadFromBuf("TERRAIN TDRP Section",
                                       NULL,param_text,
                                       param_text_len,
                                       param_text_line_no,
                                       TRUE,gd.debug2) < 0) {
      fprintf(stderr,"Please fix the <TERRAIN> parameter section\n");
      return -1;
    }
    if(strlen(gd.layers.earth._P->terrain_url) >0) {
      gd.layers.earth.terrain_active = 1;
      gd.layers.earth.terr = (met_record_t *) calloc(sizeof(met_record_t), 1);

      if(gd.layers.earth.terr == NULL) {
        fprintf(stderr,"Cannot allocate space for terrain data\n");
        return -1;
      }
      gd.layers.earth.terr->time_allowance = 5270400; // 10 years
      STRcopy(gd.layers.earth.terr->color_file,
              gd.layers.earth._P->landuse_colorscale,NAME_LENGTH);
      STRcopy(gd.layers.earth.terr->button_name,
              gd.layers.earth._P->id_label,NAME_LENGTH);
      STRcopy(gd.layers.earth.terr->legend_name,
              gd.layers.earth._P->id_label,NAME_LENGTH);
      STRcopy(gd.layers.earth.terr->url,
              gd.layers.earth._P->terrain_url,URL_LENGTH);

      gd.layers.earth.terr->h_mdvx = new DsMdvxThreaded;
      gd.layers.earth.terr->v_mdvx = new DsMdvxThreaded;
      gd.layers.earth.terr->h_mdvx_int16 = new MdvxField;
      gd.layers.earth.terr->v_mdvx_int16 = new MdvxField;
      gd.layers.earth.terr->proj =  new MdvxProj;
    }

    if(strlen(gd.layers.earth._P->landuse_url) >0) {
      gd.layers.earth.landuse_active = (gd.layers.earth._P->landuse_active == true)? 1: 0;
      gd.layers.earth.land_use = (met_record_t *) calloc(sizeof(met_record_t), 1);

      if(gd.layers.earth.land_use == NULL) {
        fprintf(stderr,"Cannot allocate space for land_use data\n");
        return -1;
      }
      gd.layers.earth.land_use->time_allowance = 5270400; // 10 years
      STRcopy(gd.layers.earth.land_use->color_file,
              gd.layers.earth._P->landuse_colorscale,NAME_LENGTH);
      STRcopy(gd.layers.earth.land_use->button_name,
              gd.layers.earth._P->id_label,NAME_LENGTH);
      STRcopy(gd.layers.earth.land_use->legend_name,
              gd.layers.earth._P->id_label,NAME_LENGTH);
      STRcopy(gd.layers.earth.land_use->url,
              gd.layers.earth._P->landuse_url,URL_LENGTH);

      gd.layers.earth.land_use->h_mdvx = new DsMdvxThreaded;
      gd.layers.earth.land_use->v_mdvx = new DsMdvxThreaded;
      gd.layers.earth.land_use->h_mdvx_int16 = new MdvxField;
      gd.layers.earth.land_use->v_mdvx_int16 = new MdvxField;
      gd.layers.earth.land_use->proj =  new MdvxProj;

      switch(gd.layers.earth._P->land_use_render_method) {
        default:
        case Cterrain_P::RENDER_RECTANGLES:
          gd.layers.earth.land_use->render_method = POLYGONS;
          break;

        case Cterrain_P::RENDER_FILLED_CONT:
          gd.layers.earth.land_use->render_method = FILLED_CONTOURS;
          break;

        case Cterrain_P::RENDER_DYNAMIC_CONTOURS:
          gd.layers.earth.land_use->render_method = DYNAMIC_CONTOURS;
          break;
      }

    }

  }

  // Instantiate and load the ROUTE_WINDS TDRP Parameter 
  gd.layers.route_wind._P = new Croutes_P();

  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"ROUTE_WINDS",
                             &param_text_len, &param_text_line_no); 
  if(param_text == NULL || param_text_len <=0 ) {
    if(gd.debug) fprintf(stderr," Warning: No ROUTE_WINDS Section in params\n");
    gd.layers.route_wind.has_params = 0;
  } else {
    if(gd.layers.route_wind._P->loadFromBuf("ROUTE_WINDS TDRP Section",
                                            NULL,param_text,
                                            param_text_len,
                                            param_text_line_no,
                                            TRUE,gd.debug2) < 0) {
      fprintf(stderr,"Please fix the <ROUTE_WINDS> parameter section\n");
      return -1;
    }

    gd.layers.route_wind.has_params = 1;
    route_winds_init();

    // Use the first route as the default.
    memcpy(&gd.h_win.route,gd.layers.route_wind.route,sizeof(route_track_t)); 
  }

  // Instantiate the GUI Config TDRP 
  gd.gui_P = new Cgui_P();

  // Load the GUI_CONFIG parameters
  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"GUI_CONFIG",
                             &param_text_len, &param_text_line_no);

  if(param_text == NULL || param_text_len <=0 ) {
  } else {
    if(gd.gui_P->loadFromBuf("GUI_CONFIG TDRP Section",
                             NULL,param_text,
                             param_text_len,
                             param_text_line_no,
                             TRUE,gd.debug2)  < 0) { 
      fprintf(stderr,"Please fix the <GUI_CONFIG> parameter section\n");
      return -1;
    }
  }

  // Instantiate the IMAGES Config TDRP 
  gd.images_P = new Cimages_P();

  // Load the IMAGES_CONFIG parameters
  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"IMAGE_GENERATION",
                             &param_text_len, &param_text_line_no);

  if(param_text == NULL || param_text_len <=0 ) {
  } else {
    if(gd.images_P->loadFromBuf("IMAGE_GENERATION TDRP Section",
                                NULL,param_text,
                                param_text_len,
                                param_text_line_no,
                                TRUE,gd.debug2)  < 0) { 
      fprintf(stderr,"Please fix the <IMAGE_GENERATION> parameter section\n");
      return -1;
    }
  }

  // Instantiate the Draw TDRP 
  gd.draw_P = new Cdraw_P();

  // Load the Draw_Export parameters
  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"DRAW_EXPORT",
                             &param_text_len, &param_text_line_no);

  if(param_text == NULL || param_text_len <=0 ) {
    if(gd.debug) fprintf(stderr," Warning: No DRAW_EXPORT Section in params\n");
    gd.draw.num_draw_products = 0;
  } else {
    if(gd.draw_P->loadFromBuf("DRAW EXPORT TDRP Section",
			      NULL,param_text,
			      param_text_len,
			      param_text_line_no,
			      TRUE,gd.debug2)  < 0) { 
      fprintf(stderr,"Please fix the <DRAW_EXPORT> parameter section\n");
      return -1;
    }

    /* Establish and initialize Draw-Export params */
    if (_initDrawExportLinks()) {
      return -1;
    }
  }
    
  if(gd.draw.num_draw_products == 0 && gd.menu_bar.set_draw_mode_bit >0) {
    fprintf(stderr,
	    "Fatal Error: DRAW Button Enabled, without any DRAW_EXPORT Products defined\n"); 
    fprintf(stderr,
	    "Either remove SET_DRAW_MODE button or define products in DRAW_EXPORT \n"); 
    fprintf(stderr,
	    "Section of the parameter file \n"); 
    return -1;
  }

#endif

#ifdef JUNK

  // Load the Map Overlay parameters
  param_text_line_no = 0;
  param_text_len = 0;
  param_text = find_tag_text(_paramsBuf,"MAPS",
                             &param_text_len, &param_text_line_no);

  if(param_text == NULL || param_text_len <=0 ) {
    fprintf(stderr,"Could'nt Find MAPS SECTION\n");
    return -1;
  }

  // overlays

  if (_initOverlays(param_text, param_text_len, param_text_line_no)) {
    return -1;
  }
  

  if(strlen(gd.station_loc_url) > 1) {
    if(gd.debug || gd.debug1) {
      fprintf(stderr,"Loading Station data from %s ...",gd.station_loc_url);
    }
    gd.station_loc =  new StationLoc();
    if(gd.station_loc == NULL) {
      fprintf(stderr,"CIDD: Fatal Alloc constructing new StationLoc()\n");
      return -1;
    }

    if(gd.station_loc->ReadData(gd.station_loc_url) < 0) {
      fprintf(stderr,"CIDD: Can't load Station Data from %s\n",gd.station_loc_url);
      return -1;
    }
    // gd.station_loc->PrintAll();  // DEBUG

    if(gd.debug || gd.debug1) {
      fprintf(stderr,"Done\n");
    }
  }

  if(strlen(gd.remote_ui_url) > 1) {

    gd.remote_ui = new RemoteUIQueue();

    // Create the FMW with 4096 slots - Total size 1M
    bool compression = false;
    if (gd.remote_ui->initReadWrite( gd.remote_ui_url,
                                     (char *) "CIDD",
                                     (bool) gd.debug2,
                                     DsFmq::END, compression,
                                     4096, 4096*256 ) != 0 ) { 
      fprintf(stderr,"Problems initialising Remote Command Fmq: %s - aborting\n",gd.remote_ui_url);
    }
  }

  for(i=0; i < NUM_CONT_LAYERS; i++) {
    gd.layers.cont[i].field = 0;
    gd.layers.cont[i].min = gd.mrec[0]->cont_low;
    gd.layers.cont[i].max = gd.mrec[0]->cont_high;
    gd.layers.cont[i].interval = gd.mrec[0]->cont_interv;
    gd.layers.cont[i].labels_on  = gd.label_contours;
  }
  for(i=0; i < NUM_GRID_LAYERS; i++) { gd.layers.overlay_field[i] = 0; }

  for(j=0;j < gd.num_datafields; j++) {
    gd.h_win.redraw[j] = 1;
    gd.v_win.redraw[j] = 1;
  }

  /* Get space for string parsing sub-fields */
  cfield[0] = (char *)  calloc(1,NAME_LENGTH);
  cfield[1] = (char *)  calloc(1,NAME_LENGTH);
  cfield[2] = (char *)  calloc(1,NAME_LENGTH);

  if(cfield[0]  == NULL || cfield[1] == NULL || cfield[2] == NULL) {
    fprintf(stderr,"Cidd: Fatal Alloc failure of %d bytes\n", NAME_LENGTH);
    return -1;
  }

  /* Setup default CONTOUR FIELDS */
  for(i = 1; i <= NUM_CONT_LAYERS; i++ ) {

    sprintf(str_buf,"cidd.contour%d_field",i);
    field_str = _getString(str_buf, "NoMaTcH");

    num_fields = STRparse(field_str, cfield, NAME_LENGTH, 3, NAME_LENGTH); 

    strncpy(gd.layers.cont[i-1].color_name,"white",NAME_LENGTH);

    if(gd.html_mode == 0) {
      /* Replace Underscores with spaces in field names */
      for(j=strlen(cfield[0])-1 ; j >= 0; j--) 
        if(gd.replace_underscores && cfield[0][j] == '_') cfield[0][j] = ' ';
    }
    for(j=0;j < gd.num_datafields; j++) {
      if(strcmp(gd.mrec[j]->button_name,cfield[0]) == 0) {
        gd.layers.cont[i-1].field = j;
        if(num_fields >  2 && (strncasecmp(cfield[2],"off",3) == 0) ) {
          gd.layers.cont[i-1].active = 0;
        } else {
          gd.layers.cont[i-1].active = 1;
        }

        gd.layers.cont[i-1].min = gd.mrec[j]->cont_low;
        gd.layers.cont[i-1].max = gd.mrec[j]->cont_high;
        gd.layers.cont[i-1].interval = gd.mrec[j]->cont_interv;

        if(num_fields > 1)
          strncpy(gd.layers.cont[i-1].color_name,cfield[1],NAME_LENGTH);

      }
    }
  }

  /* Set up default OVERLAY FIELDS */
  for(i = 1; i <= NUM_GRID_LAYERS; i++ ) {
    sprintf(str_buf,"cidd.layer%d_field",i);
    field_str =  _getString( str_buf, "NoMaTcH");

    num_fields = STRparse(field_str, cfield, NAME_LENGTH, 3, NAME_LENGTH); 

    if(gd.html_mode == 0) {
      /* Replace Underscores with spaces in field names */
      for(j=strlen(cfield[0])-1 ; j >= 0; j--) 
        if(gd.replace_underscores && field_str[j] == '_') cfield[0][j] = ' ';
    }
    for(j=0; j <  gd.num_datafields; j++) {
      if(strcmp(gd.mrec[j]->button_name,cfield[0]) == 0) {  
        if(num_fields >  1 && (strncasecmp(cfield[1],"off",3) == 0) ) {
          gd.layers.overlay_field_on[i-1] = 0;
        } else {
          gd.layers.overlay_field_on[i-1] = 1;
        }

        gd.layers.overlay_field[i-1] = j;
      }
    }
  }

  free(cfield[0]);
  free(cfield[1]);
  free(cfield[2]);

  // fonts

  if(gd.num_fonts > MAX_FONTS) {
    gd.num_fonts = MAX_FONTS;
    fprintf(stderr,"Cidd: Warning. Too Many Fonts. Limited to %d Fonts\n",MAX_FONTS);
  }

#endif
  
#ifdef NOTNOW
  
  // Make sure specified font for Winds, Contours and Products are within range.
  if(gd.prod.prod_font_num < 0) gd.prod.prod_font_num = 0;
  if(gd.prod.prod_font_num >= gd.num_fonts) gd.prod.prod_font_num = gd.num_fonts -1;
  
  for(i=0;i < gd.num_fonts; i++) {
    sprintf(p_name,"cidd.font%d",i+1);
    f_name = _getString(
            p_name, "fixed");
    gd.fontst[i] = (XFontStruct *) XLoadQueryFont(dpy,f_name);
    if(gd.fontst[i] != NULL) {
      gd.ciddfont[i]  = gd.fontst[i]->fid;
    } else {
      fprintf(stderr,"Can't load font: %s\n",f_name);
      fprintf(stderr,"Using 'fixed' instead\n");
      gd.fontst[i]  = (XFontStruct *) XLoadQueryFont(dpy,"fixed");
      gd.ciddfont[i]  = gd.fontst[i]->fid;
    }
  }    

#endif

  // timer control


  // setPrintTdrp(false);

  return 0;

}


////////////////////////////////////////
// read in from param file
//
// returns 0 on success, -1 on failure

int LegacyParams::_readFromPath(const char *file_path,
                                const char *prog_name)

{

  // open file

  FILE *params_file;
  if ((params_file = fopen(file_path, "r")) == NULL) {
    int errNum = errno;
    cerr << "ERROR - LegacyParams::read" << endl;
    cerr << "  Cannot read params from file: " << file_path << endl;
    cerr << "  " << strerror(errNum) << endl;
    return -1;
  }

  // loop through file
  
  char line[BUFSIZ];

  while (!feof(params_file)) {
    
    // read a line
    
    if (fgets(line, BUFSIZ, params_file) == NULL) {
      break;
    }
    
    if (feof(params_file))
      break;

    // substitute in any environment variables
    
    usubstitute_env(line, BUFSIZ);

    // delete past any hash-bang

    char *sptr;
    if ((sptr = strstr(line, "#!")) != NULL) {
      *sptr = '\0';
    }
    
    // process only if the line has the program name followed by a period.
    
    char *name = line;
    if (strlen(name) < strlen(prog_name + 1)) {
      continue;
    }
    if (strncmp(prog_name, name, strlen(prog_name)) ||
	name[strlen(prog_name)] != '.') {
      continue;
    }

    // check that there is a colon

    char *colon = strchr(name, ':');
    if (!colon) {
      continue;
    }
    
    // back up past any white space
    
    char *end_of_name = colon - 1;
    while (*end_of_name == ' ' || *end_of_name == '\t') {
      end_of_name--;
    }

    // place null at end of name

    *(end_of_name + 1) = '\0';

    // get entry string

    char *entry = colon + 1;

    // advance past white space
    
    while (*entry == ' ' || *entry == '\t') {
      entry++;
    }

    // back up past white space
    
    char *end_of_entry = entry + strlen(entry);
    while (*end_of_entry == ' ' || *end_of_entry == '\t' ||
	   *end_of_entry == '\r' || *end_of_entry == '\n' ||
	   *end_of_entry == '\0') {
      end_of_entry--;
    }

    // place null at end of entry
    
    *(end_of_entry + 1) = '\0';

    // check that we do not already have this param
    
    bool previous_entry_found = false;
    for (size_t ii = 0; ii < _plist.size(); ii++) {
      if (_plist[ii].name == name) {
	_plist[ii].entry = entry;
	previous_entry_found = true;
	break;
      }
    } // ii

    // if previous entry was not found,
    // store name and entry pointers in params list

    if (!previous_entry_found) {
      param_list_t ll;
      ll.name = name;
      ll.entry = entry;
      _plist.push_back(ll);
    }
      
  } /* while (!feof(params_file)) */

  // close file

  fclose(params_file);

  // debug print

  // for (size_t ii = 0; ii < _plist.size(); ii++) {
  //   cerr << "name, val: " << _plist[ii].name << ", " << _plist[ii].entry << endl;
  // } // ii
  // cerr << "Param list size: " << _plist.size() << endl;

  return 0;

}

////////////////////////////////////////
// read from a param buffer
//
// returns 0 on success, -1 on failure

int LegacyParams::_readFromBuf(const char *buf,
                               int buf_len,
                               const char *prog_name)

{

  // loop through lines in buffer
  
  char line[BUFSIZ];
  const char *ptr = buf;
  
  while (ptr < buf + buf_len) {
  
    // find a line

    const char *eol = strchr(ptr, '\n');
    if (eol == NULL) {
      break;
    }
    
    int lineLen = eol - ptr + 1;
    int copyLen;
    if (lineLen > BUFSIZ) {
      copyLen = BUFSIZ;
    } else {
      copyLen = lineLen;
    }
    STRncopy(line, ptr, copyLen);
    ptr += lineLen;

    // substitute in any environment variables
    
    usubstitute_env(line, BUFSIZ);
    
    // delete past any hash-bang

    char *sptr;
    if ((sptr = strstr(line, "#!")) != NULL) {
      *sptr = '\0';
    }
    
    // process only if the line has the program name followed by a period.
    
    char *name = line;
    if (strlen(name) < strlen(prog_name + 1)) {
      continue;
    }
    if (strncmp(prog_name, name, strlen(prog_name)) ||
	name[strlen(prog_name)] != '.') {
      continue;
    }

    // check that there is a colon

    char *colon = strchr(name, ':');
    if (!colon) {
      continue;
    }
    
    // back up past any white space
    
    char *end_of_name = colon - 1;
    while (*end_of_name == ' ' || *end_of_name == '\t') {
      end_of_name--;
    }

    // place null at end of name

    *(end_of_name + 1) = '\0';

    // get entry string

    char *entry = colon + 1;

    // advance past white space
    
    while (*entry == ' ' || *entry == '\t') {
      entry++;
    }

    // back up past white space
    
    char *end_of_entry = entry + strlen(entry);
    while (*end_of_entry == ' ' || *end_of_entry == '\t' ||
	   *end_of_entry == '\r' || *end_of_entry == '\n' ||
	   *end_of_entry == '\0') {
      end_of_entry--;
    }

    // place null at end of entry
    
    *(end_of_entry + 1) = '\0';

    // check that we do not already have this param
    
    bool previous_entry_found = false;
    for (size_t ii = 0; ii < _plist.size(); ii++) {
      if (_plist[ii].name == name) {
	_plist[ii].entry = entry;
	previous_entry_found = true;
	break;
      }
    } // ii

    // if previous entry was not found,
    // store name and entry pointers in params list

    if (!previous_entry_found) {
      param_list_t ll;
      ll.name = name;
      ll.entry = entry;
      _plist.push_back(ll);
    }
      
  } /* while (!feof(params_file)) */

  // debug print

  // for (size_t ii = 0; ii < _plist.size(); ii++) {
  //   cerr << "name, val: " << _plist[ii].name << ", " << _plist[ii].entry << endl;
  // } // ii
  // cerr << "Param list size: " << _plist.size() << endl;

  return 0;

}

///////////////////////////////////////////////////////////////
// gets an entry from the param list
// returns NULL if this fails
///////////////////////////////////////////////////////////////

const char *LegacyParams::_get(const char *search_name) const

{
  
  for (size_t ii =  0; ii < _plist.size(); ii++) {
    if (_plist[ii].name == search_name) {
      return (_plist[ii].entry.c_str());
    }
  }

  return NULL;

}

///////////////////////////////////////////////////////////////
// returns the value of a double parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

double LegacyParams::_getDouble(const char *name, double default_val)
{

  if (_printTdrp) {
    cout << endl;
    cout << "paramdef double {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  double dval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    double val;
    if (sscanf(entryStr, "%lg", &val) == 1) {
      dval = val;
    }
  }

  fprintf(_tdrpFile, "%s = %lg;\n", _removeCiddStr(name), dval);

  return dval;

}

///////////////////////////////////////////////////////////////
// returns the value of a float parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

float LegacyParams::_getFloat(const char *name, float default_val)
{

  if (_printTdrp) {
    cout << endl;
    cout << "paramdef double {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  float fval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    float val;
    if (sscanf(entryStr, "%g", &val) == 1) {
      fval = val;
    }
  }
  
  fprintf(_tdrpFile, "%s = %g;\n", _removeCiddStr(name), fval);

  return fval;

}

//////////////////////////////////////////////////////////////
// remove cidd. from start of parameter name

const char *LegacyParams::_removeCiddStr(const char *name) const

{

  if (strncmp(name, "cidd.", 5) == 0) {
    return (name + 5);
  } else {
    return name;
  }
  
}


///////////////////////////////////////////////////////////////
// returns the value of a boolean parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

bool LegacyParams::_getBoolean(const char *name, int default_val)

{

  if (_printTdrp) {
    cout << endl;
    cout << "paramdef boolean {" << endl;
    if (default_val == 0) {
      cout << "  p_default = FALSE;" << endl;
    } else {
      cout << "  p_default = TRUE;" << endl;
    }
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  bool bval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    int val;
    if (sscanf(entryStr, "%d", &val) == 1) {
      bval = val;
    }
  }

  fprintf(_tdrpFile, "%s = %s;\n", _removeCiddStr(name), (bval?"TRUE":"FALSE"));
  
  return bval;

}

///////////////////////////////////////////////////////////////
// returns the value of a int parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

int LegacyParams::_getInt(const char *name, int default_val)

{

  if (_printTdrp) {
    cout << endl;
    cout << "paramdef int {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }

  int ival = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    int val;
    if (sscanf(entryStr, "%d", &val) == 1) {
      ival = val;
    }
  }
  
  fprintf(_tdrpFile, "%s = %d;\n", _removeCiddStr(name), ival);

  return ival;

}

///////////////////////////////////////////////////////////////
// returns the value of a long parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

long LegacyParams::_getLong(const char *name, long default_val)

{

  if (_printTdrp) {
    cout << endl;
    cout << "paramdef int {" << endl;
    cout << "  p_default = " << default_val << ";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }
  
  long lval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    long val;
    if (sscanf(entryStr, "%ld", &val) == 1) {
      lval = val;
    }
  }
  
  fprintf(_tdrpFile, "%s = %ld;\n", _removeCiddStr(name), lval);

  return lval;

}

///////////////////////////////////////////////////////////////
// returns the value of a string parameter
// If it cannot find the parameter, returns the default
///////////////////////////////////////////////////////////////

const string LegacyParams::_getString(const char *name, const char *default_val)
  
{

  if (_printTdrp) {
    cout << endl;
    cout << "paramdef string {" << endl;
    cout << "  p_default = \"" << default_val << "\";" << endl;
    cout << "  p_descr = \"\"" << ";" << endl;
    cout << "  p_help = \"\"" << ";" << endl;
    cout << "} " << _removeCiddStr(name) << ";" << endl;
    cout << endl;
  }
  
  string sval = default_val;
  const char *entryStr = _get(name);
  if (entryStr != NULL) {
    sval = entryStr;
  }

  fprintf(_tdrpFile, "%s = \"%s\";\n", _removeCiddStr(name), sval.c_str());

  return sval;
  
}

/////////////////////////////////////////////////////////////////////////////
// FIND_TAG_TEXT Search a null terminated string for the text between tags
//
// Searches through input_buf for text between tags of the form <TAG>...Text...</TAG>
// Returns a pointer to the beginning of the text and its length if found.
// text_line_no is used on input to begin counting and is set on output to the starting
// line number of the tagged text

#define TAG_BUF_LEN 256
const char *LegacyParams::_findTagText(const char *input_buf,
                                       const char * tag,
                                       long *text_len,
                                       long *text_line_no)
{
  int start_line_no;
  const char *start_ptr;
  const char *end_ptr;
  const char *ptr;
  char end_tag[TAG_BUF_LEN];
  char start_tag[TAG_BUF_LEN];
  
  // Reasonable tag check - Give up
  if(strlen(tag) > TAG_BUF_LEN - 5) {
    fprintf(stderr,"Unreasonable tag: %s - TOO long!\n",tag);
    *text_len = 0;
    return NULL;
  }
  
  // Clear the string buffers
  memset(start_tag,0,TAG_BUF_LEN);
  memset(end_tag,0,TAG_BUF_LEN);
  
  start_line_no = *text_line_no;
  
  snprintf(start_tag, TAG_BUF_LEN - 1, "<%s>", tag);
  snprintf(end_tag,TAG_BUF_LEN - 1, "</%s>", tag);
  
  // Search for Start tag
  if((start_ptr = strstr(input_buf,start_tag)) == NULL) {
    *text_len = 0;
    *text_line_no = start_line_no;
    return NULL;
  }
  start_ptr +=  strlen(start_tag); // Skip ofer tag to get to the text
  
  // Search for end tag after the start tag
  if((end_ptr = strstr(start_ptr,end_tag)) == NULL) {
    *text_len = 0;
    *text_line_no = start_line_no;
    return NULL;
  }
  end_ptr--;  // Skip back one character to last text character
  
  // Compute the length of the text_tag
  *text_len = (long) (end_ptr - start_ptr);
  
  // Count the lines before the starting tag
  ptr = input_buf;
  while(((ptr = strchr(ptr,'\n')) != NULL) && (ptr < start_ptr)) {
    ptr++; // Move past the found NL
    start_line_no++;
  }
  
  *text_line_no = start_line_no;
  return start_ptr;
}

/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA_DEFAULT : Allocate and load the parameter data base using the
//                        default parameter settings and set Global Struct
//                        members
// 

int LegacyParams::_loadKeyValPairsDefault(char* &db_buf, int &db_len)
{

  // Generate the full params string.  The non-TDRP portions are kept in
  // static strings while the TDRP portions are loaded from the default
  // parameters

  gd.gui_P = new Cgui_P;
  gd.syprod_P = new Csyprod_P;
  gd.draw_P = new Cdraw_P;
  gd.images_P = new Cimages_P;
  gd.layers.earth._P = new Cterrain_P;
  gd.layers.route_wind._P = new Croutes_P;
  
  string params_text = ParamsTextMasterHeader;
  params_text += get_default_tdrp_params("GUI_CONFIG", gd.gui_P);
  params_text += ParamsTextGrids;
  params_text += ParamsTextWinds;
  params_text += ParamsTextMaps;
  params_text += ParamsTextMainParams;
  params_text += get_default_tdrp_params("DRAW_EXPORT", gd.draw_P);
  params_text += get_default_tdrp_params("IMAGE_GENERATION", gd.images_P);
  params_text += get_default_tdrp_params("SYMPRODS", gd.syprod_P);
  params_text += get_default_tdrp_params("TERRAIN",
					 gd.layers.earth._P);
  params_text += get_default_tdrp_params("ROUTE_WINDS",
					 gd.layers.route_wind._P);
  

  // Allocate space for the buffer copy
  
  db_len = params_text.size() + 1;
  
  if ((db_buf = (char *)calloc(db_len, 1)) == NULL) {
    fprintf(stderr,"Problems allocating %ld bytes for parameter file\n",
	    (long)db_len);
    return -1;
  }

  // Copy the parameters into the buffer

  memcpy(db_buf, params_text.c_str(), db_len - 1);
  db_buf[db_len-1] = '\0';

  return 0;
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA_FILE : Allocate and load the parameter data base from a file
//                     and set Global Struct members
// 

int LegacyParams::_loadKeyValPairsFile(const string &fname,
                                  char* &db_buf,
                                  int &db_len)
{

  FILE *infile;
  
  // create temp buffer
  
  int tmpLen = 1000000;
  char *tmpBuf = new char[tmpLen];
  
  // Open DB file
  
  if((infile = fopen(fname.c_str(),"r")) == NULL) {
    perror(fname.c_str());
    fprintf(stderr,"Problems Opening %s\n",fname.c_str());
    return -1;
  }
  
  // Read into tmp buf
  db_len = fread(tmpBuf,1,tmpLen,infile);
  if(db_len <= 0) {
    perror(fname.c_str());
    fprintf(stderr,"Problems Reading %s\n",fname.c_str());
    return -1;
  }
  
  // Allocate space for the whole file plus a null
  if((db_buf = (char *)  calloc(db_len + 1, 1)) == NULL) {
    fprintf(stderr,"Problems allocating %d bytes for parameter file\n",
            db_len);
    return -1;
  }
  
  // copy in
  
  memcpy(db_buf, tmpBuf, db_len);
  db_buf[db_len] = '\0'; // Make sure to null terminate
  delete[] tmpBuf;
  
  // Close DB file
  if(fclose(infile) != 0 )  {
    fprintf(stderr,"Problems Closing %s\n",fname.c_str());
    return -1;
  }

  return 0;
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA_HTTP : Allocate and load the parameter data base from a Web
//                     server and set Global Struct members
// 

int LegacyParams::_loadKeyValPairsHttp(const string &fname,
                                  char* &db_buf,
                                  int &db_len)
{

  int ret_stat;
  
  // Allow 5 seconds to retrieve the data 
  
  if(strlen(gd.http_proxy_url)  > URL_MIN_SIZE) {
    ret_stat = HTTPgetURL_via_proxy(gd.http_proxy_url, fname.c_str(), 5000,
				    &db_buf, &db_len);
  } else {
    ret_stat = HTTPgetURL(fname.c_str(), 5000, &db_buf, &db_len);
  }
  
  if(ret_stat <= 0 || db_len <= 0) {
    fprintf(stderr,"Could'nt Load Parameter Database from URL: %s,  %d\n",
	    fname.c_str(), ret_stat);
    if(ret_stat < 0) {
      fprintf(stderr,"Failed to successfully trasnact with the http server\n");
    } else {
      fprintf(stderr,
	      "HTTP server couldn't retreive the file - Returned  Stat: %d\n",
	      ret_stat);
    }
    fprintf(stderr,
	    "Make sure URL looks like: http://host.domain/dir/filename\n");
    fprintf(stderr,
	    "The most common problem is usually missing  the :// part \n");
    fprintf(stderr,"or a misspelled/incorrect host, directory or filename\n");
    if(strlen(gd.http_proxy_url)  > URL_MIN_SIZE)
      fprintf(stderr,"Also Check Proxy URL:%s\n",gd.http_proxy_url);
    return -1;
  }

  return 0;
  
}


/////////////////////////////////////////////////////////////////////////////
// LOAD_DB_DATA : Allocate and load the data base file - Set Global
// Struct members
// 

int LegacyParams::_loadKeyValPairs(const string &fname)
{
  
  char *db_buf = NULL;
  int db_len = 0;
  int iret = 0;
  
  if (fname == "") {
    // Default parameters
    iret = _loadKeyValPairsDefault(db_buf, db_len);
  } else if(strncasecmp(fname.c_str(), "http:", 5) == 0) {
    // HTTP Based retrieve 
    iret = _loadKeyValPairsHttp(fname, db_buf, db_len);
  } else {
    // FILE based retrieve
    iret = _loadKeyValPairsFile(fname, db_buf, db_len);
  }

  if (iret == 0) {
    _paramsBuf = db_buf;
    _paramsBufLen = db_len;
    return 0;
  } else {
    return -1;
  }
  
}

/////////////////////////////////////////////////////////////////////////////
// initialize data field structs

#define NUM_PARSE_FIELDS    32
#define PARSE_FIELD_SIZE    1024
#define INPUT_LINE_LEN      10000

int LegacyParams::_initDataFields(const char *param_buf,
                                  long param_buf_len,
                                  long line_no)
{
  int  len,total_len;
  const char *start_ptr;
  const char *end_ptr;
  char *cfield[NUM_PARSE_FIELDS];

  gd.num_datafields = 0;
  total_len = 0;
  start_ptr = param_buf;

  // cerr << "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" << endl;
  // cerr << "fields_n: " << gParams.fields_n << endl;
  // for (int ii = 0; ii < gParams.fields_n; ii++) {
  //   Params::field_t &fld = gParams._fields[ii];
  //   cerr << "  button name: " << fld.button_name << endl;
  //   cerr << "  legend name: " << fld.legend_name << endl;
  //   cerr << "  contour_low: " << fld.contour_low << endl;
  // }
  // cerr << "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" << endl;

  // read all the lines in the data information buffer

  vector<Field> flds;
  
  while((end_ptr = strchr(start_ptr,'\n')) != NULL && (total_len < param_buf_len)) {

    // Skip over blank, short or commented lines
    len = (end_ptr - start_ptr)+1;
    if( (len < 20)  || (*start_ptr == '#')) {
      total_len += len  +1;
      start_ptr = end_ptr +1; // Skip past the newline
      line_no++;
      continue;
    }

    if(gd.num_datafields < MAX_DATA_FIELDS -1) {

      Field fld;
      
      // Ask for 128 extra bytes for the null and potential env var  expansion
      // gd.data_info[gd.num_datafields] = (char *)  calloc(len+128, 1);
      // STRcopy(gd.data_info[gd.num_datafields],start_ptr,len);

      // create space for text line

      fld.text_line.resize(10000);
      STRcopy((char *) fld.text_line.c_str(), start_ptr, len);

      /* Do Environment variable substitution */
      // usubstitute_env(gd.data_info[gd.num_datafields], len+128);
      usubstitute_env((char *) fld.text_line.c_str(), len + 10000);
      gd.num_datafields++;

      flds.push_back(fld);

    } else {

      fprintf(stderr,
              "Cidd: Warning. Too many Data Fields. Data field not processed\n");
      fprintf(stderr,"Line %ld \n",line_no);
	 
    }

    total_len += len + 1;   // Count characters processed 
    start_ptr = end_ptr +1; // Skip past the newline
    line_no++;

  }
  
  if (flds.size() < 1) {
    fprintf(stderr,"CIDD requires at least one valid gridded data field to be defined\n");
    return -1;
  }

  /* get temp space for substrings */
  for(int ii = 0; ii < NUM_PARSE_FIELDS; ii++) {
    cfield[ii] = (char *)  calloc(PARSE_FIELD_SIZE, 1);
  }

  /* scan through each of the data information lines */
  for(size_t ifield = 0; ifield < flds.size(); ifield++) {

    Field &fld = flds[ifield];
    
    /* get space for data info */
    // gd.mrec[ifield] =  (met_record_t *) calloc(sizeof(met_record_t), 1);

    /* separate into substrings */

    STRparse(fld.text_line.c_str(), cfield, INPUT_LINE_LEN, NUM_PARSE_FIELDS, PARSE_FIELD_SIZE);
    fld.legend_label = cfield[0];
    fld.button_label = cfield[1];

    if(gd.html_mode == 0) {
      /* Replace Underscores with spaces in names */
      for(int jj = (int) fld.button_label.size() - 1 ; jj >= 0; jj--) {
        if(gd.replace_underscores && fld.button_label[jj] == '_') fld.button_label[jj] = ' ';
        if(gd.replace_underscores && fld.legend_label[jj] == '_') fld.legend_label[jj] = ' ';
      }
    }

    // split the URL into url and field name - the delimiter is '&'
    
    vector<string> toks;
    TaStr::tokenize(cfield[2], "&", toks);
    if (toks.size() != 2) {
      cerr << "WARNING - bad data field line, no field name" << endl;
      cerr << fld.text_line << endl;
      fld.is_valid = false;
      continue;
    }
    fld.url = toks[0];
    fld.field_name = toks[1];

    // other members
    
    fld.color_map = cfield[3];
      
    // if units are "" or --, set to zero-length string
    if (!strcmp(cfield[4], "\"\"") || !strcmp(cfield[4], "--")) {
      fld.field_units.clear();
    } else {
      fld.field_units = cfield[4];
    }

    fld.contour_low = atof(cfield[5]);
    fld.contour_high = atof(cfield[6]);
    fld.contour_interval = atof(cfield[7]);

    // gd.mrec[ifield]->time_allowance = gd.movie.mr_stretch_factor * gd.movie.time_interval;

    if (strncasecmp(cfield[8],"rad",3) == 0) {
      fld.render_mode = POLYGONS;
    } else {
      fld.render_mode = POLYGONS;
    }

    if (strncasecmp(cfield[8],"cont",4) == 0) {
      fld.render_mode = FILLED_CONTOURS;
    }

    if (strncasecmp(cfield[8],"lcont",4) == 0) {
      fld.render_mode = LINE_CONTOURS;
    }

    if (strncasecmp(cfield[8],"dcont",4) == 0) {
      fld.render_mode = DYNAMIC_CONTOURS;
    }

    if (strstr(cfield[8],"comp") != NULL) {
      fld.composite_mode = TRUE;
    }

    if (strstr(cfield[8],"autoscale") != NULL) {
      fld.auto_scale = TRUE;
    }

    fld.display_in_menu = atoi(cfield[9]);
    
    if(gd.run_once_and_exit) {
      fld.auto_render = 1;
    } else {
      fld.auto_render = atoi(cfield[10]);
    }

    // gd.mrec[ifield]->last_elev = (char *)NULL;
    // gd.mrec[ifield]->elev_size = 0;

    // gd.mrec[ifield]->plane = 0;
    // gd.mrec[ifield]->h_data_valid = 0;
    // gd.mrec[ifield]->v_data_valid = 0;
    // gd.mrec[ifield]->h_last_scale  = -1.0;
    // gd.mrec[ifield]->h_last_bias  = -1.0;
    // gd.mrec[ifield]->h_last_missing  = -1.0;
    // gd.mrec[ifield]->h_last_bad  = -1.0;
    // gd.mrec[ifield]->h_last_transform  = -1;
    // gd.mrec[ifield]->v_last_scale  = -1.0;
    // gd.mrec[ifield]->v_last_bias  = -1.0;
    // gd.mrec[ifield]->v_last_missing  = -1.0;
    // gd.mrec[ifield]->v_last_bad  = -1.0;
    // gd.mrec[ifield]->v_last_transform  = -1;
    // gd.mrec[ifield]->h_fhdr.proj_origin_lat  = 0.0;
    // gd.mrec[ifield]->h_fhdr.proj_origin_lon  = 0.0;
    // gd.mrec[ifield]->time_list.num_alloc_entries = 0;
    // gd.mrec[ifield]->time_list.num_entries = 0;

    // STRcopy(gd.mrec[ifield]->units_label_cols,"KM",LABEL_LENGTH);
    // STRcopy(gd.mrec[ifield]->units_label_rows,"KM",LABEL_LENGTH);
    // STRcopy(gd.mrec[ifield]->units_label_sects,"KM",LABEL_LENGTH);

    // // instantiate classes
    // gd.mrec[ifield]->h_mdvx = new DsMdvxThreaded;
    // gd.mrec[ifield]->v_mdvx = new DsMdvxThreaded;
    // gd.mrec[ifield]->h_mdvx_int16 = new MdvxField;
    // gd.mrec[ifield]->v_mdvx_int16 = new MdvxField;
    // gd.mrec[ifield]->proj = new MdvxProj;

  } // ifield
  
  /* Make sure the first field is always on */
  // gd.mrec[0]->currently_displayed = 1;
    
  /* free up temp storage for substrings */
  for(int i = 0; i < NUM_PARSE_FIELDS; i++) {
    free(cfield[i]);
  }

  /* write to tdrp params file */

  fprintf(_tdrpFile, "fields = {\n");
  for(size_t ifield = 0; ifield < flds.size(); ifield++) {
    Field &fld = flds[ifield];
    fprintf(_tdrpFile, "{\n");
    fprintf(_tdrpFile, "  button_label = \"%s\",\n", fld.button_label.c_str());
    fprintf(_tdrpFile, "  legend_label = \"%s\",\n", fld.legend_label.c_str());
    fprintf(_tdrpFile, "  url = \"%s\",\n", fld.url.c_str());
    fprintf(_tdrpFile, "  field_name = \"%s\",\n", fld.field_name.c_str());
    fprintf(_tdrpFile, "  color_map = \"%s\",\n", fld.color_map.c_str());
    fprintf(_tdrpFile, "  field_units = \"%s\",\n", fld.field_units.c_str());
    fprintf(_tdrpFile, "  contour_low = %lg,\n", fld.contour_low);
    fprintf(_tdrpFile, "  contour_high = %lg,\n", fld.contour_high);
    fprintf(_tdrpFile, "  contour_interval = %lg,\n", fld.contour_interval);
    switch (fld.render_mode) {
      case POLYGONS:
        fprintf(_tdrpFile, "  render_mode = POLYGONS,\n");
        break;
      case FILLED_CONTOURS:
        fprintf(_tdrpFile, "  render_mode = FILLED_CONTOURS,\n");
        break;
      case DYNAMIC_CONTOURS:
        fprintf(_tdrpFile, "  render_mode = DYNAMIC_CONTOURS,\n");
        break;
      case LINE_CONTOURS:
        fprintf(_tdrpFile, "  render_mode = LINE_CONTOURS,\n");
        break;
    }
    fprintf(_tdrpFile, "  display_in_menu = %s,\n", (fld.display_in_menu?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  background_render = %s,\n", (fld.background_render?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  composite_mode = %s,\n", (fld.composite_mode?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  auto_scale = %s,\n", (fld.auto_scale?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "  auto_render = %s\n", (fld.auto_render?"TRUE":"FALSE"));
    fprintf(_tdrpFile, "}\n");
    if (ifield < flds.size() - 1) {
      fprintf(_tdrpFile, ",\n");
    }
  } // ifield
  fprintf(_tdrpFile, "};\n");

  return 0;

}
/************************************************************************
 * INIT_WIND_DATA_LINKS:  Scan cidd_wind_data.info file and setup link to
 *         data source for the wind fields.
 *
 */

int LegacyParams::_initWindFields(const char *param_buf,
                                  long param_buf_len,
                                  long line_no)
{
  int    i;
  int    len,total_len;
  int    num_sets;    /* number of sets of wind data */
  int    num_fields;
  const char   *start_ptr;
  const char   *end_ptr;
  char   *cfield[NUM_PARSE_FIELDS];
  
  // initialize pointers to NULL
  
  for(i = 0; i < NUM_PARSE_FIELDS; i++) {
    cfield[i] = NULL;
  }
  
  /* PASS 1 - Count the wind set lines */
  num_sets = 0;
  total_len = 0;
  start_ptr = param_buf;
  while((end_ptr = strchr(start_ptr,'\n')) != NULL && 
        (total_len < param_buf_len)) {
    // Skip over blank, short or commented lines
    len = (end_ptr - start_ptr)+1;
    if( len > 15  && *start_ptr != '#') {
      num_sets++;
    }
    start_ptr = end_ptr +1; // Skip past the newline
    total_len += len  +1;
  }

   
  int default_marker_type = ARROWS;  
  if(num_sets > 0) {  /* ALLOCATE Space */
    /* get temp space for substrings */
    for(i = 0; i < NUM_PARSE_FIELDS; i++) {
      cfield[i] =(char *)  calloc(PARSE_FIELD_SIZE, 1);
    }
    
    if((gd.layers.wind =(wind_data_t*) calloc(num_sets,sizeof(wind_data_t))) == NULL) {
      fprintf(stderr,"Unable to allocate space for %d wind sets\n",num_sets);
      perror("Cidd");
      return -1;
    }
    
    // Set up global barb preferences
    const char *type_ptr = gd.wind_marker_type;
    
    if(strncasecmp(type_ptr, "tuft", 4) == 0)  default_marker_type = TUFT;
    if(strncasecmp(type_ptr, "barb", 4) == 0)  default_marker_type = BARB;
    if(strncasecmp(type_ptr, "vector", 6) == 0)  default_marker_type = VECTOR;
    if(strncasecmp(type_ptr, "tickvector", 10) == 0)  default_marker_type = TICKVECTOR; 
    if(strncasecmp(type_ptr, "labeledbarb", 11) == 0)  default_marker_type = LABELEDBARB;
    if(strncasecmp(type_ptr, "metbarb", 7) == 0)  default_marker_type = METBARB;
    if(strncasecmp(type_ptr, "barb_sh", 7) == 0)  default_marker_type = BARB_SH;
    if(strncasecmp(type_ptr, "labeledbarb_sh", 14) == 0)  default_marker_type = LABELEDBARB_SH;
    
    /* PASS 2 - fill in the params in the wind sets */
    num_sets = 0;
    
    total_len = 0;
    start_ptr = param_buf;
    while((end_ptr = strchr(start_ptr,'\n')) != NULL && 
          (total_len < param_buf_len)) {
      len = (end_ptr - start_ptr)+1; 
      // Skip over blank, short or commented lines
      if( len > 15  && *start_ptr != '#') {
        num_fields = STRparse(start_ptr, cfield, len, NUM_PARSE_FIELDS, PARSE_FIELD_SIZE); 
        if( *start_ptr != '#' && num_fields >= 7) {
          
          // Ask for 128 extra bytes for the null and potential env var  expansion
          gd.layers.wind[num_sets].data_info = (char *) calloc(len+128, 1);
          if(gd.layers.wind[num_sets].data_info == NULL) {
            fprintf(stderr,"Unable to allocate %d bytes for wind info\n",len+128);
            perror("Cidd");
            return -1;
          }
          STRcopy(gd.layers.wind[num_sets].data_info,start_ptr,len);
          
          /* DO Environment variable substitution */
          usubstitute_env(gd.layers.wind[num_sets].data_info, len+128);
          num_sets++;
        }
      }
      start_ptr = end_ptr +1; // Skip past the newline
      total_len += len  +1;
    }
  }
  
  gd.layers.num_wind_sets = num_sets;
  
  for(i=0; i < gd.layers.num_wind_sets; i++) {
    num_fields = STRparse(gd.layers.wind[i].data_info, cfield,
                          INPUT_LINE_LEN,
                          NUM_PARSE_FIELDS, PARSE_FIELD_SIZE);
    if(num_fields < 7) {
      fprintf(stderr,
              "Error in wind field line. Wrong number of parameters,  -Line: \n %s"
              ,gd.layers.wind[i].data_info);
    }
    
    /* Allocate Space for U record and initialize */
    gd.layers.wind[i].wind_u = (met_record_t *)
      calloc(sizeof(met_record_t), 1);
    gd.layers.wind[i].wind_u->h_data_valid = 0;
    gd.layers.wind[i].wind_u->v_data_valid = 0;
    gd.layers.wind[i].wind_u->h_vcm.nentries = 0;
    gd.layers.wind[i].wind_u->v_vcm.nentries = 0;
    gd.layers.wind[i].wind_u->h_fhdr.scale = -1.0;
    gd.layers.wind[i].wind_u->h_last_scale = 0.0;
    gd.layers.wind[i].wind_u->time_list.num_alloc_entries = 0;
    gd.layers.wind[i].wind_u->time_list.num_entries = 0;
    STRcopy(gd.layers.wind[i].wind_u->legend_name,cfield[0],NAME_LENGTH);
    STRcopy(gd.layers.wind[i].wind_u->button_name,cfield[0],NAME_LENGTH);
    STRcopy(gd.layers.wind[i].wind_u->url,cfield[1],URL_LENGTH);
    
    if(gd.html_mode == 0) { /* Replace Underscores with spaces in names */
      for(int j=strlen(gd.layers.wind[i].wind_u->button_name)-1 ; j >= 0; j--) {
        if(gd.replace_underscores && gd.layers.wind[i].wind_u->button_name[j] == '_') gd.layers.wind[i].wind_u->button_name[j] = ' ';
        if(gd.replace_underscores && gd.layers.wind[i].wind_u->legend_name[j] == '_') gd.layers.wind[i].wind_u->legend_name[j] = ' ';
      }
    }
    
    // Append the field name
    strcat(gd.layers.wind[i].wind_u->url,cfield[2]);
    
    STRcopy(gd.layers.wind[i].wind_u->field_units,cfield[5],LABEL_LENGTH);
    gd.layers.wind[i].wind_u->currently_displayed = atoi(cfield[6]);
    gd.layers.wind[i].active = (atoi(cfield[6]) > 0)? 1: 0;
    gd.layers.wind[i].line_width = abs(atoi(cfield[6]));
    // Sanity check
    if(gd.layers.wind[i].line_width == 0 ||
       gd.layers.wind[i].line_width > 10) gd.layers.wind[i].line_width = 1;
    
    // Pick out Optional Marker type fields
    gd.layers.wind[i].marker_type = default_marker_type;
    if(strstr(cfield[6], ",tuft") != NULL)  gd.layers.wind[i].marker_type = TUFT;
    if(strstr(cfield[6], ",barb") != NULL)  gd.layers.wind[i].marker_type = BARB;
    if(strstr(cfield[6], ",vector") != NULL)  gd.layers.wind[i].marker_type = VECTOR;
    if(strstr(cfield[6], ",tickvector") != NULL)  gd.layers.wind[i].marker_type = TICKVECTOR; 
    if(strstr(cfield[6], ",labeledbarb") != NULL)  gd.layers.wind[i].marker_type = LABELEDBARB;
    if(strstr(cfield[6], ",metbarb") != NULL)  gd.layers.wind[i].marker_type = METBARB;
    if(strstr(cfield[6], ",barb_sh") != NULL)  gd.layers.wind[i].marker_type = BARB_SH;
    if(strstr(cfield[6], ",labeledbarb_sh") != NULL)  gd.layers.wind[i].marker_type = LABELEDBARB_SH;
    
    
    // Pick out Optional Color
    if(num_fields > 7) {
      STRcopy(gd.layers.wind[i].color_name, cfield[7], NAME_LENGTH);
    } else {
      STRcopy(gd.layers.wind[i].color_name, "white", NAME_LENGTH);
    }
    gd.layers.wind[i].wind_u->time_allowance = gd.movie.mr_stretch_factor * gd.movie.time_interval;
    gd.layers.wind[i].wind_u->h_fhdr.proj_origin_lon = 0.0;
    gd.layers.wind[i].wind_u->h_fhdr.proj_origin_lat = 0.0;
    
    // instantiate classes
    gd.layers.wind[i].wind_u->h_mdvx = new DsMdvxThreaded;
    gd.layers.wind[i].wind_u->v_mdvx = new DsMdvxThreaded;
    gd.layers.wind[i].wind_u->h_mdvx_int16 = new MdvxField;
    gd.layers.wind[i].wind_u->v_mdvx_int16 = new MdvxField;
    gd.layers.wind[i].wind_u->proj = new MdvxProj;
    
    /* Allocate Space for V record and initialize */
    gd.layers.wind[i].wind_v = (met_record_t *)
      calloc(sizeof(met_record_t), 1);
    gd.layers.wind[i].wind_v->h_data_valid = 0;
    gd.layers.wind[i].wind_v->v_data_valid = 0;
    gd.layers.wind[i].wind_v->h_vcm.nentries = 0;
    gd.layers.wind[i].wind_v->v_vcm.nentries = 0;
    gd.layers.wind[i].wind_v->h_fhdr.scale = -1.0;
    gd.layers.wind[i].wind_v->h_last_scale = 0.0;
    gd.layers.wind[i].wind_v->time_list.num_alloc_entries = 0;
    gd.layers.wind[i].wind_v->time_list.num_entries = 0;
    STRcopy(gd.layers.wind[i].wind_v->legend_name,cfield[0],NAME_LENGTH);
    STRcopy(gd.layers.wind[i].wind_v->button_name,cfield[0],NAME_LENGTH);
    STRcopy(gd.layers.wind[i].wind_v->url,cfield[1],URL_LENGTH);
    
    
    if(gd.html_mode == 0) { /* Replace Underscores with spaces in names */
      for(int j=strlen(gd.layers.wind[i].wind_v->button_name)-1 ; j >= 0; j--) {
        if(gd.replace_underscores && gd.layers.wind[i].wind_v->button_name[j] == '_') gd.layers.wind[i].wind_v->button_name[j] = ' ';
        if(gd.replace_underscores && gd.layers.wind[i].wind_v->legend_name[j] == '_') gd.layers.wind[i].wind_v->legend_name[j] = ' ';
      }
    }
    // Append the field name
    strcat(gd.layers.wind[i].wind_v->url,cfield[3]);
    
    STRcopy(gd.layers.wind[i].wind_v->field_units,cfield[5],LABEL_LENGTH);
    gd.layers.wind[i].wind_v->currently_displayed = atoi(cfield[6]);
    gd.layers.wind[i].wind_v->time_allowance = gd.movie.mr_stretch_factor * gd.movie.time_interval;
    gd.layers.wind[i].wind_v->h_fhdr.proj_origin_lon = 0.0;
    gd.layers.wind[i].wind_v->h_fhdr.proj_origin_lat = 0.0;
    
    // instantiate classes
    gd.layers.wind[i].wind_v->h_mdvx = new DsMdvxThreaded();
    gd.layers.wind[i].wind_v->v_mdvx = new DsMdvxThreaded();
    gd.layers.wind[i].wind_v->h_mdvx_int16 = new MdvxField;
    gd.layers.wind[i].wind_v->v_mdvx_int16 = new MdvxField;
    gd.layers.wind[i].wind_v->proj = new MdvxProj;
    
    /* Allocate Space for W  record (If necessary)  and initialize */
    if(strncasecmp(cfield[4],"None",4) != 0) {
      gd.layers.wind[i].wind_w = (met_record_t *) calloc(sizeof(met_record_t), 1);
      gd.layers.wind[i].wind_w->h_data_valid = 0;
      gd.layers.wind[i].wind_w->v_data_valid = 0;
      gd.layers.wind[i].wind_w->v_vcm.nentries = 0;
      gd.layers.wind[i].wind_w->h_vcm.nentries = 0;
      gd.layers.wind[i].wind_w->h_fhdr.scale = -1.0;
      gd.layers.wind[i].wind_w->h_last_scale = 0.0;
      gd.layers.wind[i].wind_w->time_list.num_alloc_entries = 0;
      gd.layers.wind[i].wind_w->time_list.num_entries = 0;
      
      STRcopy(gd.layers.wind[i].wind_w->legend_name,cfield[0],NAME_LENGTH);
      snprintf(gd.layers.wind[i].wind_w->button_name, NAME_LENGTH - 1, "%s_W ",cfield[0]);
      STRcopy(gd.layers.wind[i].wind_w->url,cfield[1],URL_LENGTH);
      
      if(gd.html_mode == 0) { /* Replace Underscores with spaces in names */
        for(int j=strlen(gd.layers.wind[i].wind_w->button_name)-1 ; j >= 0; j--) {
          if(gd.replace_underscores && gd.layers.wind[i].wind_w->button_name[j] == '_') gd.layers.wind[i].wind_w->button_name[j] = ' ';
          if(gd.layers.wind[i].wind_w->legend_name[j] == '_') gd.layers.wind[i].wind_w->legend_name[j] = ' ';
        }
      }
      
      // Append the field name
      strcat(gd.layers.wind[i].wind_w->url,cfield[4]);
      
      STRcopy(gd.layers.wind[i].wind_w->field_units,cfield[5],LABEL_LENGTH);
      gd.layers.wind[i].wind_w->currently_displayed = atoi(cfield[6]);
      gd.layers.wind[i].wind_w->time_allowance = gd.movie.mr_stretch_factor * gd.movie.time_interval;
      gd.layers.wind[i].wind_w->h_fhdr.proj_origin_lon = 0.0;
      gd.layers.wind[i].wind_w->h_fhdr.proj_origin_lat = 0.0;
      
      // instantiate classes
      gd.layers.wind[i].wind_w->h_mdvx = new DsMdvxThreaded();
      gd.layers.wind[i].wind_w->v_mdvx = new DsMdvxThreaded();
      gd.layers.wind[i].wind_w->h_mdvx_int16 = new MdvxField;
      gd.layers.wind[i].wind_w->v_mdvx_int16 = new MdvxField;
      gd.layers.wind[i].wind_w->proj = new MdvxProj;
    } else {
      gd.layers.wind[i].wind_w =  (met_record_t *) NULL;
    }
    
    gd.layers.wind[i].units_scale_factor = gd.wind_units_scale_factor;
    gd.layers.wind[i].reference_speed = gd.wind_reference_speed;
    gd.layers.wind[i].units_label = gd.wind_units_label;
    
  }
  
  /* free temp space */
  for(i = 0; i < NUM_PARSE_FIELDS; i++) {
    if (cfield[i] != NULL) {
      free(cfield[i]);
    }
  }

  return 0;
  
}
/************************************************************************
 * INIT_DRAW_EXPORT_LINKS:  Scan param file and setup links to
 *  for drawn and exported points 
 *
 */

int LegacyParams::_initDrawExportLinks()
{
  int  i,len;
  
  gd.draw.num_draw_products = gd.draw_P->dexport_info_n;
  
  if((gd.draw.dexport =(draw_export_info_t*)
      calloc(gd.draw.num_draw_products,sizeof(draw_export_info_t))) == NULL) {
    fprintf(stderr,"Unable to allocate space for %d draw.dexport sets\n",gd.draw.num_draw_products);
    perror("CIDD");
    return -1;
  }

  
  // Allocate space for control struct and record starting values for each product.
  for(i=0; i < gd.draw.num_draw_products;  i++) {
    
    // Product ID  
    len = strlen(gd.draw_P->_dexport_info[i].id_label) +1;
    gd.draw.dexport[i].product_id_label = (char *)  calloc(1,len);
    STRcopy(gd.draw.dexport[i].product_id_label,gd.draw_P->_dexport_info[i].id_label,len);
    
    // Allocate space for product_label_text (annotations) and set to nulls
    gd.draw.dexport[i].product_label_text =  (char *) calloc(1,TITLE_LENGTH);
    
    strncpy(gd.draw.dexport[i].product_label_text, gd.draw_P->_dexport_info[i].default_label,TITLE_LENGTH-1);
    
    // FMQ URL 
    len = strlen(gd.draw_P->_dexport_info[i].url) +1;
    if(len > NAME_LENGTH) {
      fprintf(stderr,"URL: %s too long - Must be less than %d chars. Sorry.",
              gd.draw_P->_dexport_info[i].url,URL_LENGTH);
      return -1;
    }
    gd.draw.dexport[i].product_fmq_url =  (char *) calloc(1,URL_LENGTH);
    STRcopy(gd.draw.dexport[i].product_fmq_url,gd.draw_P->_dexport_info[i].url,URL_LENGTH);
    
    // Get the Default valid time  
    gd.draw.dexport[i].default_valid_minutes = gd.draw_P->_dexport_info[i].valid_minutes;
    
    // Get the Default ID   
    gd.draw.dexport[i].default_serial_no = gd.draw_P->_dexport_info[i].default_id_no;
  }

  return 0;
  
}
/************************************************************************
 * LOAD_OVERLAY_INFO:  Scan info file and record info about overlay
 *         sources. Returns number of overlay info lines found &
 *         filled;
 *
 */

int LegacyParams::_loadOverlayInfo(const char *param_buf, long param_buf_len,
                                   long line_no,
                                   int  max_overlays)
{
  int i,num_overlays;
  int  len,total_len;
  int num_fields;
  const char *start_ptr;
  const char *end_ptr;
  char    *cfield[32];
   
  char full_line[BUFSIZ];
    
  for(i=0; i < 32; i++)  cfield[i] = (char *) calloc(1,64);  /* get space for sub strings */

  /* read all the lines in the information file */
  num_overlays = 0;
  total_len = 0;
  start_ptr = param_buf;
  while((end_ptr = strchr(start_ptr,'\n')) != NULL &&
        (total_len < param_buf_len) && 
        (num_overlays < max_overlays)) {
    len = (end_ptr - start_ptr)+1;
    // Skip over blank, short or commented lines
    if((len > 20)  && *start_ptr != '#') {
      
      STRcopy(full_line, start_ptr, len);
      usubstitute_env(full_line, BUFSIZ);
      
      // over[num_overlays] = (Overlay_t *) calloc(1,sizeof(Overlay_t));
      
      num_fields = STRparse(full_line,cfield,BUFSIZ,32,64);  /* separate into substrings */
      
      if(num_fields >= 7) {    /* Is a correctly formatted line */
        // STRcopy(over[num_overlays]->map_code,cfield[0],LABEL_LENGTH);
        // STRcopy(over[num_overlays]->control_label,cfield[1],LABEL_LENGTH);
        // STRcopy(over[num_overlays]->map_file_name,cfield[2],NAME_LENGTH);
        // over[num_overlays]->default_on_state = atoi(cfield[3]);
        // over[num_overlays]->line_width = atoi(cfield[3]);
        // if(over[num_overlays]->line_width <=0) 
        //   over[num_overlays]->line_width = 1;
        // over[num_overlays]->detail_thresh_min = atof(cfield[4]);
        // over[num_overlays]->detail_thresh_max = atof(cfield[5]);
        
        // over[num_overlays]->active = over[num_overlays]->default_on_state;
        
        // over[num_overlays]->color_name[0] = '\0';
        // for(i=6; i < num_fields; i++) {
        //   strncat(over[num_overlays]->color_name,cfield[i],NAME_LENGTH-1);
        //   strncat(over[num_overlays]->color_name," ",NAME_LENGTH-1);
        // }
        // over[num_overlays]->color_name[strlen(over[num_overlays]->color_name) -1] = '\0';
        
        /* strip underscores out of control label */
        // for(i = strlen(over[num_overlays]->control_label)-1;i >0 ; i--) {
        //   if (gd.replace_underscores && over[num_overlays]->control_label[i] == '_') 
        //     over[num_overlays]->control_label[i] = ' ';
        // }
        
        num_overlays++;
      }
    }

    total_len += len  +1;
    start_ptr = end_ptr +1; // Skip past the newline
    line_no++;
  }

  for(i=0; i < 32; i++)  free(cfield[i]);         /* free space for sub strings */
     
  return num_overlays;
}


/************************************************************************
 * LOAD_OVERLAY_DATA: Load each Map
 */

int LegacyParams::_loadOverlayData(int  num_overlays)
{

  // int i;

#ifdef JUNK
  Overlay_t    *ov;    /* pointer to the current overlay structure */
  const char *map_file_subdir = gd.map_file_subdir;
  
  /* Read in each overlay file */
  for(i=0; i < num_overlays; i++) {
    ov = over[i];
    ov->num_polylines = 0;
    ov->num_labels = 0;
    ov->num_icons = 0;
    
    if(strstr(ov->map_file_name,".shp") != NULL  ||
       strstr(ov->map_file_name,".shx") != NULL) {
      
      load_shape_map(ov,map_file_subdir);

    } else {  // Assume RAP Map Format 
      load_rap_map(ov,map_file_subdir);
    }
    
    if(gd.debug)
      printf("Overlay File %s contains %ld Polylines, %ld Icon_defns, %ld Icons, %ld Labels\n",
             ov->map_file_name,ov->num_polylines,ov->num_icondefs,ov->num_icons,ov->num_labels);
    
  }  // End for(i=0; i < num_overlays ...
#endif
  
  return 0;
}

/************************************************************************
 * INIT_OVER_DATA_LINKS:  Scan cidd_overlays.info file and setup
 *
 */ 

int LegacyParams::_initOverlays(const char *param_buf,
                                long param_buf_len,
                                long line_no)
  
{

  gd.num_map_overlays =
    _loadOverlayInfo(param_buf, param_buf_len, line_no, MAX_OVERLAYS);
  
  if(_loadOverlayData(gd.num_map_overlays) != 0) {
    fprintf(stderr,"Problem loading overlay data\n");
    return -1;
  }
  
  // calc_local_over_coords();

  return 0;
  
}
