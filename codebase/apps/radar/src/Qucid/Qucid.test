/**********************************************************************
 * TDRP params for ./Qucid
 **********************************************************************/

//======================================================================
//
// Qucid is an integrating display for weather data products.
//
// This is a C++ application using the QT GUI toolkit. It is based on 
//   the legacy CIDD app.
//
//======================================================================
 
//======================================================================
//
// DEBUGGING AND PROCESS CONTROL.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_NORM
//     DEBUG_VERBOSE
//     DEBUG_EXTRA
//

debug = DEBUG_OFF;

///////////// check_ray_alloc /////////////////////////
//
// Print out checks on ray memory allocation.
// If TRUE, the app will keep track of the number of rays allocated and 
//   freed, and print out that information every 100 rays.
//
// Type: boolean
//

check_ray_alloc = FALSE;

///////////// register_with_procmap ///////////////////
//
// Option to register this process with the process mapper (procmap).
// If TRUE, every minute this process will register a heartbeat with 
//   procmap. If the process hangs, it will be restared by the 
//   auto_restarter.
//
// Type: boolean
//

register_with_procmap = FALSE;

///////////// instance ////////////////////////////////
//
// Process instance.
// Used for registration with procmap.
//
// Type: string
//

instance = "test";

//======================================================================
//
// REALTIME DATA INPUT.
//
//======================================================================
 
///////////// input_mode //////////////////////////////
//
// Method for reading the input data.
// 	IWRF_FMQ_INPUT: read IWRF moments from an FMQ.
// 	IWRF_TCP_INPUT: read an IWRF moments stream from a TCP socket.
// 	SIMULATED_INPUT: internally-generated test pattern data.
// 	DSR_FMQ_INPUT: deprecated.
//
// Type: enum
// Options:
//     IWRF_FMQ_INPUT
//     IWRF_TCP_INPUT
//     SIMULATED_INPUT
//     DSR_FMQ_INPUT
//

input_mode = IWRF_FMQ_INPUT;

///////////// input_fmq_url ///////////////////////////
//
// DSR_FMQ_INPUT or IWRF_FMQ_INPUT mode: input URL for moments data from 
//   an FMQ.
// Full url is of the form fmqp:://hostname:port:path. Path does not in 
//   lude the file extension.
//
// Type: string
//

input_fmq_url = "/tmp/fmq/test";

///////////// seek_to_start_of_fmq ////////////////////
//
// Option to seek to the start of the input FMQ.
// If TRUE, the program will seek to the start of the fmq and read the 
//   entire contents at startup. If FALSE, it will read only new data as 
//   it arrives.
//
// Type: boolean
//

seek_to_start_of_fmq = FALSE;

///////////// input_tcp_host //////////////////////////
//
// IWRF_TCP_INPUT: name of host running IWRF moments server.
//
// Type: string
//

input_tcp_host = "localhost";

///////////// input_tcp_port //////////////////////////
//
// IWRF_TCP_INPUT: port for IWRF moments server.
//
// Type: int
//

input_tcp_port = 11000;

///////////// beam_queue_size /////////////////////////
//
// Size of the internal queue used to store beams.
// The reader runs in a separate thread, and stored the beams in a 
//   queue. The main thread then grabs the available beams from the queue 
//   as they become available.
//
// Type: int
//

beam_queue_size = 400;

//======================================================================
//
// ARCHIVE MODE.
//
//======================================================================
 
///////////// begin_in_archive_mode ///////////////////
//
// Option to begin in archive mode.
// If TRUE, the app will start up and read data from the 
//   archive_data_url, at the specified start time. If the start time is 
//   not set, the start time will be set to NOW.
//
// Type: boolean
//

begin_in_archive_mode = TRUE;

///////////// archive_start_time //////////////////////
//
// Start time for archive mode.
// In archive mode, data retrieval starts at this time.
//
// Type: string
//

archive_start_time = "1970 01 01 00 00 00";

///////////// archive_time_span_secs //////////////////
//
// Time span in ARCHIVE mode (secs).
// Archive end time = archive_start_time + archive_time_span.
//
// Type: double
//

archive_time_span_secs = 3600;

///////////// archive_data_url ////////////////////////
//
// URL for archive data files.
// This should point to a CfRadial moments data set.
//
// Type: string
//

archive_data_url = ".";

//======================================================================
//
// STATUS TO BE SHOWN IN GUI.
//
//======================================================================
 
///////////// show_status_in_gui //////////////////////
//
// Indicate which status items to show in GUI.
// These items are shown in the left panel in the GUI. Setting an item 
//   to false will hide it in the GUI.
//
// Type: struct
//   typedef struct {
//      boolean azimuth;
//      boolean elevation;
//      boolean fixed_angle;
//      boolean volume_number;
//      boolean sweep_number;
//      boolean n_samples;
//      boolean n_gates;
//      boolean gate_length;
//      boolean pulse_width;
//      boolean prf_mode;
//      boolean prf;
//      boolean nyquist;
//      boolean max_range;
//      boolean unambiguous_range;
//      boolean measured_power_h;
//      boolean measured_power_v;
//      boolean scan_name;
//      boolean scan_mode;
//      boolean polarization_mode;
//      boolean latitude;
//      boolean longitude;
//      boolean altitude;
//      boolean altitude_rate;
//      boolean sun_elevation;
//      boolean sun_azimuth;
//      boolean speed;
//      boolean heading;
//      boolean track;
//   }
//
//

show_status_in_gui = { TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE };

//======================================================================
//
// FIELDS TO BE DISPLAYED.
//
//======================================================================
 
///////////// color_scale_dir /////////////////////////
//
// Directory for color scales.
// You can set this in 2 ways:
//
// (a) Set to the absolute path
//
// (b)Set as a path relative to the location of the application binary 
//   executable.
//
// Type: string
//

color_scale_dir = "$(HOME)/git/lrose-displays/color_scales";

//======================================================================
//
// <GRIDS>.
//
//======================================================================
 
///////////// fields //////////////////////////////////
//
// Fields to be displayed.
// /nbutton_label: appears on the GUI. /nlegend_label: appears in the 
//   plot. /nurl: location of data or data server. /nfield_name: name in 
//   the file. /ncolor_map: name of color map in color_scale_dir. /nunits: 
//   units to appear on the display. /ncontour_low: contour rendering 
//   lower limit. /ncontour_high: contour rendering upper limit. 
//   /ncontour_interval: contour rendering interval. /nrender_mode:/n  
//   POLYGONS: Rectangle/polygon fills of gridded data./n  
//   FILLED_CONTOURS: false color filled contours./n  LINE_CONTOURS: line 
//   contours./n  DYNAMIC_CONTOURS: auto switching between cart and 
//   cont./n         uses dynamic_contour_treshold./ndisplay_in_menu: 
//   display this field in the menu./nbackground_render: render this field 
//   automatically in the background./ncomposite_mode: display max over 
//   height./nauto_scale: scale automatically./nauto_render: render 
//   automatically./n.
//
// Type: struct
//   typedef struct {
//      string button_label;
//      string legend_label;
//      string url;
//      string field_name;
//      string color_map;
//      string field_units;
//      double contour_low;
//      double contour_high;
//      double contour_interval;
//      render_mode_t render_mode;
//        Options:
//          POLYGONS
//          FILLED_CONTOURS
//          DYNAMIC_CONTOURS
//          LINE_CONTOURS
//      boolean display_in_menu;
//      boolean background_render;
//      boolean composite_mode;
//      boolean auto_scale;
//      boolean auto_render;
//   }
//
// 1D array - variable length.
//

fields = {
  { "MRMS_DBZ_COMP_2D", "WIDE_MRMS_DBZ_COMP_2D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/mrms_comp?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, TRUE, FALSE, FALSE},
  { "MRMS_DBZ_COMP_3D", "WIDE_MRMS_DBZ_COMP_3D", "mdvp::composite//front.eol.ucar.edu:8080:pecan/mdv/radarCart/mrms_mosaic?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "MRMS_DBZ_3D", "WIDE_MRMS_DBZ_3D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/mrms_mosaic?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, POLYGONS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, POLYGONS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, POLYGONS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, POLYGONS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, POLYGONS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_DBZ_COMP_2D", "WIDE_NCAR_DBZ_COMP_2D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_comp?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, TRUE, FALSE, FALSE},
  { "NCAR_DBZ_COMP_3D", "WIDE_NCAR_DBZ_COMP_3D", "mdvp::composite//front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_DBZ_3D", "WIDE_NCAR_DBZ_3D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_ZDR_COMP", "WIDE_NCAR_ZDR_COMP", "mdvp::composite//front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "ZDR", "zdr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_ZDR_3D", "WIDE_NCAR_ZDR_3D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "ZDR", "zdr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_WIDTH_COMP", "WIDE_NCAR_WIDTH_COMP", "mdvp::composite//front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "WIDTH", "width.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_WIDTH_3D", "WIDE_NCAR_WIDTH_3D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "WIDTH", "width.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "NCAR_RANGE_3D", "WIDE_NCAR_RANGE_3D", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/radarCart/3D_mosaic?use_http=true", "range", "range_250.colors", "km", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SURF_Temp", "WIDE_Temp", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/surf_interp?use_http=true", "Temp", "temp.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SURF_DewPt", "WIDE_DewPt", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/surf_interp?use_http=true", "DewPoint", "temp.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SURF_Conv", "WIDE_Conv", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/surf_interp?use_http=true", "Convergence", "conv.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "Terrain", "WIDE_Terrain", "mdvp::terrain//front.eol.ucar.edu:8080:pecan/mdv/terrain?use_http=true", "Elevation", "terrain_pecan.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_=====", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_=====", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_=====", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_=====", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "RUC-temp", "WIDE_RUC-temp", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/ruc?use_http=true", "TMP", "temp.colors", "C", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "RUC-RH", "WIDE_RUC-RH", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/ruc?use_http=true", "RH", "rh.colors", "%", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "RUC-Wspd", "WIDE_RUC-Wspd", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/ruc?use_http=true", "speed", "wind_speed.colors", "m/s", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "=========", "WIDE_========", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "=========", "WIDE_========", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "=========", "WIDE_========", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "=========", "WIDE_========", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "=========", "WIDE_========", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SAT_Vis", "WIDE_Vis", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/sat/goes13_1km?use_http=true", "gvar_ch1", "sat_cloud.colors", "albedo", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SAT_IR2", "WIDE_IR2", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/sat/goes13_4km?use_http=true", "gvar_ch2", "sat_tempC_toga.colors", "C", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SAT_IR3", "WIDE_IR3", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/sat/goes13_4km?use_http=true", "gvar_ch3", "sat_tempC_2.colors", "C", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SAT_IR4", "WIDE_IR4", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/sat/goes13_4km?use_http=true", "gvar_ch4", "sat_tempC_2.colors", "C", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SAT_WV", "WIDE_WV", "mdvp:://front.eol.ucar.edu:8080:pecan/mdv/sat/goes13_4km?use_http=true", "gvar_ch6", "wv_uwC.colors", "C", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_====", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_====", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "========", "WIDE_====", "mdvp::static//front.eol.ucar.edu:8080:/spacer?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_DBZ_F", "SPOLQC_DBZ_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "DBZ_F", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_DBZM_F", "SPOLQC_DBZM_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "DBZM_F", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_VEL_F", "SPOLQC_VEL_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "VEL_F", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_VEL_HV_F", "SPOLQC_VEL_HV_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "VEL_HV_F", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_WIDTH_F", "SPOLQC_WIDTH_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "WIDTH_F", "width.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_NCP_F", "SPOLQC_NCP_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "NCP_F", "ncp.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOLQC==", "SPOLQC_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOLQC==", "SPOLQC_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_ZDR_F", "SPOLQC_ZDR_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "ZDR_F", "zdr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_ZDRM_F", "SPOLQC_ZDRM_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "ZDRM_F", "zdr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_LDRH_F", "SPOLQC_LDRH_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "LDRH_F", "ldr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_LDRV_F", "SPOLQC_LDRV_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "LDRV_F", "ldr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_PHIDP_F", "SPOLQC_PHIDP_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "PHIDP_F", "phidp_alt.colors", "deg", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_PHIDP2_F", "SPOLQC_PHIDP2_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "PHIDP_F", "phidp_pecan_rhi.colors", "deg", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOLQC_KDP_F", "SPOLQC_KDP_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/qc_moments/sband/sur?use_http=true", "KDP_F", "kdp_sband.colors", "deg/km", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOLQC==", "SPOLQC_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_DBZ_F", "SPOL_DBZ_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "DBZ_F", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_DBZ", "SPOL_DBZ", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_DBZ_BRAGG_F", "SPOL_DBZ_BRAGG_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/bragg/sur?use_http=true", "DBZ_F", "dbz_bragg.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_DBZ_BRAGG", "SPOL_DBZ_BRAGG", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "DBZ", "dbz_bragg.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_VEL_F", "SPOL_VEL_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "VEL_F", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_VEL", "SPOL_VEL", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "VEL", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_VELALT_F", "SPOL_VELALT_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "VEL_ALT_F", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_VELALT", "SPOL_VELALT", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "VEL_ALT", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_NCP", "SPOL_NCP", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "NCP", "ncp.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_NCP_F", "SPOL_NCP_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "NCP_F", "ncp.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_KDP_F", "SPOL_KDP_F", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "KDP_F", "kdp_sband.colors", "deg/km", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "SPOL_KDP", "SPOL_KDP", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/spol/moments/sband/sur?use_http=true", "KDP", "kdp_sband.colors", "deg/km", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOL==", "SPOL_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOL==", "SPOL_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOL==", "SPOL_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "==SPOL==", "SPOL_========", "mdvp::static//localhost::/spacer?", "None", "none.colors", "m", 0, 0, 0, DYNAMIC_CONTOURS, FALSE, FALSE, FALSE, FALSE, FALSE},
  { "KAMA_DBZ", "NEXR_KAMA_DBZ", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/kama/moments?use_http=true", "DBZ", "dbz.colors", "dBZ", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "KAMA_VEL", "NEXR_KAMA_VEL", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/kama/moments?use_http=true", "VEL", "vel.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "KAMA_WIDTH", "NEXR_KAMA_WIDTH", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/kama/moments?use_http=true", "WIDTH", "width.colors", "m/s", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "KAMA_ZDR", "NEXR_KAMA_ZDR", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/kama/moments?use_http=true", "ZDR", "zdr.colors", "dB", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "KAMA_PHIDP", "NEXR_KAMA_PHIDP", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/kama/moments?use_http=true", "PHIDP", "phidp.colors", "deg", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "KAMA_RHOHV", "NEXR_KAMA_RHOHV", "mdvp:://front.eol.ucar.edu:8080:pecan/cfradial/kama/moments?use_http=true", "RHOHV", "rhohv.colors", "-", -5, 80, 5, POLYGONS, TRUE, FALSE, FALSE, FALSE, FALSE},
  { "========", "NEXR_========", "mdvp::static//front.eol.ucar.edu:8080:/spacer/moments?use_http=true", "Elevation", "none.colors", "m", -5, 80, 5, DYNAMIC_CONTOURS, TRUE, FALSE, FALSE, FALSE, FALSE}
};

//======================================================================
//
// </GRIDS>.
//
//======================================================================
 
///////////// background_render_mins //////////////////
//
// Background rendering time period in minutes.
// Any field which is viewed will continue to be rendered in the 
//   background for this number of minutes.
// Minimum val: 0
//
// Type: double
//

background_render_mins = 2;

///////////// use_field_label_in_title ////////////////
//
// Option to use field label in the display title.
// If TRUE, the label will be used in the title. If FALSE, the raw_name 
//   or filtered name will be used.
//
// Type: boolean
//

use_field_label_in_title = FALSE;

//======================================================================
//
// SET MAX RANGE.
//
//======================================================================
 
///////////// set_max_range ///////////////////////////
//
// Option to set the max range to be used for plotting.
// If FALSE, the max range of the data will be used. If TRUE, 
//   max_range_km will override the max range in the data.
//
// Type: boolean
//

set_max_range = FALSE;

///////////// max_range_km ////////////////////////////
//
// Max range for the display (km).
//
// Type: double
//

max_range_km = 225;

//======================================================================
//
// DISPLAY TYPE.
//
//======================================================================
 
///////////// display_mode ////////////////////////////
//
// Main display mode.
// 	POLAR_DISPLAY - normal HORIZ and VERT display. 	BSCAN_DISPLAY - 
//   BSCAN mode.
//
// Type: enum
// Options:
//     POLAR_DISPLAY
//     BSCAN_DISPLAY
//

display_mode = POLAR_DISPLAY;

//======================================================================
//
// NAMES AND LABELS.
//
//======================================================================
 
///////////// override_radar_name /////////////////////
//
// Option to override radar name in the data.
//
// Type: boolean
//

override_radar_name = FALSE;

///////////// radar_name //////////////////////////////
//
// Radar name if overridden.
//
// Type: string
//

radar_name = "SPOL";

///////////// display_site_name ///////////////////////
//
// Option to display the site name in the left panel.
//
// Type: boolean
//

display_site_name = FALSE;

///////////// override_site_name //////////////////////
//
// Option to override site name in the data.
//
// Type: boolean
//

override_site_name = FALSE;

///////////// site_name ///////////////////////////////
//
// Site name if overridden.
//
// Type: string
//

site_name = "MARSHALL";

//======================================================================
//
// WINDOW DIMENSIONS AND PLOTTING DETAILS.
//
//======================================================================
 
///////////// main_window_width ///////////////////////
//
// Startup width of main window (pixels).
//
// Type: int
//

main_window_width = 1100;

///////////// main_window_height //////////////////////
//
// Startup height of main window (pixels).
//
// Type: int
//

main_window_height = 635;

///////////// main_window_start_x /////////////////////
//
// Startup X for main window (pixels).
//
// Type: int
//

main_window_start_x = 0;

///////////// main_window_start_y /////////////////////
//
// Startup Y for main window (pixels).
//
// Type: int
//

main_window_start_y = 0;

///////////// color_scale_width ///////////////////////
//
// Width of color scale (pixels).
//
// Type: int
//

color_scale_width = 40;

///////////// label_font_size /////////////////////////
//
// Basic font size for labels (pixels).
// Some of the labels are scaled relative to this size.
//
// Type: int
//

label_font_size = 12;

///////////// background_color2 ///////////////////////
//
// Color of main display background.
//
// Type: string
//

background_color2 = "black";

///////////// text_color //////////////////////////////
//
// Color of text annotation in main display.
//
// Type: string
//

text_color = "yellow";

///////////// grid_and_range_ring_color ///////////////
//
// Color of grids and range rings.
//
// Type: string
//

grid_and_range_ring_color = "white";

///////////// range_ring_label_font_size //////////////
//
// Font size for labels on range rings (pixels).
//
// Type: int
//

range_ring_label_font_size = 8;

///////////// click_cross_color ///////////////////////
//
// Color of cross at click point.
//
// Type: string
//

click_cross_color = "cyan";

///////////// click_cross_size ////////////////////////
//
// Size of cross at click point (pixels).
// Size of cross drawn at click point, to select data.
//
// Type: int
//

click_cross_size = 11;

///////////// click_cross_line_width //////////////////
//
// Line width for click cross.
//
// Type: int
//

click_cross_line_width = 1;

//======================================================================
//
// HORIZ MODE DISPLAY.
//
//======================================================================
 
///////////// horiz_display_type //////////////////////
//
// Type of display to use for the HORIZ window.
// 	HORIZ_FULL - Display the full 360 degrees of the HORIZ. This is the 
//   default.
// 	HORIZ_AIRBORN - Use the airborn radar HORIZ display. This display 
//   shows just the 180 degrees of radar pointing forward from the nose of 
//   the plane.
//
// Type: enum
// Options:
//     HORIZ_FULL
//     HORIZ_AIRBORNE
//

horiz_display_type = HORIZ_FULL;

///////////// horiz_aspect_ratio //////////////////////
//
// Aspect ratio (width/height) of HORIZ window.
//
// Type: double
//

horiz_aspect_ratio = 1;

///////////// horiz_grids_on_at_startup ///////////////
//
// Set HORIZ grids overlay on at startup.
//
// Type: boolean
//

horiz_grids_on_at_startup = FALSE;

///////////// horiz_range_rings_on_at_startup /////////
//
// Set HORIZ range rings overlay on at startup.
//
// Type: boolean
//

horiz_range_rings_on_at_startup = TRUE;

///////////// horiz_azimuth_lines_on_at_startup ///////
//
// Set HORIZ azimuth lines overlay on at startup.
//
// Type: boolean
//

horiz_azimuth_lines_on_at_startup = TRUE;

///////////// horiz_main_legend_pos ///////////////////
//
// Position of main legend in the HORIZ plot window.
// This include time, field name and elevation angle.
//
// Type: enum
// Options:
//     LEGEND_TOP_LEFT
//     LEGEND_TOP_RIGHT
//     LEGEND_BOTTOM_LEFT
//     LEGEND_BOTTOM_RIGHT
//

horiz_main_legend_pos = LEGEND_TOP_LEFT;

///////////// horiz_override_rendering_beam_width /////
//
// Option to override the azimuth beam width for rendering.
// Normally Qucid determines the azimuth rendering beam width 
//   automatically. You can override this and specifcally set the azimuth 
//   beam width for rendering.
//
// Type: boolean
//

horiz_override_rendering_beam_width = FALSE;

///////////// horiz_rendering_beam_width //////////////
//
// Rendering beam width, if override is active.
// See 'horiz_override_rendering_beam_width'.
//
// Type: double
//

horiz_rendering_beam_width = 1;

//======================================================================
//
// VERT MODE DISPLAY.
//
//======================================================================
 
///////////// vert_window_width ///////////////////////
//
// Startup width of VERT window (pixels).
//
// Type: int
//

vert_window_width = 500;

///////////// vert_window_height //////////////////////
//
// Startup height of VERT window (pixels).
//
// Type: int
//

vert_window_height = 500;

///////////// vert_window_start_x /////////////////////
//
// Startup X for VERT window (pixels).
//
// Type: int
//

vert_window_start_x = 1100;

///////////// vert_window_start_y /////////////////////
//
// Startup Y for VERT window (pixels).
//
// Type: int
//

vert_window_start_y = 0;

///////////// vert_top_margin2 ////////////////////////
//
// Height of top margin in VERT mode (pixels).
// Titles go in the top margin.
//
// Type: int
//

vert_top_margin2 = 20;

///////////// vert_bottom_margin //////////////////////
//
// Height of bottom margin in VERT mode (pixels).
// Time scale goes in the bottom margin.
//
// Type: int
//

vert_bottom_margin = 20;

///////////// vert_left_margin2 ///////////////////////
//
// Width of left margin in VERT mode (pixels).
// Height scale goes in the left margin.
//
// Type: int
//

vert_left_margin2 = 20;

///////////// vert_right_margin2 //////////////////////
//
// Width of right margin in VERT mode (pixels).
// Height scale goes in the right margin.
//
// Type: int
//

vert_right_margin2 = 20;

///////////// vert_label_font_size ////////////////////
//
// Font size for labels on range rings (pixels).
//
// Type: int
//

vert_label_font_size = 8;

///////////// vert_axis_tick_len //////////////////////
//
// Length of ticks on axes (pixels).
//
// Type: int
//

vert_axis_tick_len = 7;

///////////// vert_n_ticks_ideal //////////////////////
//
// Ideal number of ticks on axes.
//
// Type: int
//

vert_n_ticks_ideal = 7;

///////////// vert_text_margin ////////////////////////
//
// Margin around some text (pixels).
//
// Type: int
//

vert_text_margin = 5;

///////////// vert_display_180_degrees ////////////////
//
// Flag indicating to display full 180 degrees in VERT window. If set to 
//   false, the VERT window will just display 90 degrees of the VERT.
//
// Type: boolean
//

vert_display_180_degrees = FALSE;

///////////// vert_aspect_ratio ///////////////////////
//
// Aspect ratio (width/height) of VERT window.
//
// Type: double
//

vert_aspect_ratio = 1;

///////////// vert_max_height_km //////////////////////
//
// Max height of data in VERT window (km).
//
// Type: double
//

vert_max_height_km = 25;

///////////// vert_color_scale_width //////////////////
//
// Width of color scale for VERT window (pixels).
//
// Type: int
//

vert_color_scale_width = 40;

///////////// vert_grids_on_at_startup ////////////////
//
// Set VERT grids overlay on at startup.
//
// Type: boolean
//

vert_grids_on_at_startup = TRUE;

///////////// vert_range_rings_on_at_startup //////////
//
// Set VERT range rings overlay on at startup.
//
// Type: boolean
//

vert_range_rings_on_at_startup = TRUE;

///////////// vert_elevation_lines_on_at_startup //////
//
// Set VERT elevation lines overlay on at startup.
//
// Type: boolean
//

vert_elevation_lines_on_at_startup = FALSE;

///////////// vert_main_legend_pos ////////////////////
//
// Position of main legend in the VERT plot window.
// This include time, field name and elevation angle.
//
// Type: enum
// Options:
//     LEGEND_TOP_LEFT
//     LEGEND_TOP_RIGHT
//     LEGEND_BOTTOM_LEFT
//     LEGEND_BOTTOM_RIGHT
//

vert_main_legend_pos = LEGEND_TOP_LEFT;

///////////// vert_beam_queue_size ////////////////////
//
// Size of the queue for VERT beams.
// After the queue reaches this size, older beams are discarded.
//
// Type: int
//

vert_beam_queue_size = 360;

///////////// vert_override_rendering_beam_width //////
//
// Option to override the azimuth beam width for rendering.
// Normally Qucid determines the azimuth rendering beam width 
//   automatically. You can override this and specifcally set the azimuth 
//   beam width for rendering.
//
// Type: boolean
//

vert_override_rendering_beam_width = FALSE;

///////////// vert_rendering_beam_width ///////////////
//
// Rendering beam width, if override is active.
// See 'vert_override_rendering_beam_width'.
//
// Type: double
//

vert_rendering_beam_width = 1;

//======================================================================
//
// BSCAN TIME LIMITS.
//
//======================================================================
 
///////////// bscan_time_span_secs ////////////////////
//
// Number of seconds in BSCAN display.
// In REALTIME mode, when we reach the right-hand side of the display, 
//   the existing plot will be moved left to make room for more data.
//
// Type: double
//

bscan_time_span_secs = 60;

///////////// bscan_truncate_start_time ///////////////
//
// Option to truncate the plot start time to even seconds.
// If true, we truncate the start time to the previous second.
//
// Type: boolean
//

bscan_truncate_start_time = FALSE;

///////////// bscan_subsec_precision //////////////////
//
// Precision of subseconds in time labels.
// Number of decimals of precision in time labels. Set to 0 for times in 
//   integer seconds.
// Minimum val: 0
// Maximum val: 9
//
// Type: int
//

bscan_subsec_precision = 3;

//======================================================================
//
// BSCAN REALTIME CONTROLS.
//
//======================================================================
 
///////////// bscan_realtime_fraction_saved ///////////
//
// What fraction of the existing data to save when moving the plot to 
//   the left.
// When we reach the right-hand side of the display, we need to move the 
//   plot to the left. This is the fraction of the plot that is saved 
//   after the move has taken place.
//
// Type: double
//

bscan_realtime_fraction_saved = 0.5;

///////////// bscan_min_secs_between_reading_beams ////
//
// Min time between incoming beams (secs).
// If beams arrive too fast, we discard some so that the time between 
//   the beams is at least this long.
//
// Type: double
//

bscan_min_secs_between_reading_beams = 0.01;

///////////// bscan_min_secs_between_rendering_beams //
//
// Min time between rendering (secs).
// Setting this higher makes the display less smooth, but prevents the 
//   display from taking up too much CPU and/or GPU.
//
// Type: double
//

bscan_min_secs_between_rendering_beams = 0;

//======================================================================
//
// BSCAN RANGE AND ALTITUDE LIMITS.
//
//======================================================================
 
///////////// bscan_specify_range_limits //////////////
//
// Specify the min and max range when in range mode.
// If false, we will use the start range and max range in the data.
//
// Type: boolean
//

bscan_specify_range_limits = TRUE;

///////////// bscan_min_range_km //////////////////////
//
// Min range to be plotted (km).
// Used if 'bscan_specify_range_limits' is true.
//
// Type: double
//

bscan_min_range_km = 0;

///////////// bscan_max_range_km //////////////////////
//
// Max range to be plotted (km).
// Used if 'bscan_specify_range_limits' is true.
//
// Type: double
//

bscan_max_range_km = 25;

///////////// bscan_min_altitude_km ///////////////////
//
// Min altitude plotted (km).
//
// Type: double
//

bscan_min_altitude_km = -0.5;

///////////// bscan_max_altitude_km ///////////////////
//
// Max altitude plotted (km).
//
// Type: double
//

bscan_max_altitude_km = 25;

///////////// bscan_altitude_in_feet //////////////////
//
// Use feet for altitude units?.
//
// Type: boolean
//

bscan_altitude_in_feet = FALSE;

///////////// bscan_range_in_feet /////////////////////
//
// Use feet for range units?.
//
// Type: boolean
//

bscan_range_in_feet = FALSE;

///////////// bscan_range_axis_mode ///////////////////
//
// Options for plotting range in the vertical scale.
// RANGE_AXIS_UP - instrument is at the bottom, range plotted positively 
//   upwards. RANGE_AXIS_DOWN: instrument is at the top, range plotted 
//   downwards. RANGE_AXIS_ALTITUDE: vertical scale represents the 
//   altitude of the gates in earth coordinates.
//
// Type: enum
// Options:
//     RANGE_AXIS_UP
//     RANGE_AXIS_DOWN
//     RANGE_AXIS_ALTITUDE
//

bscan_range_axis_mode = RANGE_AXIS_ALTITUDE;

//======================================================================
//
// BSCAN ANGLE LIMITS.
//
//======================================================================
 
///////////// bscan_specify_elevation_limits //////////
//
// Specify the min and max elevation angle.
// If true, only beams within the specified limits will be plotted.
//
// Type: boolean
//

bscan_specify_elevation_limits = FALSE;

///////////// bscan_min_elevation_deg /////////////////
//
// Min elevation angle to be plotted (deg).
// Used if 'bscan_specify_elevation_limits' is true.
//
// Type: double
//

bscan_min_elevation_deg = 89;

///////////// bscan_max_elevation_deg /////////////////
//
// Max elevation angle to be plotted (deg).
// Used if 'bscan_specify_elevation_limits' is true.
//
// Type: double
//

bscan_max_elevation_deg = 91;

///////////// bscan_specify_azimuth_limits ////////////
//
// Specify the min and max azimuth angle.
// If true, only beams within the specified limits will be plotted.
//
// Type: boolean
//

bscan_specify_azimuth_limits = FALSE;

///////////// bscan_min_azimuth_deg ///////////////////
//
// Min azimuth angle to be plotted (deg).
// Used if 'bscan_specify_azimuth_limits' is true.
//
// Type: double
//

bscan_min_azimuth_deg = 89;

///////////// bscan_max_azimuth_deg ///////////////////
//
// Max azimuth angle to be plotted (deg).
// Used if 'bscan_specify_azimuth_limits' is true.
//
// Type: double
//

bscan_max_azimuth_deg = 91;

//======================================================================
//
// BSCAN CENSOR DATA BELOW SURFACE.
//
//======================================================================
 
///////////// bscan_censor_data_below_surface /////////
//
// Option to censor data below the measured surface.
//
// Type: boolean
//

bscan_censor_data_below_surface = FALSE;

///////////// bscan_surface_field /////////////////////
//
// Name of field used to identify the surface from the data.
// The surface will be identified at the gate with the maximum value in 
//   this field.
//
// Type: string
//

bscan_surface_field = "DBZ";

///////////// bscan_min_range_to_surface_km ///////////
//
// Minumum range to the surface (km).
// We will search for the surface echo in the gates beyound this range.
//
// Type: double
//

bscan_min_range_to_surface_km = 0.5;

///////////// bscan_surface_range_margin_km ///////////
//
// Margin of data plotted beyond the surface (km).
// We will censor the data beyond the surface gate, plus this range 
//   margin.
//
// Type: double
//

bscan_surface_range_margin_km = 0.2;

///////////// bscan_max_field_val_below_surface ///////
//
// Maximum value of the surface field, below the measured surface.
// After finding the range to the surface, we inspect the surface_field 
//   values below the surface. If we find values that exceed this 
//   parameter, we conclude that the surface cannot be reliably found.
//
// Type: double
//

bscan_max_field_val_below_surface = 5;

//======================================================================
//
// BSCAN MARGINS.
//
//======================================================================
 
///////////// bscan_top_margin ////////////////////////
//
// Height of top margin in BSCAN mode (pixels).
// Titles go in the top margin.
//
// Type: int
//

bscan_top_margin = 40;

///////////// bscan_bottom_margin /////////////////////
//
// Height of bottom margin in BSCAN mode (pixels).
// Time scale goes in the bottom margin.
//
// Type: int
//

bscan_bottom_margin = 45;

///////////// bscan_left_margin ///////////////////////
//
// Width of left margin in BSCAN mode (pixels).
// Height scale goes in the left margin.
//
// Type: int
//

bscan_left_margin = 50;

///////////// bscan_right_margin //////////////////////
//
// Width of right margin in BSCAN mode (pixels).
// Height scale goes in the right margin.
//
// Type: int
//

bscan_right_margin = 40;

///////////// bscan_axis_tick_len /////////////////////
//
// Length of ticks on axes (pixels).
//
// Type: int
//

bscan_axis_tick_len = 6;

///////////// bscan_n_ticks_ideal /////////////////////
//
// Ideal number of ticks on axes.
//
// Type: int
//

bscan_n_ticks_ideal = 10;

///////////// bscan_text_margin ///////////////////////
//
// Margin around some text (pixels).
//
// Type: int
//

bscan_text_margin = 5;

//======================================================================
//
// BSCAN TITLES, LABELS AND AXES.
//
//======================================================================
 
///////////// bscan_title_font_size ///////////////////
//
// Font size of center title (pixels).
//
// Type: int
//

bscan_title_font_size = 12;

///////////// bscan_axis_label_font_size //////////////
//
// Font size of axis labels in bscan (pixels).
//
// Type: int
//

bscan_axis_label_font_size = 10;

///////////// bscan_axis_values_font_size /////////////
//
// Font size of axis values (pixels).
//
// Type: int
//

bscan_axis_values_font_size = 8;

///////////// bscan_axes_color ////////////////////////
//
// Color of axes in bscan.
//
// Type: string
//

bscan_axes_color = "white";

///////////// bscan_grid_color ////////////////////////
//
// Color of grid lines on bscan.
//
// Type: string
//

bscan_grid_color = "gray";

///////////// bscan_labels_color //////////////////////
//
// Color of labels in bscan.
//
// Type: string
//

bscan_labels_color = "white";

///////////// bscan_draw_time_grid_lines //////////////
//
// Option to draw grid lines across plot at regular time intervals.
//
// Type: boolean
//

bscan_draw_time_grid_lines = TRUE;

///////////// bscan_draw_range_grid_lines /////////////
//
// Option to draw grid lines across plot at regular range intervals.
//
// Type: boolean
//

bscan_draw_range_grid_lines = TRUE;

///////////// bscan_draw_instrument_height_line ///////
//
// Option to draw a line for the instrument location.
//
// Type: boolean
//

bscan_draw_instrument_height_line = TRUE;

///////////// bscan_instrument_height_color ///////////
//
// Color of instrument height line in ALTITUDE plot.
//
// Type: string
//

bscan_instrument_height_color = "white";

//======================================================================
//
// DISTANCE SCALE.
//
//======================================================================
 
///////////// bscan_add_distance_to_time_axis /////////
//
// Option to plot distance as well as time on the time axis.
// If true, extra tick marks will show the distance in km along the time 
//   axis, in addition to the time.
//
// Type: boolean
//

bscan_add_distance_to_time_axis = TRUE;

///////////// bscan_n_segments_for_computing_distance /
//
// Number of segments to be used for computing distance.
// We divide the rays into this number of segments and then compute the 
//   distance travelled during each segment using the change in lat/lon 
//   position. We keep the number of segments reasonably small to avoid 
//   unnecessary CPU usage.
//
// Type: int
//

bscan_n_segments_for_computing_distance = 50;

//======================================================================
//
// BSCAN LEGENDS.
//
//======================================================================
 
///////////// bscan_plot_starting_latlon_as_legend ////
//
// Option to plot the starting lat/lon position as a legend.
// This helps in geolocating the data from a mobile system.
//
// Type: boolean
//

bscan_plot_starting_latlon_as_legend = TRUE;

///////////// bscan_starting_latlon_legend_pos ////////
//
// Position of lat/lon legend in plot.
// The starting latitude/longitude will be plotted as a legend in the 
//   location specified. See 'bscan_plot_starting_latlon_as_legend'.
//
// Type: enum
// Options:
//     LEGEND_TOP_LEFT
//     LEGEND_TOP_RIGHT
//     LEGEND_BOTTOM_LEFT
//     LEGEND_BOTTOM_RIGHT
//

bscan_starting_latlon_legend_pos = LEGEND_TOP_LEFT;

///////////// bscan_plot_mean_track_and_speed_as_legend 
//
// Option to plot the mean track and speed in a legend.
// This helps in geolocating the data from a mobile system.
//
// Type: boolean
//

bscan_plot_mean_track_and_speed_as_legend = TRUE;

///////////// bscan_mean_track_and_speed_legend_pos ///
//
// Position of track/speed legend in plot.
// The mean track and speed will be plotted as a legend in the location 
//   specified. See 'bscan_plot_track_and_speed_as_legend'.
//
// Type: enum
// Options:
//     LEGEND_TOP_LEFT
//     LEGEND_TOP_RIGHT
//     LEGEND_BOTTOM_LEFT
//     LEGEND_BOTTOM_RIGHT
//

bscan_mean_track_and_speed_legend_pos = LEGEND_TOP_RIGHT;

//======================================================================
//
// BSCAN DWELL CONTROLS.
//
//======================================================================
 
///////////// bscan_archive_dwell_auto ////////////////
//
// Compute dwell from image size and time range.
// If TRUE, we compute the optimal dwell so that there will be 
//   approximately 1 dwell for each pixel in the resulting image. If 
//   FALSE, the dwell is specified below.
//
// Type: boolean
//

bscan_archive_dwell_auto = TRUE;

///////////// bscan_archive_dwell_secs ////////////////
//
// Specified dwell time for archive mode (secs).
//
// Type: double
//

bscan_archive_dwell_secs = 0.1;

///////////// bscan_dwell_stats ///////////////////////
//
// Method for computing stats on the dwell.
// Applies to READ_RAYS_IN_INTERVAL mode. MIDDLE refers to the middle 
//   ray in the dwell sequence.
//
// Type: enum
// Options:
//     DWELL_STATS_MEAN
//     DWELL_STATS_MEDIAN
//     DWELL_STATS_MAXIMUM
//     DWELL_STATS_MINIMUM
//     DWELL_STATS_MIDDLE
//

bscan_dwell_stats = DWELL_STATS_MIDDLE;

//======================================================================
//
// SAVING IMAGES TO FILE.
//
// In creating files for the field catalog, the file name is of the 
//   form:
//
// 	category.platform.YYYYMMDDHHmm.product_name.ext
//
// The following parameters control the output directory, and the 
//   construction of the file name.
//
//======================================================================
 
///////////// images_output_dir ///////////////////////
//
// Output directory for images generated by this app.
//
// Type: string
//

images_output_dir = "/tmp/images/Qucid";

///////////// images_write_to_day_dir /////////////////
//
// Option to create a subdirectory for each day.
//
// Type: boolean
//

images_write_to_day_dir = TRUE;

///////////// images_file_name_category ///////////////
//
// Set the category string.
// If empty, no category will be included.
//
// Type: string
//

images_file_name_category = "radar";

///////////// images_file_name_platform ///////////////
//
// Set the platform string.
// If empty, no platform will be included.
//
// Type: string
//

images_file_name_platform = "NSF_NCAR_GV_HCR";

///////////// images_file_name_extension //////////////
//
// Set the extension string. This also governs the file format. It 
//   should be 'png', 'jpg', 'gif' etc.
// An extension is always required.
//
// Type: string
//

images_file_name_extension = "png";

///////////// images_file_name_delimiter //////////////
//
// Set the delimiter between the parts of the file name.
// NOTE: before the extension the delimited is always a period: '.'.
//
// Type: string
//

images_file_name_delimiter = ".";

///////////// images_include_time_part_in_file_name ///
//
// Normally the file name includes a time part: YYYYMMDDHHMMSS.
// If FALSE, the time part will be omitted.
//
// Type: boolean
//

images_include_time_part_in_file_name = TRUE;

///////////// images_include_seconds_in_time_part /////
//
// Normally the time part include the seconds: YYYYMMDDHHMMSS.
// If FALSE, the SS will be excluuded from the time part.
//
// Type: boolean
//

images_include_seconds_in_time_part = FALSE;

///////////// images_include_field_label_in_file_name /
//
// Normally the file name includes the field label (product type).
// If FALSE, the field label will be omitted.
//
// Type: boolean
//

images_include_field_label_in_file_name = TRUE;

///////////// images_include_scan_type_in_file_name ///
//
// Option to include the scan type in the image file name.
// If TRUE, the scan type will be added to the image file name.
//
// Type: boolean
//

images_include_scan_type_in_file_name = FALSE;

///////////// images_include_scan_id_in_file_name /////
//
// Option to include the scan Id in the image file name.
// If TRUE, the scan Id will be added to the image file name.
//
// Type: boolean
//

images_include_scan_id_in_file_name = FALSE;

///////////// images_write_latest_data_info ///////////
//
// Option to write latest_data_info files when an image is created.
//
// Type: boolean
//

images_write_latest_data_info = TRUE;

//======================================================================
//
// OPTION TO CREATE IMAGES AUTOMATICALLY.
//
//======================================================================
 
///////////// images_auto_create //////////////////////
//
// Option to create images automatically.
//
// Type: boolean
//

images_auto_create = FALSE;

///////////// images_creation_mode ////////////////////
//
// Mode for controlling auto image creation.

//
// CREATE_IMAGES_FROM_GUI: create images interactively using the GUI.
//
// CREATE_IMAGES_THEN_EXIT: for the specified start time and time span, 
//   create an output image for every field in the fields array, and then 
//   exit.
//
// CREATE_IMAGES_ON_REALTIME_SCHEDULE: wait for the scheduled time, then 
//   generate an image for each field.
//
// CREATE_IMAGES_ON_ARCHIVE_SCHEDULE: for each scheduled time between 
//   the start and end times, generate an image for each field.
//
// Type: enum
// Options:
//     CREATE_IMAGES_THEN_EXIT
//     CREATE_IMAGES_ON_REALTIME_SCHEDULE
//     CREATE_IMAGES_ON_ARCHIVE_SCHEDULE
//

images_creation_mode = CREATE_IMAGES_THEN_EXIT;

///////////// images_schedule_interval_secs ///////////
//
// Interval at which images are created on schedule (secs).
// The application waits until the interval has passed, plus any 
//   specified delay, and then creates the images.
//
// Type: int
//

images_schedule_interval_secs = 300;

///////////// images_schedule_delay_secs //////////////
//
// Delay between scheduled time and image creation (secs).
// In order to ensure that the data has been written, a delay may be 
//   provided. This allows for the writing application to complete writing 
//   the data before this application tries to access it.
//
// Type: int
//

images_schedule_delay_secs = 60;

///////////// images_archive_start_time ///////////////
//
// Start time for image generation in archive mode.
// Image generation starts with a seach at this time, and the proceeds 
//   at increments of images_schedule_interval_secs.
//
// Type: string
//

images_archive_start_time = "1970 01 01 00 00 00";

///////////// images_archive_end_time /////////////////
//
// End time for image generation in archive mode.
// Image generation is terminated when the search time exceeds this end 
//   time.
//
// Type: string
//

images_archive_end_time = "1970 01 01 00 00 00";

///////////// images_scan_interval_secs ///////////////
//
// Time between scans in archive mode (secs).
// Only applies to POLAR (HORIZ/VERT) mode, not BSCAN mode.
//
// Type: int
//

images_scan_interval_secs = 300;

///////////// images_set_sweep_index_list /////////////
//
// Option to specify the sweep indexes for the image generation.
// If TRUE, only the specified sweeps will be processed.
//
// Type: boolean
//

images_set_sweep_index_list = FALSE;

///////////// images_sweep_index_list /////////////////
//
// List of valid sweep indexes for image generation.
// See 'images_set_sweep_index_list'. Images will only be generated for 
//   the specified sweep indexes.
//
// Type: int
// 1D array - variable length.
//

images_sweep_index_list = { 0, 1, 2 };

//======================================================================
//
// SIMULATION MODE.
//
//======================================================================
 
///////////// sim_sleep_msecs /////////////////////////
//
// Number of milliseconds to sleep between beams in simulated input 
//   mode.
//
// Type: int
//

sim_sleep_msecs = 10;

///////////// sim_n_gates /////////////////////////////
//
// Number of gates in simulated data.
//
// Type: int
//

sim_n_gates = 1000;

///////////// sim_start_range_km //////////////////////
//
// Start range in simulated mode (km).
//
// Type: double
//

sim_start_range_km = 0.075;

///////////// sim_gate_spacing_km /////////////////////
//
// Gate spacing in simulated mode (km).
//
// Type: double
//

sim_gate_spacing_km = 0.15;

//======================================================================
//
// CLICK POINT DATA MESSAGING.
//
// Writing the click point location to an FMQ in XML format.
//
//======================================================================
 
///////////// click_point_fmq_url /////////////////////
//
// URL for click point URL.
// The details of the latest click point are written to an FMQ. The 
//   format is XML. You can view the FMQ using FmqMon -mode ASCII_PRINT.
//
// Type: string
//

click_point_fmq_url = "/tmp/fmq/click_point";

//======================================================================
//
// CIDD GUI Configuration Parameters.
//
//======================================================================
 
///////////// gui_field_list //////////////////////////
//
//  Groups Grids into Sets.
//  Each Entry needs:
// ID_Label  List
// 	List - Space Delimited list of grid legend names match strings.
// 	If a group is "ON", then any grid whose legend label contains any  
//   of the match strings in the group list becomes active.
//
// Type: struct
//   typedef struct {
//      char* id_label;
//      char* grid_list;
//   }
//
// 1D array - variable length.
//

gui_field_list = {
};

//======================================================================
//
// Draw/Export Parameters.
//
//======================================================================
 
///////////// dexport_info ////////////////////////////
//
// Human Drawn Products for Export Parameters.
//  Each Entry needs:
// ID_Label FMQ_URL Valid_Minutes Default_ID_no    ID_LABEL - This is 
//   used to designate Product types
//     FMQ_URL: example: fmqp:://host::dir/file 
//    Valid_Minutes: How many minutes the product is valid by default
//    Default_ID_no: Default Data Type (Enumerated ID)
//    Default_label: Test to place into Label field by default.
//
// Type: struct
//   typedef struct {
//      char* id_label;
//      char* url;
//      double valid_minutes;
//      int default_id_no;
//      char* default_label;
//   }
//
// 1D array - variable length.
//

dexport_info = {
  { "Boundry", "/tmp/cidd.fmq", 60, 0, "A"},
  { "Boundry-b", "/tmp/cidd.fmq", 60, 0, "B"}
};

///////////// symprod_debug ///////////////////////////
//
// Debug option.
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     SYMPROD_DEBUG_OFF
//     SYMPROD_DEBUG_NORM
//     SYMPROD_DEBUG_VERBOSE
//

symprod_debug = SYMPROD_DEBUG_OFF;

///////////// symprod_short_requests //////////////////
//
// Gather Data Frame by Frame, Otherwise by loop span.
// Gathers Products valid for the current frame only - Speeds up 
//   gathering of large data sets, like METAR data.
//
// Type: boolean
//

symprod_short_requests = FALSE;

///////////// symprod_gzip_requests ///////////////////
//
// Request data using GZIP compression.
// If true, symprod data will be GZIP compressed by the server.
//
// Type: boolean
//

symprod_gzip_requests = FALSE;

///////////// symprod_prod_info ///////////////////////
//
// Product Source and Rendering Information Array.
// The fields in the structure are as follows:
//
//   menu_label: label to be used for the product in menu.
//
//   url: for retrieving the data.
//     example: 
//   spdbp:transform_executable:[param_file]//host.dom:[port]:dir1/dir2
//
//   data_type: used when querying the SPDB data server
//     (set to 0 to retrieve all data).
//
//   render_type: Select how temporal clipping is done:
//     RENDER_ALL: Do no temporal clipping.
//     RENDER_ALL_VALID: Render all Valid in frame
//     RENDER_VALID_IN_LAST_FRAME: Render all Valid in the last frame
//     RENDER_LATEST_IN_FRAME: Render the latest product of like 
//   data_types (ID)  in the frame.
//     RENDER_LATEST_IN_LOOP:  Render the latest product of like 
//   data_types (ID)  valid in the movie loop.
//     RENDER_FIRST_BEFORE_FRAME_TIME:  Render the latest product of 
//   like data_types (ID) before the end of frame time
//     RENDER_FIRST_BEFORE_DATA_TIME:   Render the latest product of 
//   like data_types (ID  before the data time in each frame.
//     RENDER_FIRST_AFTER_DATA_TIME:    Render the earliest product 
//   after the data time in each frame.
//     RENDER_ALL_BEFORE_DATA_TIME:     Render all valid products before 
//   the data time in each frame.
//     RENDER_ALL_AFTER_DATA_TIME:      Render all valid products after 
//   the data time in each frame.
//     RENDER_GET_VALID:      Render all valid products returned with a 
//   GetValid Spdb call.
//     RENDER_GET_VALID_AT_FRAME_TIME:  Render products which have not 
//   expired at the frame time
//
// Note: all comparisons are less than or equal or greater than or equal
//
//   on_by_default: True or False
//
//   minutes_allow_before: Stretch the frame time this many minutes - 
//   prior
//   minutes_allow_after: Stretch the frame time this many minutes - 
//   after
//
//   text_off_threshold: Threshold where text disappears. Use the 
//   function:
//       log10(scaling_constant/km_distance_across_screen ) + 1.0
//       Use 0.0 to disable the off feature. (always displayed)
//
//   request_data_on_zoom: Flag indicating whether to request new data 
//   for
//       this product whenever the user changes the zoom.  Normally, 
//   this
//       should be set to false for efficiency reasons.  If the products
//       to be rendered would change with a zoom change then this should 
//   be
//       set to true.
//
//   request_data_on_vert_change: Flag indicating whether to request new 
//   data
//       for this product whenever the user changes the currently 
//   displayed
//       vertical level.  Normally, this should be set to false for 
//   efficiency
//       reasons.  If the products to be rendered would change with a 
//   zoom
//       change then this should be set to true.
//
// Type: struct
//   typedef struct {
//      string menu_label;
//      string url;
//      int data_type;
//      symprod_render_type_t render_type;
//        Options:
//          RENDER_ALL
//          RENDER_ALL_VALID
//          RENDER_VALID_IN_LAST_FRAME
//          RENDER_LATEST_IN_FRAME
//          RENDER_LATEST_IN_LOOP
//          RENDER_FIRST_BEFORE_FRAME_TIME
//          RENDER_FIRST_BEFORE_DATA_TIME
//          RENDER_FIRST_AFTER_DATA_TIME
//          RENDER_ALL_BEFORE_DATA_TIME
//          RENDER_ALL_AFTER_DATA_TIME
//          RENDER_GET_VALID
//          RENDER_GET_VALID_AT_FRAME_TIME
//      boolean on_by_default;
//      double minutes_allow_before;
//      double minutes_allow_after;
//      double text_off_threshold;
//      boolean request_data_on_zoom;
//      boolean request_data_on_vert_change;
//   }
//
// 1D array - variable length.
//

symprod_prod_info = {
  { "RHI-ticks", "spdbp:Rhi2Symprod://localhost::spdb/rhi", 0, RENDER_ALL_VALID, FALSE, 20, 10, 0.4, FALSE, FALSE}
};

//======================================================================
//
// Terrain Parameters.
//
//======================================================================
 
///////////// terrain_id_label ////////////////////////
//
// Label used for legends.
//
// Type: string
//

terrain_id_label = "Terrain";

///////////// terrain_url /////////////////////////////
//
// Used to located gridded terrain data.
// Terrain_URL 
//  Note example URL:
//   mdvp::static//venus::mdv/terrain&Elevation
//  Field name follows the Ampersand. Use #N for field number override   
//   Use caret: ^ as a substitute for spaces in field names.
//
// Type: string
//

terrain_url = "";

///////////// terrain_height_scaler ///////////////////
//
// Conversion from terrain units to local coords.
// Choose a scaler which converts plane height values
// Default is Hecto-feet (FL) per meter.
//
// Type: double
//

terrain_height_scaler = 0.0328083;

///////////// landuse_url /////////////////////////////
//
// Used to located gridded land use data.
// Land Use URL 
//  Note URL is of the form 
//   mdvp::[param_file]//host.dom::dir/dir&field_name
//  Field name follows the Ampersand. Use #N for field number override   
//   Use caret: ^ as a substitute for spaces in field names.
//
// Type: string
//

landuse_url = "mdvp:://tempest:0:topo/relief/mdv&RGBA";

///////////// landuse_colorscale //////////////////////
//
// Color lookup table for Land use.
// Land Use colorscale file name
//  Note: CIDD looks in the colorscale dir, then in the current dir for 
//   this file.
//
// Type: string
//

landuse_colorscale = "terrain.colors";

///////////// land_use_render_method //////////////////
//
// Land Use rendering style.
// Use Contours only for continious data like elevation.
//
// Type: enum
// Options:
//     TERRAIN_RENDER_FILLED_CONT
//     TERRAIN_RENDER_RECTANGLES
//     TERRAIN_RENDER_DYNAMIC_CONTOURS
//

land_use_render_method = TERRAIN_RENDER_RECTANGLES;

///////////// landuse_active //////////////////////////
//
// Default Display state of Land Use/ Basemap.
//
// Type: boolean
//

landuse_active = FALSE;

///////////// earth_color1 ////////////////////////////
//
// Earth's skin color.
//
// Type: string
//

earth_color1 = "sienna";

///////////// earth_color2 ////////////////////////////
//
// Earth's core color.
//
// Type: string
//

earth_color2 = "red4";

///////////// image_debug /////////////////////////////
//
// Debug option.
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     IMAGE_DEBUG_OFF
//     IMAGE_DEBUG_NORM
//     IMAGE_DEBUG_VERBOSE
//

image_debug = IMAGE_DEBUG_OFF;

///////////// generate_vsection_images ////////////////
//
// Generate images for specified vertical sections.
// If TRUE, and CIDD is in html_mode, it will generate vertical section 
//   images in addition to the normal plan view images.
//
// Type: boolean
//

generate_vsection_images = FALSE;

///////////// image_vsection_waypts_in_latlon /////////
//
// The specified waypts are in latlon degree units.
// If TRUE, the waypts are specified in lat/lon degrees. If FALSE, they 
//   are specified in (xkm, ykm) units in the current projection.
//
// Type: boolean
//

image_vsection_waypts_in_latlon = FALSE;

///////////// image_vsection_spec /////////////////////
//
// Vertical section information array.
// The fields in the structure are as follows:
//
//   vsection_label: label to be used for the specified vertical 
//   section.
//
//   n_waypts: number of waypts for specifying the vert section.
//             Normally this is 2 - for a single vertical section 
//   segment.
//
//   waypt_locs: location of way points. This is a string with pairs of 
//   points in it, with the following format: (x, y) (x, y) ..... (x, y).
//
// Type: struct
//   typedef struct {
//      string vsection_label;
//      int n_waypts;
//      string waypt_locs;
//   }
//
// 1D array - variable length.
//

image_vsection_spec = {
  { "RHI-north", 2, "(0, 0) (0, 150)"}
};

//======================================================================
//
// Route Winds Parameters.
//
//======================================================================
 
///////////// route_debug /////////////////////////////
//
// Set to DEBUG_NORM or DEBUG_VERBOSE for diagnostic output.
//
// Type: enum
// Options:
//     ROUTE_DEBUG_OFF
//     ROUTE_DEBUG_NORM
//     ROUTE_DEBUG_VERBOSE
//

route_debug = ROUTE_DEBUG_OFF;

///////////// route_font_height ///////////////////////
//
//  Maximum height in Pixels of labels.
//
// Type: int
//

route_font_height = 13;

///////////// route_add_waypoints_labels //////////////
//
// Default state of the add_waypoints_labels.
// 0 = off, 1 = on.
//
// Type: int
//

route_add_waypoints_labels = 1;

///////////// route_add_wind_text /////////////////////
//
// Default state of the add_wind_text labels.
// 0 = off, 1 = on.
//
// Type: int
//

route_add_wind_text = 1;

///////////// route_label_style ///////////////////////
//
// Set to REGULAR_INTERVALS or EQUAL_DIVISIONS.
//
// Type: enum
// Options:
//     REGULAR_INTERVALS
//     EQUAL_DIVISIONS
//

route_label_style = REGULAR_INTERVALS;

///////////// route_label_interval ////////////////////
//
// Distance in km between winds labels.
// Used if label_style is set to REGULAR_INTERVALS.
//
// Type: double
//

route_label_interval = 55.6;

///////////// route_num_route_labels //////////////////
//
// number of route wind labels to plot along the route.
// Typically this should be set between 5 and 20.
// Minimum val: 2
// Maximum val: 100
//
// Type: int
//

route_num_route_labels = 10;

///////////// route_track_line_width //////////////////
//
// Width in pixels of the route winds track.
// Minimum val: 1
// Maximum val: 20
//
// Type: int
//

route_track_line_width = 3;

///////////// route_u_url /////////////////////////////
//
// U Wind Componet.
//  URL's take the form  mdvp::[paramfile]//host.dom::dir/dir&fieldname.
//
// Type: string
//

route_u_url = "mdvp::zoom_mds//neptune::mdv/mm5&U";

///////////// route_v_url /////////////////////////////
//
// v Wind Componet.
//
// Type: string
//

route_v_url = "mdvp::zoom_mds//neptune::mdv/mm5&V";

///////////// route_turb_url //////////////////////////
//
// Turbulence Index.
//
// Type: string
//

route_turb_url = "mdvp::d3_d4//neptune::mdv/mm5&Turb";

///////////// route_turb_low_thresh ///////////////////
//
// Value at which the turbulence is considered Low.
//
// Type: double
//

route_turb_low_thresh = 0.25;

///////////// route_turb_mod_thresh ///////////////////
//
// Value at which the turbulence is considered Moderate.
//
// Type: double
//

route_turb_mod_thresh = 0.5;

///////////// route_turb_hi_thresh ////////////////////
//
// Value at which the turbulence is considered High.
//
// Type: double
//

route_turb_hi_thresh = 0.75;

///////////// route_icing_url /////////////////////////
//
// Icing Index.
//
// Type: string
//

route_icing_url = "mdvp::d3_d4//neptune::mdv/mm5&Icing";

///////////// route_icing_low_thresh //////////////////
//
// Value at which the icing is considered Light.
//
// Type: double
//

route_icing_low_thresh = 0.25;

///////////// route_icing_mod_thresh //////////////////
//
// Value at which the icing is considered Moderate.
//
// Type: double
//

route_icing_mod_thresh = 0.5;

///////////// route_icing_hi_thresh ///////////////////
//
// Value at which the icing is considered Heavy.
//
// Type: double
//

route_icing_hi_thresh = 0.75;

///////////// route_paths /////////////////////////////
//
//  Route path strings - Format of each string isROUTE_LABEL NPOINTS  
//   ID_String Lat Lon ID_String LAT Lon ...
// ROUTE_LABEL will be used in the menu, 
// NPoints = Number of way points in route 
//   Followed by NPoint triplets of the following:
// ID_string -> usually a Airport or VOR 
// Lat Lon :  decimal degrees.
//
// Type: string
// 1D array - variable length.
//

route_paths = { "A-1 8 BULAN 27.0917 124.0000 OSTAR 26.3317 123.0000 SHARK 25.8333 122.3583 ANNNA 25.5717 122.0217 APU 25.1767 121.5233 HLG 24.6400 120.7833 MKG 23.5583 119.6283 ELATO 22.3333 117.5000 ", "M-750 12 MOLKA 26.6583 124.0000 MORSU 25.9100 123.0000 LEKOS 25.5100 122.4717 ROBIN 25.4200 122.2083 NOKAS 25.1317 121.9917 SANAS 24.8967 121.6917 PILOX 24.4150 121.0250 ANLOT 23.9417 120.5233 TOROX 23.3533 119.9083 RENOT 22.5683 118.5117 DADON 22.2767 118.0033 ENVAR 21.9917 117.5000 ", "G-581 7 IGURU 23.9500 124.0000 TULTO 23.3233 123.0000 HCN 21.9283 120.8433 PARPA 22.0150 120.1683 CYRUS 22.2167 118.5317 DADON 22.2767 118.0033 ELATO 22.3333 117.5000 ", "B-591 9 APU 25.1767 121.5233 SANAS 24.8967 121.6917 TINHO 24.3533 122.0283 TITUS 23.8283 121.8517 TACLE 22.9933 121.5867 GID 22.6733 121.4867 TUNNY 22.3600 121.2150 HCN 21.9283 120.8433 DOREX 21.0000 120.7833 ", "R-583 5 BORDO 26.0167 124.0000 KIKIT 25.8817 123.5917 PABSO 25.6517 122.8750 LEKOS 25.5100 122.4717 APU 25.1767 121.5233 ", "G-86 3 HCN 21.9283 120.8433 ANDRE 21.7783 120.1683 KAPLI 21.1667 117.5000 ", "B-576 3 SALMI 28.3150 124.0000 BERBA 27.0783 123.0000 APU 25.1767 121.5233 " };

//======================================================================
//
// <MAIN>.
//
//======================================================================
 
///////////// debug_flag //////////////////////////////
//
// Basic debug flag.
// General informational messages - Initialization messages.
//
// Type: boolean
//

debug_flag = FALSE;

///////////// debug1_flag /////////////////////////////
//
// More verbose debug flag.
// Data flow related messages.
//
// Type: boolean
//

debug1_flag = FALSE;

///////////// debug2_flag /////////////////////////////
//
// Verbose diagnostics.
// Developer debugging information.
//
// Type: boolean
//

debug2_flag = FALSE;

///////////// demo_time ///////////////////////////////
//
// Startup time for the display data.
// If set, start up cidd in archival mode. Starting at the indicated 
//   time. Enter HH:MM MM/DD/YY format time string. System will startup 
//   using field 0, requesting data closest to the demo time. The movie 
//   frame will be centered on the time after applying temporal rounding.
//
// Type: string
//

demo_time = "20:00 5/25/2000";

///////////// temporal_rounding ///////////////////////
//
// Set times to the nearest value divisible by the number of seconds.
//
// Type: int
//

temporal_rounding = 300;

///////////// climo_mode //////////////////////////////
//
// Options are 'regular', 'daily' or 'yearly'.
// Users can do this interactively by entering '1 yr' or '1 day' in the 
//   movie control panel interval text widget. CIDD will recognize these 
//   special 'intervals' and will do the right thing.
//
// Type: string
//

climo_mode = "regular";

///////////// max_time_list_span //////////////////////
//
// Maximum number of days over which to request time lists.
// If the epoch exceeds this number of days, then no time list requests 
//   will be made. Time lists requests spanning many years can take too 
//   long.
//
// Type: int
//

max_time_list_span = 365;

//======================================================================
//
// Movie loops.
//
//======================================================================
 
///////////// starting_movie_frames ///////////////////
//
// This determines how many movie frames are in the loop at startup.
// Setting this high will cause the X server to hog memory.
//
// Type: int
//

starting_movie_frames = 16;

///////////// time_interval ///////////////////////////
//
// Minutes per movie frame on startup.
// The display will automatically update every this interval, throwing 
//   away its oldest movie frame and creating and drawing a new one.
//
// Type: double
//

time_interval = 5;

///////////// frame_span //////////////////////////////
//
// Span in minutes a frame covers in Climo mode.
// The time_interval will be either '1 day' or '1 year'.
//
// Type: double
//

frame_span = 60;

///////////// forecast_interval ///////////////////////
//
// This parameter sets the maximum number of hours in the future a user 
//   can select from the quick forecast menu.
// See SHOW_FORECAST_MENU menu bar button.
//
// Type: double
//

forecast_interval = 24;

///////////// past_interval ///////////////////////////
//
// The maximum number of hours in the PAST a user can selectfrom the 
//   quick forecast menu.
// See SHOW_PAST_MENU menu bar button.
//
// Type: double
//

past_interval = 96;

///////////// movie_magnify_factor ////////////////////
//
// When a Forecast hour is chosen, magnify the time interval by this 
//   factor.
// This adjusts the frame time_interval to be more appropriate for 
//   forecast (model) data, which is often output on a more coarse time 
//   interval. When 'Now' is selected the magnification is undone.
//
// Type: double
//

movie_magnify_factor = 10;

///////////// check_data_times ////////////////////////
//
// Used to reject 'out of date' data.
// Set this param to TRUE to check and reject for rendering any data 
//   that falls outside the movie frame interval + the 
//   slop/stretch_factor.
//
// Type: boolean
//

check_data_times = FALSE;

///////////// check_clipping //////////////////////////
//
// Set this parameter to TRUE when displaying data on dissimilar grid 
//   projection and stripes or other artifacts are rendered.
// Each polygon will be checked to make sure it will render correctly. 
//   This slows down the rendering a bit so it is FALSE by default.
//
// Type: boolean
//

check_clipping = FALSE;

///////////// stretch_factor //////////////////////////
//
// Sets the allowable time error for data to appear in movie frames.
// (times the time_interval) (6 min * 6 = 36 minutes before or after the 
//   beginning or end of the movie frame times.
//
// Type: double
//

stretch_factor = 6;

///////////// gather_data_mode ////////////////////////
//
// Sets whether we request data closest to the midpoint of a movie frame 
//   (0) or the end (1).
// 0= Midpoint requests(Closest_to), 1 = End point requests 
//   (First_before). Typically, real-time operation should operate as 1 
//   (End point requests). Choose mode 0 if you want to enter a time and 
//   have data the data at that time appear, regardless of how wide the 
//   movie frame interval is.
//
// Type: int
//

gather_data_mode = 0;

///////////// redraw_interval /////////////////////////
//
// Number of milliseconds between checks for images needing redrawn.
// Set this lower on faster hardware - Recommended 50-250. This sets the 
//   ultimate speed of the movie looping.
//
// Type: int
//

redraw_interval = 100;

///////////// update_interval /////////////////////////
//
// Number of seconds between data update requests.
// The display will check the Data Mapper for new data every interval in 
//   real-time mode. At every interval we will check for updates to each 
//   grid and product. If no datamap_host is set, the data is assumed to 
//   be old and will be reloaded every interval. Set this wisely. Values 
//   of 10-900 are typical. Default=120 Setting this below 3 seconds is 
//   not advised.  interacts with the Data Mapper Host parameter: 
//   cidd.datamap_host:.
//
// Type: int
//

update_interval = 300;

///////////// datamap_host ////////////////////////////
//
// DataMapper Host.
// Host on which the DataMapper app is running.
//
// Type: string
//

datamap_host = "venus";

///////////// data_timeout_secs ///////////////////////
//
// Number of seconds to wait for data to come in before giving up.
// On very slow networks this may need to go as high as 180 seconds.
//
// Type: int
//

data_timeout_secs = 40;

///////////// simple_command_timeout_secs /////////////
//
// Length of time to wait before killing simple external commands.
// Used When running single image convert scripts and driving Browsers 
//   to web pages.
//
// Type: int
//

simple_command_timeout_secs = 30;

///////////// complex_command_timeout_secs ////////////
//
// Length of time to wait before killing complex external commands.
// Used when spawning animation building script.
//
// Type: int
//

complex_command_timeout_secs = 180;

///////////// movie_on ////////////////////////////////
//
// Determine whether to start with movie looping on.
// Set to TRUE to start up in movie-on mode, FALSE = off.
//
// Type: boolean
//

movie_on = FALSE;

///////////// movie_delay /////////////////////////////
//
// Set the delay at the end of the movie loop in (msec).
//
// Type: int
//

movie_delay = 3000;

///////////// movie_speed_msec ////////////////////////
//
// Set the speed of the movie loop (msec per frame).
//
// Type: int
//

movie_speed_msec = 75;

///////////// reset_frames ////////////////////////////
//
// Forces reload of all data every time the movie frames rotate one old 
//   frame out and generate a new frame.
// If TRUE, this will slow down data gathering for movie rendering.
//
// Type: boolean
//

reset_frames = FALSE;

///////////// model_run_list_hours ////////////////////
//
// Gather model run times within these number of hours from the end of 
//   the movie loop.
// More hours means more Model runs will appear in the menu.
//
// Type: int
//

model_run_list_hours = 24;

///////////// idle_reset_seconds //////////////////////
//
// After this period of inactivity, the display will reset itself to a 
//   known starting point.
// Set this <= 0 to essentially turn off.
//
// Type: int
//

idle_reset_seconds = 0;

//======================================================================
//
// Image generation.
//
//======================================================================
 
///////////// html_mode ///////////////////////////////
//
// Set this to TRUE to activate automatic HTML output mode.
// Note: image_dir MUST be set.
//
// Type: boolean
//

html_mode = FALSE;

///////////// run_once_and_exit ///////////////////////
//
// After this period of inactivity, the display will reset itself to a 
//   known starting point.
// Set this to FALSE to essentially turn off.
//
// Type: boolean
//

run_once_and_exit = FALSE;

///////////// transparent_images //////////////////////
//
// Set transparency of generated images.
// If FALSE, the normal background color is used. Set to TRUE for 
//   transparent background.
//
// Type: boolean
//

transparent_images = FALSE;

///////////// image_dir ///////////////////////////////
//
// Directory for output image plots.
//
// Type: string
//

image_dir = "/tmp";

///////////// save_images_to_day_subdir ///////////////
//
// Save images to subdirs based on date.
//
// Type: boolean
//

save_images_to_day_subdir = FALSE;

///////////// image_ext ///////////////////////////////
//
// Sets the output image type.
// In latest version, only png type is available.
//
// Type: string
//

image_ext = "png";

///////////// image_horiz_prefix //////////////////////
//
// The prefix for the horiz (plan view) image file names.
//
// Type: string
//

image_horiz_prefix = "CH";

///////////// image_vert_prefix ///////////////////////
//
// The prefix for the vert image file names.
//
// Type: string
//

image_vert_prefix = "CV";

///////////// image_name_separator ////////////////////
//
// The separator used in the image file names.
//
// Type: string
//

image_name_separator = "_";

//======================================================================
//
// The HTML MODE Output file name is built from parts.
//
// Some of these are optional - see related parameters below. 'Prefix' + 
//   Frame_number + legend_label + zoom_level + [button_label] + [height] 
//   + frame_time + [data_generation_time] + [data_valid_time] + 
//   .'cidd.image_ext'.
//
//======================================================================
 
///////////// add_height_to_filename //////////////////
//
// Adds height to the output file name.
//
// Type: boolean
//

add_height_to_filename = TRUE;

///////////// add_frame_time_to_filename //////////////
//
// Adds frame time to the output file name.
//
// Type: boolean
//

add_frame_time_to_filename = TRUE;

///////////// add_button_name_to_filename /////////////
//
// Adds GUI button label to the output file name.
//
// Type: boolean
//

add_button_name_to_filename = FALSE;

///////////// add_frame_num_to_filename ///////////////
//
// Adds frame number to the output file name.
//
// Type: boolean
//

add_frame_num_to_filename = TRUE;

///////////// add_gen_time_to_filename ////////////////
//
// Adds model gen time to the output file name.
//
// Type: boolean
//

add_gen_time_to_filename = FALSE;

///////////// add_valid_time_to_filename //////////////
//
// Adds data valid time to the output file name.
//
// Type: boolean
//

add_valid_time_to_filename = FALSE;

//======================================================================
//
// Separate Horizontal and Vertical Image save resources.
//
// NOTE: we append the image name to the command string before 
//   executing.This allows the script to pull the name off the command 
//   line. It is often useful to place a 'rm' as the last command to 
//   remove the image after printing, conversion, etc.
//
//======================================================================
 
///////////// horiz_image_dir /////////////////////////
//
// Image directory for horiz images.
// Note - this is initially set to image_dir.
//
// Type: string
//

horiz_image_dir = "/tmp";

///////////// horiz_image_fname ///////////////////////
//
// The default file name until reset by the user.
// Appends other info automatically.
//
// Type: string
//

horiz_image_fname = "cidd_horiz_view.png";

///////////// horiz_image_command /////////////////////
//
// Command to be run after image is created.
// Note that this is initially set to 'image_convert_script'.
//
// Type: string
//

horiz_image_command = "convert_image.csh";

///////////// vert_image_dir //////////////////////////
//
// Image directory for vert images.
// Note - this is initially set to image_dir.
//
// Type: string
//

vert_image_dir = "/tmp";

///////////// vert_image_fname ////////////////////////
//
// The default file name until reset by the user.
// Appends other info automatically.
//
// Type: string
//

vert_image_fname = "CV";

///////////// vert_image_command //////////////////////
//
// Command to be run after image is created.
// Note that this is initially set to 'image_convert_script'.
//
// Type: string
//

vert_image_command = "convert_image.csh";

///////////// output_geo_xml //////////////////////////
//
// Output an imagename.xml file which contains geo referencing 
//   information.
// If use_latlon_in_geo_xml is true, then the georeferencing information 
//   will be given in latitude/longitude values.
//
// Type: boolean
//

output_geo_xml = FALSE;

///////////// use_latlon_in_geo_xml ///////////////////
//
// Georef info is in lat/lon projection.
// For a lat/lon projection, information is always given in 
//   latitude/longitude. Otherwise projection information will be used.
//
// Type: boolean
//

use_latlon_in_geo_xml = FALSE;

///////////// movieframe_time_format //////////////////
//
// Set the format for the time fields in the names of output xwd images.
// See strftime(3) for options.  Default is: %H%M.
//
// Type: string
//

movieframe_time_format = "%H%M";

///////////// movieframe_time_mode ////////////////////
//
//
// Type: int
//

movieframe_time_mode = 0;

///////////// image_convert_script ////////////////////
//
// This script will be exec'd if set whenever an html_mode image is 
//   output.
// The full path name of the xwd image will be sent as the script 
//   argument. Setting horiz_image_command or cidd.horiz_image_command 
//   will override this and allow separate scripts to be called for horiz 
//   and vert images.
//
// Type: string
//

image_convert_script = "convert_image.csh";

///////////// print_script ////////////////////////////
//
// This script will be exec'd if set whenever a print command is issued.
// The full path name of the xwd image will be sent as the script 
//   argument.
//
// Type: string
//

print_script = "convert_image_print.csh";

///////////// series_convert_script ///////////////////
//
// When the user selects the OutputLoop button, this script will be 
//   exec'd after the last image in a loop has been written.
// The arguments will be a list of each output file in the series. CIDD 
//   will prepend the cidd.image_dir to each file name which takes the 
//   form: cidd_field_name_zoom_name.xwd.
//
// Type: string
//

series_convert_script = "make_anim.csh";

///////////// request_compressed_data /////////////////
//
// Request data from MDV servers be compressed.
// When a remote URL is used, the server can compress the data for 
//   transmission. This makes sense for slow remote connections.
//
// Type: boolean
//

request_compressed_data = TRUE;

///////////// request_gzip_vol_compression ////////////
//
// Use gzip-style compression for remote data access.
// See 'request_compressed_data'.
//
// Type: boolean
//

request_gzip_vol_compression = FALSE;

///////////// projection_type /////////////////////////
//
// Sets the projection for the plan view.
// Current valid choices are: CARTESIAN, LAT_LON, LAMBERT,  
//   POLAR_STEREO, STEREOGRAPHIC, MERCATOR. Mercator is relative to the 
//   longitude origin.
//
// Type: string
//

projection_type = "CARTESIAN";

///////////// lambert_lat1 ////////////////////////////
//
// Standard latitude 1.
// For LAMBERT projection. Ignored otherwise.
//
// Type: double
//

lambert_lat1 = 20;

///////////// lambert_lat2 ////////////////////////////
//
// Standard latitude 2.
// For LAMBERT projection. Ignored otherwise.
//
// Type: double
//

lambert_lat2 = 60;

///////////// tangent_lat /////////////////////////////
//
// Tangent latitude.
// For POLAR_STEREO, set to 90. For OBLIQUE_STEREO, set to 60.
//
// Type: double
//

tangent_lat = 60;

///////////// tangent_lon /////////////////////////////
//
// Tangent longitude.
// Applies to POLAR_STEREO and OBLIQUE_STEREO.
//
// Type: double
//

tangent_lon = 0;

///////////// central_scale ///////////////////////////
//
// Central scale factor.
// Applies to STEREO projections.
//
// Type: double
//

central_scale = 1;

///////////// north_angle /////////////////////////////
//
// Amount grids are rotated clockwise to true north.
// Applies to CARTESIAN (FLAT) projection.
//
// Type: double
//

north_angle = 0;

///////////// use_cosine //////////////////////////////
//
// Diagnostic mode used to ignore the Elevation angle on polar data 
//   (radars, etc).
// Set to FALSE to display all polar grids as if the elevation were 
//   always 0.0 degrees. This allows one to view radial data near 90 
//   degrees elevation.
//
// Type: boolean
//

use_cosine = TRUE;

///////////// use_cosine_correction ///////////////////
//
// See use_cosine.
//
// Type: int
//

use_cosine_correction = 1;

///////////// scale_units_per_km //////////////////////
//
// Set the scale factor and label for Range rings and Distance scales.
//
// Type: double
//

scale_units_per_km = 1;

///////////// scale_units_label ///////////////////////
//
// Set the units labels.
// km, nm, deg.
//
// Type: string
//

scale_units_label = "nm";

///////////// always_get_full_domain //////////////////
//
// Request the outer domain established by domain_limit params.
// i.e. do not clip the data on request.
//
// Type: boolean
//

always_get_full_domain = FALSE;

///////////// do_not_clip_on_mdv_request //////////////
//
// Request the whole earth or Hemisphere, centered on the origin.
//
// Type: boolean
//

do_not_clip_on_mdv_request = FALSE;

///////////// do_not_decimate_on_mdv_request //////////
//
// Do not decimate on MDV request, get all points from MDV server.
//
// Type: boolean
//

do_not_decimate_on_mdv_request = FALSE;

///////////// min_zoom_threshold //////////////////////
//
// Minimum distance to zoom into to in KM.
// Won't allow the user to define custom zooms small than this size 
//   (along the longest edge).
//
// Type: double
//

min_zoom_threshold = 5;

///////////// aspect_ratio ////////////////////////////
//
// Set the aspect ratio of the domain for the display.
// Cidd will preserve this aspect ratio for all zooms. Ratio is 
//   Width/Height. If set <= 0.0, CIDD will compute the aspect ratio based 
//   on the extent of the first domain. Note CIDD now applies a correction 
//   to LAT_LON projections to expand the Y coords, making them appear to 
//   be equi-distant in Latitude and Longitude. Based on the cos(average 
//   latitude of the current view).
//
// Type: double
//

aspect_ratio = 1;

///////////// enable_status_window ////////////////////
//
// Enable the status window.
// If FALSE, no status window is displayed.
//
// Type: boolean
//

enable_status_window = TRUE;

///////////// report_clicks_in_status_window //////////
//
// Report clicks in the status window.
// By default distance are in km and bearings in deg T.
//
// Type: boolean
//

report_clicks_in_status_window = TRUE;

///////////// report_clicks_in_degM_and_nm ////////////
//
// Report click position in degrees magnetic and nautical miles.
// By default distance are in km and bearings in deg T.
//
// Type: boolean
//

report_clicks_in_degM_and_nm = FALSE;

///////////// magnetic_variation_deg //////////////////
//
// Set the magnetic variation for the display location.
// Variation is true minus magnetic.
//
// Type: double
//

magnetic_variation_deg = 0;

///////////// enable_save_image_panel /////////////////
//
// Enable the single middle button click to save image feature.
// Warning - will allow users shell access, or to write to other dirs.
//
// Type: boolean
//

enable_save_image_panel = TRUE;

//======================================================================
//
// The Outer most domain.
//
// Overlays are clipped to this domain and pan/moves cannot exceed these 
//   edge limits. Note: CIDD does not pan on the outermost domain.
//
// Note: for Lat/Lon Domains, Choose 0-360, -90+90. to get whole earth.
//
// One can also choose Longitude range -180 to 180, -90 to 270, etc.
// For whole earth views, aspect ration 1.0,  set the outer most domain 
//   to -180 to 180 and -180 to 180. Otherwise, set the aspect ratio to 
//   2.0 and use -180 to 180 and -90 to 90.
//
//======================================================================
 
///////////// domain_limit_min_x //////////////////////
//
// Minimum X for outer domain.
//
// Type: double
//

domain_limit_min_x = -2900;

///////////// domain_limit_max_x //////////////////////
//
// Maximum X for outer domain.
//
// Type: double
//

domain_limit_max_x = 2900;

///////////// domain_limit_min_y //////////////////////
//
// Minimum Y for outer domain.
//
// Type: double
//

domain_limit_min_y = -2900;

///////////// domain_limit_max_y //////////////////////
//
// Maximum Y for outer domain.
//
// Type: double
//

domain_limit_max_y = 2900;

///////////// origin_latitude /////////////////////////
//
// The longitude of the center of the display. Internal range rings are 
//   relative to this point.
//
// Type: double
//

origin_latitude = 39.7914;

///////////// origin_longitude ////////////////////////
//
// The latitude of the center of the display. Internal range rings are 
//   relative to this point.
//
// Type: double
//

origin_longitude = -104.568;

///////////// reset_click_latitude ////////////////////
//
// On startup and each time the reset button is pressed, the display 
//   will indicate a click at this point, as if the user had clicked.
//
// Type: double
//

reset_click_latitude = 26;

///////////// reset_click_longitude ///////////////////
//
// On startup and each time the reset button is pressed, the display 
//   will indicate a click at this point, as if the user had clicked.
//
// Type: double
//

reset_click_longitude = 120;

///////////// planview_start_page /////////////////////
//
// Select the data field/page to start on.
// For the horizontal view.
//
// Type: int
//

planview_start_page = 1;

///////////// xsect_start_page ////////////////////////
//
// Select the data field/page to start on.
// For the vertical (cross section) view.
//
// Type: int
//

xsect_start_page = 1;

///////////// num_zoom_levels /////////////////////////
//
// The number of zoom levels.
//
// Type: int
//

num_zoom_levels = 5;

///////////// start_zoom_level ////////////////////////
//
// Zoom level on which to start.
//
// Type: int
//

start_zoom_level = 1;

///////////// zoom_limits_in_latlon ///////////////////
//
// The units of the zoom limits are in deg lat/lon.
//
// Type: boolean
//

zoom_limits_in_latlon = FALSE;

///////////// num_cache_zooms /////////////////////////
//
// The number of Cached images for zooms.
//
// Type: int
//

num_cache_zooms = 4;

//======================================================================
//
// Vertical Range and Resolution - Establishes a vertical coordinate 
//   system for the cross sectional imagery.
//
//  All data must map into this range for it to be visible.
// 	min_ht is value nearest the ground - Plotted at the bottom.
// 	max_ht is the value furtherest from the ground - Plotted at the top.
//
// Units are ignored and no inter conversions or re-mappings are 
//   performed.
//
// Returned cross sections are are often km, but could be sigma, 
//   pressure or degrees elevation.
//
// Examples:
// 	Sigma : min_ht = 1.0, max_ht = 0.0, ht_interval = .1
// 	Pressure : min_ht = 1100.0, max_ht = 100.0, ht_interval = -100
// 	Radial Radar:  min_ht = 0.0 max_ht = 25.0, ht_interval = 1.0.
//
//======================================================================
 
///////////// min_ht //////////////////////////////////
//
// Minimum ht of cross section.
//
// Type: double
//

min_ht = 0.25;

///////////// max_ht //////////////////////////////////
//
// Maximum ht of cross section.
//
// Type: double
//

max_ht = 22.25;

///////////// start_ht ////////////////////////////////
//
// Starting height of horizontal view.
//
// Type: double
//

start_ht = 0.5;

//======================================================================
//
// Finding the resources for maps/overlays, surface stations.
//
//======================================================================
 
///////////// map_file_subdir /////////////////////////
//
// Directory for maps/overlays.
//
// Type: string
//

map_file_subdir = "/local/maps,http://www.rap.ucar.edu/maps";

///////////// locator_margin_km ///////////////////////
//
// Station locator features.
// Maximum allowed  Distance in km between request point and station.
//
// Type: double
//

locator_margin_km = 50;

///////////// station_loc_url /////////////////////////
//
// Full Path File name or http URL to a station data file.
// The format of each line is:  ID, LAT, LON, ALT(m), TYPE.
//
// Type: string
//

station_loc_url = "http://www.rap.ucar.edu/maps/Taiwan_stations.dat";

///////////// remote_ui_url ///////////////////////////
//
// FMQ Type URL for Receiving Remote commands.
//
// Type: string
//

remote_ui_url = "/tmp/remoteUI";

//======================================================================
//
// Server access.
//
//======================================================================
 
///////////// http_tunnel_url /////////////////////////
//
// Tunnel for all DsServer (mdvp,spdbp,etc) Protocols.
// USE THIS TO CROSS A FIREWALL ON THE SERVER END OF THE CHAI. Set this 
//   to the special http tunnel that resides in the same local network as 
//   the  data server hosts. This allows 'tunneling' the MDV and Spdb data 
//   protocols through a host, running apache:httpd that is visible from 
//   the Internet or intranet. Note: a special  'Apache::Mod_perl' 
//   extension (The tunnel - it's similar to a cgi mechanism) must be 
//   installed on the http server for this to work.
//
// Type: string
//

http_tunnel_url = "http://www.rap.ucar.edu/DsServerTunnel";

///////////// http_proxy_url //////////////////////////
//
// USE THIS TO CROSS A FIREWALL AT THE Client/CIDD End of the Chain.
// # Set this to the url of a http forwarding proxy to pass http 
//   requests through the proxy. This is usually the same as the HTTP 
//   proxy URL in your browser. Note. If you need the data to flow through 
//   the proxy the http_tunnel_url must be enabled.
//
// Type: string
//

http_proxy_url = "http://webcache.ucar.edu:3128/";

//======================================================================
//
// Another view of the possible Service Topologies.
//
// All Local - No Firewalls - Standard Setup
// --------- Local Lan --------------
// CIDD<--- MDVP --->DsMdvServer
//
// Data Services Behind a firewall
// ----- Internet ----|Firewall|------ Local Lan ----------------
// CIDD<---HTTP--->DsServer Tunnel<---MDVP--->DsMdvServer
//
// Both Client and Data Services behind Firewalls
// ---Local Lan ---|Firewall|--Internet----|Firewall|--------Local Lan 
//   ----------
// CIDD<---HTTP--->Http Proxy<---HTTP--->DsServer 
//   Tunnel<---MDVP--->DsMdvServer.
//
//======================================================================
 
//======================================================================
//
// Setting colors.
//
//======================================================================
 
///////////// foreground_color ////////////////////////
//
// Legends, scales.
//
// Type: string
//

foreground_color = "white";

///////////// background_color ////////////////////////
//
// Background of images.
//
// Type: string
//

background_color = "black";

///////////// margin_color ////////////////////////////
//
// Background of margins.
//
// Type: string
//

margin_color = "black";

///////////// out_of_range_color //////////////////////
//
// Render values outside the data range of the color scale.
//
// Type: string
//

out_of_range_color = "transparent";

///////////// route_path_color ////////////////////////
//
// Color of the cross section reference line.
//
// Type: string
//

route_path_color = "yellow";

///////////// time_axis_color /////////////////////////
//
// Text in the time axis margins.
//
// Type: string
//

time_axis_color = "pink";

///////////// time_frame_color ////////////////////////
//
// A solid rectangle showing the movie frame extent.
//
// Type: string
//

time_frame_color = "gray50";

///////////// height_axis_color ///////////////////////
//
// The text in the height selector margin.
//
// Type: string
//

height_axis_color = "pink";

///////////// height_indicator_color //////////////////
//
// A solid rectangle showing the height extent of the data plane.
//
// Type: string
//

height_indicator_color = "gray50";

///////////// range_ring_color ////////////////////////
//
// Range rings and azimuth lines.
//
// Type: string
//

range_ring_color = "gray";

///////////// missing_data_color //////////////////////
//
// Set to 'transparent' to avoid having these plotted. .
// Otherwise, these data will be plotted in the indicated color.
//
// Type: string
//

missing_data_color = "grey20";

///////////// bad_data_color //////////////////////////
//
// Set to 'transparent' to avoid having these plotted. .
// Otherwise, these data will be plotted in the indicated color.
//
// Type: string
//

bad_data_color = "grey20";

///////////// epoch_indicator_color ///////////////////
//
// Time Control (Movie) Pop-up Colors.
//
// Type: string
//

epoch_indicator_color = "orange";

///////////// now_time_color //////////////////////////
//
// Color of current time tick.
//
// Type: string
//

now_time_color = "red";

///////////// time_tick_color /////////////////////////
//
// Color of time ticks.
//
// Type: string
//

time_tick_color = "yellow";

///////////// latest_click_mark_color /////////////////
//
// Color of mark showing latest click location.
//
// Type: string
//

latest_click_mark_color = "red";

//======================================================================
//
// Mode flags.
//
//======================================================================
 
///////////// show_height_sel /////////////////////////
//
// Show the height selector in the right margin.
// oggle for displaying the height Selector in Right Margin. Note Right 
//   Margin should be at least 50 pixels wide.
//
// Type: boolean
//

show_height_sel = TRUE;

///////////// show_data_messages //////////////////////
//
// Show data status messages at top of image.
// There will be one line of status for each field in the stack. This is 
//   probably not necessary in situations where all data is small and 
//   local.
//
// Type: boolean
//

show_data_messages = TRUE;

///////////// latlon_mode /////////////////////////////
//
// Sets the format for output of Lat, Lon's.
// 0= Decimal Degrees, 1 = deg min' sec'.
//
// Type: int
//

latlon_mode = 0;

///////////// label_time_format ///////////////////////
//
// Set the format for the time strings.
// See 'man strftime' for format options. Can add additional text as 
//   part of the Time string.
//
// Type: string
//

label_time_format = "%m/%d/%Y %H:%M";

///////////// moviestart_time_format //////////////////
//
// Set the format for the time string in the movie start time text field 
//   of the movie pop-up window.
// This is set separately from the general time string because you 
//   generally don't want any extra text and want to display things in an 
//   order that allows for easier entry.
//
// Type: string
//

moviestart_time_format = "%H:%M_%m/%d/%Y";

///////////// frame_range_time_format /////////////////
//
// Set the format for the time strings in the frame range text fields.
//
// Type: string
//

frame_range_time_format = "%H:%M:%S";

///////////// layer_legends_on ////////////////////////
//
// Plot a Legend for each Grid overlay.
//
// Type: boolean
//

layer_legends_on = TRUE;

///////////// cont_legends_on /////////////////////////
//
// Plot a Legend for each Contour overlay.
//
// Type: boolean
//

cont_legends_on = TRUE;

///////////// wind_legends_on /////////////////////////
//
// Plot a Legend for each Wind overlay.
//
// Type: boolean
//

wind_legends_on = TRUE;

///////////// display_labels //////////////////////////
//
// Switch to turn off all data labels on the display.
//
// Type: boolean
//

display_labels = TRUE;

///////////// display_ref_lines ///////////////////////
//
// Switch to turn on/off Height, Route and Wind Scale reference lines.
//
// Type: boolean
//

display_ref_lines = TRUE;

//======================================================================
//
// Window sizes.
//
// Window width and height is specified in pixels.
//
//======================================================================
 
///////////// horiz_default_x_pos /////////////////////
//
// Startup position of main window, relative to top-left of screen 
//   (pixels).
// The main display window will start at this location.
//
// Type: int
//

horiz_default_x_pos = 0;

///////////// horiz_default_y_pos /////////////////////
//
// Startup position of main window, relative to top-left of screen 
//   (pixels).
// The main display window will start at this location.
//
// Type: int
//

horiz_default_y_pos = 0;

///////////// horiz_default_width /////////////////////
//
// Default width of main window (pixels).
// Height of main window at startup.
//
// Type: int
//

horiz_default_width = 800;

///////////// horiz_default_height ////////////////////
//
// Default height of main window (pixels).
// Width of main window at startup.
//
// Type: int
//

horiz_default_height = 800;

///////////// horiz_min_width /////////////////////////
//
// Minimum width of main window (pixels).
// The user cannot shrink the main window smaller than this.
//
// Type: int
//

horiz_min_width = 400;

///////////// horiz_min_height ////////////////////////
//
// Minimum height of main window (pixels).
// The user cannot shrink the main window smaller than this.
//
// Type: int
//

horiz_min_height = 400;

///////////// vert_default_x_pos //////////////////////
//
// Startup position of main window, relative to top-left of screen 
//   (pixels).
// The main display window will start at this location.
//
// Type: int
//

vert_default_x_pos = 0;

///////////// vert_default_y_pos //////////////////////
//
// Startup position of main window, relative to top-left of screen 
//   (pixels).
// The main display window will start at this location.
//
// Type: int
//

vert_default_y_pos = 0;

///////////// vert_default_width //////////////////////
//
// Default width of vert section window (pixels).
// Height of vert section window at startup.
//
// Type: int
//

vert_default_width = 600;

///////////// vert_default_height /////////////////////
//
// Default height of vert section window (pixels).
// Width of vert section window at startup.
//
// Type: int
//

vert_default_height = 440;

///////////// vert_min_width //////////////////////////
//
// Minimum width of vert section window (pixels).
// The user cannot shrink the vert section window smaller than this.
//
// Type: int
//

vert_min_width = 120;

///////////// vert_min_height /////////////////////////
//
// Minimum height of vert section window (pixels).
// The user cannot shrink the vert section window smaller than this.
//
// Type: int
//

vert_min_height = 120;

//======================================================================
//
// Margin details.
//
// Margins are specified in pixels.
//
//======================================================================
 
///////////// top_margin_render_style /////////////////
//
// TOP Margin styles.
//  1 (Default): Places a distance scale in the top Margin. 2: Place a 
//   Frame number and Time - Used often for HTML output. 3: None -  Used 
//   often to place the Data label.
//
// Type: int
//

top_margin_render_style = 1;

///////////// bot_margin_render_style /////////////////
//
// Bottom Margin Styles.
// 1 - Distance Scale. 2 - Time Scale.
//
// Type: int
//

bot_margin_render_style = 2;

///////////// horiz_top_margin ////////////////////////
//
// Height of top margin (pixels).
// Size of top margin for main window.
//
// Type: int
//

horiz_top_margin = 20;

///////////// horiz_bot_margin ////////////////////////
//
// Height of bottom margin (pixels).
// Size of bottom margin for main window.
//
// Type: int
//

horiz_bot_margin = 20;

///////////// horiz_left_margin ///////////////////////
//
// Width of left margin (pixels).
// Size of left margin for main window.
//
// Type: int
//

horiz_left_margin = 20;

///////////// horiz_right_margin //////////////////////
//
// Width of right margin (pixels).
// Size of right margin for main window.
//
// Type: int
//

horiz_right_margin = 60;

///////////// vert_top_margin /////////////////////////
//
// Height of top margin (pixels).
// Size of top margin for vert section window.
//
// Type: int
//

vert_top_margin = 20;

///////////// vert_bot_margin /////////////////////////
//
// Height of bottom margin (pixels).
// Size of bottom margin for vert section window.
//
// Type: int
//

vert_bot_margin = 20;

///////////// vert_left_margin ////////////////////////
//
// Width of left margin (pixels).
// Size of left margin for vert section window.
//
// Type: int
//

vert_left_margin = 20;

///////////// vert_right_margin ///////////////////////
//
// Width of right margin (pixels).
// Size of right margin for vert section window.
//
// Type: int
//

vert_right_margin = 30;

//======================================================================
//
// Legends displayed within the plot window.
//
// A legend can be displayed for each data layer. Explicitly set the 
//   Label start coords, and delta Y. If left unset, legends start 
//   relative to the top and left margins.
//
//======================================================================
 
///////////// horiz_legends_start_x ///////////////////
//
// Horizontal window legends start x position (pixels).
// Relative to top left of window.
//
// Type: int
//

horiz_legends_start_x = 30;

///////////// horiz_legends_start_y ///////////////////
//
// Horizontal window legends start y position (pixels).
// Relative to top left of window.
//
// Type: int
//

horiz_legends_start_y = 30;

///////////// horiz_legends_delta_y ///////////////////
//
// Horizontal window legends spacing (pixels).
// This is the line spacing between the legends.
//
// Type: int
//

horiz_legends_delta_y = 30;

///////////// vert_legends_start_x ////////////////////
//
// Vertical window legends start x position (pixels).
// Relative to top left of window.
//
// Type: int
//

vert_legends_start_x = 0;

///////////// vert_legends_start_y ////////////////////
//
// Vertical window legends start y position (pixels).
// Relative to top left of window.
//
// Type: int
//

vert_legends_start_y = 0;

///////////// vert_legends_delta_y ////////////////////
//
// Vertical window legends spacing (pixels).
// This is the line spacing between the legends.
//
// Type: int
//

vert_legends_delta_y = 0;

//======================================================================
//
// Draw range rings and azimuth lines.
//
// These apply to radars only.
//
//======================================================================
 
///////////// range_rings /////////////////////////////
//
// Turn range rings on/off.
// TRUE means on - i.r. plot range rings.
//
// Type: boolean
//

range_rings = FALSE;

///////////// range_ring_spacing //////////////////////
//
// Spacing between range rings (km).
//
// Type: double
//

range_ring_spacing = 50;

///////////// max_ring_range //////////////////////////
//
// Maximum range ring (km).
//
// Type: double
//

max_ring_range = 1000;

///////////// range_ring_follows_data /////////////////
//
// Plot range rings relative to radar location.
// We get the location from the data. If FALSE, rings are relative to 
//   plot origin.
//
// Type: boolean
//

range_ring_follows_data = FALSE;

///////////// range_ring_for_radar_only ///////////////
//
// Only plot range rings for radar data sets.
// TRUE turns off rings for non-radar data sets.
//
// Type: boolean
//

range_ring_for_radar_only = TRUE;

///////////// domain_follows_data /////////////////////
//
// Plot domain moves with origin of the data set.
// Shift the domain limits if the data origin shifts.
//
// Type: boolean
//

domain_follows_data = FALSE;

///////////// range_ring_x_space //////////////////////
//
// Spacing in x for range ring labels (pixels).
//
// Type: int
//

range_ring_x_space = 40;

///////////// range_ring_y_space //////////////////////
//
// Spacing in y for range ring labels (pixels).
//
// Type: int
//

range_ring_y_space = 13;

///////////// range_ring_labels ///////////////////////
//
// Plot range ring labels.
// Label the range for each ring.
//
// Type: boolean
//

range_ring_labels = TRUE;

///////////// azmith_lines ////////////////////////////
//
// Draw azimuth lines for a radar location.
// These complement range rings, to provide guidance on azimuths for 
//   radar gates.
//
// Type: boolean
//

azmith_lines = FALSE;

///////////// azmith_interval /////////////////////////
//
// Interval for azimuth lines.
// If azimuth lines are on.
//
// Type: double
//

azmith_interval = 30;

///////////// azmith_radius ///////////////////////////
//
// Max radius for azimuth lines.
// If azimuth lines are on.
//
// Type: double
//

azmith_radius = 200;

//======================================================================
//
// Plotting wind vectors.
//
// See also the wind layers section.
//
//======================================================================
 
///////////// all_winds_on ////////////////////////////
//
// Plot all wind layers.
// Turns on all wind layers.
//
// Type: boolean
//

all_winds_on = TRUE;

///////////// wind_mode ///////////////////////////////
//
// Activate wind rendering.
// TO DO - check how this works.
//
// Type: boolean
//

wind_mode = FALSE;

///////////// barb_shaft_len //////////////////////////
//
// Wind barb shaft length (pixels).
//
// Type: int
//

barb_shaft_len = 30;

///////////// ideal_x_vectors /////////////////////////
//
// Ideal number of vectors in the x dimension.
// The display will space the wind vectors in x accordingly.
//
// Type: int
//

ideal_x_vectors = 20;

///////////// ideal_y_vectors /////////////////////////
//
// Ideal number of vectors in the y dimension.
// The display will space the wind vectors in y accordingly.
//
// Type: int
//

ideal_y_vectors = 20;

///////////// wind_head_size //////////////////////////
//
// Minimum arrow head size for wind vectors (pixels).
//
// Type: int
//

wind_head_size = 5;

///////////// wind_head_angle /////////////////////////
//
// Angle of arrow head for wind vectors (deg).
//
// Type: double
//

wind_head_angle = 30;

///////////// wind_scaler /////////////////////////////
//
// The display will space the wind vectors in x accordingly.
// Vectors will be drawn to show wind_scaler * wind_time_scale_interval 
//   minutes of motion.
//
// Type: int
//

wind_scaler = 3;

///////////// wind_time_scale_interval ////////////////
//
// inutes between steps on the wind scaling slider.
// Wind vector length = wind_scaler * wind_time_scale_interval *  wind 
//   velocity.
//
// Type: double
//

wind_time_scale_interval = 10;

///////////// wind_marker_type ////////////////////////
//
// Wind vector rendering style.
// 'arrow': centered at data point.
// 'vector': Vertex at data point.
// 'barb': N Hemisp.
// 'labeledbarb': labeled to nearest 10 degrees at the center - N. 
//   Hemisp.
// 'tuft': like a piece of yarn - the least obtrusive - like a headless 
//   vector.
// 'tickvector': Cross ticks at wind_time_scale_interval minutes.
// 'metbarb': Calcs latitude - works for both hemispheres and adds a 
//   label of the 10's digit off the end of the barb, ala winds aloft 
//   charts.
// 'barb_sh': S Hemisphere.
// 'labeledbarb': labeled to nearest 10 degrees at the center - N. 
//   Hemisp.
//
// NOTE: When using arrow,vector,tuft,tickvector,  the data must be in 
//   m/sec for the scaling to work correctly. For barbs the units are 
//   arbitrary, but the flag units on the barbs will reflect the data's 
//   native units.
//
// Type: string
//

wind_marker_type = "arrow";

///////////// wind_w_scale_factor /////////////////////
//
// Scale the vertical velocity by this factor, relative to the U/V. .
// W tends to be small compared to U/V. Scaling it up makes the 
//   rendering more meaningful.
//
// Type: double
//

wind_w_scale_factor = 10;

///////////// wind_units_scale_factor /////////////////
//
// Value to convert from the your reference speed units to m/sec. .
// i.e. wind_units_scale_factor =  m/sec / chosen units.
//
// Type: double
//

wind_units_scale_factor = 1;

///////////// wind_reference_speed ////////////////////
//
// Sets the length of the wind vector reference legend.
// The legend shows a symbos representing a wind speed of this value.
//
// Type: double
//

wind_reference_speed = 30;

///////////// wind_units_label ////////////////////////
//
// Select the label to be printed next to the reference bar.
//
// Type: string
//

wind_units_label = "km/hr";

//======================================================================
//
// Plotting contours in data fields.
//
// In the data layers section you can select contour plotting.
//
//======================================================================
 
///////////// label_contours //////////////////////////
//
// Set to TRUE to have numeric labels on line contours.
//
// Type: boolean
//

label_contours = FALSE;

///////////// contour_line_width //////////////////////
//
// Width of contour lines.
//
// Type: int
//

contour_line_width = 1;

///////////// smooth_contours /////////////////////////
//
// Apply smoothing to data grids before contouring.
// 0 = Off, 1 = single pass, 2 = double pass.
//
// Type: int
//

smooth_contours = 0;

///////////// use_alt_contours ////////////////////////
//
// Use Alternate (Mdvx) Contouring Routines.
// Slower - Nicer labeling - Less smooth. Warning - Does not work 
//   correctly when data and display origins are different. Works fine in 
//   lat/lon projections.
//
// Type: boolean
//

use_alt_contours = FALSE;

///////////// add_noise ///////////////////////////////
//
// Add 1 part in 250 Noise to help smooth contours.
//
// Type: boolean
//

add_noise = FALSE;

///////////// special_contour_value ///////////////////
//
// Specify special contour value.
// Contours at this value will have a wider line.
//
// Type: double
//

special_contour_value = 0.25;

///////////// map_bad_to_min_value ////////////////////
//
// Contour the bad value, by setting bad cells to have min value in 
//   data.
// Sometimes, for CONTOURING it is useful to make the assumption that 
//   the bad and/or missing values should be considered at the minimum of 
//   the dynamic range of the data. i.e. if you want bad contoured, set 
//   this to TRUE.
//
// Type: boolean
//

map_bad_to_min_value = FALSE;

///////////// map_missing_to_min_value ////////////////
//
// Contour the missing value, by setting missing cells to have min value 
//   in data.
// Sometimes, for CONTOURING it is useful to make the assumption that 
//   the missing and/or missing values should be considered at the minimum 
//   of the dynamic range of the data. i.e. if you want missing contoured, 
//   set this to TRUE.
//
// Type: boolean
//

map_missing_to_min_value = FALSE;

//======================================================================
//
// Overall rendering order.
//
//======================================================================
 
///////////// draw_main_on_top ////////////////////////
//
// TRUE: render main field first, then layers.
// FALSE: render main field on top of layers.
//
// Type: boolean
//

draw_main_on_top = FALSE;

//======================================================================
//
// Marking click location from separate app.
//
// CIDD can cooperate with a secondary app, receiving click details via 
//   shared memo.
//
//======================================================================
 
///////////// mark_latest_click_location //////////////
//
// Option to mark latest click location from client app.
//
// Type: boolean
//

mark_latest_click_location = FALSE;

///////////// latest_click_mark_size //////////////////
//
// Size of marker at latest click location (pixels).
// Location clicked in client app.
//
// Type: int
//

latest_click_mark_size = 11;

///////////// latest_client_mark_color ////////////////
//
// Color of mark showing latest click of remote client.
//
// Type: string
//

latest_client_mark_color = "yellow";

///////////// click_posn_rel_to_origin ////////////////
//
// Compute click posn in coords relative to display origin.
// If FALSE, click posn is computed in absolute coords for the 
//   projection in use.
//
// Type: boolean
//

click_posn_rel_to_origin = FALSE;

//======================================================================
//
// Fonts.
//
// TO-DO - fix this.
//
//======================================================================
 
///////////// num_fonts ///////////////////////////////
//
// Number of fonts of increasing size.
// The display picks the appropriate font size in tight location - e.g. 
//   axis labels,.
//
// Type: int
//

num_fonts = 8;

///////////// font_display_mode ///////////////////////
//
// 1 - Clears background behind label text. 0 - Does not clear.
// Using 1 can maket the text stand out better, but some data is 
//   overwritten.
//
// Type: int
//

font_display_mode = 0;

//======================================================================
//
// Analog clock.
//
//======================================================================
 
///////////// show_clock //////////////////////////////
//
// Set TRUE for displaying an analog clock in the upper right hand 
//   corner of the image.
//
// Type: boolean
//

show_clock = FALSE;

///////////// draw_clock_local ////////////////////////
//
// Set TRUE for clock in local time.
// Otherwise UTC.
//
// Type: boolean
//

draw_clock_local = FALSE;

///////////// use_local_timestamps ////////////////////
//
// TRUE: time stamps are local. FALSE: time stamps are UTC.
// All Input time widgets expect UTC when FALSE, local times when set 
//   TRUE.
//
// Type: boolean
//

use_local_timestamps = FALSE;

//======================================================================
//
// GUI.
//
//======================================================================
 
///////////// num_field_menu_cols /////////////////////
//
// Set this parameter to force the field menu pop-up to this many 
//   columns.
//
// Type: int
//

num_field_menu_cols = 1;

///////////// wsddm_mode //////////////////////////////
//
// Turn on WSDDM-specific behavior.
// Go to end of loop when movie stops. No on-image no-data message when 
//   winds are missing.
//
// Type: boolean
//

wsddm_mode = FALSE;

///////////// one_click_rhi ///////////////////////////
//
// This parameter allows the user to define a route/rhi with one mouse 
//   click and drag.
// When set to TRUE, disallows multi way point cross sections. RHI are 
//   defined by clicking right mouse near the radar origin and dragging 
//   away from the radar along the desired  azimuth and releasing.
//
// Type: boolean
//

one_click_rhi = FALSE;

///////////// rotate_coarse_adjust ////////////////////
//
// CIDD uses the number pad keys 7,9,4,6,1,3 to rotate the RHI by +/- 
//   these amounts (deg).
// 7-9 is coarse, 4-6 is medium, and 1-3 is fine.
//
// Type: double
//

rotate_coarse_adjust = 6;

///////////// rotate_medium_adjust ////////////////////
//
// Adjust RHI azimuth in medium mode.
// Keys 4-6.
//
// Type: double
//

rotate_medium_adjust = 2;

///////////// rotate_fine_adjust //////////////////////
//
// Adjust RHI azimuth in fine mode.
// Keys 1-3.
//
// Type: double
//

rotate_fine_adjust = 0.5;

///////////// disable_pick_mode ///////////////////////
//
// Disable pick feature.
//
// Type: boolean
//

disable_pick_mode = FALSE;

///////////// replace_underscores /////////////////////
//
// Underscores in field names and legends are replaced by spaces.
//
// Type: boolean
//

replace_underscores = TRUE;

///////////// close_popups ////////////////////////////
//
// Close CIDD's pop ups When the main window is closed.
// Set this to FALSE if you don't want CIDD to close its pop ups when 
//   switching between virtual desktops.
//
// Type: boolean
//

close_popups = FALSE;

///////////// clip_overlay_fields /////////////////////
//
// The default behavior is to render the overlay fields using the same 
//   render method as the primary field.
// CIDD can Render Overlay fields using filled polygons, and clip the 
//   data between some minimum and maximum. This is useful, for example, 
//   if one wants to show Radar data over +40dB overlaid on satellite 
//   imagery.
//
// Type: boolean
//

clip_overlay_fields = FALSE;

///////////// horiz_frame_label ///////////////////////
//
// Label in top bar of main window.
//
// Type: string
//

horiz_frame_label = "**  Colorado/ Front Range NIDS DATA - Master Parameter file **";

///////////// no_data_message /////////////////////////
//
// Message to display when no data is found.
//
// Type: string
//

no_data_message = "NO DATA FOUND (in this area at the selected time)";

///////////// status_info_file ////////////////////////
//
// System NO-Data Status/Info File.
// Will check for updates to this file, if it exists, and will replace 
//   the no_data_message with the text from this file. Leave blank if no 
//   file is to be checked.
//
// Type: string
//

status_info_file = "";

//======================================================================
//
// HELP.
//
//======================================================================
 
///////////// help_command ////////////////////////////
//
// Main command to run to get help.
//
// Type: string
//

help_command = "/opt/google/chrome/chrome http://www.rap.ucar.edu/CIDD'";

///////////// canvas_help /////////////////////////////
//
// Help text links.
// These take the form:
// widget_name_help: file_name:file_index_key_string.
// The HELPPATH environment variable must be set or the help file must 
//   be located in /usr/lib/help.
// Note the file name gets expanded to file_name.info.
//
// Type: string
//

canvas_help = "cidd_help::canvas";

///////////// frame_message_help //////////////////////
//
// Help text links.
// These take the form:
// widget_name_help: file_name:file_index_key_string.
// The HELPPATH environment variable must be set or the help file must 
//   be located in /usr/lib/help.
// Note the file name gets expanded to file_name.info.
//
// Type: string
//

frame_message_help = "cidd_help:frame_message";

//======================================================================
//
// BOOKMARKS.
//
//======================================================================
 
///////////// bookmark_command ////////////////////////
//
// This command is run whenever a BOOKMARK_MENU button is pressed.
// The characters: %U are replaced with the url text from the 
//   parameters; cidd.bookmarkN below.
//
// Type: string
//

bookmark_command = "/opt/google/chrome/chrome %U";

///////////// num_bookmarks ///////////////////////////
//
// Number of bookmarks in the Menu.
//
// Type: int
//

num_bookmarks = 4;

//======================================================================
//
// RENDERING.
//
//======================================================================
 
///////////// image_inten /////////////////////////////
//
// Sets the relative intensity of images, relative to the overlays.
// Set between 0.2 and 1.0.
//
// Type: double
//

image_inten = 0.8;

///////////// inten_levels ////////////////////////////
//
// The number of selectable intensity levels in the slider control.
//
// Type: int
//

inten_levels = 32;

///////////// data_inten //////////////////////////////
//
// Sets the relative intensity of data grid colors, relative to the 
//   overlays.
//
// Type: double
//

data_inten = 1;

///////////// image_fill_threshold ////////////////////
//
// Sets the threshold in drawable grid points where image rendering is 
//   done by a filling method on the client, rather than by rectangles on 
//   the Xserver.
// Set this high if the X server is fast or the comm link to the server 
//   is slow. Set this low if the X server is slow. Typical values range 
//   from 10,000 to 100,000  Used for 'cart' style rendering.
//
// Type: int
//

image_fill_threshold = 80000;

///////////// dynamic_contour_threshold ///////////////
//
// This sets the threshold in grid cells when the the display will 
//   render a grid as contours or as filled rectangles.
// Grids containing less than the threshold cells will be rendered as 
//   filled contours. Used for 'dcont' style rendering.
//
// Type: int
//

dynamic_contour_threshold = 160000;

///////////// coord_key ///////////////////////////////
//
// Key for coordinate in shared memory.
// Store clicked locations in shmem. Other apps can watch for those 
//   clicks, and respond approppriately.
//
// Type: int
//

coord_key = 61500;

///////////// titan_key ///////////////////////////////
//
// Key for titan clicks in shared memory.
// Store clicked locations in shmem. Rview and TimeHist can watch for 
//   those clicks, and respond approppriately.
//
// Type: int
//

titan_key = 61600;

//======================================================================
//
// RENDERING PRODUCTS.
//
//======================================================================
 
///////////// products_on /////////////////////////////
//
// Render all of the products in the overlay menu.
//
// Type: boolean
//

products_on = TRUE;

///////////// product_line_width //////////////////////
//
// Line width for rendering products.
//
// Type: int
//

product_line_width = 1;

///////////// product_font_size ///////////////////////
//
// Default font size for products.
//
// Type: int
//

product_font_size = 4;

///////////// scale_constant //////////////////////////
//
// Product scaling constant.
// Set this constant to determine at what zoom icons and will have a 
//   scale factor of 1.0. Default = 300. Function = log10(Constant 
//   /km_across_screen) + 1.0; Set to less than 0 to disable icon scaling.
//
// Type: double
//

scale_constant = 300;

//======================================================================
//
// </MAIN>.
//
//======================================================================
 
