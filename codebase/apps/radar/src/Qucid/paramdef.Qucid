/*********************************************************
 * parameter definitions for Qucid
 *
 * Mike Dixon, RAP, NCAR, Boulder, CO, USA, 80307-3000
 *
 * May 2010
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "Qucid is an integrating display for weather data products.";
  p_text = "This is a C++ application using the QT GUI toolkit. It is based on the legacy CIDD app.";
}

commentdef {
  p_header = "DEBUGGING AND PROCESS CONTROL";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Print out checks on ray memory allocation.";
  p_help = "If TRUE, the app will keep track of the number of rays allocated and freed, and print out that information every 100 rays.";
} check_ray_alloc;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to register this process with the process mapper (procmap).";
  p_help = "If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.";
} register_with_procmap;

paramdef string {
  p_default = "test";
  p_descr = "Process instance";
  p_help = "Used for registration with procmap.";
} instance;

commentdef {
  p_header = "REALTIME DATA INPUT";
}

typedef enum {
  IWRF_FMQ_INPUT, 
  IWRF_TCP_INPUT, 
  SIMULATED_INPUT, 
  DSR_FMQ_INPUT // deprecated
} input_mode_t;

paramdef enum input_mode_t {
  p_default = IWRF_FMQ_INPUT;
  p_descr = "Method for reading the input data";
  p_help = "\tIWRF_FMQ_INPUT: read IWRF moments from an FMQ.\n\tIWRF_TCP_INPUT: read an IWRF moments stream from a TCP socket.\n\tSIMULATED_INPUT: internally-generated test pattern data.\n\tDSR_FMQ_INPUT: deprecated.";
} input_mode;

paramdef string {
  p_default = "/tmp/fmq/test";
  p_descr = "DSR_FMQ_INPUT or IWRF_FMQ_INPUT mode: input URL for moments data from an FMQ";
  p_help = "Full url is of the form fmqp:://hostname:port:path. Path does not in lude the file extension.";
} input_fmq_url;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to seek to the start of the input FMQ.";
  p_help = "If TRUE, the program will seek to the start of the fmq and read the entire contents at startup. If FALSE, it will read only new data as it arrives.";
} seek_to_start_of_fmq;

paramdef string {
  p_default = "localhost";
  p_descr = "IWRF_TCP_INPUT: name of host running IWRF moments server.";
} input_tcp_host;

paramdef int {
  p_default = 11000;
  p_descr = "IWRF_TCP_INPUT: port for IWRF moments server.";
} input_tcp_port;

paramdef int {
  p_default = 400;
  p_descr = "Size of the internal queue used to store beams.";
  p_help = "The reader runs in a separate thread, and stored the beams in a queue. The main thread then grabs the available beams from the queue as they become available.";
} beam_queue_size;

commentdef {
  p_header = "ARCHIVE MODE";
}

paramdef boolean {
  p_default = TRUE;
  p_descr = "Option to begin in archive mode.";
  p_help = "If TRUE, the app will start up and read data from the archive_data_url, at the specified start time. If the start time is not set, the start time will be set to NOW.";
} begin_in_archive_mode;

paramdef string {
  p_default = "1970 01 01 00 00 00";
  p_descr = "Start time for archive mode.";
  p_help = "In archive mode, data retrieval starts at this time.";
} archive_start_time;

paramdef double {
  p_default = 3600;
  p_descr = "Time span in ARCHIVE mode (secs).";
  p_help = "Archive end time = archive_start_time + archive_time_span.";
} archive_time_span_secs;

paramdef string {
  p_default = ".";
  p_descr = "URL for archive data files.";
  p_help = "This should point to a CfRadial moments data set.";
} archive_data_url;

commentdef {
  p_header = "STATUS TO BE SHOWN IN GUI";
}

typedef struct {

  boolean azimuth;
  boolean elevation;
  boolean fixed_angle;
  boolean volume_number;
  boolean sweep_number;
  boolean n_samples;
  boolean n_gates;
  boolean gate_length;
  boolean pulse_width;
  boolean prf_mode;
  boolean prf;
  boolean nyquist;
  boolean max_range;
  boolean unambiguous_range;
  boolean measured_power_h;
  boolean measured_power_v;
  boolean scan_name;
  boolean scan_mode;
  boolean polarization_mode;
  boolean latitude;
  boolean longitude;
  boolean altitude;
  boolean altitude_rate;
  boolean sun_elevation;
  boolean sun_azimuth;
  boolean speed;
  boolean heading;
  boolean track;

} show_status_t;

paramdef struct show_status_t {

  p_default = {
    azimuth = true,
    elevation = true,
    fixed_angle = true,
    volume_number = false,
    sweep_number = true,
    n_samples = true,
    n_gates = true,
    gate_length = true,
    pulse_width = true,
    prf_mode = true,
    prf = true,
    nyquist = true,
    max_range = true,
    unambiguous_range = true,
    measured_power_h = false,
    measured_power_v = false,
    scan_name = false,
    scan_mode = true,
    polarization_mode = true,
    latitude = true,
    longitude = true,
    altitude = true,
    altitude_rate = false,
    sun_elevation = true,
    sun_azimuth = true,
    speed = false,
    heading = false,
    track = false
  };

  p_descr = "Indicate which status items to show in GUI.";

  p_help = "These items are shown in the left panel in the GUI. Setting an item to false will hide it in the GUI.";

} show_status_in_gui;

commentdef {
  p_header = "FIELDS TO BE DISPLAYED";
}

paramdef string {
  p_default = "$(HOME)/git/lrose-displays/color_scales";
  p_descr = "Directory for color scales";
  p_help = "You can set this in 2 ways:\n\n(a) Set to the absolute path\n\n(b)Set as a path relative to the location of the application binary executable.";
} color_scale_dir;

typedef enum {
  POLYGONS,
  FILLED_CONTOURS,
  DYNAMIC_CONTOURS,
  LINE_CONTOURS
} render_mode_t;

typedef struct {
  string button_label;
  string legend_label;
  string url;
  string field_name;
  string color_map;
  string units;
  double contour_low;
  double contour_high;
  double contour_interval;
  render_mode_t render_mode;
  boolean display_in_menu;
  boolean background_render;
} field_t;

paramdef struct field_t {
  p_default = {
    {
      button_label = "DBZ_F",
      legend_label = "DBZ_F",
      url = "mdvp:://front.eol.ucar.edu:8080:dynamo/cfradial/orig/moments/sband/sur",
      field_name = "DBZ_F",
      color_map = "dbz.colors",
      units = "dBZ",
      contour_low = -5,
      contour_high = 80,
      contour_interval = 5,
      render_mode = POLYGONS,
      display_in_menu = true,
      background_render = false
    }
    ,
    {
      button_label = "VEL_F",
      legend_label = "VEL_F",
      url = "mdvp:://front.eol.ucar.edu:8080:dynamo/cfradial/orig/moments/sband/sur",
      field_name = "VEL_F",
      color_map = "vel.colors",
      units = "m/s",
      contour_low = -5,
      contour_high = 80,
      contour_interval = 5,
      render_mode = POLYGONS,
      display_in_menu = true,
      background_render = false
    }
  };
  p_descr = "Fields to be displayed.";
  p_help =
    "/nbutton_label: appears on the GUI. "
    "/nlegend_label: appears in the plot. "
    "/nurl: location of data or data server. "
    "/nfield_name: name in the file. "
    "/ncolor_map: name of color map in color_scale_dir. "
    "/nunits: units to appear on the display. "
    "/ncontour_low: contour rendering lower limit. "
    "/ncontour_high: contour rendering upper limit. "
    "/ncontour_interval: contour rendering interval. "
    "/nrender_mode:"
    "/n  cart: Rectangle/polygon fills of gridded data."
    "/n  cont: false color filled contours."
    "/n  lcont: line contours."
    "/n  dcont: dynamic contours, auto switching between cart and cont."
    "/n         uses dynamic_contour_treshold.";
} fields[];

paramdef double {
  p_default = 2.0;
  p_descr = "Background rendering time period in minutes.";
  p_help = "Any field which is viewed will continue to be rendered in the "
           "background for this number of minutes.";
  p_min = 0.0;
} background_render_mins;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to use field label in the display title.";
  p_help = "If TRUE, the label will be used in the title. If FALSE, the raw_name or filtered name will be used.";
} use_field_label_in_title;

commentdef {
  p_header = "SET MAX RANGE";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to set the max range to be used for plotting.";
  p_help = "If FALSE, the max range of the data will be used. If TRUE, max_range_km will override the max range in the data.";
} set_max_range;

paramdef double {
  p_default = 225.0;
  p_descr = "Max range for the display (km).";
} max_range_km;

commentdef {
  p_header = "DISPLAY TYPE";
}

typedef enum
{
  POLAR_DISPLAY,
  BSCAN_DISPLAY
} display_mode_t;

paramdef enum display_mode_t
{
  p_descr = "Main display mode.";
  p_help =
  "\tPOLAR_DISPLAY - normal HORIZ and VERT display. "
  "\tBSCAN_DISPLAY - BSCAN mode.\n";
  p_default = POLAR_DISPLAY;
} display_mode;

commentdef {
  p_header = "NAMES AND LABELS";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to override radar name in the data.";
} override_radar_name;

paramdef string {
  p_default = "SPOL";
  p_descr = "Radar name if overridden.";
} radar_name;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to display the site name in the left panel.";
} display_site_name;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to override site name in the data.";
} override_site_name;

paramdef string {
  p_default = "MARSHALL";
  p_descr = "Site name if overridden.";
} site_name;

commentdef {
  p_header = "WINDOW DIMENSIONS AND PLOTTING DETAILS";
}

paramdef int {
  p_default = 1100;
  p_descr = "Startup width of main window (pixels).";
} main_window_width;

paramdef int {
  p_default = 635;
  p_descr = "Startup height of main window (pixels).";
} main_window_height;

paramdef int {
  p_default = 0;
  p_descr = "Startup X for main window (pixels).";
} main_window_start_x;

paramdef int {
  p_default = 0;
  p_descr = "Startup Y for main window (pixels).";
} main_window_start_y;

paramdef int {
  p_default = 40;
  p_descr = "Width of color scale (pixels).";
} color_scale_width;

paramdef int {
  p_default = 12;
  p_descr = "Basic font size for labels (pixels).";
  p_help = "Some of the labels are scaled relative to this size.";
} label_font_size;

paramdef string {
  p_default = "black";
  p_descr = "Color of main display background.";
} background_color;

paramdef string {
  p_default = "yellow";
  p_descr = "Color of text annotation in main display.";
} text_color;

paramdef string {
  p_default = "white";
  p_descr = "Color of grids and range rings.";
} grid_and_range_ring_color;

paramdef int {
  p_default = 8;
  p_descr = "Font size for labels on range rings (pixels).";
} range_ring_label_font_size;

paramdef string {
  p_default = "cyan";
  p_descr = "Color of cross at click point.";
} click_cross_color;

paramdef int {
  p_default = 11;
  p_descr = "Size of cross at click point (pixels).";
  p_help = "Size of cross drawn at click point, to select data.";
} click_cross_size;

paramdef int {
  p_default = 1;
  p_descr = "Line width for click cross.";
} click_cross_line_width;

commentdef {
  p_header = "HORIZ MODE DISPLAY";
}

typedef enum
{
  HORIZ_FULL,
  HORIZ_AIRBORNE
} horiz_display_type_t;

paramdef enum horiz_display_type_t
{
  p_descr = "Type of display to use for the HORIZ window.";
  p_help = "\tHORIZ_FULL - Display the full 360 degrees of the HORIZ. "
           "This is the default.\n"
           "\tHORIZ_AIRBORN - Use the airborn radar HORIZ display. "
           "This display shows just the 180 degrees of radar pointing forward "
           "from the nose of the plane.\n";
  p_default = HORIZ_FULL;
} horiz_display_type;

paramdef double {
  p_default = 1.0;
  p_descr = "Aspect ratio (width/height) of HORIZ window.";
  p_descr = "Set to -1 to allow aspect ratio to vary as the main window is resized.";
} horiz_aspect_ratio;

paramdef boolean {
  p_default = false;
  p_descr = "Set HORIZ grids overlay on at startup.";
} horiz_grids_on_at_startup;

paramdef boolean {
  p_default = true;
  p_descr = "Set HORIZ range rings overlay on at startup.";
} horiz_range_rings_on_at_startup;

paramdef boolean {
  p_default = true;
  p_descr = "Set HORIZ azimuth lines overlay on at startup.";
} horiz_azimuth_lines_on_at_startup;

typedef enum {
  LEGEND_TOP_LEFT, LEGEND_TOP_RIGHT, LEGEND_BOTTOM_LEFT, LEGEND_BOTTOM_RIGHT
} legend_pos_t;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of main legend in the HORIZ plot window";
  p_help = "This include time, field name and elevation angle.";
} horiz_main_legend_pos;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the azimuth beam width for rendering.";
  p_help = "Normally Qucid determines the azimuth rendering beam width automatically. You can override this and specifcally set the azimuth beam width for rendering.";
} horiz_override_rendering_beam_width;

paramdef double {
  p_default = 1.0;
  p_descr = "Rendering beam width, if override is active.";
  p_help = "See 'horiz_override_rendering_beam_width'";
} horiz_rendering_beam_width;

commentdef {
  p_header = "VERT MODE DISPLAY";
}

paramdef int {
  p_default = 500;
  p_descr = "Startup width of VERT window (pixels).";
} vert_window_width;

paramdef int {
  p_default = 500;
  p_descr = "Startup height of VERT window (pixels).";
} vert_window_height;

paramdef int {
  p_default = 1100;
  p_descr = "Startup X for VERT window (pixels).";
} vert_window_start_x;

paramdef int {
  p_default = 0;
  p_descr = "Startup Y for VERT window (pixels).";
} vert_window_start_y;

paramdef int {
  p_default = 20;
  p_descr = "Height of top margin in VERT mode (pixels).";
  p_help = "Titles go in the top margin.";
} vert_top_margin;

paramdef int {
  p_default = 20;
  p_descr = "Height of bottom margin in VERT mode (pixels).";
  p_help = "Time scale goes in the bottom margin.";
} vert_bottom_margin;

paramdef int {
  p_default = 20;
  p_descr = "Width of left margin in VERT mode (pixels).";
  p_help = "Height scale goes in the left margin.";
} vert_left_margin;

paramdef int {
  p_default = 20;
  p_descr = "Width of right margin in VERT mode (pixels).";
  p_help = "Height scale goes in the right margin.";
} vert_right_margin;

paramdef int {
  p_default = 8;
  p_descr = "Font size for labels on range rings (pixels).";
} vert_label_font_size;

paramdef int {
  p_default = 7;
  p_descr = "Length of ticks on axes (pixels).";
} vert_axis_tick_len;

paramdef int {
  p_default = 7;
  p_descr = "Ideal number of ticks on axes.";
} vert_n_ticks_ideal;

paramdef int {
  p_default = 5;
  p_descr = "Margin around some text (pixels).";
} vert_text_margin;

paramdef boolean {
  p_default = false;
  p_descr = "Flag indicating to display full 180 degrees in VERT window. "
            "If set to false, the VERT window will just display 90 degrees "
            "of the VERT.";
} vert_display_180_degrees;

paramdef double {
  p_default = 1.0;
  p_descr = "Aspect ratio (width/height) of VERT window.";
  p_descr = "Set to -1 to allow aspect ratio to vary as the VERT window is resized.";
} vert_aspect_ratio;

paramdef double {
  p_default = 25.0;
  p_descr = "Max height of data in VERT window (km).";
  p_descr = "This can be adjusted interactively.";
} vert_max_height_km;

paramdef int {
  p_default = 40;
  p_descr = "Width of color scale for VERT window (pixels).";
} vert_color_scale_width;

paramdef boolean {
  p_default = true;
  p_descr = "Set VERT grids overlay on at startup.";
} vert_grids_on_at_startup;

paramdef boolean {
  p_default = true;
  p_descr = "Set VERT range rings overlay on at startup.";
} vert_range_rings_on_at_startup;

paramdef boolean {
  p_default = false;
  p_descr = "Set VERT elevation lines overlay on at startup.";
} vert_elevation_lines_on_at_startup;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of main legend in the VERT plot window";
  p_help = "This include time, field name and elevation angle.";
} vert_main_legend_pos;

paramdef int {
  p_default = 360;
  p_descr = "Size of the queue for VERT beams.";
  p_help = "After the queue reaches this size, older beams are discarded.";
} vert_beam_queue_size;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the azimuth beam width for rendering.";
  p_help = "Normally Qucid determines the azimuth rendering beam width automatically. You can override this and specifcally set the azimuth beam width for rendering.";
} vert_override_rendering_beam_width;

paramdef double {
  p_default = 1.0;
  p_descr = "Rendering beam width, if override is active.";
  p_help = "See 'vert_override_rendering_beam_width'";
} vert_rendering_beam_width;

commentdef {
  p_header = "BSCAN TIME LIMITS";
}

paramdef double {
  p_default = 60;
  p_descr = "Number of seconds in BSCAN display.";
  p_help = "In REALTIME mode, when we reach the right-hand side of the display, the existing plot will be moved left to make room for more data.";
} bscan_time_span_secs;

paramdef boolean {
  p_default = false;
  p_descr = "Option to truncate the plot start time to even seconds.";
  p_help = "If true, we truncate the start time to the previous second.";
} bscan_truncate_start_time;

paramdef int {
  p_default = 3;
  p_descr = "Precision of subseconds in time labels.";
  p_help = "Number of decimals of precision in time labels. Set to 0 for times in integer seconds.";
  p_min = 0;
  p_max = 9;
} bscan_subsec_precision;

commentdef {
  p_header = "BSCAN REALTIME CONTROLS";
}

paramdef double {
  p_default = 0.5;
  p_descr = "What fraction of the existing data to save when moving the plot to the left.";
  p_help = "When we reach the right-hand side of the display, we need to move the plot to the left. This is the fraction of the plot that is saved after the move has taken place.";
} bscan_realtime_fraction_saved;

paramdef double {
  p_default = 0.01;
  p_descr = "Min time between incoming beams (secs).";
  p_help = "If beams arrive too fast, we discard some so that the time between the beams is at least this long.";
} bscan_min_secs_between_reading_beams;

paramdef double {
  p_default = 0.0;
  p_descr = "Min time between rendering (secs).";
  p_help = "Setting this higher makes the display less smooth, but prevents the display from taking up too much CPU and/or GPU.";
} bscan_min_secs_between_rendering_beams;

commentdef {
  p_header = "BSCAN RANGE AND ALTITUDE LIMITS";
}

paramdef boolean {
  p_default = true;
  p_descr = "Specify the min and max range when in range mode.";
  p_help = "If false, we will use the start range and max range in the data.";
} bscan_specify_range_limits;

paramdef double {
  p_default = 0;
  p_descr = "Min range to be plotted (km).";
  p_help = "Used if 'bscan_specify_range_limits' is true.";
} bscan_min_range_km;

paramdef double {
  p_default = 25;
  p_descr = "Max range to be plotted (km).";
  p_help = "Used if 'bscan_specify_range_limits' is true.";
} bscan_max_range_km;

paramdef double {
  p_default = -0.5;
  p_descr = "Min altitude plotted (km).";
} bscan_min_altitude_km;

paramdef double {
  p_default = 25;
  p_descr = "Max altitude plotted (km).";
} bscan_max_altitude_km;

paramdef boolean {
  p_default = false;
  p_descr = "Use feet for altitude units?";
  p_descr = "If true, kft (kilofeet) will be used. If false, km will be used.";
} bscan_altitude_in_feet;

paramdef boolean {
  p_default = false;
  p_descr = "Use feet for range units?";
  p_descr = "If true, kft (kilofeet) will be used. If false, km will be used.";
} bscan_range_in_feet;

typedef enum {
  RANGE_AXIS_UP, RANGE_AXIS_DOWN, RANGE_AXIS_ALTITUDE
} range_axis_mode_t;

paramdef enum range_axis_mode_t {
  p_default = RANGE_AXIS_ALTITUDE;
  p_descr = "Options for plotting range in the vertical scale.";
  p_help = "RANGE_AXIS_UP - instrument is at the bottom, range plotted positively upwards. RANGE_AXIS_DOWN: instrument is at the top, range plotted downwards. RANGE_AXIS_ALTITUDE: vertical scale represents the altitude of the gates in earth coordinates.";
} bscan_range_axis_mode;

commentdef {
  p_header = "BSCAN ANGLE LIMITS";
}

paramdef boolean {
  p_default = false;
  p_descr = "Specify the min and max elevation angle.";
  p_help = "If true, only beams within the specified limits will be plotted.";
} bscan_specify_elevation_limits;

paramdef double {
  p_default = 89;
  p_descr = "Min elevation angle to be plotted (deg).";
  p_help = "Used if 'bscan_specify_elevation_limits' is true.";
} bscan_min_elevation_deg;

paramdef double {
  p_default = 91;
  p_descr = "Max elevation angle to be plotted (deg).";
  p_help = "Used if 'bscan_specify_elevation_limits' is true.";
} bscan_max_elevation_deg;

paramdef boolean {
  p_default = false;
  p_descr = "Specify the min and max azimuth angle.";
  p_help = "If true, only beams within the specified limits will be plotted.";
} bscan_specify_azimuth_limits;

paramdef double {
  p_default = 89;
  p_descr = "Min azimuth angle to be plotted (deg).";
  p_help = "Used if 'bscan_specify_azimuth_limits' is true.";
} bscan_min_azimuth_deg;

paramdef double {
  p_default = 91;
  p_descr = "Max azimuth angle to be plotted (deg).";
  p_help = "Used if 'bscan_specify_azimuth_limits' is true.";
} bscan_max_azimuth_deg;

commentdef {
  p_header = "BSCAN CENSOR DATA BELOW SURFACE";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to censor data below the measured surface";
  p_descr = "If true, and we can identify the surface echo, suppress data below the surface.";
} bscan_censor_data_below_surface;

paramdef string {
  p_default = "DBZ";
  p_descr = "Name of field used to identify the surface from the data.";
  p_help = "The surface will be identified at the gate with the maximum value in this field.";
} bscan_surface_field;

paramdef double {
  p_default = 0.5;
  p_descr = "Minumum range to the surface (km).";
  p_help = "We will search for the surface echo in the gates beyound this range.";
} bscan_min_range_to_surface_km;

paramdef double {
  p_default = 0.2;
  p_descr = "Margin of data plotted beyond the surface (km).";
  p_help = "We will censor the data beyond the surface gate, plus this range margin.";
} bscan_surface_range_margin_km;

paramdef double {
  p_default = 5;
  p_descr = "Maximum value of the surface field, below the measured surface.";
  p_help = "After finding the range to the surface, we inspect the surface_field values below the surface. If we find values that exceed this parameter, we conclude that the surface cannot be reliably found.";
} bscan_max_field_val_below_surface;

commentdef {
  p_header = "BSCAN MARGINS";
}

paramdef int {
  p_default = 40;
  p_descr = "Height of top margin in BSCAN mode (pixels).";
  p_help = "Titles go in the top margin.";
} bscan_top_margin;

paramdef int {
  p_default = 45;
  p_descr = "Height of bottom margin in BSCAN mode (pixels).";
  p_help = "Time scale goes in the bottom margin.";
} bscan_bottom_margin;

paramdef int {
  p_default = 50;
  p_descr = "Width of left margin in BSCAN mode (pixels).";
  p_help = "Height scale goes in the left margin.";
} bscan_left_margin;

paramdef int {
  p_default = 40;
  p_descr = "Width of right margin in BSCAN mode (pixels).";
  p_help = "Height scale goes in the right margin.";
} bscan_right_margin;

paramdef int {
  p_default = 6;
  p_descr = "Length of ticks on axes (pixels).";
} bscan_axis_tick_len;

paramdef int {
  p_default = 10;
  p_descr = "Ideal number of ticks on axes.";
} bscan_n_ticks_ideal;

paramdef int {
  p_default = 5;
  p_descr = "Margin around some text (pixels).";
} bscan_text_margin;

commentdef {
  p_header = "BSCAN TITLES, LABELS AND AXES";
}

paramdef int {
  p_default = 12;
  p_descr = "Font size of center title (pixels).";
} bscan_title_font_size;

paramdef int {
  p_default = 10;
  p_descr = "Font size of axis labels in bscan (pixels).";
} bscan_axis_label_font_size;

paramdef int {
  p_default = 8;
  p_descr = "Font size of axis values (pixels).";
} bscan_axis_values_font_size;

paramdef string {
  p_default = "white";
  p_descr = "Color of axes in bscan.";
} bscan_axes_color;

paramdef string {
  p_default = "gray";
  p_descr = "Color of grid lines on bscan.";
} bscan_grid_color;

paramdef string {
  p_default = "white";
  p_descr = "Color of labels in bscan.";
} bscan_labels_color;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw grid lines across plot at regular time intervals.";
} bscan_draw_time_grid_lines;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw grid lines across plot at regular range intervals.";
} bscan_draw_range_grid_lines;

paramdef boolean {
  p_default = true;
  p_descr = "Option to draw a line for the instrument location.";
  p_descr = "Applies to RANGE_AXIS_SCALE_ALTITUDE option only.";
} bscan_draw_instrument_height_line;

paramdef string {
  p_default = "white";
  p_descr = "Color of instrument height line in ALTITUDE plot.";
} bscan_instrument_height_color;

commentdef {
  p_header = "DISTANCE SCALE";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot distance as well as time on the time axis.";
  p_help = "If true, extra tick marks will show the distance in km along the time axis, in addition to the time.";
} bscan_add_distance_to_time_axis;

paramdef int {
  p_default = 50;
  p_descr = "Number of segments to be used for computing distance.";
  p_help = "We divide the rays into this number of segments and then compute the distance travelled during each segment using the change in lat/lon position. We keep the number of segments reasonably small to avoid unnecessary CPU usage.";
} bscan_n_segments_for_computing_distance;

commentdef {
  p_header = "BSCAN LEGENDS";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot the starting lat/lon position as a legend.";
  p_help = "This helps in geolocating the data from a mobile system.";
} bscan_plot_starting_latlon_as_legend;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_LEFT;
  p_descr = "Position of lat/lon legend in plot";
  p_help = "The starting latitude/longitude will be plotted as a legend in the location specified. See 'bscan_plot_starting_latlon_as_legend'.";
} bscan_starting_latlon_legend_pos;

paramdef boolean {
  p_default = true;
  p_descr = "Option to plot the mean track and speed in a legend.";
  p_help = "This helps in geolocating the data from a mobile system.";
} bscan_plot_mean_track_and_speed_as_legend;

paramdef enum legend_pos_t {
  p_default = LEGEND_TOP_RIGHT;
  p_descr = "Position of track/speed legend in plot";
  p_help = "The mean track and speed will be plotted as a legend in the location specified. See 'bscan_plot_track_and_speed_as_legend'.";
} bscan_mean_track_and_speed_legend_pos;

commentdef {
  p_header = "BSCAN DWELL CONTROLS";
}

paramdef boolean {
  p_default = TRUE;
  p_descr = "Compute dwell from image size and time range.";
  p_help = "If TRUE, we compute the optimal dwell so that there will be approximately 1 dwell for each pixel in the resulting image. If FALSE, the dwell is specified below.";;
} bscan_archive_dwell_auto;

paramdef double {
  p_default = 0.1;
  p_descr = "Specified dwell time for archive mode (secs).";
} bscan_archive_dwell_secs;

typedef enum {
  DWELL_STATS_MEAN = 0,
  DWELL_STATS_MEDIAN = 1,
  DWELL_STATS_MAXIMUM = 2,
  DWELL_STATS_MINIMUM = 3,
  DWELL_STATS_MIDDLE = 4
} bscan_dwell_stats_t;

paramdef enum bscan_dwell_stats_t {
  p_default = DWELL_STATS_MIDDLE;
  p_descr = "Method for computing stats on the dwell.";
  p_help = "Applies to READ_RAYS_IN_INTERVAL mode. MIDDLE refers to the middle ray in the dwell sequence.";
} bscan_dwell_stats;

commentdef {
  p_header = "SAVING IMAGES TO FILE";
  p_text =
    "In creating files for the field catalog, the file name is of the form:\n\n"
    "\tcategory.platform.YYYYMMDDHHmm.product_name.ext\n\n"
    "The following parameters control the output directory, and the construction of the file name";
}

paramdef string {
  p_default = "/tmp/images/Qucid";
  p_descr = "Output directory for images generated by this app.";
} images_output_dir;

paramdef boolean {
  p_default = true;
  p_descr = "Option to create a subdirectory for each day.";
  p_descr = "If true, a subdirectory named YYYYMMDD will be appended to images_output_dir.";
} images_write_to_day_dir;

paramdef string {
  p_default = "radar";
  p_descr = "Set the category string.";
  p_help = "If empty, no category will be included.";
} images_file_name_category;

paramdef string {
  p_default = "NSF_NCAR_GV_HCR";
  p_descr = "Set the platform string.";
  p_help = "If empty, no platform will be included.";
} images_file_name_platform;

paramdef string {
  p_default = "png";
  p_descr = "Set the extension string. This also governs the file format. It should be 'png', 'jpg', 'gif' etc.";
  p_help = "An extension is always required";
} images_file_name_extension;

paramdef string {
  p_default = ".";
  p_descr = "Set the delimiter between the parts of the file name.";
  p_help = "NOTE: before the extension the delimited is always a period: '.'.";
} images_file_name_delimiter;

paramdef boolean {
  p_default = true;
  p_descr = "Normally the file name includes a time part: YYYYMMDDHHMMSS.";
  p_help = "If FALSE, the time part will be omitted.";
} images_include_time_part_in_file_name;

paramdef boolean {
  p_default = false;
  p_descr = "Normally the time part include the seconds: YYYYMMDDHHMMSS.";
  p_help = "If FALSE, the SS will be excluuded from the time part.";
} images_include_seconds_in_time_part;

paramdef boolean {
  p_default = true;
  p_descr = "Normally the file name includes the field label (product type).";
  p_help = "If FALSE, the field label will be omitted.";
} images_include_field_label_in_file_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to include the scan type in the image file name.";
  p_help = "If TRUE, the scan type will be added to the image file name.";
} images_include_scan_type_in_file_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to include the scan Id in the image file name.";
  p_help = "If TRUE, the scan Id will be added to the image file name.";} images_include_scan_id_in_file_name;

paramdef boolean {
  p_default = true;
  p_descr = "Option to write latest_data_info files when an image is created.";
  p_descr = "If true, _latest_data_info files will be written to the output directory, and the file write will be registered with the DataMapper.";
} images_write_latest_data_info;

commentdef {
  p_header = "OPTION TO CREATE IMAGES AUTOMATICALLY";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to create images automatically.";
  p_descr = "If true, images will either be created on a schedule, or the images will be created for a single time and the app will then exit.";
} images_auto_create;

typedef enum {
  CREATE_IMAGES_THEN_EXIT,
  CREATE_IMAGES_ON_REALTIME_SCHEDULE,
  CREATE_IMAGES_ON_ARCHIVE_SCHEDULE
} images_creation_mode_t;

paramdef enum images_creation_mode_t {
  p_default = CREATE_IMAGES_THEN_EXIT;
  p_descr = "Mode for controlling auto image creation.";
  p_help = "\n\nCREATE_IMAGES_FROM_GUI: create images interactively using the GUI.\n\nCREATE_IMAGES_THEN_EXIT: for the specified start time and time span, create an output image for every field in the fields array, and then exit.\n\nCREATE_IMAGES_ON_REALTIME_SCHEDULE: wait for the scheduled time, then generate an image for each field.\n\nCREATE_IMAGES_ON_ARCHIVE_SCHEDULE: for each scheduled time between the start and end times, generate an image for each field.";
} images_creation_mode;

paramdef int {
  p_default = 300;
  p_descr = "Interval at which images are created on schedule (secs).";
  p_help = "The application waits until the interval has passed, plus any specified delay, and then creates the images.";
} images_schedule_interval_secs;

paramdef int {
  p_default = 60;
  p_descr = "Delay between scheduled time and image creation (secs).";
  p_help = "In order to ensure that the data has been written, a delay may be provided. This allows for the writing application to complete writing the data before this application tries to access it.";
} images_schedule_delay_secs;

paramdef string {
  p_default = "1970 01 01 00 00 00";
  p_descr = "Start time for image generation in archive mode.";
  p_help = "Image generation starts with a seach at this time, and the proceeds at increments of images_schedule_interval_secs.";
} images_archive_start_time;

paramdef string {
  p_default = "1970 01 01 00 00 00";
  p_descr = "End time for image generation in archive mode.";
  p_help = "Image generation is terminated when the search time exceeds this end time.";
  p_help = "Only applicable for image generation.";
} images_archive_end_time;

paramdef int {
  p_default = 300;
  p_descr = "Time between scans in archive mode (secs).";
  p_help = "Only applies to POLAR (HORIZ/VERT) mode, not BSCAN mode.";
} images_scan_interval_secs;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to specify the sweep indexes for the image generation.";
  p_help = "If TRUE, only the specified sweeps will be processed.";
} images_set_sweep_index_list;

paramdef int {
  p_default = { 0, 1, 2 };
  p_descr = "List of valid sweep indexes for image generation.";
  p_help = "See 'images_set_sweep_index_list'. Images will only be generated for the specified sweep indexes.";
} images_sweep_index_list[];

commentdef {
  p_header = "SIMULATION MODE";
}

paramdef int {
  p_default = 10;
  p_descr = "Number of milliseconds to sleep between beams in simulated input "
            "mode.";
} sim_sleep_msecs;

paramdef int {
  p_default = 1000;
  p_descr = "Number of gates in simulated data.";
} sim_n_gates;

paramdef double {
  p_default = 0.075;
  p_descr = "Start range in simulated mode (km).";
} sim_start_range_km;

paramdef double {
  p_default = 0.150;
  p_descr = "Gate spacing in simulated mode (km).";
} sim_gate_spacing_km;

commentdef {
  p_header = "CLICK POINT DATA MESSAGING";
  p_text = "Writing the click point location to an FMQ in XML format.";
}

paramdef string {
  p_default = "/tmp/fmq/click_point";
  p_descr = "URL for click point URL.";
  p_help = "The details of the latest click point are written to an FMQ. The format is XML. You can view the FMQ using FmqMon -mode ASCII_PRINT.";
} click_point_fmq_url;

//////////////////////////////////////////////////////////
// paramdef.Cidd_gui: Parameter definitions for gui configuration

commentdef {
  p_header = "CIDD GUI Configuration Parameters";
};

typedef struct {
  char* id_label;
  char* grid_list;
} gui_field_set_t;

paramdef struct gui_field_set_t {
  p_descr = " Groups Grids into Sets";
  p_help = " Each Entry needs:\n"
  "ID_Label  List\n"
  "\tList - Space Delimited list of grid legend names match strings.\n"
  "\tIf a group is \"ON\", then any grid whose legend label contains any "
  " of the match strings in the group list becomes active.\n"
   "\n";
  p_default = {
  };
} gui_field_list[];

//////////////////////////////////////////////////////////
// paramdef.Cidd_Draw: Parameter definitions for Human Drawn
// Products

commentdef {
  p_header = "Draw/Export Parameters";
};

typedef struct {
  char* id_label;
  char* url;
  double valid_minutes;
  int default_id_no;
  char* default_label;
} dexport_t;

paramdef struct dexport_t {
  p_default = { {"Boundry",   "/tmp/cidd.fmq",      60, 0, "A"},
                {"Boundry-b",   "/tmp/cidd.fmq",      60, 0, "B"} };
  p_descr = "Human Drawn Products for Export Parameters.";
  p_help = 
  " Each Entry needs:\n"
  "ID_Label FMQ_URL Valid_Minutes Default_ID_no"
  "    ID_LABEL - This is used to designate Product types\n"
  "    FMQ_URL: example: fmqp:://host::dir/file \n"
   "   Valid_Minutes: How many minutes the product is valid by default\n"
   "   Default_ID_no: Default Data Type (Enumerated ID)\n"
   "   Default_label: Test to place into Label field by default\n"
   "\n";
} dexport_info[];

/////////////////////////////////////////////////////////////////////////
// paramdef.CIDD_syprods
//
// This file contains the TDRP parameter definitions for CIDD
//

ccommentdef {
  p_header = "CIDD's TDRP parameters for product rendering.";
}

typedef enum {
  SYMPROD_DEBUG_OFF, SYMPROD_DEBUG_NORM, SYMPROD_DEBUG_VERBOSE
} symprod_debug_t;

paramdef enum symprod_debug_t
{
  p_default = SYMPROD_DEBUG_OFF;
  p_help = "Debug option.\n"
           "If set, debug messages will be printed appropriately.\n";
} symprod_debug;

paramdef boolean { 
  p_descr = "Gather Data Frame by Frame, Otherwise by loop span";
  p_help = "Gathers Products valid for the current frame only - Speeds up"
           " gathering of large data sets, like METAR data" ;
  p_default = FALSE;
} symprod_short_requests;

paramdef boolean { 
  p_descr = "Request data using GZIP compression";
  p_help = "If true, symprod data will be GZIP compressed by the server.";
  p_default = FALSE;
} symprod_gzip_requests;

typedef enum {
  RENDER_ALL,             // Do no temporal clipping
  RENDER_ALL_VALID,       // Render all Valid in frame
  RENDER_VALID_IN_LAST_FRAME,   // Render all Valid in the last movie frame 
  RENDER_LATEST_IN_FRAME, // Render the latest product of like data_types (ID) valid in the frame.
  RENDER_LATEST_IN_LOOP,  // Render the latest product of like data_types (ID) valid in the movie loop.
  RENDER_FIRST_BEFORE_FRAME_TIME,// Render the latest product before the end of frame time
  RENDER_FIRST_BEFORE_DATA_TIME,// Render the latest product before the data time in each frame 
  RENDER_FIRST_AFTER_DATA_TIME, // Render the earliest product after the data time in each frame 
  RENDER_ALL_BEFORE_DATA_TIME,  // Render all valid products before the data time in each frame 
  RENDER_ALL_AFTER_DATA_TIME,   // Render all valid products after the data time in each frame 
  RENDER_GET_VALID, // Render only those returned with an SPDB GetValid() call
  RENDER_GET_VALID_AT_FRAME_TIME // Render products which have not expired at the frame time
} symprod_render_type_t;

typedef struct {
  string menu_label;
  string url;
  int data_type;
  symprod_render_type_t render_type;
  boolean on_by_default;
  double minutes_allow_before;
  double minutes_allow_after;
  double text_off_threshold;
  boolean request_data_on_zoom;
  boolean request_data_on_vert_change;
} symprod_prod_info_t;

paramdef struct symprod_prod_info_t {

  p_descr = "Product Source and Rendering Information Array";
  
  p_help =
  "The fields in the structure are as follows:\n"
  "\n"
  "  menu_label: label to be used for the product in menu.\n"
  "\n"
  "  url: for retrieving the data.\n"
  "    example: spdbp:transform_executable:[param_file]//host.dom:[port]:dir1/dir2\n"
  "\n"
  "  data_type: used when querying the SPDB data server\n"
  "    (set to 0 to retrieve all data).\n"
  "\n"
  "  render_type: Select how temporal clipping is done:\n"
  "    RENDER_ALL: Do no temporal clipping.\n"
  "    RENDER_ALL_VALID: Render all Valid in frame\n"
  "    RENDER_VALID_IN_LAST_FRAME: Render all Valid in the last frame\n"
  "    RENDER_LATEST_IN_FRAME: Render the latest product of like data_types (ID)  in the frame.\n"
  "    RENDER_LATEST_IN_LOOP:  Render the latest product of like data_types (ID)  valid in the movie loop.\n"
  "    RENDER_FIRST_BEFORE_FRAME_TIME:  Render the latest product of like data_types (ID) before the end of frame time\n"
  "    RENDER_FIRST_BEFORE_DATA_TIME:   Render the latest product of like data_types (ID  before the data time in each frame.\n"
  "    RENDER_FIRST_AFTER_DATA_TIME:    Render the earliest product after the data time in each frame.\n"
  "    RENDER_ALL_BEFORE_DATA_TIME:     Render all valid products before the data time in each frame.\n"
  "    RENDER_ALL_AFTER_DATA_TIME:      Render all valid products after the data time in each frame.\n"
  "    RENDER_GET_VALID:      Render all valid products returned with a GetValid Spdb call.\n"
  "    RENDER_GET_VALID_AT_FRAME_TIME:  Render products which have not expired at the frame time\n"
  "\n"
  "Note: all comparisons are less than or equal or greater than or equal\n"
  "\n"
  "  on_by_default: True or False\n"
  "\n"
  "  minutes_allow_before: Stretch the frame time this many minutes - prior\n"
  "  minutes_allow_after: Stretch the frame time this many minutes - after\n"
  "\n"
  "  text_off_threshold: Threshold where text disappears. Use the function:\n"
  "      log10(scaling_constant/km_distance_across_screen ) + 1.0\n"
  "      Use 0.0 to disable the off feature. (always displayed)\n"
  "\n"
  "  request_data_on_zoom: Flag indicating whether to request new data for\n"
  "      this product whenever the user changes the zoom.  Normally, this\n"
  "      should be set to false for efficiency reasons.  If the products\n"
  "      to be rendered would change with a zoom change then this should be\n"
  "      set to true.\n"
  "\n"
  "  request_data_on_vert_change: Flag indicating whether to request new data\n"
  "      for this product whenever the user changes the currently displayed\n"
  "      vertical level.  Normally, this should be set to false for efficiency\n"
  "      reasons.  If the products to be rendered would change with a zoom\n"
  "      change then this should be set to true.\n"
  "\n";
  
  p_default = {
    {
      menu_label = "RHI-ticks",
      url = "spdbp:Rhi2Symprod://localhost::spdb/rhi",
      data_type = 0,
      render_type = RENDER_ALL_VALID,
      on_by_default = FALSE,
      minutes_allow_before = 20.0,
      minutes_allow_after = 10.0,
      text_off_threshold = 0.4,
      request_data_on_zoom = false,
      request_data_on_vert_change = false
    }
  };

} symprod_prod_info[];

//////////////////////////////////////////////////////////
// paramdef.Cidd_terrain: Parameter definitions for
// Terrain Data

commentdef {
  p_header = "Terrain Parameters";
  p_comment = "Note: Terrain Fields must be on the same projection as the Display";
};

paramdef string {
  p_default = "Terrain";
  p_descr = "Label used for legends";
} terrain_id_label ;

paramdef string {
  p_default = "";
  p_descr = "Used to located gridded terrain data";
  p_help = "Terrain_URL \n"
    " Note example URL:\n"
    "  mdvp::static//venus::mdv/terrain&Elevation\n"
    " Field name follows the Ampersand. Use #N for field number override "
    "  Use caret: ^ as a substitute for spaces in field names";
    "\n";
} terrain_url;

paramdef double {
  p_default = 0.03280834;
  p_descr = "Conversion from terrain units to local coords";
  p_help = "Choose a scaler which converts plane height values\n"
           "Default is Hecto-feet (FL) per meter";
} terrain_height_scaler;

paramdef string {
  p_default = "mdvp:://tempest:0:topo/relief/mdv&RGBA";
  p_descr = "Used to located gridded land use data";
  p_help = "Land Use URL \n"
    " Note URL is of the form mdvp::[param_file]//host.dom::dir/dir&field_name\n"
    " Field name follows the Ampersand. Use #N for field number override "
    "  Use caret: ^ as a substitute for spaces in field names";
    "\n";
} landuse_url;

paramdef string {
  p_default = "terrain.colors";
  p_descr = "Color lookup table for Land use";
  p_help = "Land Use colorscale file name\n"
    " Note: CIDD looks in the colorscale dir, then in the current dir for this file"; 
} landuse_colorscale;

typedef enum {
   TERRAIN_RENDER_FILLED_CONT = 1, TERRAIN_RENDER_RECTANGLES, TERRAIN_RENDER_DYNAMIC_CONTOURS
} terrain_render_type_t;

paramdef enum terrain_render_type_t {
  p_default = TERRAIN_RENDER_RECTANGLES;
  p_descr = "Land Use rendering style";
  p_help = "Use Contours only for continious data like elevation";
} land_use_render_method;

paramdef boolean {
  p_default = false;
  p_descr = "Default Display state of Land Use/ Basemap";
} landuse_active;

paramdef string {
  p_default = "sienna";
  p_descr = "Earth's skin color";
} earth_color1;

paramdef string {
  p_default = "red4";
  p_descr = "Earth's core color";
} earth_color2;

/////////////////////////////////////////////////////////////////////////
// paramdef.CIDD_images
//
// This file contains the TDRP parameter definitions for handling some
// of the CIDD image generation options.

ccommentdef {
  p_header = "CIDD's TDRP parameters for image generation.";
}

typedef enum {
  IMAGE_DEBUG_OFF, IMAGE_DEBUG_NORM, IMAGE_DEBUG_VERBOSE
} image_debug_t;

paramdef enum image_debug_t
{
  p_default = IMAGE_DEBUG_OFF;
  p_help = "Debug option.\n"
           "If set, debug messages will be printed appropriately.\n";
} image_debug;

paramdef boolean { 
  p_descr = "Generate images for specified vertical sections.";
  p_help = "If TRUE, and CIDD is in html_mode, it will generate vertical section images in addition to the normal plan view images.";
  p_default = FALSE;
} generate_vsection_images;

paramdef boolean { 
  p_descr = "The specified waypts are in latlon degree units.";
  p_help = "If TRUE, the waypts are specified in lat/lon degrees. If FALSE, they are specified in (xkm, ykm) units in the current projection.";
  p_default = FALSE;
} image_vsection_waypts_in_latlon;

typedef struct {
  string vsection_label;
  int n_waypts;
  string waypt_locs;
} image_vsection_spec_t;

paramdef struct image_vsection_spec_t {

  p_descr = "Vertical section information array";
  
  p_help =
  "The fields in the structure are as follows:\n"
  "\n"
  "  vsection_label: label to be used for the specified vertical section.\n"
  "\n"
  "  n_waypts: number of waypts for specifying the vert section.\n"
  "            Normally this is 2 - for a single vertical section segment.\n"
  "\n"
  "  waypt_locs: location of way points. This is a string with pairs of points in it, with the following format: (x, y) (x, y) ..... (x, y)\n"
  "\n";
  
  p_default = {
    {
      vsection_label = "RHI-north",
      n_waypts = 2,
      waypt_locs = "(0, 0) (0, 150)"
    }
  };

} image_vsection_spec[];

//////////////////////////////////////////////////////////
// paramdef.Cidd_routes: Parameter definitions for 
// Predefined route wind, etc support

commentdef {
  p_header = "Route Winds Parameters";
};

typedef enum {
  ROUTE_DEBUG_OFF, ROUTE_DEBUG_NORM, ROUTE_DEBUG_VERBOSE
} route_debug_t;

paramdef enum route_debug_t
{
  p_default = ROUTE_DEBUG_OFF;
  p_help = "Set to DEBUG_NORM or DEBUG_VERBOSE for diagnostic output";
} route_debug; 

paramdef int {
  p_default = 13;
  p_descr = " Maximum height in Pixels of labels";
} route_font_height;

paramdef int {
  p_default = 1;
  p_descr = "Default state of the add_waypoints_labels";
  p_help = "0 = off, 1 = on";
} route_add_waypoints_labels;

paramdef int {
  p_default = 1;
  p_descr = "Default state of the add_wind_text labels";
  p_help = "0 = off, 1 = on";
} route_add_wind_text;

typedef enum {
  REGULAR_INTERVALS, EQUAL_DIVISIONS
} route_label_style_t; 

paramdef enum route_label_style_t
{
    p_default = REGULAR_INTERVALS;
    p_help = "Set to REGULAR_INTERVALS or EQUAL_DIVISIONS";
} route_label_style;

paramdef double {
    p_default = 55.6;
    p_help =  "Used if label_style is set to REGULAR_INTERVALS";
    p_descr = "Distance in km between winds labels";
} route_label_interval;

paramdef int {
  p_default = 10;
  p_min = 2;
  p_max = 100;
  p_descr = "number of route wind labels to plot along the route.";
  p_help = "Typically this should be set between 5 and 20";
} route_num_route_labels; 

paramdef int {
  p_default = 3;
  p_min = 1;
  p_max = 20;
  p_descr = "Width in pixels of the route winds track";
} route_track_line_width;

paramdef string {
  p_default = "mdvp::zoom_mds//neptune::mdv/mm5&U"; 
  p_descr = "U Wind Componet";
  p_help = " URL's take the form  mdvp::[paramfile]//host.dom::dir/dir&fieldname\n";
} route_u_url;

paramdef string {
  p_default = "mdvp::zoom_mds//neptune::mdv/mm5&V"; 
  p_descr = "v Wind Componet";
} route_v_url;

paramdef string {
  p_default = "mdvp::d3_d4//neptune::mdv/mm5&Turb";
  p_descr = "Turbulence Index";
} route_turb_url;

paramdef double {
  p_default = 0.25;
  p_descr = "Value at which the turbulence is considered Low";
} route_turb_low_thresh;

paramdef double {
  p_default = 0.50;
  p_descr = "Value at which the turbulence is considered Moderate";
} route_turb_mod_thresh;

paramdef double {
  p_default = 0.75;
  p_descr = "Value at which the turbulence is considered High";
} route_turb_hi_thresh;

paramdef string {
  p_default = "mdvp::d3_d4//neptune::mdv/mm5&Icing";
  p_descr = "Icing Index";
} route_icing_url;

paramdef double {
  p_default = 0.25;
  p_descr = "Value at which the icing is considered Light";
} route_icing_low_thresh;

paramdef double {
  p_default = 0.50;
  p_descr = "Value at which the icing is considered Moderate";
} route_icing_mod_thresh;

paramdef double {
  p_default = 0.75;
  p_descr = "Value at which the icing is considered Heavy";
} route_icing_hi_thresh;

paramdef string {
  p_default = {
  "A-1 8 "
  "BULAN 27.0917 124.0000 "
  "OSTAR 26.3317 123.0000 "
  "SHARK 25.8333 122.3583 "
  "ANNNA 25.5717 122.0217 "
  "APU 25.1767 121.5233 "
  "HLG 24.6400 120.7833 "
  "MKG 23.5583 119.6283 "
  "ELATO 22.3333 117.5000 ",

  "M-750 12 "
  "MOLKA 26.6583 124.0000 "
  "MORSU 25.9100 123.0000 "
  "LEKOS 25.5100 122.4717 "
  "ROBIN 25.4200 122.2083 "
  "NOKAS 25.1317 121.9917 "
  "SANAS 24.8967 121.6917 "
  "PILOX 24.4150 121.0250 "
  "ANLOT 23.9417 120.5233 "
  "TOROX 23.3533 119.9083 "
  "RENOT 22.5683 118.5117 "
  "DADON 22.2767 118.0033 "
  "ENVAR 21.9917 117.5000 ",

  "G-581 7 "
  "IGURU 23.9500 124.0000 "
  "TULTO 23.3233 123.0000 "
  "HCN 21.9283 120.8433 "
  "PARPA 22.0150 120.1683 "
  "CYRUS 22.2167 118.5317 "
  "DADON 22.2767 118.0033 "
  "ELATO 22.3333 117.5000 ",

  "B-591 9 "
  "APU 25.1767 121.5233 "
  "SANAS 24.8967 121.6917 "
  "TINHO 24.3533 122.0283 "
  "TITUS 23.8283 121.8517 "
  "TACLE 22.9933 121.5867 "
  "GID 22.6733 121.4867 "
  "TUNNY 22.3600 121.2150 "
  "HCN 21.9283 120.8433 "
  "DOREX 21.0000 120.7833 ",

  "R-583 5 "
  "BORDO 26.0167 124.0000 "
  "KIKIT 25.8817 123.5917 "
  "PABSO 25.6517 122.8750 "
  "LEKOS 25.5100 122.4717 "
  "APU 25.1767 121.5233 ",

  "G-86 3 "
  "HCN 21.9283 120.8433 "
  "ANDRE 21.7783 120.1683 "
  "KAPLI 21.1667 117.5000 ",

  "B-576 3 "
  "SALMI 28.3150 124.0000 "
  "BERBA 27.0783 123.0000 "
  "APU 25.1767 121.5233 "
  };
   p_descr = " Route path strings - Format of each string is"
      "ROUTE_LABEL NPOINTS  ID_String Lat Lon ID_String LAT Lon ...\n";
   p_help = "ROUTE_LABEL will be used in the menu, \n"
      "NPoints = Number of way points in route \n"
      "  Followed by NPoint triplets of the following:\n"
      "ID_string -> usually a Airport or VOR \n"
      "Lat Lon :  decimal degrees\n";
      "\n";
      "Note: Make sure white space separates the fields!\n";
} route_paths[];


