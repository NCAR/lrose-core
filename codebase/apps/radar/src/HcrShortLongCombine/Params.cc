/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program HcrShortLongCombine
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Combines 100Hz HCR moments stream containing both long and short pulses, and optionally long and short PRTs. Groups the long and short pulses into dwells (normally 10Hz). We write out the individual fields (i.e. long and short) and combined fields. The long pulse rays have a longer PRT than the short pulse rays. This allows us to unfold the velocity field using the staggered-PRT technique. If both long and short PRT data are present, the velocity field is unfolded into a final velocity field.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'register_with_procmap'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("register_with_procmap");
    tt->descr = tdrpStrDup("Option to register this process with the process mapper (procmap).");
    tt->help = tdrpStrDup("If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.");
    tt->val_offset = (char *) &register_with_procmap - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Program instance for process registration.");
    tt->help = tdrpStrDup("This application registers with procmap. This is the instance used for registration.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("\n\nREALTIME: read data from two moments FMQ, combine the dwells and write to an output queue. \n\nARCHIVE: move through the data between the start and end times set on the command line.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[0].val = REALTIME;
      tt->enum_def.fields[1].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[1].val = ARCHIVE;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'input_dir_short'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir_short");
    tt->descr = tdrpStrDup("Input directory short.");
    tt->help = tdrpStrDup("ARCHIVE mode only. Directory for short pulse files.");
    tt->val_offset = (char *) &input_dir_short - &_start_;
    tt->single_val.s = tdrpStrDup("$(DATA_DIR)/cfradial/moments/100hz_short");
    tt++;
    
    // Parameter 'input_dir_long'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir_long");
    tt->descr = tdrpStrDup("Input directory long.");
    tt->help = tdrpStrDup("ARCHIVE mode only. Directory for long pulse files.");
    tt->val_offset = (char *) &input_dir_long - &_start_;
    tt->single_val.s = tdrpStrDup("$(DATA_DIR)/cfradial/moments/100hz_long");
    tt++;
    
    // Parameter 'input_fmq_url_short'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url_short");
    tt->descr = tdrpStrDup("FMQ from which to read the short pulse moments stream.");
    tt->help = tdrpStrDup("REALTIME mode only.");
    tt->val_offset = (char *) &input_fmq_url_short - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::/tmp/fmq/input_short");
    tt++;
    
    // Parameter 'input_fmq_url_long'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url_long");
    tt->descr = tdrpStrDup("FMQ from which to read the long pulse moments stream.");
    tt->help = tdrpStrDup("REALTIME mode only.");
    tt->val_offset = (char *) &input_fmq_url_long - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::/tmp/fmq/input_long");
    tt++;
    
    // Parameter 'seek_to_end_of_input_fmq'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("seek_to_end_of_input_fmq");
    tt->descr = tdrpStrDup("Option to seek to the end of the input FMQ.");
    tt->help = tdrpStrDup("REALTIME mode only. If TRUE, the program will seek to the end of the fmq and only read in new data. If FALSE, it will start reading from the beginning of the FMQ.");
    tt->val_offset = (char *) &seek_to_end_of_input_fmq - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("LIMIT RANGE?");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_max_range'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_max_range");
    tt->descr = tdrpStrDup("Option to set the max range for any ray.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_max_range - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_range_km");
    tt->descr = tdrpStrDup("Specified maximim range - km.");
    tt->help = tdrpStrDup("Gates beyond this range are removed.");
    tt->val_offset = (char *) &max_range_km - &_start_;
    tt->single_val.d = 9999;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("SET THE COMBINED DWELL DETAILS");
    tt->comment_text = tdrpStrDup("Normally we combine the high-rate moments data (say at 100 hz) into lower-rate dwells, say at 10 hz.");
    tt++;
    
    // Parameter 'dwell_length_secs'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dwell_length_secs");
    tt->descr = tdrpStrDup("Specify the output dwell length (secs).");
    tt->help = tdrpStrDup("Dwells from the input data will be combined to form dwells covering the specified time.");
    tt->val_offset = (char *) &dwell_length_secs - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'dwell_stats_method'
    // ctype is '_dwell_stats_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("dwell_stats_method");
    tt->descr = tdrpStrDup("Method for computing stats on the dwell.");
    tt->help = tdrpStrDup("MIDDLE refers to the middle ray in the dwell sequence. The DISCRETE_MODE computes applies only to discrete (integer) fields, and returns the most common entry in a discrete data set.");
    tt->val_offset = (char *) &dwell_stats_method - &_start_;
    tt->enum_def.name = tdrpStrDup("dwell_stats_method_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DWELL_STATS_MEAN");
      tt->enum_def.fields[0].val = DWELL_STATS_MEAN;
      tt->enum_def.fields[1].name = tdrpStrDup("DWELL_STATS_MEDIAN");
      tt->enum_def.fields[1].val = DWELL_STATS_MEDIAN;
      tt->enum_def.fields[2].name = tdrpStrDup("DWELL_STATS_MAXIMUM");
      tt->enum_def.fields[2].val = DWELL_STATS_MAXIMUM;
      tt->enum_def.fields[3].name = tdrpStrDup("DWELL_STATS_MINIMUM");
      tt->enum_def.fields[3].val = DWELL_STATS_MINIMUM;
      tt->enum_def.fields[4].name = tdrpStrDup("DWELL_STATS_MIDDLE");
      tt->enum_def.fields[4].val = DWELL_STATS_MIDDLE;
      tt->enum_def.fields[5].name = tdrpStrDup("DWELL_STATS_DISCRETE_MODE");
      tt->enum_def.fields[5].val = DWELL_STATS_DISCRETE_MODE;
    tt->single_val.e = DWELL_STATS_MEAN;
    tt++;
    
    // Parameter 'dwell_stats_max_fraction_missing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dwell_stats_max_fraction_missing");
    tt->descr = tdrpStrDup("Specify the max fraction of the dwell that can have missing data.");
    tt->help = tdrpStrDup("We compute how much of the dwell is missing for each field. If the fraction exceeds this parameter, the combined value will be set to missing.");
    tt->val_offset = (char *) &dwell_stats_max_fraction_missing - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 0;
    tt->max_val.d = 1;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("OPTION TO SET STATS METHOD FOR INDIVIDUAL FIELDS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_stats_method_for_individual_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_stats_method_for_individual_fields");
    tt->descr = tdrpStrDup("Set the stats method for individual fields.");
    tt->help = tdrpStrDup("The global stats method is set by the 'dwell_stats_method' parameter. If 'set_stats_method_for_individual_fields' is true, we can set the stats method on particular fields. Fields not specified here will use the global parameter.");
    tt->val_offset = (char *) &set_stats_method_for_individual_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'stats_method_fields'
    // ctype is '_stats_method_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("stats_method_fields");
    tt->descr = tdrpStrDup("Stats methods for individual fields.");
    tt->help = tdrpStrDup("Applies if 'set_stats_method_for_individual_fields' is true. The global stats method is set by the 'dwell_stats_method' parameter. Fields not specified here will use the global parameter.");
    tt->array_offset = (char *) &_stats_method_fields - &_start_;
    tt->array_n_offset = (char *) &stats_method_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(stats_method_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("stats_method_field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_stats_method_fields->field_name - (char *) _stats_method_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("dwell_stats_method_t");
      tt->struct_def.fields[1].fname = tdrpStrDup("stats_method");
      tt->struct_def.fields[1].ptype = ENUM_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_stats_method_fields->stats_method - (char *) _stats_method_fields;
        tt->struct_def.fields[1].enum_def.name = tdrpStrDup("dwell_stats_method_t");
        tt->struct_def.fields[1].enum_def.nfields = 6;
        tt->struct_def.fields[1].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[1].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[1].enum_def.fields[0].name = tdrpStrDup("DWELL_STATS_MEAN");
        tt->struct_def.fields[1].enum_def.fields[0].val = DWELL_STATS_MEAN;
        tt->struct_def.fields[1].enum_def.fields[1].name = tdrpStrDup("DWELL_STATS_MEDIAN");
        tt->struct_def.fields[1].enum_def.fields[1].val = DWELL_STATS_MEDIAN;
        tt->struct_def.fields[1].enum_def.fields[2].name = tdrpStrDup("DWELL_STATS_MAXIMUM");
        tt->struct_def.fields[1].enum_def.fields[2].val = DWELL_STATS_MAXIMUM;
        tt->struct_def.fields[1].enum_def.fields[3].name = tdrpStrDup("DWELL_STATS_MINIMUM");
        tt->struct_def.fields[1].enum_def.fields[3].val = DWELL_STATS_MINIMUM;
        tt->struct_def.fields[1].enum_def.fields[4].name = tdrpStrDup("DWELL_STATS_MIDDLE");
        tt->struct_def.fields[1].enum_def.fields[4].val = DWELL_STATS_MIDDLE;
        tt->struct_def.fields[1].enum_def.fields[5].name = tdrpStrDup("DWELL_STATS_DISCRETE_MODE");
        tt->struct_def.fields[1].enum_def.fields[5].val = DWELL_STATS_DISCRETE_MODE;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("FLAG");
      tt->struct_vals[1].e = DWELL_STATS_MEDIAN;
      tt->struct_vals[2].s = tdrpStrDup("ANTENNA_FLAG");
      tt->struct_vals[3].e = DWELL_STATS_MIDDLE;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("FIELD NAMES for combination");
    tt->comment_text = tdrpStrDup("The long pulse rays have a longer PRT than the short pulse rays. This allows us to unfold the velocity field using the staggered-PRT technique. If both long and short PRT data are present, the velocity field is unfolded into a final velocity field.");
    tt++;
    
    // Parameter 'perform_velocity_unfolding'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("perform_velocity_unfolding");
    tt->descr = tdrpStrDup("Option to unfold the velocity field.");
    tt->help = tdrpStrDup("If false, the short vel will be copied to the unfolded field. The vel_unfolded field will be added to the output data set.");
    tt->val_offset = (char *) &perform_velocity_unfolding - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'input_vel_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_vel_field_name");
    tt->descr = tdrpStrDup("This is the name for the velocity field in the input data.");
    tt->help = tdrpStrDup("The field name must be the same for the short- and long-prt rays.");
    tt->val_offset = (char *) &input_vel_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("VEL");
    tt++;
    
    // Parameter 'suffix_to_add_for_short_pulse_fields'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("suffix_to_add_for_short_pulse_fields");
    tt->descr = tdrpStrDup("This suffix is added to the input fields for short-prt moments.");
    tt->help = tdrpStrDup("For each incoming short-pulse field, we add this suffix to the incoming field name.");
    tt->val_offset = (char *) &suffix_to_add_for_short_pulse_fields - &_start_;
    tt->single_val.s = tdrpStrDup("_short");
    tt++;
    
    // Parameter 'suffix_to_add_for_long_pulse_fields'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("suffix_to_add_for_long_pulse_fields");
    tt->descr = tdrpStrDup("This suffix is added to the input fields for long-prt moments.");
    tt->help = tdrpStrDup("For each incoming long-pulse field, we add this suffix to the incoming field name.");
    tt->val_offset = (char *) &suffix_to_add_for_long_pulse_fields - &_start_;
    tt->single_val.s = tdrpStrDup("_long");
    tt++;
    
    // Parameter 'vel_unfolded_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vel_unfolded_field_name");
    tt->descr = tdrpStrDup("Name for the unfolded velocity.");
    tt->help = tdrpStrDup("This is an output field, computed by unfolding the dual-prt vel fields.");
    tt->val_offset = (char *) &vel_unfolded_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("VEL_unfold");
    tt++;
    
    // Parameter 'correct_velocity_for_platform_vertical_motion'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("correct_velocity_for_platform_vertical_motion");
    tt->descr = tdrpStrDup("Option to correct the estimated velocity corrected for vertical platform motion.");
    tt->help = tdrpStrDup("For an airborne platform, we measure the vertical velocity of the platform using an INS system. We can optionally correct the measured velocity for the plaform vertical motion. This correction is applied AFTER the unfolding computation.");
    tt->val_offset = (char *) &correct_velocity_for_platform_vertical_motion - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("OPTION TO SPECIFY OUTPUT FIELD NAMES AND ENCODING");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_output_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_output_fields");
    tt->descr = tdrpStrDup("Set the field names and output encoding");
    tt->help = tdrpStrDup("If false, all fields will be used.");
    tt->val_offset = (char *) &set_output_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_output_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("Output field details.");
    tt->help = tdrpStrDup("Set the details for the output fields. The output_field_name is the ndtCDF variable name. Set the long name to a more descriptive name. Set the standard name to the CF standard name for this field. If the long name or standard name are empty, the existing names are used. If SCALING_SPECIFIED, then the scale and offset is used.");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(output_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("output_field_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("input_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_fields->input_field_name - (char *) _output_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("output_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_fields->output_field_name - (char *) _output_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("long_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_output_fields->long_name - (char *) _output_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("standard_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_output_fields->standard_name - (char *) _output_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("output_units");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_output_fields->output_units - (char *) _output_fields;
      tt->struct_def.fields[5].ftype = tdrpStrDup("output_encoding_t");
      tt->struct_def.fields[5].fname = tdrpStrDup("encoding");
      tt->struct_def.fields[5].ptype = ENUM_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_output_fields->encoding - (char *) _output_fields;
        tt->struct_def.fields[5].enum_def.name = tdrpStrDup("output_encoding_t");
        tt->struct_def.fields[5].enum_def.nfields = 5;
        tt->struct_def.fields[5].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[5].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[5].enum_def.fields[0].name = tdrpStrDup("OUTPUT_ENCODING_ASIS");
        tt->struct_def.fields[5].enum_def.fields[0].val = OUTPUT_ENCODING_ASIS;
        tt->struct_def.fields[5].enum_def.fields[1].name = tdrpStrDup("OUTPUT_ENCODING_FLOAT32");
        tt->struct_def.fields[5].enum_def.fields[1].val = OUTPUT_ENCODING_FLOAT32;
        tt->struct_def.fields[5].enum_def.fields[2].name = tdrpStrDup("OUTPUT_ENCODING_INT32");
        tt->struct_def.fields[5].enum_def.fields[2].val = OUTPUT_ENCODING_INT32;
        tt->struct_def.fields[5].enum_def.fields[3].name = tdrpStrDup("OUTPUT_ENCODING_INT16");
        tt->struct_def.fields[5].enum_def.fields[3].val = OUTPUT_ENCODING_INT16;
        tt->struct_def.fields[5].enum_def.fields[4].name = tdrpStrDup("OUTPUT_ENCODING_INT08");
        tt->struct_def.fields[5].enum_def.fields[4].val = OUTPUT_ENCODING_INT08;
      tt->struct_def.fields[6].ftype = tdrpStrDup("output_scaling_t");
      tt->struct_def.fields[6].fname = tdrpStrDup("output_scaling");
      tt->struct_def.fields[6].ptype = ENUM_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_output_fields->output_scaling - (char *) _output_fields;
        tt->struct_def.fields[6].enum_def.name = tdrpStrDup("output_scaling_t");
        tt->struct_def.fields[6].enum_def.nfields = 2;
        tt->struct_def.fields[6].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[6].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[6].enum_def.fields[0].name = tdrpStrDup("SCALING_DYNAMIC");
        tt->struct_def.fields[6].enum_def.fields[0].val = SCALING_DYNAMIC;
        tt->struct_def.fields[6].enum_def.fields[1].name = tdrpStrDup("SCALING_SPECIFIED");
        tt->struct_def.fields[6].enum_def.fields[1].val = SCALING_SPECIFIED;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("output_scale");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_output_fields->output_scale - (char *) _output_fields;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("output_offset");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_output_fields->output_offset - (char *) _output_fields;
    tt->n_struct_vals = 18;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].s = tdrpStrDup("DBZ");
      tt->struct_vals[2].s = tdrpStrDup("reflectivity");
      tt->struct_vals[3].s = tdrpStrDup("equivalent_reflectivity_factor");
      tt->struct_vals[4].s = tdrpStrDup("dBZ");
      tt->struct_vals[5].e = OUTPUT_ENCODING_ASIS;
      tt->struct_vals[6].e = SCALING_DYNAMIC;
      tt->struct_vals[7].d = 0.01;
      tt->struct_vals[8].d = 0;
      tt->struct_vals[9].s = tdrpStrDup("VEL");
      tt->struct_vals[10].s = tdrpStrDup("VEL");
      tt->struct_vals[11].s = tdrpStrDup("radial_velocity");
      tt->struct_vals[12].s = tdrpStrDup("radial_velocity_of_scatterers_away_from_instrument");
      tt->struct_vals[13].s = tdrpStrDup("m/s");
      tt->struct_vals[14].e = OUTPUT_ENCODING_ASIS;
      tt->struct_vals[15].e = SCALING_DYNAMIC;
      tt->struct_vals[16].d = 0.01;
      tt->struct_vals[17].d = 0;
    tt++;
    
    // Parameter 'exclude_specified_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("exclude_specified_fields");
    tt->descr = tdrpStrDup("Option to exclude fields in the specified list.");
    tt->help = tdrpStrDup("If true, the specified fields will be excluded. This may be easier than specifiying all of the fields to be included, if that list is very long.");
    tt->val_offset = (char *) &exclude_specified_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'excluded_fields'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("excluded_fields");
    tt->descr = tdrpStrDup("List of fields to be excluded.");
    tt->help = tdrpStrDup("List the names to be excluded");
    tt->array_offset = (char *) &_excluded_fields - &_start_;
    tt->array_n_offset = (char *) &excluded_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("DBZ");
      tt->array_vals[1].s = tdrpStrDup("VEL");
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("OPTION TO SPECIFY OUTPUT ENCODING FOR ALL FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_output_encoding_for_all_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_output_encoding_for_all_fields");
    tt->descr = tdrpStrDup("Option to set output encoding for all fields");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_output_encoding_for_all_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_encoding'
    // ctype is '_output_encoding_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_encoding");
    tt->descr = tdrpStrDup("Output encoding for all fields, if requested.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_encoding - &_start_;
    tt->enum_def.name = tdrpStrDup("output_encoding_t");
    tt->enum_def.nfields = 5;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("OUTPUT_ENCODING_ASIS");
      tt->enum_def.fields[0].val = OUTPUT_ENCODING_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("OUTPUT_ENCODING_FLOAT32");
      tt->enum_def.fields[1].val = OUTPUT_ENCODING_FLOAT32;
      tt->enum_def.fields[2].name = tdrpStrDup("OUTPUT_ENCODING_INT32");
      tt->enum_def.fields[2].val = OUTPUT_ENCODING_INT32;
      tt->enum_def.fields[3].name = tdrpStrDup("OUTPUT_ENCODING_INT16");
      tt->enum_def.fields[3].val = OUTPUT_ENCODING_INT16;
      tt->enum_def.fields[4].name = tdrpStrDup("OUTPUT_ENCODING_INT08");
      tt->enum_def.fields[4].val = OUTPUT_ENCODING_INT08;
    tt->single_val.e = OUTPUT_ENCODING_ASIS;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("WRITE CFRADIAL FILES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_format'
    // ctype is '_output_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_format");
    tt->descr = tdrpStrDup("Format for the output files.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_format - &_start_;
    tt->enum_def.name = tdrpStrDup("output_format_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("OUTPUT_FORMAT_CFRADIAL");
      tt->enum_def.fields[0].val = OUTPUT_FORMAT_CFRADIAL;
      tt->enum_def.fields[1].name = tdrpStrDup("OUTPUT_FORMAT_CFRADIAL2");
      tt->enum_def.fields[1].val = OUTPUT_FORMAT_CFRADIAL2;
    tt->single_val.e = OUTPUT_FORMAT_CFRADIAL;
    tt++;
    
    // Parameter 'output_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_dir");
    tt->descr = tdrpStrDup("Output directory path.");
    tt->help = tdrpStrDup("Files will be written to this directory.");
    tt->val_offset = (char *) &output_dir - &_start_;
    tt->single_val.s = tdrpStrDup("./output");
    tt++;
    
    // Parameter 'output_filename_mode'
    // ctype is '_filename_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_filename_mode");
    tt->descr = tdrpStrDup("Mode for computing output file name.");
    tt->help = tdrpStrDup("START_AND_END_TIMES: include both start and end times in file name. START_TIME_ONLY: include only start time in file name. END_TIME_ONLY: include only end time in file name. SPECIFY_FILE_NAME: file of this name will be written to output_dir.");
    tt->val_offset = (char *) &output_filename_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("filename_mode_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("START_AND_END_TIMES");
      tt->enum_def.fields[0].val = START_AND_END_TIMES;
      tt->enum_def.fields[1].name = tdrpStrDup("START_TIME_ONLY");
      tt->enum_def.fields[1].val = START_TIME_ONLY;
      tt->enum_def.fields[2].name = tdrpStrDup("END_TIME_ONLY");
      tt->enum_def.fields[2].val = END_TIME_ONLY;
      tt->enum_def.fields[3].name = tdrpStrDup("SPECIFY_FILE_NAME");
      tt->enum_def.fields[3].val = SPECIFY_FILE_NAME;
    tt->single_val.e = START_AND_END_TIMES;
    tt++;
    
    // Parameter 'output_filename_prefix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_filename_prefix");
    tt->descr = tdrpStrDup("Optional prefix for output filename.");
    tt->help = tdrpStrDup("If empty, the standard prefix will be used.");
    tt->val_offset = (char *) &output_filename_prefix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_output_files_on_time_boundaries'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_output_files_on_time_boundaries");
    tt->descr = tdrpStrDup("Option to write the output files on time boundaries.");
    tt->help = tdrpStrDup("See 'output_file_time_interval_secs'.");
    tt->val_offset = (char *) &write_output_files_on_time_boundaries - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_file_time_interval_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_file_time_interval_secs");
    tt->descr = tdrpStrDup("Time interval at which files will be written out (secs).");
    tt->help = tdrpStrDup("See 'split_output_files_on_time'. To make sense, this interval should divide evenly into an hour - i.e. 3600.");
    tt->val_offset = (char *) &output_file_time_interval_secs - &_start_;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'include_instrument_name_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_instrument_name_in_file_name");
    tt->descr = tdrpStrDup("Option to include the instrument name in the file name.");
    tt->help = tdrpStrDup("Only applies to CfRadial files. If true, the instrument name will be included just before the volume number in the output file name.");
    tt->val_offset = (char *) &include_instrument_name_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'include_subsecs_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_subsecs_in_file_name");
    tt->descr = tdrpStrDup("Option to include sub-seconds in date-time part of file name.");
    tt->help = tdrpStrDup("Default is true. Only applies to CfRadial files. If true, the millisecs of the start and end time will be included in the file name.");
    tt->val_offset = (char *) &include_subsecs_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'include_scan_type_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_scan_type_in_file_name");
    tt->descr = tdrpStrDup("Option to include the scan type in the file name.");
    tt->help = tdrpStrDup("Default is true. Only applies to CfRadial files. If true, the scan type (SUR, SEC, RHI, VER etc) will be included in the file name.");
    tt->val_offset = (char *) &include_scan_type_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'use_hyphen_in_file_name_datetime_part'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_hyphen_in_file_name_datetime_part");
    tt->descr = tdrpStrDup("Option to use a hyphen between date and time in filename.");
    tt->help = tdrpStrDup("Default is false. Only applies to CfRadial files. Normally an underscore is used.");
    tt->val_offset = (char *) &use_hyphen_in_file_name_datetime_part - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_filename'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_filename");
    tt->descr = tdrpStrDup("Name of output file.");
    tt->help = tdrpStrDup("Applies only if output_filename_mode is SPECIFY_FILE_NAME. File of this name will be written to output_dir.");
    tt->val_offset = (char *) &output_filename - &_start_;
    tt->single_val.s = tdrpStrDup("cfradial.test.nc");
    tt++;
    
    // Parameter 'append_day_dir_to_output_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("append_day_dir_to_output_dir");
    tt->descr = tdrpStrDup("Add the day directory to the output directory.");
    tt->help = tdrpStrDup("Path will be output_dir/yyyymmdd/filename.");
    tt->val_offset = (char *) &append_day_dir_to_output_dir - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'append_year_dir_to_output_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("append_year_dir_to_output_dir");
    tt->descr = tdrpStrDup("Add the year directory to the output directory.");
    tt->help = tdrpStrDup("Path will be output_dir/yyyy/yyyymmdd/filename.");
    tt->val_offset = (char *) &append_year_dir_to_output_dir - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_latest_data_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_latest_data_info");
    tt->descr = tdrpStrDup("Option to write out _latest_data_info files.");
    tt->help = tdrpStrDup("If true, the _latest_data_info files will be written after the converted file is written.");
    tt->val_offset = (char *) &write_latest_data_info - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("OUTPUT IN FMQ MODE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_url");
    tt->descr = tdrpStrDup("FMQ to which the combined dwells are written.");
    tt->help = tdrpStrDup("FMQ mode only.");
    tt->val_offset = (char *) &output_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::/tmp/fmq/output");
    tt++;
    
    // Parameter 'output_fmq_compress'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_compress");
    tt->descr = tdrpStrDup("Option to compress the output fmq.");
    tt->help = tdrpStrDup("The default is for no compression.");
    tt->val_offset = (char *) &output_fmq_compress - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_fmq_n_slots'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_n_slots");
    tt->descr = tdrpStrDup("Number of slots in output FMQ.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_fmq_n_slots - &_start_;
    tt->single_val.i = 5000;
    tt++;
    
    // Parameter 'output_fmq_buf_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_buf_size");
    tt->descr = tdrpStrDup("Size of buffer in output FMQ.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_fmq_buf_size - &_start_;
    tt->single_val.i = 100000000;
    tt++;
    
    // Parameter 'output_fmq_write_blocking'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_write_blocking");
    tt->descr = tdrpStrDup("Option to block on write when the radar queue fills up.");
    tt->help = tdrpStrDup("If false, the program writes data to the output queue without regard to whether the reader is keeping up. This mode should usually be used in realtime, to avoid holding things up if a client becomes slow. If true, the program will not overwrite data in the queue which has not been read by the reader. This is recommended for ARCHIVE and FILELIST mode. In this mode there should be only one reader. If you need to service more than one reader, use Fmq2Fmq in write blocking mode with multiple output urls to multiplex the queue.");
    tt->val_offset = (char *) &output_fmq_write_blocking - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_fmq_data_mapper_report_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_data_mapper_report_interval");
    tt->descr = tdrpStrDup("Number of seconds between reports to DataMapper.");
    tt->help = tdrpStrDup("If > 0, the program will register with the DataMapper when the output FMQs are written to. If <= 0, registration will not be performed.");
    tt->val_offset = (char *) &output_fmq_data_mapper_report_interval - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
