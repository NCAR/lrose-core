/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program HcrShortLongCombine
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Combines 100Hz HCR moments stream containing both long and short pulses, and optionally long and short PRTs. Groups the long and short pulses into dwells (normally 10Hz). We write out the individual fields (i.e. long and short) and combined fields. The long pulse rays have a longer PRT than the short pulse rays. This allows us to unfold the velocity field using the staggered-PRT technique. If both long and short PRT data are present, the velocity field is unfolded into a final velocity field.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'register_with_procmap'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("register_with_procmap");
    tt->descr = tdrpStrDup("Option to register this process with the process mapper (procmap).");
    tt->help = tdrpStrDup("If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.");
    tt->val_offset = (char *) &register_with_procmap - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Program instance for process registration.");
    tt->help = tdrpStrDup("This application registers with procmap. This is the instance used for registration.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("\n\nREALTIME: we read data from two moments FMQ, combine the dwells and write to an output queue. \n\nARCHIVE: we read the moments data from CfRadial files, between the start and end times set on the command line.\n\nIn both REALTIME and ARCHIVE mode, we write the resulting moments to an output FMQ.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[0].val = REALTIME;
      tt->enum_def.fields[1].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[1].val = ARCHIVE;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'input_fmq_url_short'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url_short");
    tt->descr = tdrpStrDup("FMQ from which to read the short pulse moments stream.");
    tt->help = tdrpStrDup("REALTIME mode only.");
    tt->val_offset = (char *) &input_fmq_url_short - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::/tmp/fmq/input_short");
    tt++;
    
    // Parameter 'input_fmq_url_long'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url_long");
    tt->descr = tdrpStrDup("FMQ from which to read the long pulse moments stream.");
    tt->help = tdrpStrDup("REALTIME mode only.");
    tt->val_offset = (char *) &input_fmq_url_long - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::/tmp/fmq/input_long");
    tt++;
    
    // Parameter 'seek_to_end_of_input_fmq'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("seek_to_end_of_input_fmq");
    tt->descr = tdrpStrDup("Option to seek to the end of the input FMQ.");
    tt->help = tdrpStrDup("REALTIME mode only. If TRUE, the program will seek to the end of the fmq and only read in new data. If FALSE, it will start reading from the beginning of the FMQ.");
    tt->val_offset = (char *) &seek_to_end_of_input_fmq - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'input_dir_short'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir_short");
    tt->descr = tdrpStrDup("Input directory short.");
    tt->help = tdrpStrDup("ARCHIVE mode only. Directory for short pulse files.");
    tt->val_offset = (char *) &input_dir_short - &_start_;
    tt->single_val.s = tdrpStrDup("$(DATA_DIR)/cfradial/moments/100hz_short");
    tt++;
    
    // Parameter 'input_dir_long'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir_long");
    tt->descr = tdrpStrDup("Input directory long.");
    tt->help = tdrpStrDup("ARCHIVE mode only. Directory for long pulse files.");
    tt->val_offset = (char *) &input_dir_long - &_start_;
    tt->single_val.s = tdrpStrDup("$(DATA_DIR)/cfradial/moments/100hz_long");
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("OVERRIDE PLATFORM TYPE?");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_platform_type'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_platform_type");
    tt->descr = tdrpStrDup("Option to override platform type on read. If true, the file will be read in, the platform type will be changed, and then any post-read processing will be performed.");
    tt->help = tdrpStrDup("\tPLATFORM_FIXED  - radar is in a fixed location\n\tPLATFORM_VEHICLE -  radar is mounted on a land vehicle\n\tPLATFORM_SHIP - radar is mounted on a ship\n\tPLATFORM_AIRCRAFT_FORE - forward-looking on aircraft\n\tPLATFORM_AIRCRAFT_AFT - backward-looking on aircraft\n\tPLATFORM_AIRCRAFT_TAIL - tail - e.g. ELDORA\n\tPLATFORM_AIRCRAFT_BELLY -  belly radar on aircraft\n\tPLATFORM_AIRCRAFT_ROOF - roof radar on aircraft\n\tPLATFORM_AIRCRAFT_NOSE - radar in nose radome on aircraft\n\tPLATFORM_SATELLITE_ORBIT - orbiting satellite\n\tPLATFORM_SATELLITE_GEOSTAT - geostationary satellite\n");
    tt->val_offset = (char *) &override_platform_type - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'platform_type'
    // ctype is '_platform_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("platform_type");
    tt->descr = tdrpStrDup("Platform type.");
    tt->help = tdrpStrDup("See override_platform_type.");
    tt->val_offset = (char *) &platform_type - &_start_;
    tt->enum_def.name = tdrpStrDup("platform_type_t");
    tt->enum_def.nfields = 11;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PLATFORM_FIXED");
      tt->enum_def.fields[0].val = PLATFORM_FIXED;
      tt->enum_def.fields[1].name = tdrpStrDup("PLATFORM_VEHICLE");
      tt->enum_def.fields[1].val = PLATFORM_VEHICLE;
      tt->enum_def.fields[2].name = tdrpStrDup("PLATFORM_SHIP");
      tt->enum_def.fields[2].val = PLATFORM_SHIP;
      tt->enum_def.fields[3].name = tdrpStrDup("PLATFORM_AIRCRAFT_FORE");
      tt->enum_def.fields[3].val = PLATFORM_AIRCRAFT_FORE;
      tt->enum_def.fields[4].name = tdrpStrDup("PLATFORM_AIRCRAFT_AFT");
      tt->enum_def.fields[4].val = PLATFORM_AIRCRAFT_AFT;
      tt->enum_def.fields[5].name = tdrpStrDup("PLATFORM_AIRCRAFT_TAIL");
      tt->enum_def.fields[5].val = PLATFORM_AIRCRAFT_TAIL;
      tt->enum_def.fields[6].name = tdrpStrDup("PLATFORM_AIRCRAFT_BELLY");
      tt->enum_def.fields[6].val = PLATFORM_AIRCRAFT_BELLY;
      tt->enum_def.fields[7].name = tdrpStrDup("PLATFORM_AIRCRAFT_ROOF");
      tt->enum_def.fields[7].val = PLATFORM_AIRCRAFT_ROOF;
      tt->enum_def.fields[8].name = tdrpStrDup("PLATFORM_AIRCRAFT_NOSE");
      tt->enum_def.fields[8].val = PLATFORM_AIRCRAFT_NOSE;
      tt->enum_def.fields[9].name = tdrpStrDup("PLATFORM_SATELLITE_ORBIT");
      tt->enum_def.fields[9].val = PLATFORM_SATELLITE_ORBIT;
      tt->enum_def.fields[10].name = tdrpStrDup("PLATFORM_SATELLITE_GEOSTAT");
      tt->enum_def.fields[10].val = PLATFORM_SATELLITE_GEOSTAT;
    tt->single_val.e = PLATFORM_AIRCRAFT_FORE;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("OVERRIDE PRIMARY AXIS?");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_primary_axis'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_primary_axis");
    tt->descr = tdrpStrDup("Option to override primary axis on read. If true, the file will be read in, the primary axis will be changed, and then any post-read processing will be performed.");
    tt->help = tdrpStrDup("\tPRIMARY_AXIS_Z - vertical\n\tPRIMARY_AXIS_Y - longitudinal axis of platform\n\tPRIMARY_AXIS_X - lateral axis of platform\n\tPRIMARY_AXIS_Z_PRIME - inverted vertical\n\tPRIMARY_AXIS_Y_PRIME - ELDORA, HRD tail\n\tPRIMARY_AXIS_X_PRIME - translated lateral\n");
    tt->val_offset = (char *) &override_primary_axis - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'primary_axis'
    // ctype is '_primary_axis_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("primary_axis");
    tt->descr = tdrpStrDup("Platform type.");
    tt->help = tdrpStrDup("See override_primary_axis.");
    tt->val_offset = (char *) &primary_axis - &_start_;
    tt->enum_def.name = tdrpStrDup("primary_axis_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PRIMARY_AXIS_Z");
      tt->enum_def.fields[0].val = PRIMARY_AXIS_Z;
      tt->enum_def.fields[1].name = tdrpStrDup("PRIMARY_AXIS_Y");
      tt->enum_def.fields[1].val = PRIMARY_AXIS_Y;
      tt->enum_def.fields[2].name = tdrpStrDup("PRIMARY_AXIS_X");
      tt->enum_def.fields[2].val = PRIMARY_AXIS_X;
      tt->enum_def.fields[3].name = tdrpStrDup("PRIMARY_AXIS_Z_PRIME");
      tt->enum_def.fields[3].val = PRIMARY_AXIS_Z_PRIME;
      tt->enum_def.fields[4].name = tdrpStrDup("PRIMARY_AXIS_Y_PRIME");
      tt->enum_def.fields[4].val = PRIMARY_AXIS_Y_PRIME;
      tt->enum_def.fields[5].name = tdrpStrDup("PRIMARY_AXIS_X_PRIME");
      tt->enum_def.fields[5].val = PRIMARY_AXIS_X_PRIME;
    tt->single_val.e = PRIMARY_AXIS_Y_PRIME;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("OVERRIDE SWEEP MODE?");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_sweep_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_sweep_mode");
    tt->descr = tdrpStrDup("Option to override the sweep modes in the data.");
    tt->help = tdrpStrDup("If TRUE, the mode for all sweeps is set to sweep_mode.");
    tt->val_offset = (char *) &override_sweep_mode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'sweep_mode'
    // ctype is '_sweep_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("sweep_mode");
    tt->descr = tdrpStrDup("Sweep mode for all sweeps.");
    tt->help = tdrpStrDup("See override_sweep_mode.");
    tt->val_offset = (char *) &sweep_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("sweep_mode_t");
    tt->enum_def.nfields = 9;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("SWEEP_MODE_SECTOR");
      tt->enum_def.fields[0].val = SWEEP_MODE_SECTOR;
      tt->enum_def.fields[1].name = tdrpStrDup("SWEEP_MODE_RHI");
      tt->enum_def.fields[1].val = SWEEP_MODE_RHI;
      tt->enum_def.fields[2].name = tdrpStrDup("SWEEP_MODE_VERTICAL_POINTING");
      tt->enum_def.fields[2].val = SWEEP_MODE_VERTICAL_POINTING;
      tt->enum_def.fields[3].name = tdrpStrDup("SWEEP_MODE_AZIMUTH_SURVEILLANCE");
      tt->enum_def.fields[3].val = SWEEP_MODE_AZIMUTH_SURVEILLANCE;
      tt->enum_def.fields[4].name = tdrpStrDup("SWEEP_MODE_ELEVATION_SURVEILLANCE");
      tt->enum_def.fields[4].val = SWEEP_MODE_ELEVATION_SURVEILLANCE;
      tt->enum_def.fields[5].name = tdrpStrDup("SWEEP_MODE_SUNSCAN");
      tt->enum_def.fields[5].val = SWEEP_MODE_SUNSCAN;
      tt->enum_def.fields[6].name = tdrpStrDup("SWEEP_MODE_POINTING");
      tt->enum_def.fields[6].val = SWEEP_MODE_POINTING;
      tt->enum_def.fields[7].name = tdrpStrDup("SWEEP_MODE_SUNSCAN_RHI");
      tt->enum_def.fields[7].val = SWEEP_MODE_SUNSCAN_RHI;
      tt->enum_def.fields[8].name = tdrpStrDup("SWEEP_MODE_ELECTRONIC_STEERING");
      tt->enum_def.fields[8].val = SWEEP_MODE_ELECTRONIC_STEERING;
    tt->single_val.e = SWEEP_MODE_AZIMUTH_SURVEILLANCE;
    tt++;
    
    // Parameter 'set_max_range'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_max_range");
    tt->descr = tdrpStrDup("Option to set the max range for any ray.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_max_range - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_range_km");
    tt->descr = tdrpStrDup("Specified maximim range - km.");
    tt->help = tdrpStrDup("Gates beyond this range are removed.");
    tt->val_offset = (char *) &max_range_km - &_start_;
    tt->single_val.d = 9999;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("GROUND-BASED MODE");
    tt->comment_text = tdrpStrDup("In ground-based the instrument is not moving. Therefore we override the latitude/longitude/altitude in the georeference data blocks, and set the platform velocities to 0.");
    tt++;
    
    // Parameter 'fixed_location_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("fixed_location_mode");
    tt->descr = tdrpStrDup("Option to set fixed location in ground-based mode.");
    tt->help = tdrpStrDup("If TRUE, the program will override the metadata for latitude/longitude/altitude, and set platform velocities to 0.");
    tt->val_offset = (char *) &fixed_location_mode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'fixed_radar_location'
    // ctype is '_radar_location_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fixed_radar_location");
    tt->descr = tdrpStrDup("Radar location if override is set true.");
    tt->help = tdrpStrDup("The radar_location is only used if 'override_radar_location' is set true. Otherwise the information in the input data stream is used. Note that the altitude is in km MSL.");
    tt->val_offset = (char *) &fixed_radar_location - &_start_;
    tt->struct_def.name = tdrpStrDup("radar_location_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("latitudeDeg");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &fixed_radar_location.latitudeDeg - (char *) &fixed_radar_location;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("longitudeDeg");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &fixed_radar_location.longitudeDeg - (char *) &fixed_radar_location;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("altitudeKm");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &fixed_radar_location.altitudeKm - (char *) &fixed_radar_location;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("COMPUTE MEAN RADAR LOCATION?");
    tt->comment_text = tdrpStrDup("This mode will compute the mean radar location for a ground-based insytallation.");
    tt++;
    
    // Parameter 'compute_mean_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_mean_location");
    tt->descr = tdrpStrDup("Option to compute the mean location of the radar from the georeference data in the rays.");
    tt->help = tdrpStrDup("Applicable in archive mode only, and only applicable to ground-based projects. It will compute the mean radar location, from the short- and long-pulse input data, and print the mean to the terminal. The mean values can then be used in the radar_location parameter (see above) if override_radar_location is set to TRUE.");
    tt->val_offset = (char *) &compute_mean_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("SET THE COMBINED DWELL DETAILS");
    tt->comment_text = tdrpStrDup("Normally we combine the high-rate moments data (say at 100 hz) into lower-rate dwells, say at 10 hz.");
    tt++;
    
    // Parameter 'dwell_length_secs'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dwell_length_secs");
    tt->descr = tdrpStrDup("Specify the output dwell length (secs).");
    tt->help = tdrpStrDup("Dwells from the input data will be combined to form dwells covering the specified time.");
    tt->val_offset = (char *) &dwell_length_secs - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'dwell_stats_method'
    // ctype is '_dwell_stats_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("dwell_stats_method");
    tt->descr = tdrpStrDup("Method for computing stats on the dwell.");
    tt->help = tdrpStrDup("MIDDLE refers to the middle ray in the dwell sequence. The DISCRETE_MODE computes applies only to discrete (integer) fields, and returns the most common entry in a discrete data set.");
    tt->val_offset = (char *) &dwell_stats_method - &_start_;
    tt->enum_def.name = tdrpStrDup("dwell_stats_method_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DWELL_STATS_MEAN");
      tt->enum_def.fields[0].val = DWELL_STATS_MEAN;
      tt->enum_def.fields[1].name = tdrpStrDup("DWELL_STATS_MEDIAN");
      tt->enum_def.fields[1].val = DWELL_STATS_MEDIAN;
      tt->enum_def.fields[2].name = tdrpStrDup("DWELL_STATS_MAXIMUM");
      tt->enum_def.fields[2].val = DWELL_STATS_MAXIMUM;
      tt->enum_def.fields[3].name = tdrpStrDup("DWELL_STATS_MINIMUM");
      tt->enum_def.fields[3].val = DWELL_STATS_MINIMUM;
      tt->enum_def.fields[4].name = tdrpStrDup("DWELL_STATS_MIDDLE");
      tt->enum_def.fields[4].val = DWELL_STATS_MIDDLE;
      tt->enum_def.fields[5].name = tdrpStrDup("DWELL_STATS_DISCRETE_MODE");
      tt->enum_def.fields[5].val = DWELL_STATS_DISCRETE_MODE;
    tt->single_val.e = DWELL_STATS_MEAN;
    tt++;
    
    // Parameter 'dwell_stats_max_fraction_missing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("dwell_stats_max_fraction_missing");
    tt->descr = tdrpStrDup("Specify the max fraction of the dwell that can have missing data.");
    tt->help = tdrpStrDup("We compute how much of the dwell is missing for each field. If the fraction exceeds this parameter, the combined value will be set to missing.");
    tt->val_offset = (char *) &dwell_stats_max_fraction_missing - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.d = 0;
    tt->max_val.d = 1;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("OPTION TO SET STATS METHOD FOR INDIVIDUAL FIELDS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_stats_method_for_individual_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_stats_method_for_individual_fields");
    tt->descr = tdrpStrDup("Set the stats method for individual fields.");
    tt->help = tdrpStrDup("The global stats method is set by the 'dwell_stats_method' parameter. If 'set_stats_method_for_individual_fields' is true, we can set the stats method on particular fields. Fields not specified here will use the global parameter.");
    tt->val_offset = (char *) &set_stats_method_for_individual_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'stats_method_fields'
    // ctype is '_stats_method_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("stats_method_fields");
    tt->descr = tdrpStrDup("Stats methods for individual fields.");
    tt->help = tdrpStrDup("Applies if 'set_stats_method_for_individual_fields' is true. The global stats method is set by the 'dwell_stats_method' parameter. Fields not specified here will use the global parameter.");
    tt->array_offset = (char *) &_stats_method_fields - &_start_;
    tt->array_n_offset = (char *) &stats_method_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(stats_method_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("stats_method_field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_stats_method_fields->field_name - (char *) _stats_method_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("dwell_stats_method_t");
      tt->struct_def.fields[1].fname = tdrpStrDup("stats_method");
      tt->struct_def.fields[1].ptype = ENUM_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_stats_method_fields->stats_method - (char *) _stats_method_fields;
        tt->struct_def.fields[1].enum_def.name = tdrpStrDup("dwell_stats_method_t");
        tt->struct_def.fields[1].enum_def.nfields = 6;
        tt->struct_def.fields[1].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[1].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[1].enum_def.fields[0].name = tdrpStrDup("DWELL_STATS_MEAN");
        tt->struct_def.fields[1].enum_def.fields[0].val = DWELL_STATS_MEAN;
        tt->struct_def.fields[1].enum_def.fields[1].name = tdrpStrDup("DWELL_STATS_MEDIAN");
        tt->struct_def.fields[1].enum_def.fields[1].val = DWELL_STATS_MEDIAN;
        tt->struct_def.fields[1].enum_def.fields[2].name = tdrpStrDup("DWELL_STATS_MAXIMUM");
        tt->struct_def.fields[1].enum_def.fields[2].val = DWELL_STATS_MAXIMUM;
        tt->struct_def.fields[1].enum_def.fields[3].name = tdrpStrDup("DWELL_STATS_MINIMUM");
        tt->struct_def.fields[1].enum_def.fields[3].val = DWELL_STATS_MINIMUM;
        tt->struct_def.fields[1].enum_def.fields[4].name = tdrpStrDup("DWELL_STATS_MIDDLE");
        tt->struct_def.fields[1].enum_def.fields[4].val = DWELL_STATS_MIDDLE;
        tt->struct_def.fields[1].enum_def.fields[5].name = tdrpStrDup("DWELL_STATS_DISCRETE_MODE");
        tt->struct_def.fields[1].enum_def.fields[5].val = DWELL_STATS_DISCRETE_MODE;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("FLAG");
      tt->struct_vals[1].e = DWELL_STATS_MEDIAN;
      tt->struct_vals[2].s = tdrpStrDup("ANTENNA_FLAG");
      tt->struct_vals[3].e = DWELL_STATS_MIDDLE;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("FIELD NAMES for combination");
    tt->comment_text = tdrpStrDup("The long pulse rays have a longer PRT than the short pulse rays. This allows us to unfold the velocity field using the staggered-PRT technique. If both long and short PRT data are present, the velocity field is unfolded into a final velocity field.");
    tt++;
    
    // Parameter 'perform_velocity_unfolding'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("perform_velocity_unfolding");
    tt->descr = tdrpStrDup("Option to unfold the velocity field.");
    tt->help = tdrpStrDup("If false, the short vel will be copied to the unfolded field. The vel_unfolded field will be added to the output data set.");
    tt->val_offset = (char *) &perform_velocity_unfolding - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'input_vel_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_vel_field_name");
    tt->descr = tdrpStrDup("This is the name for the velocity field in the input data.");
    tt->help = tdrpStrDup("The field name must be the same for the short- and long-prt rays.");
    tt->val_offset = (char *) &input_vel_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("VEL");
    tt++;
    
    // Parameter 'suffix_to_add_for_short_pulse_fields'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("suffix_to_add_for_short_pulse_fields");
    tt->descr = tdrpStrDup("This suffix is added to the input fields for short-prt moments.");
    tt->help = tdrpStrDup("For each incoming short-pulse field, we add this suffix to the incoming field name.");
    tt->val_offset = (char *) &suffix_to_add_for_short_pulse_fields - &_start_;
    tt->single_val.s = tdrpStrDup("_short");
    tt++;
    
    // Parameter 'suffix_to_add_for_long_pulse_fields'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("suffix_to_add_for_long_pulse_fields");
    tt->descr = tdrpStrDup("This suffix is added to the input fields for long-prt moments.");
    tt->help = tdrpStrDup("For each incoming long-pulse field, we add this suffix to the incoming field name.");
    tt->val_offset = (char *) &suffix_to_add_for_long_pulse_fields - &_start_;
    tt->single_val.s = tdrpStrDup("_long");
    tt++;
    
    // Parameter 'vel_unfolded_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vel_unfolded_field_name");
    tt->descr = tdrpStrDup("Name for the unfolded velocity.");
    tt->help = tdrpStrDup("This is an output field, computed by unfolding the dual-prt vel fields.");
    tt->val_offset = (char *) &vel_unfolded_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("VEL_unfold");
    tt++;
    
    // Parameter 'correct_velocity_for_platform_vertical_motion'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("correct_velocity_for_platform_vertical_motion");
    tt->descr = tdrpStrDup("Option to correct the estimated velocity corrected for vertical platform motion.");
    tt->help = tdrpStrDup("For an airborne platform, we measure the vertical velocity of the platform using an INS system. We can optionally correct the measured velocity for the plaform vertical motion. This correction is applied AFTER the unfolding computation.");
    tt->val_offset = (char *) &correct_velocity_for_platform_vertical_motion - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("OUTPUT FMQ");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_url");
    tt->descr = tdrpStrDup("FMQ to which the combined dwells are written.");
    tt->help = tdrpStrDup("FMQ mode only.");
    tt->val_offset = (char *) &output_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::/tmp/fmq/output");
    tt++;
    
    // Parameter 'output_fmq_compress'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_compress");
    tt->descr = tdrpStrDup("Option to compress the output fmq.");
    tt->help = tdrpStrDup("The default is for no compression.");
    tt->val_offset = (char *) &output_fmq_compress - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_fmq_n_slots'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_n_slots");
    tt->descr = tdrpStrDup("Number of slots in output FMQ.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_fmq_n_slots - &_start_;
    tt->single_val.i = 5000;
    tt++;
    
    // Parameter 'output_fmq_buf_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_buf_size");
    tt->descr = tdrpStrDup("Size of buffer in output FMQ.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_fmq_buf_size - &_start_;
    tt->single_val.i = 100000000;
    tt++;
    
    // Parameter 'output_fmq_write_blocking'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_write_blocking");
    tt->descr = tdrpStrDup("Option to block on write when the radar queue fills up.");
    tt->help = tdrpStrDup("If false, the program writes data to the output queue without regard to whether the reader is keeping up. This mode should usually be used in realtime, to avoid holding things up if a client becomes slow. If true, the program will not overwrite data in the queue which has not been read by the reader. This is recommended for ARCHIVE and FILELIST mode. In this mode there should be only one reader. If you need to service more than one reader, use Fmq2Fmq in write blocking mode with multiple output urls to multiplex the queue.");
    tt->val_offset = (char *) &output_fmq_write_blocking - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_fmq_data_mapper_report_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_data_mapper_report_interval");
    tt->descr = tdrpStrDup("Number of seconds between reports to DataMapper.");
    tt->help = tdrpStrDup("If > 0, the program will register with the DataMapper when the output FMQs are written to. If <= 0, registration will not be performed.");
    tt->val_offset = (char *) &output_fmq_data_mapper_report_interval - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
