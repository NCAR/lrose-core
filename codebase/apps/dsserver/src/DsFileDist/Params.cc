/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program DsFileDist
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("SETTING UP PARAMETER FILES FOR DsFileDist");
    tt->comment_text = tdrpStrDup("The main parameter file specifies the global behavior of DsFileDist. The program may be started with the -params option to specify a global parameter file, or there may be a '_DsFileDist' file in $RAP_DATA_DIR (or $DATA_DIR).\n \nLocal parameter files in the directory tree may override the global parameters - see 'LOCAL DISTRIBUTION PARAMETERS'.\n\n");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("ONLY set these in the global file. DO NOT set them in the local parameter files down in the data directory tree.");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Program instance for process registration.");
    tt->help = tdrpStrDup("This program registers with procmap. This is the instance used for registration.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("primary");
    tt++;
    
    // Parameter 'max_n_threads'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_n_threads");
    tt->descr = tdrpStrDup("File disrtibution is handled by child processes. This is the max number of child processes allowed to be active at a time.");
    tt->help = tdrpStrDup("If the child count reaches this number, no new children will be created until an existing child exits. This prevents the number of children from becoming excessive should children hang.");
    tt->val_offset = (char *) &max_n_threads - &_start_;
    tt->single_val.i = 128;
    tt++;
    
    // Parameter 'max_file_queue_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_file_queue_size");
    tt->descr = tdrpStrDup("Maximum number of files in file queue.");
    tt->help = tdrpStrDup("This app watches for new data files and adds them to a queue, waiting to be written to the target hosts. The files are written as fast as reasonable, and normally the queue does not grow large. However, if something prevents the files from being written, the queue will grow in size. If the queue reaches the limit specified by this parameter, file entries will be discarded and a warning will be printed.");
    tt->val_offset = (char *) &max_file_queue_size - &_start_;
    tt->single_val.i = 4096;
    tt++;
    
    // Parameter 'no_threads'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("no_threads");
    tt->descr = tdrpStrDup("No threads option. Forces single-threaded operation - no children are created.");
    tt->help = tdrpStrDup("For debugging purposes. Note that the program will handle only a single data directory in single-threaded operation.");
    tt->val_offset = (char *) &no_threads - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'server_open_timeout_msecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("server_open_timeout_msecs");
    tt->descr = tdrpStrDup("Set the timeout for server connections, in milliseconds.");
    tt->help = tdrpStrDup("If set to -1, the server connections open in blocking mode. This is the default and is recommended to internet operations. If you have a local network and wish to speed up timeout for hosts which are not up, you can set this to a positive number. 10000 (10 secs) is suggested.");
    tt->val_offset = (char *) &server_open_timeout_msecs - &_start_;
    tt->single_val.i = -1;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DIRECTORY SEARCH PARAMETERS");
    tt->comment_text = tdrpStrDup("ONLY set these in the global file. DO NOT set them in the local parameter files down in the data directory tree.");
    tt++;
    
    // Parameter 'source_top_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("source_top_dir");
    tt->descr = tdrpStrDup("Top-level directory.");
    tt->help = tdrpStrDup("DsFileDist searches recursively below source_top_dir for 'active' directories from which files are be distributed. If the specified directory starts with . or /, it is interpreted as an absolule path. If not, top_dir is computed relative to RAP_DATA_DIR.");
    tt->val_offset = (char *) &source_top_dir - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'tmp_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("tmp_dir");
    tt->descr = tdrpStrDup("Directory for temporary files.");
    tt->help = tdrpStrDup("DsFileDist uses temporary files to pass information from the child threads back to the main thread.");
    tt->val_offset = (char *) &tmp_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp");
    tt++;
    
    // Parameter 'check_for_new_directories'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_for_new_directories");
    tt->descr = tdrpStrDup("Option to periodically check for new active directories.");
    tt->help = tdrpStrDup("If TRUE, the program will periodically check for new active directories or directories which have been removed. See 'find_mode' for the definition of an active directory.\nTo force a new directory search, send the process a SIGHUP signal.\nSee 'new_directory_delay' for how often the check is performed. ");
    tt->val_offset = (char *) &check_for_new_directories - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'new_directory_delay'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("new_directory_delay");
    tt->descr = tdrpStrDup("Delay between checking for active directories using params (secs).");
    tt->help = tdrpStrDup("The program will sleep for this length of time between checking for new or removed _DsFileDist files.\nSee 'check_for_new_directories'.");
    tt->val_offset = (char *) &new_directory_delay - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 300;
    tt++;
    
    // Parameter 'check_for_new_latest_data_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_for_new_latest_data_info");
    tt->descr = tdrpStrDup("Option to periodically check for new latest_data_info files.");
    tt->help = tdrpStrDup("Only applies to directories for which find_mode = FIND_LATEST_DATA_INFO. See 'find_mode' below. If TRUE, the program will periodically check for new _latest_data_info files to activate a directory. This applies to new data sets which appear AFTER DsFileDist has been started. To force a new search, send the process a SIGHUP signal.\nSee 'new_latest_data_info_delay' for how often the check is performed. ");
    tt->val_offset = (char *) &check_for_new_latest_data_info - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'new_latest_data_info_delay'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("new_latest_data_info_delay");
    tt->descr = tdrpStrDup("Delay between checking for new latest_data_info (secs).");
    tt->help = tdrpStrDup("The program will sleep for this length of time between checking for new _latest_data_info files.");
    tt->val_offset = (char *) &new_latest_data_info_delay - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'new_data_delay'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("new_data_delay");
    tt->descr = tdrpStrDup("Delay while checking a directory for new data (secs).");
    tt->help = tdrpStrDup("Only for latest_data_info_avail = false. The program will sleep for this length of time between checking a directory for new data.");
    tt->val_offset = (char *) &new_data_delay - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0.1;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'max_simultaneous_per_host'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_simultaneous_per_host");
    tt->descr = tdrpStrDup("Max number of simultaneous active file transfers to each host.");
    tt->help = tdrpStrDup("The program will only allow this number of puts to be active to a single host at any time. This prevents the network from becoming overloaded by many simultaneous file transfers.");
    tt->val_offset = (char *) &max_simultaneous_per_host - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'max_n_tries_per_transfer'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_n_tries_per_transfer");
    tt->descr = tdrpStrDup("Number of tries to transfer a file.");
    tt->help = tdrpStrDup("Sometimes the transfer to a remote host will fail, possibly because of network problems. If max_n_tries_for_transfer is greater than 1, the application will retry to transfer the file. When the number of tries is exceeded, it will give up.");
    tt->val_offset = (char *) &max_n_tries_per_transfer - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 2;
    tt++;
    
    // Parameter 'max_age_on_queue'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_age_on_queue");
    tt->descr = tdrpStrDup("Max age for an entry on the queue (secs).");
    tt->help = tdrpStrDup("When a file is found, an entry is added to the queue for distribution. If an entry exists on the queue for longer than this, it will be aged off. Normally this only happens if a destination host is down.");
    tt->val_offset = (char *) &max_age_on_queue - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("WRITING DS MESSAGES DIRECTLY TO DISK.");
    tt->comment_text = tdrpStrDup("This is done if the host in the desination url is set to 'localfile'. If this option is selected, then DsFileDist will write its output DsMessages to files on disk rather than communicating them to servers. These files can then be transmitted via a channel (such as an LDM or a serial line) to another host, where the program DsFile2Server may be used to read the files and send them to the approriate server.");
    tt++;
    
    // Parameter 'do_post_file_write_script'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("do_post_file_write_script");
    tt->descr = tdrpStrDup("Option to execute a script after a file is written due to the URL host being set to 'localfile'");
    tt->help = tdrpStrDup("If TRUE, the script named by the parameter 'post_file_write_script' is executed after a file is written. This may be used to put that file into an LDM queue.");
    tt->val_offset = (char *) &do_post_file_write_script - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'post_file_write_script'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("post_file_write_script");
    tt->descr = tdrpStrDup("Script to execute after writing a file if do_post_file_write_script is TRUE.");
    tt->help = tdrpStrDup("The name of the file that was just written is the first argument to the script.");
    tt->val_offset = (char *) &post_file_write_script - &_start_;
    tt->single_val.s = tdrpStrDup("PostFileWriteScript");
    tt++;
    
    // Parameter 'local_file_host'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("local_file_host");
    tt->descr = tdrpStrDup("If the URL host is set to 'localfile' then the following host name will be substituted in the DsMsg URL.");
    tt->help = tdrpStrDup("Usually should be localhost.");
    tt->val_offset = (char *) &local_file_host - &_start_;
    tt->single_val.s = tdrpStrDup("localhost");
    tt++;
    
    // Parameter 'local_file_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("local_file_dir");
    tt->descr = tdrpStrDup("Directory for message files.");
    tt->help = tdrpStrDup("If the URL host is set to 'localfile' then the input files will be packaged as DsMessages and written to this directory. If the path does not start with '.' or '/', it will be relative to RAP_DATA_DIR or DATA_DIR.");
    tt->val_offset = (char *) &local_file_dir - &_start_;
    tt->single_val.s = tdrpStrDup("DsMsg");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("LOCAL DISTRIBUTION PARAMETERS");
    tt->comment_text = tdrpStrDup("Only set these parameters in the local _DsFileDist files in the data directory tree. To avoid confusing behavior, it is good practice not to override the DEBUGGING or DIRECTORY SEARCH parameters.\n \nDsFileDist searches recursively down from the top dir, looking for _DsFileDist parameter files or _latest_data_info files - see 'find_mode' for a more detailed explanation. When a _DsFileDist file is found, it overrides the gobal parameters.\n \nIf 'process' in the local params is FALSE, DsFileDist does not distribute files from that directory or any below it. This is useful for marking areas as off-limits so that they are not included in the search.\n");
    tt++;
    
    // Parameter 'process'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("process");
    tt->descr = tdrpStrDup("Processing flag - controls whether we process this directory or not.");
    tt->help = tdrpStrDup("If FALSE, stop looking for _DsFileDist param files and do not process this directory. If TRUE, process using the param information at this level.");
    tt->val_offset = (char *) &process - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'find_mode'
    // ctype is '_find_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("find_mode");
    tt->descr = tdrpStrDup("Mode for finding directories to be distributed.");
    tt->help = tdrpStrDup(" \nFIND_DSFILEDIST_PARAMS: DsFileDist searches recursively from source_top_dir for '_DsFileDist' param files. If a '_DsFileDist' file is found, the directory is marked as active and files are distributed using the information in the _DsFileDist param file. Once a _DsFileDist file is found, the search does not continue below that directory, unless the find_mode is switched to FIND_LATEST_DATA_INFO. The parameters in the '_DsFileDist' file override those in the main parameters, and the combined parameters are used to control the file distribution. It is good practice to only include parameters in the LOCAL section, so that parameters such as debug and instance are not overridden.\n \nIf 'process' in the local params is FALSE, DsFileDist does not distribute files from that directory.\n \nFIND_LATEST_DATA_INFO: if this is set in a '_DsFileDist' file, then we search recursively below that directory for '_latest_data_info' files insead of _DsFileDist param files. If a _latest_data_info file is found, the directory is marked as active, and the search does not continue below that level. The information in the _latest_data_info file, PLUS parameters set in the _DsFileDist file which set FIND_LATEST_DATA_INFO mode, are used to control distribution. The directory part of the URL is determined by stripping RAP_DATA_DIR (or DATA_DIR) from the active directory path.\n \nSee dest_url_template and dest_url_list for more on the directory settings in the url.\n");
    tt->val_offset = (char *) &find_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("find_mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FIND_DSFILEDIST_PARAMS");
      tt->enum_def.fields[0].val = FIND_DSFILEDIST_PARAMS;
      tt->enum_def.fields[1].name = tdrpStrDup("FIND_LATEST_DATA_INFO");
      tt->enum_def.fields[1].val = FIND_LATEST_DATA_INFO;
    tt->single_val.e = FIND_DSFILEDIST_PARAMS;
    tt++;
    
    // Parameter '_dsFileDist_ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("_dsFileDist_ext");
    tt->descr = tdrpStrDup("Optional extension for _DsFileDist param files.");
    tt->help = tdrpStrDup("Normally DsFileDist scans the directory tree for files named _DsFileDist. However, if this string has a non-zero length, it is appended to _DsFileDist as an extension, and only those files with the extension will be considered. For example, if the extension is set to 'special', then only param files named '_dsFileDist.special' will be considered.");
    tt->val_offset = (char *) &_dsFileDist_ext - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'latest_data_info_avail'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("latest_data_info_avail");
    tt->descr = tdrpStrDup("Indicates that _latest_data_info is available for reading.");
    tt->help = tdrpStrDup("Only applies to FIND_DSFILEDIST_PARAMS mode. If TRUE, we use the _latest_data_info files for notification that a file has arrived. Otherwise we scan the directory recursively for new files, and a latest_data_info file is created by this program to keep track of distribution times.");
    tt->val_offset = (char *) &latest_data_info_avail - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_valid_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_valid_age");
    tt->descr = tdrpStrDup("Max valid age of files to be transferred (secs).");
    tt->help = tdrpStrDup("When checking for new files to distribute, files older than this will be ignored. See also 'max_age_at_copy_time'.");
    tt->val_offset = (char *) &max_valid_age - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 360;
    tt++;
    
    // Parameter 'file_quiescence_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("file_quiescence_age");
    tt->descr = tdrpStrDup("Quiesence on a file before it is assumed to be complete (secs).");
    tt->help = tdrpStrDup("Only applicable when latest_data_info_avail = false. The program will wait for a file to stop growing before deciding that it has been completely written to disk.");
    tt->val_offset = (char *) &file_quiescence_age - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'check_file_ext'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_file_ext");
    tt->descr = tdrpStrDup("Option to only copy files with a given extension.");
    tt->help = tdrpStrDup("If TRUE, only files with extensions which match the parameter 'data_file_ext' will be copied.");
    tt->val_offset = (char *) &check_file_ext - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'data_file_ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_file_ext");
    tt->descr = tdrpStrDup("Specified data file extension before distribution.");
    tt->help = tdrpStrDup("See 'check_file_ext'.");
    tt->val_offset = (char *) &data_file_ext - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'allow_redistribution'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("allow_redistribution");
    tt->descr = tdrpStrDup("Option to allow redistribution of DsFileDist files.");
    tt->help = tdrpStrDup("If TRUE, allows files which have already been distributed by DsFileDist to be forwarded on. If FALSE, does not allow the redistribution of files which have already been distributed once. This is useful to prevent infinte loops in distribution of files between redundant hosts.");
    tt->val_offset = (char *) &allow_redistribution - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'force_copy'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("force_copy");
    tt->descr = tdrpStrDup("Option to force copy. Uses single TCP/IP message.");
    tt->help = tdrpStrDup("If TRUE, a single put message will be sent from the client to the server. The file will always be written, even if it already exists. If FALSE, the client will request the server to tell it whether to send the file. This request is made via an 'enquire' message. The server will tell the client whether to send the file. It will decline the copy request if the file already exists, and if the age of the file is less than the 'overwrite-age' parameter. This mode is intended for use with redundant data sources in which the file may be sent from more than one client.");
    tt->val_offset = (char *) &force_copy - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'overwrite_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("overwrite_age");
    tt->descr = tdrpStrDup("Overwrite age for existing file on target machine (secs).");
    tt->help = tdrpStrDup("If force_copy is true, the copy will be forced even if file exists on target machine. If force_copy is false, the file age on target machine will be checked. If the age exceeds 'overwrite_age', the file will be copied over existing file. If overwrite_age is -1, the file will never be overwritten.");
    tt->val_offset = (char *) &overwrite_age - &_start_;
    tt->single_val.i = -1;
    tt++;
    
    // Parameter 'max_age_at_copy_time'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_age_at_copy_time");
    tt->descr = tdrpStrDup("Max allowable age of files when copying starts (secs).");
    tt->help = tdrpStrDup("Before the program starts to copy a file, it will check the file age. If the age exceeds this maximum, the file will not be copied. See also 'max_valid_age'. The problem is that sometimes the network connection is bad or goes down, and the copying gets behind. When that happens, it may be that the program will try to copy files which are old. This parameter allows you to prevent old files from being copied. Set to -1 to disable checking, i.e., to force copying irrespective of the file age.");
    tt->val_offset = (char *) &max_age_at_copy_time - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'remove_after_copy'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_after_copy");
    tt->descr = tdrpStrDup("Option to remove the file after copying.");
    tt->help = tdrpStrDup("Normally the file is not removed after copying. Setting this to TRUE will cause the file to be removed after a successful copy. This will only apply for a single URL destination. If you have more than 1 destination this parameter will be ignored and an error message will be generated.");
    tt->val_offset = (char *) &remove_after_copy - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_ldata_to_input_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_ldata_to_input_dir");
    tt->descr = tdrpStrDup("Option to write the latest data file to the input dir.");
    tt->help = tdrpStrDup("This is useful for keeping the data mapper up to date for external data sets which do not have a _latest_data_info file. This will only apply if 'latest_data_info_avail' is false.");
    tt->val_offset = (char *) &write_ldata_to_input_dir - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'compression_type'
    // ctype is '_compression_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("compression_type");
    tt->descr = tdrpStrDup("Compression type for transfer.");
    tt->help = tdrpStrDup("RLE - simple run-length encoding, fastest. LZO - fast, not very compact, better than RLE. ZLIB - same as gzip, but without headers. Not as fast as LZO, better than RLE. More compact than RLE and LZO. BZIP - slow, very compact. GZIP - recommended.");
    tt->val_offset = (char *) &compression_type - &_start_;
    tt->enum_def.name = tdrpStrDup("compression_type_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("COMPRESSION_NONE");
      tt->enum_def.fields[0].val = COMPRESSION_NONE;
      tt->enum_def.fields[1].name = tdrpStrDup("COMPRESSION_RLE");
      tt->enum_def.fields[1].val = COMPRESSION_RLE;
      tt->enum_def.fields[2].name = tdrpStrDup("COMPRESSION_LZO");
      tt->enum_def.fields[2].val = COMPRESSION_LZO;
      tt->enum_def.fields[3].name = tdrpStrDup("COMPRESSION_ZLIB");
      tt->enum_def.fields[3].val = COMPRESSION_ZLIB;
      tt->enum_def.fields[4].name = tdrpStrDup("COMPRESSION_BZIP");
      tt->enum_def.fields[4].val = COMPRESSION_BZIP;
      tt->enum_def.fields[5].name = tdrpStrDup("COMPRESSION_GZIP");
      tt->enum_def.fields[5].val = COMPRESSION_GZIP;
    tt->single_val.e = COMPRESSION_NONE;
    tt++;
    
    // Parameter 'use_dest_host_list_file'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_dest_host_list_file");
    tt->descr = tdrpStrDup("Use host list in the file to create the destination urls.");
    tt->help = tdrpStrDup("The host list file contains a list of destination hosts. Each entry in this list is merged with the url_template to create a list of destination urls.");
    tt->val_offset = (char *) &use_dest_host_list_file - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'dest_url_list'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("dest_url_list");
    tt->descr = tdrpStrDup("Specified URL list for destination hosts.");
    tt->help = tdrpStrDup(" \nThis is only used if parameter 'use_dest_host_list_file' is FALSE.\n \nURL format: fcopyp:://targethost:port:dir\n \nThe files will be distributed to this list of hosts.\n \nIf the directory part is empty, the target directory will be the same as the source directory, relative to RAP_DATA_DIR or DATA_DIR.\n \nIf the directory part is set, the target directory will be as specified, relative to RAP_DATA_DIR or DATA_DIR, unless the dir starts with /, in which case it is taken as the absolute path.\n \nFor FIND_LATEST_DATA_INFO mode: if the directory part is empty, the target directory will be the same as the source directory, relative to $DATA_DIR. If the directory part is set, the target directory will be $DATA_DIR + specified-dir + source-dir-relative-to-_DsFileDist-file.\n \nDsFileDist will NOT distribute files to either 'localhost' or the IP address of the local host, unless you specify the target directory. This behavior prevents an infinite loop caused by recursively writing data to a directory, then distributing it to itself. If you want to copy files to a different directory, MAKE SURE you have set a different directory, to prevent the infinit loop problem.\n \n");
    tt->array_offset = (char *) &_dest_url_list - &_start_;
    tt->array_n_offset = (char *) &dest_url_list_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 3;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("fcopyp:://targethost1::");
      tt->array_vals[1].s = tdrpStrDup("fcopyp:://targethost2:5445:");
      tt->array_vals[2].s = tdrpStrDup("fcopyp:://targethost3::my_dir");
    tt++;
    
    // Parameter 'dest_host_list_file_path'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("dest_host_list_file_path");
    tt->descr = tdrpStrDup("Path for destination host list file");
    tt->help = tdrpStrDup("Only used if parameter 'use_dest_host_list_file' is TRUE.");
    tt->val_offset = (char *) &dest_host_list_file_path - &_start_;
    tt->single_val.s = tdrpStrDup("dest_host_list");
    tt++;
    
    // Parameter 'dest_url_template'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("dest_url_template");
    tt->descr = tdrpStrDup("URL template for all destination URLs.");
    tt->help = tdrpStrDup(" \nOnly used if parameter 'use_dest_host_list_file' is TRUE.\n \nThe host names from dest_host_list file are inserted into this template to create an array of URLs.\n \nSee dest_url_list for rules on setting the target directory.\n \nExample:\n \nSuppose the template is:\n\tfcopyp:://::my_dir\nAnd the dest_host_list is:\n\tluna\n\tearth\n\tmercury\nThen the actual url list would be\n\tfcopyp:://luna::my_dir\n\tfcopyp:://earth::my_dir\n\tfcopyp:://mercury::my_dir\n \n");
    tt->val_offset = (char *) &dest_url_template - &_start_;
    tt->single_val.s = tdrpStrDup("fcopyp:://::");
    tt++;
    
    // Parameter 'minimum_expected_transfer_speed'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("minimum_expected_transfer_speed");
    tt->descr = tdrpStrDup("Minimum expected transfer speed (kBytes/sec).");
    tt->help = tdrpStrDup("This should be set to the minimum speed expected on any of the lines to be used. The expected transfer time is set using this speed. If the transfer takes more than 10 times the expected time, the transfer is killed.");
    tt->val_offset = (char *) &minimum_expected_transfer_speed - &_start_;
    tt->single_val.i = 128;
    tt++;
    
    // Parameter 'reorder_by_file_size'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("reorder_by_file_size");
    tt->descr = tdrpStrDup("Option to use file size to alter the order for sending files.");
    tt->help = tdrpStrDup("If FALSE, files are sent in the order in which they appear on the disk. If TRUE, this order is modified by the relative size of the files to be sent. See 'max_reorder_delay_fraction'.");
    tt->val_offset = (char *) &reorder_by_file_size - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'max_reorder_delay_fraction'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("max_reorder_delay_fraction");
    tt->descr = tdrpStrDup("The cumulative delay fraction used to make reorder decisions.");
    tt->help = tdrpStrDup("If reorder_by_file_size is TRUE, small files may be inserted into the put list ahead of larger files. This parameter controls how that decision is made. When we insert a file in the queue, we note its size, 'file_size'. Once it is in the queue, we keep track of how many bytes are inserted ahead of it, 'nbytes_inserted'. We compute the delay_fraction as nybytes_inserted divided by file_size. We only allow a file to be inserted ahead of another file if the delay fraction does not exceed this parameter, reorder_delay_fraction. The bytes inserted cause a delay for the files behind. Using this scheme, the fractional delay per file will always be less than the fraction specified.");
    tt->val_offset = (char *) &max_reorder_delay_fraction - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0;
    tt->max_val.f = 1;
    tt->single_val.f = 0.4;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
