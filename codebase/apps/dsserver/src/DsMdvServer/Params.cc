// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 1992 - 2016
// ** University Corporation for Atmospheric Research(UCAR)
// ** National Center for Atmospheric Research(NCAR)
// ** Boulder, Colorado, USA
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program DsMdvServer
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'no_threads'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("no_threads");
    tt->descr = tdrpStrDup("Option to prevent server from using a thread per client.");
    tt->help = tdrpStrDup("For debugging purposes it it sometimes useful to suppress the use of threads. Set no_threads to TRUE for this type of debugging.");
    tt->val_offset = (char *) &no_threads - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance.");
    tt->help = tdrpStrDup("Used for procmap registration and auto restarting. If an empty instance name is provided, the server automatically uses the port number as its instance name");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("SERVER MANAGER SUPPORT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'port'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("port");
    tt->descr = tdrpStrDup("Port number.");
    tt->help = tdrpStrDup("The server listens on this port for client requests.");
    tt->val_offset = (char *) &port - &_start_;
    tt->single_val.i = 5440;
    tt++;
    
    // Parameter 'qmax'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("qmax");
    tt->descr = tdrpStrDup("Max quiescent period (secs).");
    tt->help = tdrpStrDup("If the server does not receive requests for this time period, it will die gracefully.");
    tt->val_offset = (char *) &qmax - &_start_;
    tt->single_val.i = 1800;
    tt++;
    
    // Parameter 'max_clients'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_clients");
    tt->descr = tdrpStrDup("Maximum number of clients");
    tt->help = tdrpStrDup("This is the maximum number of threads the application will produce to handle client requests.  If the maximum is reached, new clients will receive a SERVICE_DENIED error message and will have to request the data again.  If set to -1, no maximum is enforced.");
    tt->val_offset = (char *) &max_clients - &_start_;
    tt->single_val.i = 32;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("SECURITY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'run_secure'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("run_secure");
    tt->descr = tdrpStrDup("Option to run in secure mode.");
    tt->help = tdrpStrDup("If TRUE, the server will reject any URLs which specify an absolute path, or a path with .. in it. This prevents the server from writing any files which are not below DATA_DIR in the directory tree.");
    tt->val_offset = (char *) &run_secure - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'run_read_only'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("run_read_only");
    tt->descr = tdrpStrDup("Option to run in read-only mode.");
    tt->help = tdrpStrDup("If TRUE, the server will respond only to read requests, and will ignore write requests.");
    tt->val_offset = (char *) &run_read_only - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'allow_http'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("allow_http");
    tt->descr = tdrpStrDup("Option to allow http requests.");
    tt->help = tdrpStrDup("If TRUE, the server will strip off header in request message.");
    tt->val_offset = (char *) &allow_http - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("MEMORY MANAGEMENT FOR MESSAGES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'copy_message_memory'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("copy_message_memory");
    tt->descr = tdrpStrDup("Option to copy memory from the messages into the message objects.");
    tt->help = tdrpStrDup("Setting to FALSE will reduce the memory usage for the program.");
    tt->val_offset = (char *) &copy_message_memory - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("VERTICAL SECTIONS - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'vsection_set_nsamples'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vsection_set_nsamples");
    tt->descr = tdrpStrDup("Option to disable interpolation in vertical sections.");
    tt->help = tdrpStrDup("Some data is not amenable to interpolation. Setting this to TRUE will disable interpolation when vertical sections are computed.");
    tt->val_offset = (char *) &vsection_set_nsamples - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vsection_nsamples'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vsection_nsamples");
    tt->descr = tdrpStrDup("Number of samples in the vertical section.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &vsection_nsamples - &_start_;
    tt->single_val.i = 500;
    tt++;
    
    // Parameter 'vsection_disable_interp'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vsection_disable_interp");
    tt->descr = tdrpStrDup("Option to disable interpolation in vertical sections.");
    tt->help = tdrpStrDup("Some data is not amenable to interpolation. Setting this to TRUE will disable interpolation when vertical sections are computed.");
    tt->val_offset = (char *) &vsection_disable_interp - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("STATIC FILES - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("Option to serve out data from a static file if a time-based request is made.");
    tt++;
    
    // Parameter 'use_static_file'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_static_file");
    tt->descr = tdrpStrDup("Option to serve out data from a static file.");
    tt->help = tdrpStrDup("If set, the data will always be read from a static file. The file url is specified below. The times in the header will be set to match the request time.");
    tt->val_offset = (char *) &use_static_file - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'static_file_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("static_file_url");
    tt->descr = tdrpStrDup("URL for static file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &static_file_url - &_start_;
    tt->single_val.s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("FAILOVER OPTION - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_failover_urls'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_failover_urls");
    tt->descr = tdrpStrDup("Option to serve data from another url if the first url fails.");
    tt->help = tdrpStrDup("A list of urls is specified by the failover_urls parameter, and if one url does not deliver the data, the subsequent url is then checked. This applies to read operations only.");
    tt->val_offset = (char *) &use_failover_urls - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'failover_urls'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("failover_urls");
    tt->descr = tdrpStrDup("The list of urls to check if use_failover_urls is TRUE.");
    tt->help = tdrpStrDup("Relevant only if use_failover_urls is true.");
    tt->array_offset = (char *) &_failover_urls - &_start_;
    tt->array_n_offset = (char *) &failover_urls_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("mdvp:://fastUnreliable::mdv/data");
      tt->array_vals[1].s = tdrpStrDup("mdvp:://slowReliable::mdv/data");
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("MULTIPLE DOMAINS - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'serve_multiple_domains'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("serve_multiple_domains");
    tt->descr = tdrpStrDup("Option to serve out data from multiple domains. - So called Smart Zoom");
    tt->help = tdrpStrDup("This is applicable for data sets which are available in different resolutions, covering different domains. Generally, the finest resolution data will cover the  smallest domain, with increasing resolution covering larger domains. The search is made from the top to the bottom of the list. The required domain is assumed to be the  first one which fully encompasses the requested horizontal limits. If no horizontal limits are specified, the bottom (largest) domain is used. Note, problems getting this  mechanism to work correctly have been observed when running the DsMdvServer on an alternate port. In this circumstance, the sub-URL would not work when using the full URL  form which includes the hosts name or localhost.  Proper function was observed when the sub url contained only the directory path part of the URL.");
    tt->val_offset = (char *) &serve_multiple_domains - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'domains'
    // ctype is '_domain_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("domains");
    tt->descr = tdrpStrDup("Domain specifications - serve_multiple_domains.");
    tt->help = tdrpStrDup("The domains should be listed from smallest to largest, which normally corresponds to finest to coarsest resolution. Specify the URL from which the data for each  domain should be retrieved. If a URL in this list matches the current one it is ignored. Note for proper function, urls pointing to data on the localhost should never  include the host portion in the URL; Use only the path part.");
    tt->array_offset = (char *) &_domains - &_start_;
    tt->array_n_offset = (char *) &domains_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(domain_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("domain_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("min_lat");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_domains->min_lat - (char *) _domains;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_lon");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_domains->min_lon - (char *) _domains;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("max_lat");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_domains->max_lat - (char *) _domains;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("max_lon");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_domains->max_lon - (char *) _domains;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("url");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_domains->url - (char *) _domains;
    tt->n_struct_vals = 5;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = -90;
      tt->struct_vals[1].d = -180;
      tt->struct_vals[2].d = 90;
      tt->struct_vals[3].d = 180;
      tt->struct_vals[4].s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'auto_fail_over'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_fail_over");
    tt->descr = tdrpStrDup("Option to switch to an alternative domain if the request to the most appropriate one fails.");
    tt->help = tdrpStrDup("The server will first try the domain selected as above. If this fails, it will try the next larger domain, and so on. If no larger domain succeeds, it will try the next smaller domain. If no domain succeeds the call will fail.");
    tt->val_offset = (char *) &auto_fail_over - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("OVERRIDING DATA SET SOURCE, NAME AND INFO - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("The following options allow you to override the data set source, name and info when reading. These will be replaced by the specified XML strings, for use by the client.");
    tt++;
    
    // Parameter 'override_data_set_name_on_read'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_data_set_name_on_read");
    tt->descr = tdrpStrDup("Option to override the data set name on read.");
    tt->help = tdrpStrDup("If TRUE, the data_set_name in the master header will be overridden by the XML specified in data_set_name parameter. The maximum number of characters supported is 127.");
    tt->val_offset = (char *) &override_data_set_name_on_read - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'data_set_name_read_xml'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_name_read_xml");
    tt->descr = tdrpStrDup("XML string used for overriding data_set_name in the master header");
    tt->help = tdrpStrDup("It is suggested that you use the <name> and </name> tags to delimit the name. The maximum number of characters in the string, including the tags, is 127. If more characters are used, the string will be truncated at 127.");
    tt->val_offset = (char *) &data_set_name_read_xml - &_start_;
    tt->single_val.s = tdrpStrDup("<name></name>");
    tt++;
    
    // Parameter 'override_data_set_source_on_read'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_data_set_source_on_read");
    tt->descr = tdrpStrDup("Option to override the data set source on read.");
    tt->help = tdrpStrDup("If TRUE, the data_set_source in the master header will be overridden by the XML specified in data_set_source parameter. The maximum number of characters supported is 127.");
    tt->val_offset = (char *) &override_data_set_source_on_read - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'data_set_source_read_xml'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_source_read_xml");
    tt->descr = tdrpStrDup("XML string used for overriding data_set_source in the master header");
    tt->help = tdrpStrDup("It is suggested that you use the <source> and </source> tags to delimit the source. The maximum number of characters in the string, including the tags, is 127. If more characters are used, the string will be truncated at 127.");
    tt->val_offset = (char *) &data_set_source_read_xml - &_start_;
    tt->single_val.s = tdrpStrDup("<source></source>");
    tt++;
    
    // Parameter 'override_data_set_info_on_read'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_data_set_info_on_read");
    tt->descr = tdrpStrDup("Option to override the data set info on read.");
    tt->help = tdrpStrDup("If TRUE, the data_set_info in the master header will be overridden by the XML specified in data_set_info parameter. The maximum number of characters supported is 511.");
    tt->val_offset = (char *) &override_data_set_info_on_read - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'data_set_info_read_xml'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_info_read_xml");
    tt->descr = tdrpStrDup("XML string used for overriding data_set_info in the master header");
    tt->help = tdrpStrDup("It is suggested that you use the <info> and </info> tags to delimit the info. Other XML tags can be used to further delimit individual fields. The maximum number of characters in the string, including the tags, is 511. If more characters are used, the string will be truncated at 511.");
    tt->val_offset = (char *) &data_set_info_read_xml - &_start_;
    tt->single_val.s = tdrpStrDup("<info></info>");
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("REMAP TO LAT-LON - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("Option to remap the projection to a Lat-lon grid.");
    tt++;
    
    // Parameter 'auto_remap_to_latlon'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_remap_to_latlon");
    tt->descr = tdrpStrDup("Option to auto-remap to lat-lon grid.");
    tt->help = tdrpStrDup("If set, the data will be automaticall remapped to a lat-lon grid before being returned to the client. The grid parameters will be chosen to fit the data set as well as possible.");
    tt->val_offset = (char *) &auto_remap_to_latlon - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("CONSTRAIN THE LEAD TIMES FOR FORECAST DATA - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("This option allows you to select only certain lead times to be served out. You can also specify that the search time be interpreted as the generate time.");
    tt++;
    
    // Parameter 'constrain_forecast_lead_times'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("constrain_forecast_lead_times");
    tt->descr = tdrpStrDup("Option to constrain the lead times to be considered.");
    tt->help = tdrpStrDup("If true, only forecast lead times within the specified limits will be considerd. Also, you can specify to request the data by generate time rather than valid time. The valid time will be computed as the request_time plus the mean of the min and max lead times.");
    tt->val_offset = (char *) &constrain_forecast_lead_times - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'forecast_constraints'
    // ctype is '_forecast_constraints_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("forecast_constraints");
    tt->descr = tdrpStrDup("Set constraints for forecast lead times.");
    tt->help = tdrpStrDup("See constrain_forecast_lead_times. Only forecast lead times within the specified limits will be considerd. If request_by_gen_time is true, the search_time specified will be interpreted as the generate time rather than the valid time. The valid time will be computed as the search_time plus the mean of the min and max lead times specified.");
    tt->val_offset = (char *) &forecast_constraints - &_start_;
    tt->struct_def.name = tdrpStrDup("forecast_constraints_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("min_lead_time");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &forecast_constraints.min_lead_time - (char *) &forecast_constraints;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("max_lead_time");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &forecast_constraints.max_lead_time - (char *) &forecast_constraints;
      tt->struct_def.fields[2].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[2].fname = tdrpStrDup("request_by_gen_time");
      tt->struct_def.fields[2].ptype = BOOL_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &forecast_constraints.request_by_gen_time - (char *) &forecast_constraints;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].i = 0;
      tt->struct_vals[2].b = pFALSE;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("CREATE COMPOSITE - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("Option to create a composite - max at any height.");
    tt++;
    
    // Parameter 'create_composite_on_read'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_composite_on_read");
    tt->descr = tdrpStrDup("Option to create composite on read.");
    tt->help = tdrpStrDup("If true, compute the max-in-column on the fly during the read.");
    tt->val_offset = (char *) &create_composite_on_read - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("DECIMATION - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'decimate'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("decimate");
    tt->descr = tdrpStrDup("Option to decimate to control number of grid cells served out.");
    tt->help = tdrpStrDup("This controls the decimation feature. If TRUE, the server decimates the output data to keep the total number of xy points below 'decimation_max_nxy'.");
    tt->val_offset = (char *) &decimate - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'decimation_max_nxy'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("decimation_max_nxy");
    tt->descr = tdrpStrDup("Maximum number of XY points.");
    tt->help = tdrpStrDup("See 'decimate'.");
    tt->val_offset = (char *) &decimation_max_nxy - &_start_;
    tt->single_val.i = 1000000;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("MEASURED RHI DATA OPTION - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'serve_rhi_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("serve_rhi_data");
    tt->descr = tdrpStrDup("Option to serve out data for measured RHIs.");
    tt->help = tdrpStrDup("Normally a vertical section from polar radar data is served out as a reconstructed RHI. If this option is set, the server will try to read measured RHI data and return this. If the measured request fails, the server will revert to serving out the reconstructed RHI data.");
    tt->val_offset = (char *) &serve_rhi_data - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'rhi_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("rhi_url");
    tt->descr = tdrpStrDup("URL for measured RHI data.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &rhi_url - &_start_;
    tt->single_val.s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'polar_rhi'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("polar_rhi");
    tt->descr = tdrpStrDup("Option to serve out polar data for RHI.");
    tt->help = tdrpStrDup("If true, the raw polar RHI data is returned. If false, the RHI is remapped onto a grid with height in km.");
    tt->val_offset = (char *) &polar_rhi - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'rhi_time_margin'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("rhi_time_margin");
    tt->descr = tdrpStrDup("Time margin when searching for RHIs.");
    tt->help = tdrpStrDup("The server will look for RHI files, in time, before and after the main field file (PPI or SURVEILLANCE). This is the time margin for the search.");
    tt->val_offset = (char *) &rhi_time_margin - &_start_;
    tt->single_val.i = 900;
    tt++;
    
    // Parameter 'rhi_max_az_error'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("rhi_max_az_error");
    tt->descr = tdrpStrDup("Maximum azimuth error for retrieving RHI.");
    tt->help = tdrpStrDup("The user selects a vertical cross-section in the normal manner. The azimuth of the mid-point of the vert section is computed and the RHI closest to this azimuth is selected. If the azimuth difference between the selected azimuth and the closest RHI exceeds this max error, the RHI request fails and a normal vertical section is returned.");
    tt->val_offset = (char *) &rhi_max_az_error - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'respect_user_rhi_distance'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("respect_user_rhi_distance");
    tt->descr = tdrpStrDup("Option to respect user distance for measured RHI.");
    tt->help = tdrpStrDup("If false (default) then the end points of the measured RHI are returned. If TRUE then the start point is the sensor but the end point is obtained by travelling in the direction of the RHI azimuth for the distance specified by the user.");
    tt->val_offset = (char *) &respect_user_rhi_distance - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("VERTICAL UNITS SPECIFICATION - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'specify_vertical_units'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("specify_vertical_units");
    tt->descr = tdrpStrDup("Option to specify the vertical units for the returned data.");
    tt->help = tdrpStrDup("If set, the vertical units will be converted, if possible, as specified by 'vertical_units'. If the conversion is not possible, the data will be returned in the normal units.");
    tt->val_offset = (char *) &specify_vertical_units - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vertical_units'
    // ctype is '_vertical_units_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("vertical_units");
    tt->descr = tdrpStrDup("Vertical units");
    tt->help = tdrpStrDup("See 'specify_vertical_units'. If this is TRUE, vert units will be converted as specified if possible.");
    tt->val_offset = (char *) &vertical_units - &_start_;
    tt->enum_def.name = tdrpStrDup("vertical_units_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("HEIGHT_KM");
      tt->enum_def.fields[0].val = HEIGHT_KM;
      tt->enum_def.fields[1].name = tdrpStrDup("PRESSURE_MB");
      tt->enum_def.fields[1].val = PRESSURE_MB;
      tt->enum_def.fields[2].name = tdrpStrDup("FLIGHT_LEVEL");
      tt->enum_def.fields[2].val = FLIGHT_LEVEL;
    tt->single_val.e = HEIGHT_KM;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("DERIVED FIELDS - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("Creating derived fields on the fly.");
    tt++;
    
    // Parameter 'handle_derived_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("handle_derived_fields");
    tt->descr = tdrpStrDup("Option to allow the option of computing derived fields on the fly.");
    tt->help = tdrpStrDup("If TRUE, the server will check the requested fields against the derived_fields array. If any requested field name matches an entry in the derived fields array, it will create the derived field on the fly and add it to the Mdvx object which is returned to the client. All other fields (i.e. those which do not appear in the derived_fields array) will be returned as normal.");
    tt->val_offset = (char *) &handle_derived_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'derived_fields'
    // ctype is '_derived_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("derived_fields");
    tt->descr = tdrpStrDup("Specifications for derived fields supported by the server.");
    tt->help = tdrpStrDup("If a requested field name matches one specified in this array, and handle_derived_fields is TRUE, the server will attempt to derive the field on the fly. It will use the function specified, along with the arguments in the struct, to derive the field. The arguments actually used will be dependent on the particular function chosen. The arguments which are relevant to each function type are documented below.\n\nAfter the field has been derived, a linear function will be applied to produce the final field as follows:\n     final = derived * multiplier + constant.\n\nThis allows a simple linear scaling and offset to be applied. The field will be added to the returned Mdvx object, with the supplied name, long_name, units and transform filled in.\n\nSUPPORTED FUNCTIONS\n\nFUNC_LINEAR:\n  read in the field specified in field_name_1 and apply the linear scaling. This can be used for units conversion. Examples are (a) converting from m/s to knots (multiplier = 0.53996847, constant = 0.0), (b) converting degrees celsius to farenheight (multiplier = 1.8, constant = 32.0)\n\nFUNC_SPEED_FROM_U_V:\n  compute speed from U and V fields. U field name is in field_name_1, and V field name is in field_name_2. U and V field data must both be in the same file, at the given URL.\n\nFUNC_DIRN_FROM_U_V:\n  compute direction from U and V fields. U field name is in field_name_1, and V field name is in field_name_2. U and V field data must both be in the same file, at the given URL. Direction returned in deg T.\n\nFUNC_DIFF_FIELDS_SAME_FILE:\n  compute difference between two fields from the same file. Data for both fields must be present in the file at the requested URL. First field name is in field_name_1, and second field name is in field_name_2. Difference is computed as (field_1 - field_2). Apply a multiplier of -1 to change the sign.\n\nFUNC_DIFF_FIELDS:\n  compute difference between two fields. Field data not necessarily in same file. First field name is in field_name_1, and second field name is in field_name_2. First field is in the current file. Second field URL is url_2. Difference is computed as (field_1 - field_2). Apply a multiplier of -1 to change the sign. If i_arg_1 is not 0, the second field search time will be the first field time plus i_arg_1 in secs.\n\nFUNC_DIFF_IN_TIME:\n  compute difference between data now and at a different time. Field name is given in field_name_1. Time difference in seconds is given in i_arg_1. So time for second file is time for first file plus i_arg_1. Data difference is computed as value now minus the value at the different time. Apply a multiplier of -1 to change the sign.\n\nFUNC_VERT_COMPOSITE:\n  compute a vertical composite, which is the maximum value at any level. Optionally you can specify vertical level limits. Field name to be composited is given in field_name_1. If i_arg_1 is 0, the composite is computed from all vertical levels. If i_arg_1 is 1, the minimum vertical level is given in d_arg_1 and the maximum level in d_arg_2.\n\n  \n\n");
    tt->array_offset = (char *) &_derived_fields - &_start_;
    tt->array_n_offset = (char *) &derived_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(derived_field_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("derived_field_t");
    tt->struct_def.nfields = 23;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_derived_fields->name - (char *) _derived_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("long_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_derived_fields->long_name - (char *) _derived_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("units");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_derived_fields->units - (char *) _derived_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("transform");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_derived_fields->transform - (char *) _derived_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("function_t");
      tt->struct_def.fields[4].fname = tdrpStrDup("function");
      tt->struct_def.fields[4].ptype = ENUM_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_derived_fields->function - (char *) _derived_fields;
        tt->struct_def.fields[4].enum_def.name = tdrpStrDup("function_t");
        tt->struct_def.fields[4].enum_def.nfields = 7;
        tt->struct_def.fields[4].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[4].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[4].enum_def.fields[0].name = tdrpStrDup("FUNC_LINEAR");
        tt->struct_def.fields[4].enum_def.fields[0].val = FUNC_LINEAR;
        tt->struct_def.fields[4].enum_def.fields[1].name = tdrpStrDup("FUNC_SPEED_FROM_U_V");
        tt->struct_def.fields[4].enum_def.fields[1].val = FUNC_SPEED_FROM_U_V;
        tt->struct_def.fields[4].enum_def.fields[2].name = tdrpStrDup("FUNC_DIRN_FROM_U_V");
        tt->struct_def.fields[4].enum_def.fields[2].val = FUNC_DIRN_FROM_U_V;
        tt->struct_def.fields[4].enum_def.fields[3].name = tdrpStrDup("FUNC_DIFF_FIELDS_SAME_FILE");
        tt->struct_def.fields[4].enum_def.fields[3].val = FUNC_DIFF_FIELDS_SAME_FILE;
        tt->struct_def.fields[4].enum_def.fields[4].name = tdrpStrDup("FUNC_DIFF_FIELDS");
        tt->struct_def.fields[4].enum_def.fields[4].val = FUNC_DIFF_FIELDS;
        tt->struct_def.fields[4].enum_def.fields[5].name = tdrpStrDup("FUNC_DIFF_IN_TIME");
        tt->struct_def.fields[4].enum_def.fields[5].val = FUNC_DIFF_IN_TIME;
        tt->struct_def.fields[4].enum_def.fields[6].name = tdrpStrDup("FUNC_VERT_COMPOSITE");
        tt->struct_def.fields[4].enum_def.fields[6].val = FUNC_VERT_COMPOSITE;
      tt->struct_def.fields[5].ftype = tdrpStrDup("string");
      tt->struct_def.fields[5].fname = tdrpStrDup("field_name_1");
      tt->struct_def.fields[5].ptype = STRING_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_derived_fields->field_name_1 - (char *) _derived_fields;
      tt->struct_def.fields[6].ftype = tdrpStrDup("string");
      tt->struct_def.fields[6].fname = tdrpStrDup("field_name_2");
      tt->struct_def.fields[6].ptype = STRING_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_derived_fields->field_name_2 - (char *) _derived_fields;
      tt->struct_def.fields[7].ftype = tdrpStrDup("string");
      tt->struct_def.fields[7].fname = tdrpStrDup("url_2");
      tt->struct_def.fields[7].ptype = STRING_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_derived_fields->url_2 - (char *) _derived_fields;
      tt->struct_def.fields[8].ftype = tdrpStrDup("string");
      tt->struct_def.fields[8].fname = tdrpStrDup("url_3");
      tt->struct_def.fields[8].ptype = STRING_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_derived_fields->url_3 - (char *) _derived_fields;
      tt->struct_def.fields[9].ftype = tdrpStrDup("string");
      tt->struct_def.fields[9].fname = tdrpStrDup("s_arg_1");
      tt->struct_def.fields[9].ptype = STRING_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_derived_fields->s_arg_1 - (char *) _derived_fields;
      tt->struct_def.fields[10].ftype = tdrpStrDup("string");
      tt->struct_def.fields[10].fname = tdrpStrDup("s_arg_2");
      tt->struct_def.fields[10].ptype = STRING_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_derived_fields->s_arg_2 - (char *) _derived_fields;
      tt->struct_def.fields[11].ftype = tdrpStrDup("string");
      tt->struct_def.fields[11].fname = tdrpStrDup("s_arg_3");
      tt->struct_def.fields[11].ptype = STRING_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_derived_fields->s_arg_3 - (char *) _derived_fields;
      tt->struct_def.fields[12].ftype = tdrpStrDup("string");
      tt->struct_def.fields[12].fname = tdrpStrDup("s_arg_4");
      tt->struct_def.fields[12].ptype = STRING_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_derived_fields->s_arg_4 - (char *) _derived_fields;
      tt->struct_def.fields[13].ftype = tdrpStrDup("string");
      tt->struct_def.fields[13].fname = tdrpStrDup("s_arg_5");
      tt->struct_def.fields[13].ptype = STRING_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_derived_fields->s_arg_5 - (char *) _derived_fields;
      tt->struct_def.fields[14].ftype = tdrpStrDup("string");
      tt->struct_def.fields[14].fname = tdrpStrDup("s_arg_6");
      tt->struct_def.fields[14].ptype = STRING_TYPE;
      tt->struct_def.fields[14].rel_offset = 
        (char *) &_derived_fields->s_arg_6 - (char *) _derived_fields;
      tt->struct_def.fields[15].ftype = tdrpStrDup("int");
      tt->struct_def.fields[15].fname = tdrpStrDup("i_arg_1");
      tt->struct_def.fields[15].ptype = INT_TYPE;
      tt->struct_def.fields[15].rel_offset = 
        (char *) &_derived_fields->i_arg_1 - (char *) _derived_fields;
      tt->struct_def.fields[16].ftype = tdrpStrDup("int");
      tt->struct_def.fields[16].fname = tdrpStrDup("i_arg_2");
      tt->struct_def.fields[16].ptype = INT_TYPE;
      tt->struct_def.fields[16].rel_offset = 
        (char *) &_derived_fields->i_arg_2 - (char *) _derived_fields;
      tt->struct_def.fields[17].ftype = tdrpStrDup("int");
      tt->struct_def.fields[17].fname = tdrpStrDup("i_arg_3");
      tt->struct_def.fields[17].ptype = INT_TYPE;
      tt->struct_def.fields[17].rel_offset = 
        (char *) &_derived_fields->i_arg_3 - (char *) _derived_fields;
      tt->struct_def.fields[18].ftype = tdrpStrDup("double");
      tt->struct_def.fields[18].fname = tdrpStrDup("d_arg_1");
      tt->struct_def.fields[18].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[18].rel_offset = 
        (char *) &_derived_fields->d_arg_1 - (char *) _derived_fields;
      tt->struct_def.fields[19].ftype = tdrpStrDup("double");
      tt->struct_def.fields[19].fname = tdrpStrDup("d_arg_2");
      tt->struct_def.fields[19].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[19].rel_offset = 
        (char *) &_derived_fields->d_arg_2 - (char *) _derived_fields;
      tt->struct_def.fields[20].ftype = tdrpStrDup("double");
      tt->struct_def.fields[20].fname = tdrpStrDup("d_arg_3");
      tt->struct_def.fields[20].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[20].rel_offset = 
        (char *) &_derived_fields->d_arg_3 - (char *) _derived_fields;
      tt->struct_def.fields[21].ftype = tdrpStrDup("double");
      tt->struct_def.fields[21].fname = tdrpStrDup("multiplier");
      tt->struct_def.fields[21].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[21].rel_offset = 
        (char *) &_derived_fields->multiplier - (char *) _derived_fields;
      tt->struct_def.fields[22].ftype = tdrpStrDup("double");
      tt->struct_def.fields[22].fname = tdrpStrDup("constant");
      tt->struct_def.fields[22].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[22].rel_offset = 
        (char *) &_derived_fields->constant - (char *) _derived_fields;
    tt->n_struct_vals = 23;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("unknown");
      tt->struct_vals[1].s = tdrpStrDup("unknown");
      tt->struct_vals[2].s = tdrpStrDup("none");
      tt->struct_vals[3].s = tdrpStrDup("none");
      tt->struct_vals[4].e = FUNC_SPEED_FROM_U_V;
      tt->struct_vals[5].s = tdrpStrDup("U");
      tt->struct_vals[6].s = tdrpStrDup("V");
      tt->struct_vals[7].s = tdrpStrDup("");
      tt->struct_vals[8].s = tdrpStrDup("");
      tt->struct_vals[9].s = tdrpStrDup("");
      tt->struct_vals[10].s = tdrpStrDup("");
      tt->struct_vals[11].s = tdrpStrDup("");
      tt->struct_vals[12].s = tdrpStrDup("");
      tt->struct_vals[13].s = tdrpStrDup("");
      tt->struct_vals[14].s = tdrpStrDup("");
      tt->struct_vals[15].i = 0;
      tt->struct_vals[16].i = 0;
      tt->struct_vals[17].i = 0;
      tt->struct_vals[18].d = 0;
      tt->struct_vals[19].d = 0;
      tt->struct_vals[20].d = 0;
      tt->struct_vals[21].d = 1;
      tt->struct_vals[22].d = 0;
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("CLIMATOLOGY DATA");
    tt->comment_text = tdrpStrDup("Option to serve out data from a climatology directory if a time-based request is made.");
    tt++;
    
    // Parameter 'use_climatology_url'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_climatology_url");
    tt->descr = tdrpStrDup("Option to serve out data from a climatology directory.");
    tt->help = tdrpStrDup("If set, the data will always be read from a climatology data directory. The climatology type and URL are specified below.");
    tt->val_offset = (char *) &use_climatology_url - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'climatology_type'
    // ctype is '_climatology_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("climatology_type");
    tt->descr = tdrpStrDup("Type of climatology to collect.");
    tt->help = tdrpStrDup("\tCLIMO_HOURLY - Collect the data at hourly intervals. With this type of collection, there will be a climo file for every hour of the year, with the hourly cut off times being at the top of the hour (so you'll have data for 1:00-2:00 UTC in one file, etc). The climo files will be named at the half hour (so the 1:00 - 2:00 data will be in the 013000.mdv file).\n\tCLIMO_HOURLY_BY_MONTH - Collect the data at hourly intervals, but store all of the data for the entire month for a given hour in the same file (so you'll have data for 1:00-2:00 UTC for every day of June in one file, etc). The climo files will be named at the half hour for the 15th day of the month.\n\tCLIMO_3HOURLY_BY_MONTH - Collect the data at 3-hourly intervals, but store all of the data for the entire month for a given 3-hour period in the same file (so you'll have data for 0:00-2:59 UTC for every day of June in one file, etc). The climo file will be named at the center of the 3-hour time period (1:30, 4:30, etc) for the 15th day of the month.\n\tCLIMO_HOURLY_DIURNAL - Collect the data at hourly intervals and store all of the data for a given hour in the same file. All of the data will be stored under June 15, 2003.\n\tDIURNAL_CLIMATOLOGY - Server data from a diurnal climatology generated externally (not using MdvXxxClimo). In this case, the server will search for the climatology file in the climatology_dir directory that is closest in time to the requested data, ignoring the date information in the request.\n\tCLIMO_3HOURLY_DIURNAL - Collect the data at 3-hour intervals and store all of the data under June 15, 2003.\n\tCLIMO_DAILY - Collect the data daily and store under the current date in the year 2003 at time 12:00:00.\n\tCLIMO_DAILY_BY_YEAR - Collect the data daily and store under the current date at time 12:00:00. Note that this climatology doesn't go back through all time but keeps daily statistics for each year instead. This is useful for computing other statistics through all time.\n\tCLIMO_MONTHLY - Collect the data monthly and store under the 15th of the month in the year 2003 at time 12:00:00.\n\tCLIMO_MONTHLY_BY_YEAR - Collect the data monthly and store under the 15th of the current month at time 12:00:00. Note that this climatology doesn't go back through all time but keeps monthly statistics for each year instead. This is useful for computing other statistics through all time.\n");
    tt->val_offset = (char *) &climatology_type - &_start_;
    tt->enum_def.name = tdrpStrDup("climatology_type_t");
    tt->enum_def.nfields = 10;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLIMO_HOURLY");
      tt->enum_def.fields[0].val = CLIMO_HOURLY;
      tt->enum_def.fields[1].name = tdrpStrDup("CLIMO_HOURLY_BY_MONTH");
      tt->enum_def.fields[1].val = CLIMO_HOURLY_BY_MONTH;
      tt->enum_def.fields[2].name = tdrpStrDup("CLIMO_3HOURLY_BY_MONTH");
      tt->enum_def.fields[2].val = CLIMO_3HOURLY_BY_MONTH;
      tt->enum_def.fields[3].name = tdrpStrDup("CLIMO_HOURLY_DIURNAL");
      tt->enum_def.fields[3].val = CLIMO_HOURLY_DIURNAL;
      tt->enum_def.fields[4].name = tdrpStrDup("DIURNAL_CLIMATOLOGY");
      tt->enum_def.fields[4].val = DIURNAL_CLIMATOLOGY;
      tt->enum_def.fields[5].name = tdrpStrDup("CLIMO_3HOURLY_DIURNAL");
      tt->enum_def.fields[5].val = CLIMO_3HOURLY_DIURNAL;
      tt->enum_def.fields[6].name = tdrpStrDup("CLIMO_DAILY");
      tt->enum_def.fields[6].val = CLIMO_DAILY;
      tt->enum_def.fields[7].name = tdrpStrDup("CLIMO_DAILY_BY_YEAR");
      tt->enum_def.fields[7].val = CLIMO_DAILY_BY_YEAR;
      tt->enum_def.fields[8].name = tdrpStrDup("CLIMO_MONTHLY");
      tt->enum_def.fields[8].val = CLIMO_MONTHLY;
      tt->enum_def.fields[9].name = tdrpStrDup("CLIMO_MONTHLY_BY_YEAR");
      tt->enum_def.fields[9].val = CLIMO_MONTHLY_BY_YEAR;
    tt->single_val.e = CLIMO_HOURLY;
    tt++;
    
    // Parameter 'climatology_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("climatology_dir");
    tt->descr = tdrpStrDup("Directory containing the climatology data.");
    tt->help = tdrpStrDup("Used only if climatology_type is set to DIURNAL_CLIMATOLOGY.");
    tt->val_offset = (char *) &climatology_dir - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("FILLING IN REGIONS OF MISSING DATA - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'fill_missing_regions'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("fill_missing_regions");
    tt->descr = tdrpStrDup("Option to fill in regions of missing data from surrounding areas.");
    tt->help = tdrpStrDup("If set, the server will attempt to fill in missing regions, using adjacent data. This will only be done if less than 20% of the area is missing.");
    tt->val_offset = (char *) &fill_missing_regions - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("SETTING VALID TIME SEARCH WEIGHT - READ OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("Only applies to forecast data sets stored in the gen_time/forecast_time format.");
    tt++;
    
    // Parameter 'set_valid_time_search_wt'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_valid_time_search_wt");
    tt->descr = tdrpStrDup("Option to sey valid time search weight.");
    tt->help = tdrpStrDup("This applies to finding the best forecast when forecast data is stored in the gen_time/lead_time directory structure.\n\nWhen the data is stored in this manner, forecast times (valid times) from one gen time often overlap with forecast times from a different generate time. As a result there is ambiguity about which is the 'best forecast' to use.\n\nIn this discussion, we will use 'valid time' and 'forecast time' synonymously, referring to the time at which a forecast is valid. The 'generate time' refers to the time at which a model was initialized (the analysis) or the time at which a forecast was made. The 'request time' is the time for which the client has requested the 'best forecast'.\n\nModel data is generally written out at even intervals (on say even hour or half-hour intervals), so that the valid times match exactly. Other forecast systems, such as the auto-nowcaster, produce forecasts at times which are not at even times relative to the hour, so when forecasts overlap the valid times do not match exactly.\n\nThe Mdvx classes perform what amounts to a 2-D search in the time domain, where one axis is valid time and the other axis is generate time. For each applicable file, the following are computed: (a) the difference between the request time and the valid time, say deltaV, and (b) the difference between the request time and generate time, say deltaG.\n\nThe following quantities are then computed:\n\n\twtdDeltaV = weight * deltaV;\n\tdelta2D = sqrt((deltaG * deltaG) + (wtdDeltaV * wtdDeltaV))\n\nThe 'best forecast' is the forecast with the lowest delta2D.\n\nThe optimum weight depends on the relative spacing between the valid times and the gen times. If gen times are much more widely spaced than valid times, a higher weight is needed to make sure we make the decision more on valid time than gen time.\n\nFor model data, the user generally wants to see a valid time closest to the time requested. To achieve this, we want to weight deltaV heavily. If the gen time spacing is 3 hours and the forecast spacing is 1 hour, a weight of 10 seems to work well. If the gen times are 6 hours apart and the forecast times only 30 minutes apart, a weight of 15 or more is recommended.\n\nFor nowcast-type applications, in which the gen time spacing is similar to or less than the valid time spacing, a value of 2.5 seems to work OK.\n\nIf set_valid_time_search_wt is FALSE, the default of 2.5 in the MdvxTimeList class is used.\n\nYou can also set this client-side, using setValidTimeSearchWt() in Mdvx.");
    tt->val_offset = (char *) &set_valid_time_search_wt - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'valid_time_search_wt'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("valid_time_search_wt");
    tt->descr = tdrpStrDup("See 'set_valid_time_search_wt.'");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &valid_time_search_wt - &_start_;
    tt->single_val.d = 2.5;
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("FORWARD ON WRITE - WRITE OPERATIONS ONLY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'forward_on_write'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("forward_on_write");
    tt->descr = tdrpStrDup("Option to forward to multiple URLs on write.");
    tt->help = tdrpStrDup("A list of urls is specified by the 'forward_on_write_urls' parameter. The data is written to these URLs in ADDITION to the client-specified URL.");
    tt->val_offset = (char *) &forward_on_write - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'forward_on_write_urls'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("forward_on_write_urls");
    tt->descr = tdrpStrDup("The list of ADDITIONAL urls to which data will be written.");
    tt->help = tdrpStrDup("See 'forward_on_write'. The data is always written to the original URL, and will be optioanlly written to the additional specified URLs.");
    tt->array_offset = (char *) &_forward_on_write_urls - &_start_;
    tt->array_n_offset = (char *) &forward_on_write_urls_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("mdvp:://localhost::mdv/data/set1");
      tt->array_vals[1].s = tdrpStrDup("mdvp:://remotehost::mdv/data/set1");
    tt++;
    
    // Parameter 'Comment 20'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 20");
    tt->comment_hdr = tdrpStrDup("OVERRIDE FORMAT for WRITES");
    tt->comment_text = tdrpStrDup("If set, these override the write format specified in the message from the client.\n\nFORMAT_MDV: normal legacy MDV format\n\nFORMAT_XML: XML format. XML data consists of 2 buffers/files: an XML text buffer for the headers/meta-data, and a data buffer for the data. NOTE: only COMPRESSION_NONE and COMPRESSION_GZIP_VOL are supported in XML. File extensions are .mdv.xml and .xml.buf\n\nFORMAT_NCF: netCDF CF format. File extension is .mdv.nc");
    tt++;
    
    // Parameter 'override_write_format'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_write_format");
    tt->descr = tdrpStrDup("Option to override write format as specified by the client.");
    tt->help = tdrpStrDup("If specified, this will override that specified by the client. Default is MDV.\n\nHowever, if the environment variable MDV_WRITE_FORMAT is set, that will override this write_format parameter.\n\nThe environment variable MDV_WRITE_FORMAT can take the value 'FORMAT_MDV', 'FORMAT_XML' or 'FORMAT_NCF'.");
    tt->val_offset = (char *) &override_write_format - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_format'
    // ctype is '_data_format_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("write_format");
    tt->descr = tdrpStrDup("Specify format of data files to be written.");
    tt->help = tdrpStrDup("See 'override_write_format'");
    tt->val_offset = (char *) &write_format - &_start_;
    tt->enum_def.name = tdrpStrDup("data_format_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FORMAT_MDV");
      tt->enum_def.fields[0].val = FORMAT_MDV;
      tt->enum_def.fields[1].name = tdrpStrDup("FORMAT_XML");
      tt->enum_def.fields[1].val = FORMAT_XML;
      tt->enum_def.fields[2].name = tdrpStrDup("FORMAT_NCF");
      tt->enum_def.fields[2].val = FORMAT_NCF;
    tt->single_val.e = FORMAT_MDV;
    tt++;
    
    // Parameter 'Comment 21'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 21");
    tt->comment_hdr = tdrpStrDup("WRITE IN FORECAST PATH STYLE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_as_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_as_forecast");
    tt->descr = tdrpStrDup("Set to write the data as forecast in mdv format.");
    tt->help = tdrpStrDup("This forces a forecast style write.");
    tt->val_offset = (char *) &write_as_forecast - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'if_forecast_write_as_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("if_forecast_write_as_forecast");
    tt->descr = tdrpStrDup("Set to write the files in forecast style, if the data is of a forecast type.");
    tt->help = tdrpStrDup("This only writes out in forecast style if the data_collection_type in the master header is of type FORECAST or EXTRAPOLATED.");
    tt->val_offset = (char *) &if_forecast_write_as_forecast - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 22'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 22");
    tt->comment_hdr = tdrpStrDup("WRITE USING EXTENDED PATHS");
    tt->comment_text = tdrpStrDup("This will be overridden if the environment variable MDV_WRITE_USING_EXTENDED_PATHS exists and is set to TRUE.");
    tt++;
    
    // Parameter 'write_using_extended_paths'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_using_extended_paths");
    tt->descr = tdrpStrDup("Option to write files with extended paths.");
    tt->help = tdrpStrDup("If specified, this will override that specified by the client. Default is FALSE.\n\nIf set, paths will include a separate year subdirectory, and the file name will include date and time.\n\nNon-forecast path:\n  dir/yyyy/yyyymmdd/yyyymmdd_hhmmss.mdv.\n\nForecast path:\n  dir/yyyy/yyyymmdd/yyyymmdd_g_hhmmss_f_llllllll.mdv.");
    tt->val_offset = (char *) &write_using_extended_paths - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 23'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 23");
    tt->comment_hdr = tdrpStrDup("NETCDF CF SUPPORT.");
    tt->comment_text = tdrpStrDup("The following parameters control conversion of MDV files to NetCDF CF-compliant files.");
    tt++;
    
    // Parameter 'control_mdv2ncf'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("control_mdv2ncf");
    tt->descr = tdrpStrDup("Option to set parameters for converting MDV to NCF.");
    tt->help = tdrpStrDup("If TRUE, the following netCDF-specific parameters will be used. If FALSE, these are ignored and the default conversion is performed.");
    tt->val_offset = (char *) &control_mdv2ncf - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_global_attributes'
    // ctype is '_ncf_global_attributes_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ncf_global_attributes");
    tt->descr = tdrpStrDup("Global attributes for netCDF file");
    tt->help = tdrpStrDup("These strings will be included as global attributes in the NetCDF file. Other global attributes will be determined from the MDV headers.");
    tt->val_offset = (char *) &ncf_global_attributes - &_start_;
    tt->struct_def.name = tdrpStrDup("ncf_global_attributes_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("institution");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ncf_global_attributes.institution - (char *) &ncf_global_attributes;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("references");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ncf_global_attributes.references - (char *) &ncf_global_attributes;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("comment");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &ncf_global_attributes.comment - (char *) &ncf_global_attributes;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("UCAR");
      tt->struct_vals[1].s = tdrpStrDup("");
      tt->struct_vals[2].s = tdrpStrDup("Converted by DsMdvServer");
    tt++;
    
    // Parameter 'mdv2ncf_field_transforms'
    // ctype is '_mdv2ncf_field_transform_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("mdv2ncf_field_transforms");
    tt->descr = tdrpStrDup("List of transforms. If mdv_field_name is found in the MDV data, these other parameters will be used to set the field variable in the netCDF file.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_mdv2ncf_field_transforms - &_start_;
    tt->array_n_offset = (char *) &mdv2ncf_field_transforms_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(mdv2ncf_field_transform_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("mdv2ncf_field_transform_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("mdv_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->mdv_field_name - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("ncf_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->ncf_field_name - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("ncf_standard_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->ncf_standard_name - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("ncf_long_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->ncf_long_name - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("ncf_units");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->ncf_units - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("do_linear_transform");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->do_linear_transform - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[6].ftype = tdrpStrDup("float");
      tt->struct_def.fields[6].fname = tdrpStrDup("linear_multiplier");
      tt->struct_def.fields[6].ptype = FLOAT_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->linear_multiplier - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[7].ftype = tdrpStrDup("float");
      tt->struct_def.fields[7].fname = tdrpStrDup("linear_const");
      tt->struct_def.fields[7].ptype = FLOAT_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->linear_const - (char *) _mdv2ncf_field_transforms;
      tt->struct_def.fields[8].ftype = tdrpStrDup("data_pack_t");
      tt->struct_def.fields[8].fname = tdrpStrDup("packed_data_type");
      tt->struct_def.fields[8].ptype = ENUM_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_mdv2ncf_field_transforms->packed_data_type - (char *) _mdv2ncf_field_transforms;
        tt->struct_def.fields[8].enum_def.name = tdrpStrDup("data_pack_t");
        tt->struct_def.fields[8].enum_def.nfields = 4;
        tt->struct_def.fields[8].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[8].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[8].enum_def.fields[0].name = tdrpStrDup("DATA_PACK_FLOAT");
        tt->struct_def.fields[8].enum_def.fields[0].val = DATA_PACK_FLOAT;
        tt->struct_def.fields[8].enum_def.fields[1].name = tdrpStrDup("DATA_PACK_SHORT");
        tt->struct_def.fields[8].enum_def.fields[1].val = DATA_PACK_SHORT;
        tt->struct_def.fields[8].enum_def.fields[2].name = tdrpStrDup("DATA_PACK_BYTE");
        tt->struct_def.fields[8].enum_def.fields[2].val = DATA_PACK_BYTE;
        tt->struct_def.fields[8].enum_def.fields[3].name = tdrpStrDup("DATA_PACK_ASIS");
        tt->struct_def.fields[8].enum_def.fields[3].val = DATA_PACK_ASIS;
    tt->n_struct_vals = 9;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("mdv_field_name");
      tt->struct_vals[1].s = tdrpStrDup("ncf_field_name");
      tt->struct_vals[2].s = tdrpStrDup("ncf_standard_name");
      tt->struct_vals[3].s = tdrpStrDup("ncf_long_name");
      tt->struct_vals[4].s = tdrpStrDup("ncf_units");
      tt->struct_vals[5].b = pFALSE;
      tt->struct_vals[6].f = 1;
      tt->struct_vals[7].f = 0;
      tt->struct_vals[8].e = DATA_PACK_ASIS;
    tt++;
    
    // Parameter 'ncf_compress_data'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_compress_data");
    tt->descr = tdrpStrDup("Option to compress field data.");
    tt->help = tdrpStrDup("Only applies to NETCDF4 and  NETCDF4_CLASSIC files.");
    tt->val_offset = (char *) &ncf_compress_data - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_compression_level'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("ncf_compression_level");
    tt->descr = tdrpStrDup("Compression level from 1 to 9 with 9 being the greatest compression. Default is 9.");
    tt->help = tdrpStrDup("Only applies to NETCDF4 and  NETCDF4_CLASSIC files.");
    tt->val_offset = (char *) &ncf_compression_level - &_start_;
    tt->single_val.i = 9;
    tt++;
    
    // Parameter 'ncf_filename_suffix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_filename_suffix");
    tt->descr = tdrpStrDup("Suffix of netCDF files");
    tt->help = tdrpStrDup("File extension is always .nc. File name will end with mdv.suffix.nc. Set to the empty string for no suffix, in which case file name will end with .mdv.nc.");
    tt->val_offset = (char *) &ncf_filename_suffix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_file_format'
    // ctype is '_ncformat_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("ncf_file_format");
    tt->descr = tdrpStrDup("NetCDF file format");
    tt->help = tdrpStrDup("netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls");
    tt->val_offset = (char *) &ncf_file_format - &_start_;
    tt->enum_def.name = tdrpStrDup("ncformat_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLASSIC");
      tt->enum_def.fields[0].val = CLASSIC;
      tt->enum_def.fields[1].name = tdrpStrDup("NC64BIT");
      tt->enum_def.fields[1].val = NC64BIT;
      tt->enum_def.fields[2].name = tdrpStrDup("NETCDF4");
      tt->enum_def.fields[2].val = NETCDF4;
      tt->enum_def.fields[3].name = tdrpStrDup("NETCDF4_CLASSIC");
      tt->enum_def.fields[3].val = NETCDF4_CLASSIC;
    tt->single_val.e = NETCDF4;
    tt++;
    
    // Parameter 'ncf_output_latlon_arrays'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_latlon_arrays");
    tt->descr = tdrpStrDup("If true latitude and longitude arrays of each grid point are output");
    tt->help = tdrpStrDup("The CF convention requires that these arrays are present in the netCDF file; however, the information is redundant since the lat and lon arrays could be constructed using the other projection and grid information required with a gridded data field");
    tt->val_offset = (char *) &ncf_output_latlon_arrays - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_output_mdv_attributes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_mdv_attributes");
    tt->descr = tdrpStrDup("Option to output non-CF compliant MDV attributes.");
    tt->help = tdrpStrDup("If true, MDV attributes which are not CF compliant will be output. This will facilitate the translation of the data back into MDV with the minimal loss of information.");
    tt->val_offset = (char *) &ncf_output_mdv_attributes - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'ncf_output_mdv_chunks'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("ncf_output_mdv_chunks");
    tt->descr = tdrpStrDup("Option to output non-CF compliant MDV chunks.");
    tt->help = tdrpStrDup("If true, MDV chunks will be included as byte binary variables.");
    tt->val_offset = (char *) &ncf_output_mdv_chunks - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
