/*********************************************************
 * parameter definitions for RadxKdp
 *
 * Mike Dixon, EOL, NCAR, Boulder, CO, USA, 80307-3000
 *
 * Nov 2018
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "RadxKdp reads moments from Radx-supported format files, computes KDP and optionally attenuation, andwrites out the results to Radx-supported format files.";
}

commentdef {
  p_header = "DEBUGGING";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef string {
  p_default = "test";
  p_descr = "Program instance for process registration.";
  p_help = "This application registers with procmap. This is the instance used for registration.";
} instance;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to register this process with the process mapper (procmap).";
  p_help = "If TRUE, every minute this process will register a heartbeat with procmap. If the process hangs, it will be restared by the auto_restarter.";
} register_with_procmap;

paramdef int {
  p_default = 60;
  p_descr = "Interval for registering with procmap (secs).";
  p_help = "The app will register with procmap at this interval, to update its status. If it does not register within twice this interval, the auto_restart script will restart the app.";
} procmap_register_interval;

commentdef {
  p_header = "THREADING FOR SPEED.";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to use multiple compute threads to improve performance.";
  p_help = "The read and write stages occur in the main thread, since netCDF is not thread safe. The compute stage can be multi-threaded to improve performance.";
} use_multiple_threads;

paramdef int {
  p_default = 4;
  p_min = 1;
  p_descr = "The number of compute threads.";
  p_help = "The moments computations are segmented in range, with each thread computing a fraction of the number of gates. For maximum performance, n_threads should be set to the number of processors multiplied by 4. For further tuning, use top to maximize CPU usage while varying the number of threads.";
} n_compute_threads;

commentdef {
  p_header = "DATA INPUT";
}

paramdef string {
  p_default = ".";
  p_descr = "Input directory for searching for files.";
  p_help = "Files will be searched for in this directory.";
} input_dir;

typedef enum {
  REALTIME, ARCHIVE, FILELIST
} mode_t;

paramdef enum mode_t {
  p_default = FILELIST;
  p_descr = "Operating mode";
  p_help = "In REALTIME mode, the program waits for a new input file.  "
           "In ARCHIVE mode, it moves through the data between the start "
           "and end times set on the command line. "
           "In FILELIST mode, it moves through the list of file names "
           "specified on the command line. "
           "Paths (in ARCHIVE mode, at least) MUST contain a "
           "day-directory above the data file -- ./data_file.ext will not "
           "work as a file path, but ./yyyymmdd/data_file.ext will.";
} mode;

paramdef int {
  p_default = 300;
  p_descr = "Maximum age of realtime data (secs)";
  p_help =  "Only data less old than this will be used.";
} max_realtime_data_age_secs;

paramdef string {
  p_default = "";
  p_descr = "File name extension.";
  p_help = "If set, only files with this extension will be processed.";
} input_file_search_ext;

paramdef string {
  p_default = "";
  p_descr = "File name sub-string.";
  p_help = "If set, only files with names containing this sub-string will be processed.";
} input_file_search_substr;

commentdef {
  p_header = "READ OPTIONS";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to set the max range for any ray.";
} set_max_range;

paramdef double {
  p_default = 9999;
  p_descr = "Specified maximim range - km.";
  p_help = "Gates beyond this range are removed.";
} max_range_km;

commentdef {
  p_header = "SETTING PSEUDO EARTH RADIUS RATIO FOR HEIGHT COMPUTATIONS";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the standard 4/3 earth radius model for refraction.";
  p_help = "If true, the standard 4/3 earth radius will be overridden. The US NWS NEXRAD system uses 1.21 instead of 1.333.";
} override_standard_pseudo_earth_radius;

paramdef double {
  p_default = 1.33333333;
  p_descr = "Ratio for computing the pseudo earth radius for beam height computations.";
  p_help = "For standard refraction this is 4/3. For super refraction it will be less than 4.3, and for sub-refraction it will be greater. NEXRAD uses 1.21.";
} pseudo_earth_radius_ratio;

commentdef {
  p_header = "INPUT FIELD INFORMATION";
  p_text = "Names of fields in the input file. The following fields are required: SNR, DBZ, ZDR, PHIDP and RHOHV. KDP is also required internally, but if KDP is not available it will be computed from PHIDP. LDR is optional, and is used for PID only.";
}

paramdef boolean {
  p_default = TRUE;
  p_descr = "Is SNR data available?";
  p_help = "If not, SNR will be computed from the DBZ field. See 'noise_dbz_at_100km'.";
} SNR_available;

paramdef string {
  p_default = "SNR";
  p_descr = "Field name for SNR.";
  p_help = "Signal-to-noise ratio (dB).";
} SNR_field_name;

paramdef double {
  p_default = 0.0;
  p_descr = "The noise value, represented as dBZ at a range of 100km.";
  p_help = "This is used for computing the SNR from the DBZ field. It is only used if SNR_available is FALSE. The SNR will be computed by range-correcting this value and using it as the noise value.";
} noise_dbz_at_100km;

paramdef string {
  p_default = "DBZ";
  p_descr = "Field name for DBZ.";
  p_help = "Horizontally-polarized reflectivity factor.";
} DBZ_field_name;

paramdef string {
  p_default = "ZDR";
  p_descr = "Field name for ZDR.";
} ZDR_field_name;

paramdef string {
  p_default = "PHIDP";
  p_descr = "Field name for PHIDP.";
} PHIDP_field_name;

paramdef string {
  p_default = "RHOHV";
  p_descr = "Field name for RHOHV.";
} RHOHV_field_name;

paramdef string {
  p_default = "KDP";
  p_descr = "Field name for KDP.";
} KDP_field_name;

commentdef {
  p_header = "COMPUTING KDP";
  p_text = "Parameters for computing KDP. KDP will be computed if KDP_available is FALSE.";
}

paramdef string {
  p_default = "use-defaults";
  p_descr = "Path for parameters for KDP computations.";
  p_help = "If set to use-defaults, no parameter file will be read in, and the default parameters will be used.";
} KDP_parameter_file_path;

commentdef {
  p_header = "PRECIP-INDUCED ATTENUATION CORRECTION FOR DBZ AND ZDR";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to apply precip attenuation correction for DBZ and ZDR.";
  p_help =
    "The following extra fields will be computed:\n"
    "\tDBZ_ATTEN_CORRECTION - correction in dB\n"
    "\tZDR_ATTEN_CORRECTION - correction in dB\n"
    "\tDBZ_ATTEN_CORRECTED - DBZHC corrected\n"
    "\tZDR_ATTEN_CORRECTED - ZDR corrected\n";
} apply_precip_attenuation_correction;

paramdef boolean {
  p_default = false;
  p_descr = "Option to specify the coefficients and exponents - see below.";
  p_help = "If false, the default coefficients will be determined for the radar wavelength.";
} specify_coefficients_for_attenuation_correction;

paramdef double {
  p_default = 0.017;
  p_descr = "Coefficient for computing DBZ attenuation correction.";
  p_help = "See Bringi and Chandrasekar, Table 7.1, page 494.";
} dbz_attenuation_coefficient;

paramdef double {
  p_default = 0.84;
  p_descr = "Exponent for computing DBZ attenuation correction.";
  p_help = "See Bringi and Chandrasekar, Table 7.1, page 494.";
} dbz_attenuation_exponent;

paramdef double {
  p_default = 0.003;
  p_descr = "Coefficient for computing ZDR attenuation correction.";
  p_help = "See Bringi and Chandrasekar, Table 7.1, page 494.";
} zdr_attenuation_coefficient;

paramdef double {
  p_default = 1.05;
  p_descr = "Exponent for computing ZDR attenuation correction.";
  p_help = "See Bringi and Chandrasekar, Table 7.1, page 494.";
} zdr_attenuation_exponent;

commentdef {
  p_header = "SPECIFYING FIELD NAMES AND OUTPUT ENCODING";
}

typedef enum {
  
  KDP,
  KDP_ZZDR,
  KDP_COND,
  KDP_BRINGI,
  PSOB,
  ZDP,

  DBZ_ATTEN_CORRECTION,
  ZDR_ATTEN_CORRECTION,
  DBZ_ATTEN_CORRECTED,
  ZDR_ATTEN_CORRECTED,

  DBZ_FOR_KDP,
  ZDR_FOR_KDP,
  RHOHV_FOR_KDP,
  SNR_FOR_KDP,
  ZDR_SDEV_FOR_KDP,
  VALID_FLAG_FOR_KDP,

  PHIDP_FOR_KDP,
  PHIDP_MEAN_FOR_KDP,
  PHIDP_MEAN_UNFOLD_FOR_KDP,
  PHIDP_SDEV_FOR_KDP,
  PHIDP_JITTER_FOR_KDP,
  PHIDP_UNFOLD_FOR_KDP,
  PHIDP_FILT_FOR_KDP,
  PHIDP_COND_FOR_KDP,
  PHIDP_COND_FILT_FOR_KDP

} output_field_id_t;

typedef enum {
  OUTPUT_ENCODING_FL32,
  OUTPUT_ENCODING_INT16,
  OUTPUT_ENCODING_INT08
} output_encoding_t;

typedef struct {
  output_field_id_t id;
  string name; 
  string long_name; 
  string standard_name; 
  string units;
  output_encoding_t encoding;
} output_field_t;

paramdef struct output_field_t {
  p_default = {
    {
      id = SNR,
      name = "SNR",
      long_name = "signal_to_noise_ratio_db",
      standard_name = "signal_to_noise_ratio",
      units = "dB",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = DBZ,
      name = "DBZ",
      long_name = "radar_reflectivity",
      standard_name = "equivalent_reflectivity_factor",
      units = "dBZ",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = ZDR,
      name = "ZDR",
      long_name = "calibrated_log_differential_reflectivity",
      standard_name = "log_differential_reflectivity",
      units = "dB",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = LDR,
      name = "LDR",
      long_name = "linear_depolarization_ratio_h_channel",
      standard_name = "log_linear_depolarization_ratio_h",
      units = "dB",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = RHOHV,
      name = "RHOHV",
      long_name = "cross_correlation_ratio",
      standard_name = "cross_correlation_ratio_hv",
      units = "",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = PHIDP,
      name = "PHIDP",
      long_name = "differential_phase",
      standard_name = "differential_phase_hv",
      units = "deg",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = KDP,
      name = "KDP",
      long_name = "specific_differential_phase",
      standard_name = "specific_differential_phase_hv",
      units = "deg/km",
      encoding = OUTPUT_ENCODING_INT16
    }
    ,
    {
      id = PSOB,
      name = "PSOB",
      long_name = "phase_shift_on_backscatter",
      standard_name = "phase_shift_on_backscatter",
      units = "deg",
      encoding = OUTPUT_ENCODING_INT16
    }
  };
  p_descr = "Indicate which fields should be written to the output file.";
  p_help = "Choose the ID from the list. The name and units can be set however the user prefers. The output_encoding apply to CfRadial output only.";
} output_fields[];

commentdef {
  p_header = "SPECIFYING COPY-THROUGH FIELDS";
  p_text = "These fields are copied unchanged from the input file to the output file. This is a way of consolidating the output data set.";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to copy input fields unchanged to the output file.";
} copy_input_fields_to_output;

typedef struct {
  string input_name; 
  string output_name;
  boolean censor_non_precip;
} copy_field_t;

paramdef struct copy_field_t {
  p_default = {
    {
      input_name = "VEL",
      output_name = "VEL",
      censor_non_precip = FALSE
    }
  };
  p_descr = "These fields are copied through unchanged to the output file.";
  p_help = "You can change the name of the field on output.";
} copy_fields[];

commentdef {
  p_header = "OUTPUT FILE FORMAT";
}

typedef enum {
  OUTPUT_FORMAT_CFRADIAL,
  OUTPUT_FORMAT_DORADE,
  OUTPUT_FORMAT_UF,
  OUTPUT_FORMAT_MDV_RADIAL
} output_format_t;

paramdef enum output_format_t {
  p_default = OUTPUT_FORMAT_CFRADIAL;
  p_descr = "Format for the output files.";
} output_format;

typedef enum {
  CLASSIC, NC64BIT, NETCDF4, NETCDF4_CLASSIC
} netcdf_style_t;

paramdef enum netcdf_style_t {
  p_default = NETCDF4;
  p_descr = "NetCDF style - if output_format is CFRADIAL";
  p_help = "netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls";
} netcdf_style;

commentdef {
  p_header = "OUTPUT BYTE-SWAPPING and COMPRESSION";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to compress data fields on output.";
  p_help = "Applies to netCDF and Dorade. UF does not support compression.";
} output_compressed;

paramdef int {
  p_default = 4;
  p_descr = "Compression level for output, if compressed.";
  p_help = "Applies to netCDF only. Dorade compression is run-length encoding, and has not options..";
} compression_level;

commentdef {
  p_header = "VOLUME OUTPUT";
}

paramdef string {
  p_default = "./output";
  p_descr = "Output directory path.";
  p_help = "Files will be written to this directory.";
} output_dir;

typedef enum {
  START_AND_END_TIMES,
  START_TIME_ONLY,
  END_TIME_ONLY,
  SPECIFY_FILE_NAME
} filename_mode_t;

paramdef enum filename_mode_t {
  p_default = START_AND_END_TIMES;
  p_descr = "Mode for computing output file name.";
  p_help = "START_AND_END_TIMES: include both start and end times in file name. START_TIME_ONLY: include only start time in file name. END_TIME_ONLY: include only end time in file name.";
} output_filename_mode;

paramdef string {
  p_default = "cfradial.test.nc";
  p_descr = "Name of output file.";
  p_help = "Applies only if output_filename_mode is SPECIFY_FILE_NAME. File of this name will be written to output_dir.";
} output_filename;

paramdef boolean {
  p_default = true;
  p_descr = "Add the day directory to the output directory.";
  p_help = "Path will be output_dir/yyyymmdd/filename.";
} append_day_dir_to_output_dir;

paramdef boolean {
  p_default = false;
  p_descr = "Add the year directory to the output directory.";
  p_help = "Path will be output_dir/yyyy/yyyymmdd/filename.";
} append_year_dir_to_output_dir;

paramdef boolean {
  p_default = false;
  p_descr = "Option to write out individual sweeps if appropriate.";
  p_help = "If true, the volume is split into individual sweeps for writing. Applies to CfRadial format. This is always true for DORADE format files.";
} write_individual_sweeps;

