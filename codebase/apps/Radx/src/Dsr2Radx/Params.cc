/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Dsr2Radx
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Dsr2Radx program");
    tt->comment_text = tdrpStrDup("Dsr2Radx reads radial radar data from an input FMQ, and writes the data to files in formats supported by Radx.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'procmap_register_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("procmap_register_interval");
    tt->descr = tdrpStrDup("Interval at which regsitration occurs with procmap (secs).");
    tt->help = tdrpStrDup("The auto_restart script expects registration at this interval. If registration does not occur in twice this time, the process is killed and restarted. Therefore, if writing the output files takes longer than 60 seconds because the files are large and compressed, then increase this interval, to say 120 secs.");
    tt->val_offset = (char *) &procmap_register_interval - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_fmq_url");
    tt->descr = tdrpStrDup("Input URL for DsRadar data via FMQ");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::./fmq.dsRadar");
    tt++;
    
    // Parameter 'seek_to_end_of_input'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("seek_to_end_of_input");
    tt->descr = tdrpStrDup("Option to seek to the end of the input FMQ.");
    tt->help = tdrpStrDup("If TRUE, the program will seek to the end of the fmq and only read in new data. If FALSE, it will start reading from the beginning of the FMQ.");
    tt->val_offset = (char *) &seek_to_end_of_input - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'use_input_scan_mode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_input_scan_mode");
    tt->descr = tdrpStrDup("Option to use the scan_mode in the input data.");
    tt->help = tdrpStrDup("The scan_mode indicates whether the scan is of type SURVEILLANCE/PPI RHI. The scan_mode is optionally included in the ray data. If available, it makes sense to use the scan mode to determine whether to save the data as a SURVEILLANCE/PPI or RHI. Dsr2Radx treats SURVEILLANCE and PPI data in the same manner. However, RHIs are saved in a different way. If the input scan_mode is NOT used, Dsr2Radx uses the antenna angle changes to determine whether the scan is in PPI or RHI mode.");
    tt->val_offset = (char *) &use_input_scan_mode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("RADAR PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'site_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("site_name");
    tt->descr = tdrpStrDup("Name of radar site");
    tt->help = tdrpStrDup("Stored in netCDF file.");
    tt->val_offset = (char *) &site_name - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_radar_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_name");
    tt->descr = tdrpStrDup("Option to override radar name.");
    tt->help = tdrpStrDup("If TRUE, we will use the parameter 'radar_name' instead of the name in the data stream.");
    tt->val_offset = (char *) &override_radar_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_name");
    tt->descr = tdrpStrDup("Name of radar site - if overridden");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_name - &_start_;
    tt->single_val.s = tdrpStrDup("Unknown");
    tt++;
    
    // Parameter 'override_radar_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_location");
    tt->descr = tdrpStrDup("Option to override radar location.");
    tt->help = tdrpStrDup("If TRUE, the program will use location specified in the 'radar_location' parameter.");
    tt->val_offset = (char *) &override_radar_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_location'
    // ctype is '_radar_location_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("radar_location");
    tt->descr = tdrpStrDup("Radar location if override is set true.");
    tt->help = tdrpStrDup("The radar_location is only used if 'override_radar_location' is set true. Otherwise the information in the input data stream is used. Note that the altitude is in meters MSL.");
    tt->val_offset = (char *) &radar_location - &_start_;
    tt->struct_def.name = tdrpStrDup("radar_location_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("latitudeDeg");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &radar_location.latitudeDeg - (char *) &radar_location;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("longitudeDeg");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &radar_location.longitudeDeg - (char *) &radar_location;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("altitudeKm");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &radar_location.altitudeKm - (char *) &radar_location;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 0;
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 0;
    tt++;
    
    // Parameter 'apply_azimuth_offset'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_azimuth_offset");
    tt->descr = tdrpStrDup("Option to apply an offset to the azimuth values.");
    tt->help = tdrpStrDup("If TRUE, this offset will be ADDED to the measured azimuth angles. This is useful, for example, in the case of a mobile platform which is not set up oriented to true north. Suppose you have a truck (like the DOWs) which is oriented off true north. Then if you add in the truck HEADING relative to true north, the measured azimuth angles will be adjusted by the heading, to give azimuth relative to TRUE north. The offset is applied as the rays are read in - i.e. all other operations use the updated azimuths.");
    tt->val_offset = (char *) &apply_azimuth_offset - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'azimuth_offset'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("azimuth_offset");
    tt->descr = tdrpStrDup("Azimuth offset (degrees).");
    tt->help = tdrpStrDup("See 'apply_azimuth_offset'. This value will be ADDED to the measured azimuths.");
    tt->val_offset = (char *) &azimuth_offset - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'apply_elevation_offset'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_elevation_offset");
    tt->descr = tdrpStrDup("Option to apply an offset to the elevation values.");
    tt->help = tdrpStrDup("If TRUE, this offset will be ADDED to the measured elevation angles. This is useful to correct for a systematic bias in measured elevation angles. The offset is applied as the rays are read in - i.e. all other operations use the updated elevations.");
    tt->val_offset = (char *) &apply_elevation_offset - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'elevation_offset'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elevation_offset");
    tt->descr = tdrpStrDup("Elevation offset (degrees).");
    tt->help = tdrpStrDup("See 'apply_elevation_offset'. This value will be ADDED to the measured elevations.");
    tt->val_offset = (char *) &elevation_offset - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE INSTRUMENT TYPE, PLATFORM TYPE AND PRIMARY AXIS.");
    tt->comment_text = tdrpStrDup("This applies to read operations.");
    tt++;
    
    // Parameter 'override_instrument_type'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_instrument_type");
    tt->descr = tdrpStrDup("Option to override instrument type on read.");
    tt->help = tdrpStrDup("If true, the file will be read in, the instrument type will be changed, and then any post-read processing will be performed.");
    tt->val_offset = (char *) &override_instrument_type - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instrument_type'
    // ctype is '_instrument_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("instrument_type");
    tt->descr = tdrpStrDup("Specify the instrument type. See override_instrument_type.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &instrument_type - &_start_;
    tt->enum_def.name = tdrpStrDup("instrument_type_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("INSTRUMENT_RADAR");
      tt->enum_def.fields[0].val = INSTRUMENT_RADAR;
      tt->enum_def.fields[1].name = tdrpStrDup("INSTRUMENT_LIDAR");
      tt->enum_def.fields[1].val = INSTRUMENT_LIDAR;
    tt->single_val.e = INSTRUMENT_RADAR;
    tt++;
    
    // Parameter 'override_platform_type'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_platform_type");
    tt->descr = tdrpStrDup("Option to override platform type on read. If true, the file will be read in, the platform type will be changed, and then any post-read processing will be performed.");
    tt->help = tdrpStrDup("\tPLATFORM_FIXED  - radar is in a fixed location\n\tPLATFORM_VEHICLE -  radar is mounted on a land vehicle\n\tPLATFORM_SHIP - radar is mounted on a ship\n\tPLATFORM_AIRCRAFT_FORE - forward-looking on aircraft\n\tPLATFORM_AIRCRAFT_AFT - backward-looking on aircraft\n\tPLATFORM_AIRCRAFT_TAIL - tail - e.g. ELDORA\n\tPLATFORM_AIRCRAFT_BELLY -  belly radar on aircraft\n\tPLATFORM_AIRCRAFT_ROOF - roof radar on aircraft\n\tPLATFORM_AIRCRAFT_NOSE - radar in nose radome on aircraft\n\tPLATFORM_SATELLITE_ORBIT - orbiting satellite\n\tPLATFORM_SATELLITE_GEOSTAT - geostationary satellite\n");
    tt->val_offset = (char *) &override_platform_type - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'platform_type'
    // ctype is '_platform_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("platform_type");
    tt->descr = tdrpStrDup("Platform type.");
    tt->help = tdrpStrDup("See override_platform_type.");
    tt->val_offset = (char *) &platform_type - &_start_;
    tt->enum_def.name = tdrpStrDup("platform_type_t");
    tt->enum_def.nfields = 11;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PLATFORM_FIXED");
      tt->enum_def.fields[0].val = PLATFORM_FIXED;
      tt->enum_def.fields[1].name = tdrpStrDup("PLATFORM_VEHICLE");
      tt->enum_def.fields[1].val = PLATFORM_VEHICLE;
      tt->enum_def.fields[2].name = tdrpStrDup("PLATFORM_SHIP");
      tt->enum_def.fields[2].val = PLATFORM_SHIP;
      tt->enum_def.fields[3].name = tdrpStrDup("PLATFORM_AIRCRAFT_FORE");
      tt->enum_def.fields[3].val = PLATFORM_AIRCRAFT_FORE;
      tt->enum_def.fields[4].name = tdrpStrDup("PLATFORM_AIRCRAFT_AFT");
      tt->enum_def.fields[4].val = PLATFORM_AIRCRAFT_AFT;
      tt->enum_def.fields[5].name = tdrpStrDup("PLATFORM_AIRCRAFT_TAIL");
      tt->enum_def.fields[5].val = PLATFORM_AIRCRAFT_TAIL;
      tt->enum_def.fields[6].name = tdrpStrDup("PLATFORM_AIRCRAFT_BELLY");
      tt->enum_def.fields[6].val = PLATFORM_AIRCRAFT_BELLY;
      tt->enum_def.fields[7].name = tdrpStrDup("PLATFORM_AIRCRAFT_ROOF");
      tt->enum_def.fields[7].val = PLATFORM_AIRCRAFT_ROOF;
      tt->enum_def.fields[8].name = tdrpStrDup("PLATFORM_AIRCRAFT_NOSE");
      tt->enum_def.fields[8].val = PLATFORM_AIRCRAFT_NOSE;
      tt->enum_def.fields[9].name = tdrpStrDup("PLATFORM_SATELLITE_ORBIT");
      tt->enum_def.fields[9].val = PLATFORM_SATELLITE_ORBIT;
      tt->enum_def.fields[10].name = tdrpStrDup("PLATFORM_SATELLITE_GEOSTAT");
      tt->enum_def.fields[10].val = PLATFORM_SATELLITE_GEOSTAT;
    tt->single_val.e = PLATFORM_FIXED;
    tt++;
    
    // Parameter 'override_primary_axis'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_primary_axis");
    tt->descr = tdrpStrDup("Option to override primary axis on read. If true, the file will be read in, the primary axis will be changed, and then any post-read processing will be performed.");
    tt->help = tdrpStrDup("\tPRIMARY_AXIS_Z - vertical\n\tPRIMARY_AXIS_Y - longitudinal axis of platform\n\tPRIMARY_AXIS_X - lateral axis of platform\n\tPRIMARY_AXIS_Z_PRIME - inverted vertical\n\tPRIMARY_AXIS_Y_PRIME - ELDORA, HRD tail\n\tPRIMARY_AXIS_X_PRIME - translated lateral\n");
    tt->val_offset = (char *) &override_primary_axis - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'primary_axis'
    // ctype is '_primary_axis_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("primary_axis");
    tt->descr = tdrpStrDup("Primary axis.");
    tt->help = tdrpStrDup("See override_primary_axis.");
    tt->val_offset = (char *) &primary_axis - &_start_;
    tt->enum_def.name = tdrpStrDup("primary_axis_t");
    tt->enum_def.nfields = 6;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PRIMARY_AXIS_Z");
      tt->enum_def.fields[0].val = PRIMARY_AXIS_Z;
      tt->enum_def.fields[1].name = tdrpStrDup("PRIMARY_AXIS_Y");
      tt->enum_def.fields[1].val = PRIMARY_AXIS_Y;
      tt->enum_def.fields[2].name = tdrpStrDup("PRIMARY_AXIS_X");
      tt->enum_def.fields[2].val = PRIMARY_AXIS_X;
      tt->enum_def.fields[3].name = tdrpStrDup("PRIMARY_AXIS_Z_PRIME");
      tt->enum_def.fields[3].val = PRIMARY_AXIS_Z_PRIME;
      tt->enum_def.fields[4].name = tdrpStrDup("PRIMARY_AXIS_Y_PRIME");
      tt->enum_def.fields[4].val = PRIMARY_AXIS_Y_PRIME;
      tt->enum_def.fields[5].name = tdrpStrDup("PRIMARY_AXIS_X_PRIME");
      tt->enum_def.fields[5].val = PRIMARY_AXIS_X_PRIME;
    tt->single_val.e = PRIMARY_AXIS_Z;
    tt++;
    
    // Parameter 'apply_georeference_corrections'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_georeference_corrections");
    tt->descr = tdrpStrDup("Option to apply the georeference info for moving platforms.");
    tt->help = tdrpStrDup("For moving platforms, measured georeference information is sometimes available. If this is set to true, the georeference data is applied and appropriate corrections made. If possible, Earth-centric azimuth and elevation angles will be computed.");
    tt->val_offset = (char *) &apply_georeference_corrections - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("CENSORING OUTPUT FIELDS");
    tt->comment_text = tdrpStrDup("You have the option of censoring the output data fields - i.e. setting the fields to missing values - at gates which meet certain criteria. If this is done correctly, it allows you to preserve the valid data and discard the noise, thereby improving compression. This leads to smaller data files.");
    tt++;
    
    // Parameter 'apply_censoring'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("apply_censoring");
    tt->descr = tdrpStrDup("Apply censoring based on field values and thresholds.");
    tt->help = tdrpStrDup("If TRUE, censoring will be performed. See 'censoring_fields' for details on how the censoring is applied.");
    tt->val_offset = (char *) &apply_censoring - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'censoring_fields'
    // ctype is '_censoring_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("censoring_fields");
    tt->descr = tdrpStrDup("Fields to be used for censoring.");
    tt->help = tdrpStrDup("Specify the fields to be used to determine whether a gate should be censored. The name refers to the input data fields. Valid field values lie in the range from min_valid_value to max_valid_value inclusive. If the value of a field at a gate lies within this range, it is considered valid. Each specified field is examined at each gate, and is flagged as valid if its value lies in the valid range. These field flags are then combined as follows: first, all of the LOGICAL_OR flags are combined, yielding a single combined_or flag which is true if any of the LOGICAL_OR fields is true. The combined_or flag is then combined with all of the LOGICAL_AND fields, yielding a true value only if the combined_or flag and the LOGICAL_AND fields are all true. If this final flag is true, then the data at the gate is regarded as valid and is retained. If the final flag is false, the data at the gate is censored, and all of the fields at the gate are set to missing.");
    tt->array_offset = (char *) &_censoring_fields - &_start_;
    tt->array_n_offset = (char *) &censoring_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(censoring_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("censoring_field_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_censoring_fields->name - (char *) _censoring_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_valid_value");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_censoring_fields->min_valid_value - (char *) _censoring_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("max_valid_value");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_censoring_fields->max_valid_value - (char *) _censoring_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("logical_t");
      tt->struct_def.fields[3].fname = tdrpStrDup("combination_method");
      tt->struct_def.fields[3].ptype = ENUM_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_censoring_fields->combination_method - (char *) _censoring_fields;
        tt->struct_def.fields[3].enum_def.name = tdrpStrDup("logical_t");
        tt->struct_def.fields[3].enum_def.nfields = 2;
        tt->struct_def.fields[3].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[3].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[3].enum_def.fields[0].name = tdrpStrDup("LOGICAL_AND");
        tt->struct_def.fields[3].enum_def.fields[0].val = LOGICAL_AND;
        tt->struct_def.fields[3].enum_def.fields[1].name = tdrpStrDup("LOGICAL_OR");
        tt->struct_def.fields[3].enum_def.fields[1].val = LOGICAL_OR;
    tt->n_struct_vals = 8;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("SNR");
      tt->struct_vals[1].d = 0;
      tt->struct_vals[2].d = 1000;
      tt->struct_vals[3].e = LOGICAL_OR;
      tt->struct_vals[4].s = tdrpStrDup("NCP");
      tt->struct_vals[5].d = 0.15;
      tt->struct_vals[6].d = 1000;
      tt->struct_vals[7].e = LOGICAL_OR;
    tt++;
    
    // Parameter 'censoring_min_valid_run'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("censoring_min_valid_run");
    tt->descr = tdrpStrDup("Minimum valid run of non-censored gates.");
    tt->help = tdrpStrDup("Only active if set to 2 or greater. A check is made to remove short runs of noise. Looking along the radial, we compute the number of contiguous gates (a 'run') with uncensored data. For the gates in this run to be accepted the length of the run must exceed censoring_min_valid_run. If the number of gates in a run is less than this, then all gates in the run are censored.");
    tt->val_offset = (char *) &censoring_min_valid_run - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("FILTER DATA BASED ON GEOMETRY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'filter_using_gate_spacing'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_using_gate_spacing");
    tt->descr = tdrpStrDup("Option to filter data based on gate spacing.");
    tt->help = tdrpStrDup("If TRUE, the program will use only ray data which matches the 'keep_gate_spacing' parameter.");
    tt->val_offset = (char *) &filter_using_gate_spacing - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specified_gate_spacing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("specified_gate_spacing");
    tt->descr = tdrpStrDup("Desired radar gate spacing (km).");
    tt->help = tdrpStrDup("The specified gate spacing is only used if 'filter_gate_spacing' is set true. Otherwise all gate spacings in the input data stream are used.");
    tt->val_offset = (char *) &specified_gate_spacing - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'filter_using_start_range'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_using_start_range");
    tt->descr = tdrpStrDup("Option to filter data based on start range.");
    tt->help = tdrpStrDup("If TRUE, the program will use only ray data which matches the 'keep _start_range' parameter.");
    tt->val_offset = (char *) &filter_using_start_range - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specified_start_range'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("specified_start_range");
    tt->descr = tdrpStrDup("Desired radar start range (km).");
    tt->help = tdrpStrDup("The specified start range is only used if 'filter_start_range' is set true. Otherwise all start ranges in the input data stream are used.");
    tt->val_offset = (char *) &specified_start_range - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'filter_using_elev'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_using_elev");
    tt->descr = tdrpStrDup("Option to filter data based on elevation angle.");
    tt->help = tdrpStrDup("If TRUE, the program will use only ray data with elevations between the given limits.");
    tt->val_offset = (char *) &filter_using_elev - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specified_min_elev'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("specified_min_elev");
    tt->descr = tdrpStrDup("Minimum valid elevation for rays (deg).");
    tt->help = tdrpStrDup("If the elevation is below this value, the ray is ignored. Applies only if filter_using_elev is true.");
    tt->val_offset = (char *) &specified_min_elev - &_start_;
    tt->single_val.d = -10;
    tt++;
    
    // Parameter 'specified_max_elev'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("specified_max_elev");
    tt->descr = tdrpStrDup("Maximum valid elevation for rays (deg).");
    tt->help = tdrpStrDup("If the elevation is above this value, the ray is ignored. Applies only if filter_using_elev is true.");
    tt->val_offset = (char *) &specified_max_elev - &_start_;
    tt->single_val.d = 90;
    tt++;
    
    // Parameter 'filter_using_sweep_number'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_using_sweep_number");
    tt->descr = tdrpStrDup("Option to filter data based on the sweep number.");
    tt->help = tdrpStrDup("If TRUE, the program will use only ray data with a sweep numbers between the given limits.");
    tt->val_offset = (char *) &filter_using_sweep_number - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specified_min_sweep_number'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("specified_min_sweep_number");
    tt->descr = tdrpStrDup("Minimum valid sweep number for rays.");
    tt->help = tdrpStrDup("If the sweep number is below this value, the ray is ignored. Applies only if filter_using_sweep_number is true.");
    tt->val_offset = (char *) &specified_min_sweep_number - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'specified_max_sweep_number'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("specified_max_sweep_number");
    tt->descr = tdrpStrDup("Maximum valid sweep number for rays.");
    tt->help = tdrpStrDup("If the sweep number is above this value, the ray is ignored. Applies only if filter_using_sweep_number is true.");
    tt->val_offset = (char *) &specified_max_sweep_number - &_start_;
    tt->single_val.i = 999;
    tt++;
    
    // Parameter 'filter_using_sweep_number_list'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_using_sweep_number_list");
    tt->descr = tdrpStrDup("Option to filter data based on sweep numbers in the list.");
    tt->help = tdrpStrDup("If TRUE, the program will use only ray data with a sweep number that is in the specified list.");
    tt->val_offset = (char *) &filter_using_sweep_number_list - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specified_sweep_number_list'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("specified_sweep_number_list");
    tt->descr = tdrpStrDup("List of valid sweep numbers.");
    tt->help = tdrpStrDup("If the sweep number is not in this list, the ray is ignored. Applies only if filter_using_sweep_number_list is true.");
    tt->array_offset = (char *) &_specified_sweep_number_list - &_start_;
    tt->array_n_offset = (char *) &specified_sweep_number_list_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(int);
    tt->array_n = 3;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].i = 0;
      tt->array_vals[1].i = 1;
      tt->array_vals[2].i = 2;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("FILTER DATA BASED ON ANTENNA or SCAN STATE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'filter_antenna_stationary'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_antenna_stationary");
    tt->descr = tdrpStrDup("Option to not ingest data when the antenna is stationary.");
    tt->help = tdrpStrDup("If true, rays will only be stored if the antenna is moving. If the antenna stops, rays will be ignored.");
    tt->val_offset = (char *) &filter_antenna_stationary - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_angle_change_for_moving_antenna'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_angle_change_for_moving_antenna");
    tt->descr = tdrpStrDup("Minimun angle change ray-to-ray for antenna to be moving (deg).");
    tt->help = tdrpStrDup("For the antenna to be considered moving. the antenna much move by this amount from one ray to the next. The angle check is made in both azimuth and elevation.");
    tt->val_offset = (char *) &min_angle_change_for_moving_antenna - &_start_;
    tt->single_val.d = 0.05;
    tt++;
    
    // Parameter 'clear_transition_flag_on_all_rays'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("clear_transition_flag_on_all_rays");
    tt->descr = tdrpStrDup("Option to clear the transition flag on all rays.");
    tt->help = tdrpStrDup("If true, for all rays on which the transition flag is set, this flag will be removed, so that all rays are considered to be NOT in transition.");
    tt->val_offset = (char *) &clear_transition_flag_on_all_rays - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'filter_antenna_transitions'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_antenna_transitions");
    tt->descr = tdrpStrDup("Option to ignore rays for which the transition flag is set.");
    tt->help = tdrpStrDup("If TRUE, the program will filter out rays which are computed when the antenna is moving from one sweep to the next, or one volume to the next.");
    tt->val_offset = (char *) &filter_antenna_transitions - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'filter_when_scan_idle'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_when_scan_idle");
    tt->descr = tdrpStrDup("Option to filter rays when scan mode is IDLE.");
    tt->help = tdrpStrDup("If TRUE, the program will filter out all rays for which the scan mode is IDLE.");
    tt->val_offset = (char *) &filter_when_scan_idle - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'filter_when_scan_pointing'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_when_scan_pointing");
    tt->descr = tdrpStrDup("Option to filter rays when scan mode is POINT.");
    tt->help = tdrpStrDup("If TRUE, the program will filter out all rays for which the scan mode is POINTING.");
    tt->val_offset = (char *) &filter_when_scan_pointing - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("OUTPUT GATE GEOMETRY");
    tt->comment_text = tdrpStrDup("You can only choose one range geometry remapping option. If none are picked, all rays which do not match the predominant geometry will be discarded.");
    tt++;
    
    // Parameter 'convert_to_predominant_gate_geometry'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("convert_to_predominant_gate_geometry");
    tt->descr = tdrpStrDup("Option to convert all rays to predominant geometry.");
    tt->help = tdrpStrDup("If true, all rays will be converted to the predominant gate geometry - i.e. start_range and gate_spacing.");
    tt->val_offset = (char *) &convert_to_predominant_gate_geometry - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'convert_to_finest_gate_geometry'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("convert_to_finest_gate_geometry");
    tt->descr = tdrpStrDup("Option to convert all rays to finest range gate spacing.");
    tt->help = tdrpStrDup("If true, all rays will be converted to the finest gate spacing.");
    tt->val_offset = (char *) &convert_to_finest_gate_geometry - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'convert_to_specified_output_gate_geometry'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("convert_to_specified_output_gate_geometry");
    tt->descr = tdrpStrDup("Option to convert all rays to a specified gate geometry.");
    tt->help = tdrpStrDup("See 'specified_start_range_k', 'specified_gate_spacing_km' and 'interpolate_to_specified_gate_geometry'.");
    tt->val_offset = (char *) &convert_to_specified_output_gate_geometry - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_start_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("output_start_range_km");
    tt->descr = tdrpStrDup("Start range for specified remapping (km).");
    tt->help = tdrpStrDup("See 'convert_to_specified_gate_geometry'.");
    tt->val_offset = (char *) &output_start_range_km - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'output_gate_spacing_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("output_gate_spacing_km");
    tt->descr = tdrpStrDup("Gate spacing for specified remapping (km).");
    tt->help = tdrpStrDup("See 'convert_to_specified_gate_geometry'.");
    tt->val_offset = (char *) &output_gate_spacing_km - &_start_;
    tt->single_val.d = 0.2;
    tt++;
    
    // Parameter 'interpolate_to_output_gate_geometry'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("interpolate_to_output_gate_geometry");
    tt->descr = tdrpStrDup("Option to use interpolation when converting to the specified gate geometry.");
    tt->help = tdrpStrDup("If false, nearest neighbor mapping is used. See 'convert_to_specified_gate_geometry'.");
    tt->val_offset = (char *) &interpolate_to_output_gate_geometry - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("COMPUTING THE SWEEP ANGLE HISTOGRAM");
    tt->comment_text = tdrpStrDup("Normally we use the sweep numbers in the input data to logically separate the sweeps. Optionally, however, if the scan information is not available in the data, we can use a histogram technique to determine the sweep information instead.");
    tt++;
    
    // Parameter 'find_sweep_numbers_using_histogram'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("find_sweep_numbers_using_histogram");
    tt->descr = tdrpStrDup("Option to use histogram to determine sweep numbers.");
    tt->help = tdrpStrDup("If FALSE, the sweep numbers in the ray data will be used directly to group the rays into sweeps. If FALSE, the antenna angles will be analysed using a histogram technique to determine the sweep numbers.");
    tt->val_offset = (char *) &find_sweep_numbers_using_histogram - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_target_angles_for_hist'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_target_angles_for_hist");
    tt->descr = tdrpStrDup("Option to use target angles instead of actual angles to compute the histogram.");
    tt->help = tdrpStrDup("If TRUE, the target angles will be used to compute the histograms. If FALSE, the measured angles will be used.");
    tt->val_offset = (char *) &use_target_angles_for_hist - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'hist_angle_resolution'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("hist_angle_resolution");
    tt->descr = tdrpStrDup("Resolution of histogram (deg).");
    tt->help = tdrpStrDup("The angle data is binned at this resolution. If the scan strategy has angles very close together you may need to use a fine resolution.");
    tt->val_offset = (char *) &hist_angle_resolution - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'hist_search_width'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("hist_search_width");
    tt->descr = tdrpStrDup("The width of the search in looking for peaks in the histogram.");
    tt->help = tdrpStrDup("When looking for peaks, the program searches by this number of bins on either side of the search bin. For example, if the hist_angle_resolution is 0.1 and the hist_angle_search_width is 3, the program will search 3 bins, or 0.3 degrees, on either side of the search bin. It looks for a peak with values equal to or below the peak in the adjacent bins and less than the peak in bins further out.");
    tt->val_offset = (char *) &hist_search_width - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("CROPPING ABOVE A GIVEN HEIGHT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'crop_above_max_height'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("crop_above_max_height");
    tt->descr = tdrpStrDup("Option to crop all gates above a selectted maximum height.");
    tt->help = tdrpStrDup("Normally all gates are processed. If this is set to true, gates above the selected height will be removed from the processing.");
    tt->val_offset = (char *) &crop_above_max_height - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_height_km_msl'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_height_km_msl");
    tt->descr = tdrpStrDup("Height MSL for cropping (km).");
    tt->help = tdrpStrDup("Only gates below this height will be processed.");
    tt->val_offset = (char *) &max_height_km_msl - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("REMOVING TEST PULSE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'remove_test_pulse'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_test_pulse");
    tt->descr = tdrpStrDup("Option to remove the test pulse data.");
    tt->help = tdrpStrDup("If true, the test pulse data will be removed from the end of the ray. The test pulse data generally lies in the last few gates in the ray. If true, the number of gates will be reduced by 'ngates_test_pulse'.");
    tt->val_offset = (char *) &remove_test_pulse - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ngates_test_pulse'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("ngates_test_pulse");
    tt->descr = tdrpStrDup("Number of gates to remove to get rid of test pulse.");
    tt->help = tdrpStrDup("See 'remove_test_pulse'.");
    tt->val_offset = (char *) &ngates_test_pulse - &_start_;
    tt->single_val.i = 20;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("CHECKING SWEEP DATA");
    tt->comment_text = tdrpStrDup("Checking whether sweeps should be included.");
    tt++;
    
    // Parameter 'check_min_rays_in_sweep'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_rays_in_sweep");
    tt->descr = tdrpStrDup("Option to check the number of rays in a sweep.");
    tt->help = tdrpStrDup("If TRUE, a sweep is only considered valid if the number of rays exceeds 'min_rays_in_sweep'.");
    tt->val_offset = (char *) &check_min_rays_in_sweep - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_rays_in_sweep'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_rays_in_sweep");
    tt->descr = tdrpStrDup("The min number of rays for a sweep to be valid.");
    tt->help = tdrpStrDup("See 'check_min_rays_in_sweep'.");
    tt->val_offset = (char *) &min_rays_in_sweep - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'check_min_rays_in_ppi_sweep'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_rays_in_ppi_sweep");
    tt->descr = tdrpStrDup("Option to check the number of rays in a PPI sweep.");
    tt->help = tdrpStrDup("If TRUE, a PPI sweep is only considered valid if the number of rays exceeds 'min_rays_in_ppi_sweep'.");
    tt->val_offset = (char *) &check_min_rays_in_ppi_sweep - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_rays_in_ppi_sweep'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_rays_in_ppi_sweep");
    tt->descr = tdrpStrDup("The min number of rays for a PPI sweep to be valid.");
    tt->help = tdrpStrDup("See 'check_min_rays_in_ppi_sweep'.");
    tt->val_offset = (char *) &min_rays_in_ppi_sweep - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'check_min_rays_in_rhi_sweep'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_min_rays_in_rhi_sweep");
    tt->descr = tdrpStrDup("Option to check the number of rays in a RHI sweep.");
    tt->help = tdrpStrDup("If TRUE, a RHI sweep is only considered valid if the number of rays exceeds 'min_rays_in_rhi_sweep'.");
    tt->val_offset = (char *) &check_min_rays_in_rhi_sweep - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_rays_in_rhi_sweep'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_rays_in_rhi_sweep");
    tt->descr = tdrpStrDup("The min number of rays for a RHI sweep to be valid.");
    tt->help = tdrpStrDup("See 'check_min_rays_in_rhi_sweep'.");
    tt->val_offset = (char *) &min_rays_in_rhi_sweep - &_start_;
    tt->single_val.i = 45;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("COMPUTING FIXED ANGLES FROM RAYS");
    tt->comment_text = tdrpStrDup("NOTE: if the antenna control system does not point the antenna correctly, there will be an offset between the fixed (commanded) angles and the measured antenna angles. This option allows you to re-compute the fixed angles so that they are derived from the measured angles.");
    tt++;
    
    // Parameter 'compute_ppi_fixed_angles_from_measured_elevation'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_ppi_fixed_angles_from_measured_elevation");
    tt->descr = tdrpStrDup("Option to recompute the fixed angles from the measured angles for PPI sweeps - i.e. surveillance and sector mode.");
    tt->help = tdrpStrDup("See NOTE above.");
    tt->val_offset = (char *) &compute_ppi_fixed_angles_from_measured_elevation - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'compute_rhi_fixed_angles_from_measured_azimuth'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_rhi_fixed_angles_from_measured_azimuth");
    tt->descr = tdrpStrDup("Option to recompute the fixed angles from the measured angles for RHI sweeps.");
    tt->help = tdrpStrDup("See NOTE above.");
    tt->val_offset = (char *) &compute_rhi_fixed_angles_from_measured_azimuth - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_mean_to_compute_fixed_angles'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_mean_to_compute_fixed_angles");
    tt->descr = tdrpStrDup("Option to use mean to compute the fixed angles. This is the default.");
    tt->help = tdrpStrDup("If false, uses the median.");
    tt->val_offset = (char *) &use_mean_to_compute_fixed_angles - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("INCREMENTING SWEEP NUMBERS BASED ON MODE CHANGES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'increment_sweep_num_when_pol_mode_changes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("increment_sweep_num_when_pol_mode_changes");
    tt->descr = tdrpStrDup("Option to increment the sweep number on a ray when the polarization mode changes.");
    tt->help = tdrpStrDup("This operation is performed before writing the data out. We search through the rays, and if a polarization mode change occurs in the middle of a sweep, the sweep number is incremented to break up the sweep into multiple parts.");
    tt->val_offset = (char *) &increment_sweep_num_when_pol_mode_changes - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'increment_sweep_num_when_prt_mode_changes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("increment_sweep_num_when_prt_mode_changes");
    tt->descr = tdrpStrDup("Option to increment the sweep number on a ray when the prt mode changes.");
    tt->help = tdrpStrDup("This operation is performed before writing the data out. We search through the rays, and if a prt mode change occurs in the middle of a sweep, the sweep number is incremented to break up the sweep into multiple parts.");
    tt->val_offset = (char *) &increment_sweep_num_when_prt_mode_changes - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("OPTION TO ADJUST SWEEP LIMITS USING FIXED AND MEASURED ANGLES");
    tt->comment_text = tdrpStrDup("Sometimes the transitions from one fixed angle to another are not accurately described by the scan flags, and as a result rays are not correctly assigned to the sweeps. This option goes through the volume in ray order, and adjusts the way rays are associated with each sweep. It does this by comparing the actual angle with the fixed angle, and minimizes the angular difference at the transition from one sweep to the next. If you use this section, then 'filter_antenna_transitions' should be set to FALSE.");
    tt++;
    
    // Parameter 'adjust_sur_sweep_limits_using_angles'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("adjust_sur_sweep_limits_using_angles");
    tt->descr = tdrpStrDup("Adjust the limits of sweeps in surveillance mode.");
    tt->help = tdrpStrDup("We compare the actual angle with the fixed angle, and minimize the angular difference at the transition from one sweep to the next.");
    tt->val_offset = (char *) &adjust_sur_sweep_limits_using_angles - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'adjust_sur_sweep_max_angle_error'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("adjust_sur_sweep_max_angle_error");
    tt->descr = tdrpStrDup("Max angle error to be used when adjusting sur sweep limits (deg).");
    tt->help = tdrpStrDup("See 'adjust_sur_sweep_limits_using angles'. We only adjust sweeps for which the elevation error is less than this.");
    tt->val_offset = (char *) &adjust_sur_sweep_max_angle_error - &_start_;
    tt->single_val.d = 2;
    tt++;
    
    // Parameter 'adjust_sector_sweep_limits_using_angles'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("adjust_sector_sweep_limits_using_angles");
    tt->descr = tdrpStrDup("Adjust the limits of sweeps in sector mode.");
    tt->help = tdrpStrDup("We compare the actual angle with the fixed angle, and minimize the angular difference at the transition from one sweep to the next.");
    tt->val_offset = (char *) &adjust_sector_sweep_limits_using_angles - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'adjust_rhi_sweep_limits_using_angles'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("adjust_rhi_sweep_limits_using_angles");
    tt->descr = tdrpStrDup("Adjust the limits of sweeps in RHI mode.");
    tt->help = tdrpStrDup("We compare the actual angle with the fixed angle, and minimize the angular difference at the transition from one sweep to the next.");
    tt->val_offset = (char *) &adjust_rhi_sweep_limits_using_angles - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("OPTION TO MAKE SURVEILLANCE SWEEP TRANSITIONS OCCUR AT A SPECIFIED AZIMUTH");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'force_sur_sweep_transitions_at_fixed_azimuth'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("force_sur_sweep_transitions_at_fixed_azimuth");
    tt->descr = tdrpStrDup("Adjust the limits of surveillance sweeps, changing the sweep number when the azimuth crosses the specified value.");
    tt->help = tdrpStrDup("Sometimes the transitions from one fixed angle to another are not accurately described by the scan flags, and as a result rays are not correctly assigned to the sweeps. This option goes through a surveillance volume in ray order, and adjusts the way rays are associated with each sweep. It forces a change in sweep when the azimuth transitions across 'sur_sweep_transitions_azimuth_deg'.\n\nNOTE: this applies in surveillance mode only, and will override 'adjust_sur_sweep_limits_using_angles' if both are set to TRUE. It has no effect on sweeps from RHI or SECTOR modes.");
    tt->val_offset = (char *) &force_sur_sweep_transitions_at_fixed_azimuth - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'sur_sweep_transitions_azimuth_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("sur_sweep_transitions_azimuth_deg");
    tt->descr = tdrpStrDup("Azimuth to be used for forcing surveillance sweep transitions (deg).");
    tt->help = tdrpStrDup("See 'adjust_sur_sweep_limits_to_fixed_azimuth'. Any azimuth_offset will be applied before this check.");
    tt->val_offset = (char *) &sur_sweep_transitions_azimuth_deg - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("TRIM SURVEILLANCE SWEEPS TO SPAN ONLY 360 DEG");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'trim_surveillance_sweeps_to_360deg'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("trim_surveillance_sweeps_to_360deg");
    tt->descr = tdrpStrDup("Option to trip surveillance sweeps so that they only cover 360 degrees.");
    tt->help = tdrpStrDup("Some sweeps will have rays which cover more than a 360-degree rotation. Often these include antenna transitions. If this is set to true, rays are trimmed off either end of the sweep to limit the coverage to 360 degrees. The median elevation angle is computed and the end ray which deviates from the median in elevation is trimmed first.");
    tt->val_offset = (char *) &trim_surveillance_sweeps_to_360deg - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("DETERMINING END OF VOL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'end_of_vol_decision'
    // ctype is '_end_of_vol_decision_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("end_of_vol_decision");
    tt->descr = tdrpStrDup("Decision type for end-of-volume.");
    tt->help = tdrpStrDup("\nEND_OF_VOL_FLAG: the end-of-volume flag in the data will be used to trigger the end of volume.\n\nCHANGE_IN_VOL_NUM: an end of volume will be assumed when the volume number changes from one ray to the next.\n\nCHANGE_IN_SWEEP_NUM: each sweep will be written out as a separate volume.\n\nCHANGE_IN_SWEEP_MODE: triggers and end of vol if the sweep mode changes, for example from SUR to RHI.\n\nEVERY_360_DEG: the volume will end after every 360 degree sweep. The azimuth at which the vol changes is specified by az_for_end_of_vol_360.\n\nLAST_SWEEP_IN_VOL: the end of the sweep number given by 'last_sweep_in_vol' will be used  to trigger the end-of-volume.\n\nAUTOMATIC: end-of-volume condition will be determined from the antenna-angle information.\n\nELAPSED_TIME: an end-of-volume will be triggered after 'nsecs_per_volume' seconds.");
    tt->val_offset = (char *) &end_of_vol_decision - &_start_;
    tt->enum_def.name = tdrpStrDup("end_of_vol_decision_t");
    tt->enum_def.nfields = 8;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("END_OF_VOL_FLAG");
      tt->enum_def.fields[0].val = END_OF_VOL_FLAG;
      tt->enum_def.fields[1].name = tdrpStrDup("CHANGE_IN_VOL_NUM");
      tt->enum_def.fields[1].val = CHANGE_IN_VOL_NUM;
      tt->enum_def.fields[2].name = tdrpStrDup("CHANGE_IN_SWEEP_NUM");
      tt->enum_def.fields[2].val = CHANGE_IN_SWEEP_NUM;
      tt->enum_def.fields[3].name = tdrpStrDup("CHANGE_IN_SWEEP_MODE");
      tt->enum_def.fields[3].val = CHANGE_IN_SWEEP_MODE;
      tt->enum_def.fields[4].name = tdrpStrDup("EVERY_360_DEG");
      tt->enum_def.fields[4].val = EVERY_360_DEG;
      tt->enum_def.fields[5].name = tdrpStrDup("LAST_SWEEP_IN_VOL");
      tt->enum_def.fields[5].val = LAST_SWEEP_IN_VOL;
      tt->enum_def.fields[6].name = tdrpStrDup("AUTOMATIC");
      tt->enum_def.fields[6].val = AUTOMATIC;
      tt->enum_def.fields[7].name = tdrpStrDup("ELAPSED_TIME");
      tt->enum_def.fields[7].val = ELAPSED_TIME;
    tt->single_val.e = END_OF_VOL_FLAG;
    tt++;
    
    // Parameter 'last_sweep_in_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("last_sweep_in_vol");
    tt->descr = tdrpStrDup("The sweep number used to end the volume.");
    tt->help = tdrpStrDup("Only applies if 'end_of_vol_decision' is set to LAST_SWEEP_IN_VOL.");
    tt->val_offset = (char *) &last_sweep_in_vol - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'az_for_end_of_vol_360'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("az_for_end_of_vol_360");
    tt->descr = tdrpStrDup("Azimuth at which the volume changes.");
    tt->help = tdrpStrDup("An end-of-vol is triggered every time the antenna moves across this azimuth.");
    tt->val_offset = (char *) &az_for_end_of_vol_360 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'write_end_of_vol_when_data_stops'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_end_of_vol_when_data_stops");
    tt->descr = tdrpStrDup("Write end of vol event when data stops.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &write_end_of_vol_when_data_stops - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nsecs_no_data_for_end_of_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nsecs_no_data_for_end_of_vol");
    tt->descr = tdrpStrDup("Number of secs before writing end of vol.");
    tt->help = tdrpStrDup("See 'write_end_of_vol_when_data_stops'");
    tt->val_offset = (char *) &nsecs_no_data_for_end_of_vol - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'nsecs_per_volume'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nsecs_per_volume");
    tt->descr = tdrpStrDup("Number of secs in a volume.");
    tt->help = tdrpStrDup("Applies to ELAPSED_TIME mode - see 'end_of_volume_decision'");
    tt->val_offset = (char *) &nsecs_per_volume - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'min_rays_per_ppi_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_rays_per_ppi_vol");
    tt->descr = tdrpStrDup("Min number of non-transition rays per PPI volume.");
    tt->help = tdrpStrDup("Used to prevent end-of-volume conditions being determined during antenna transition to the start of the next volume.");
    tt->val_offset = (char *) &min_rays_per_ppi_vol - &_start_;
    tt->single_val.i = 180;
    tt++;
    
    // Parameter 'min_rays_per_rhi_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_rays_per_rhi_vol");
    tt->descr = tdrpStrDup("Min number of non-transition rays per RHI volume.");
    tt->help = tdrpStrDup("Used to prevent end-of-volume conditions being determined during antenna transition to the start of the next volume.");
    tt->val_offset = (char *) &min_rays_per_rhi_vol - &_start_;
    tt->single_val.i = 30;
    tt++;
    
    // Parameter 'max_rays_in_vol'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_rays_in_vol");
    tt->descr = tdrpStrDup("The maximum number of rays in a volume.");
    tt->help = tdrpStrDup("This prevents memory from filling up if no end-of-volume is found.");
    tt->val_offset = (char *) &max_rays_in_vol - &_start_;
    tt->single_val.i = 20000;
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("AUTOMATIC END-OF-VOLUME DETECTION");
    tt->comment_text = tdrpStrDup("These parameters are used if end_of_volume_decision is set to AUTOMATIC. This assumes a simple bottom-up or top-down scan strategy. No attempt will be made to search for RHIs, or other complicattions in the SCAN strategy.");
    tt++;
    
    // Parameter 'set_end_of_vol_from_elev_change'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_end_of_vol_from_elev_change");
    tt->descr = tdrpStrDup("Option to set the end of vol flag based on change in elevation angle.");
    tt->help = tdrpStrDup("If true, the program will look for changes in elevation angle to compute the end of volume. Only this test, and the test for prf change, will be used to identify the end of volume condition.");
    tt->val_offset = (char *) &set_end_of_vol_from_elev_change - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'vol_starts_at_bottom'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vol_starts_at_bottom");
    tt->descr = tdrpStrDup("Flag to indicate that elevation angles increase in the volume.");
    tt->help = tdrpStrDup("If the volume starts at the top, i.e. elevations decrease during the volume, set this to FALSE.");
    tt->val_offset = (char *) &vol_starts_at_bottom - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'elev_change_for_end_of_vol'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elev_change_for_end_of_vol");
    tt->descr = tdrpStrDup("Change in elevation which triggers and end of volume.");
    tt->help = tdrpStrDup("If the elevation angle changes by this amount, and end of volume flag will be set.");
    tt->val_offset = (char *) &elev_change_for_end_of_vol - &_start_;
    tt->has_min = TRUE;
    tt->min_val.d = 0.1;
    tt->single_val.d = 1.5;
    tt++;
    
    // Parameter 'nrays_history'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("nrays_history");
    tt->descr = tdrpStrDup("Number of rays in history list.");
    tt->help = tdrpStrDup("This is the number of rays stored in the history list. The list is used for determining the status of the antenna. The antenna algorithm checks o see if either the elevation angle is stable (PPI mode) or the azimuth angle is stable (RHI mode). The el_accuracy and az_accuracy parameters are used to detect whether el or az are stable.");
    tt->val_offset = (char *) &nrays_history - &_start_;
    tt->single_val.i = 16;
    tt++;
    
    // Parameter 'el_accuracy'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("el_accuracy");
    tt->descr = tdrpStrDup("Accuracy of antenna controller in elevation (deg).");
    tt->help = tdrpStrDup("Used to determine if antenna is stationary in elevation, i.e. is it in PPI mode? If the cumulative elevation change during the history period is less than this value, the antenna is assumed to be in PPI mode.");
    tt->val_offset = (char *) &el_accuracy - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'az_accuracy'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("az_accuracy");
    tt->descr = tdrpStrDup("Accuracy of antenna controller in azimuth (deg).");
    tt->help = tdrpStrDup("Used to determine if antenna is stationary in azimuth, i.e. is it in RHI mode? If the cumulative azimuth change during the history period is less than this value, the antenna is assumed to be in RHI mode.");
    tt->val_offset = (char *) &az_accuracy - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'min_az_change_ppi'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_az_change_ppi");
    tt->descr = tdrpStrDup("Min azimuth change for PPI (deg).");
    tt->help = tdrpStrDup("For a valid PPI, the azimuth must change by at least this amount during nrays_history, while the elevation is not changing.");
    tt->val_offset = (char *) &min_az_change_ppi - &_start_;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'min_el_change_rhi'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_el_change_rhi");
    tt->descr = tdrpStrDup("Min elevation change for RHI (deg).");
    tt->help = tdrpStrDup("For a valid RHI, the elevation must change by at least this amount during nrays_history, while the azimuth is not changing.");
    tt->val_offset = (char *) &min_el_change_rhi - &_start_;
    tt->single_val.d = 4;
    tt++;
    
    // Parameter 'max_az_change_per_sweep'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_az_change_per_sweep");
    tt->descr = tdrpStrDup("Maximum azimuth change per sweep (deg).");
    tt->help = tdrpStrDup("If the sweep elevation has not changed by the time the azimuth has changed by this number of degrees, an end-of-volume condition is triggered. This is used to handle the single-elevation surveillance case in which the antenna scans in PPI at a single elevation angle.");
    tt->val_offset = (char *) &max_az_change_per_sweep - &_start_;
    tt->single_val.i = 540;
    tt++;
    
    // Parameter 'debug_auto_detection'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug_auto_detection");
    tt->descr = tdrpStrDup("Flag for debugging auto end-of-vol detection.");
    tt->help = tdrpStrDup("If set, messages will be printed to stderr on how the auto-detection algorithm is making decisions.");
    tt->val_offset = (char *) &debug_auto_detection - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 20'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 20");
    tt->comment_hdr = tdrpStrDup("OUTPUT FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_output_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("Array of output fields.");
    tt->help = tdrpStrDup("The program will only output these fields. The dsr_name is the field name in the dsr data. If the output_name is an empty string, the output name will be set to the dsr_name. If output_name is non-empty, this will be used. Likewise for the units. long_name and standard_name are netCDF conventions. Set the output encoding type to select the resolution of the output data.");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(output_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("output_field_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("dsr_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_fields->dsr_name - (char *) _output_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("output_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_fields->output_name - (char *) _output_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("long_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_output_fields->long_name - (char *) _output_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("standard_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_output_fields->standard_name - (char *) _output_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("output_units");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_output_fields->output_units - (char *) _output_fields;
      tt->struct_def.fields[5].ftype = tdrpStrDup("output_encoding_t");
      tt->struct_def.fields[5].fname = tdrpStrDup("output_encoding");
      tt->struct_def.fields[5].ptype = ENUM_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_output_fields->output_encoding - (char *) _output_fields;
        tt->struct_def.fields[5].enum_def.name = tdrpStrDup("output_encoding_t");
        tt->struct_def.fields[5].enum_def.nfields = 3;
        tt->struct_def.fields[5].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[5].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[5].enum_def.fields[0].name = tdrpStrDup("OUTPUT_FLOAT");
        tt->struct_def.fields[5].enum_def.fields[0].val = OUTPUT_FLOAT;
        tt->struct_def.fields[5].enum_def.fields[1].name = tdrpStrDup("OUTPUT_SHORT");
        tt->struct_def.fields[5].enum_def.fields[1].val = OUTPUT_SHORT;
        tt->struct_def.fields[5].enum_def.fields[2].name = tdrpStrDup("OUTPUT_BYTE");
        tt->struct_def.fields[5].enum_def.fields[2].val = OUTPUT_BYTE;
    tt->n_struct_vals = 12;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].s = tdrpStrDup("DBZ");
      tt->struct_vals[2].s = tdrpStrDup("");
      tt->struct_vals[3].s = tdrpStrDup("");
      tt->struct_vals[4].s = tdrpStrDup("dBZ");
      tt->struct_vals[5].e = OUTPUT_SHORT;
      tt->struct_vals[6].s = tdrpStrDup("VEL");
      tt->struct_vals[7].s = tdrpStrDup("VEL");
      tt->struct_vals[8].s = tdrpStrDup("");
      tt->struct_vals[9].s = tdrpStrDup("");
      tt->struct_vals[10].s = tdrpStrDup("m/s");
      tt->struct_vals[11].e = OUTPUT_SHORT;
    tt++;
    
    // Parameter 'Comment 21'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 21");
    tt->comment_hdr = tdrpStrDup("OUTPUT DATA SETS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_data_set'
    // ctype is '_output_data_set_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_data_set");
    tt->descr = tdrpStrDup("Detais for output data sets.");
    tt->help = tdrpStrDup("Multiple formats may be output from a single instance of this application.\n\n\t output_dir: top level directory for data set.\n\t format: output file format.\n\t name_from_end_time: flag to indicate whether to compute the name from the start or end time of the volume. For DORADE files, the start time is always used, since this is the convention for DORADE.");
    tt->array_offset = (char *) &_output_data_set - &_start_;
    tt->array_n_offset = (char *) &output_data_set_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(output_data_set_t);
    tt->array_n = 3;
    tt->struct_def.name = tdrpStrDup("output_data_set_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("output_dir");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_data_set->output_dir - (char *) _output_data_set;
      tt->struct_def.fields[1].ftype = tdrpStrDup("output_format_t");
      tt->struct_def.fields[1].fname = tdrpStrDup("format");
      tt->struct_def.fields[1].ptype = ENUM_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_data_set->format - (char *) _output_data_set;
        tt->struct_def.fields[1].enum_def.name = tdrpStrDup("output_format_t");
        tt->struct_def.fields[1].enum_def.nfields = 4;
        tt->struct_def.fields[1].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[1].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[1].enum_def.fields[0].name = tdrpStrDup("OUTPUT_FORMAT_CFRADIAL");
        tt->struct_def.fields[1].enum_def.fields[0].val = OUTPUT_FORMAT_CFRADIAL;
        tt->struct_def.fields[1].enum_def.fields[1].name = tdrpStrDup("OUTPUT_FORMAT_FORAY");
        tt->struct_def.fields[1].enum_def.fields[1].val = OUTPUT_FORMAT_FORAY;
        tt->struct_def.fields[1].enum_def.fields[2].name = tdrpStrDup("OUTPUT_FORMAT_DORADE");
        tt->struct_def.fields[1].enum_def.fields[2].val = OUTPUT_FORMAT_DORADE;
        tt->struct_def.fields[1].enum_def.fields[3].name = tdrpStrDup("OUTPUT_FORMAT_UF");
        tt->struct_def.fields[1].enum_def.fields[3].val = OUTPUT_FORMAT_UF;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("/tmp/data/cfradial");
      tt->struct_vals[1].e = OUTPUT_FORMAT_CFRADIAL;
      tt->struct_vals[2].s = tdrpStrDup("/tmp/data/dorade");
      tt->struct_vals[3].e = OUTPUT_FORMAT_DORADE;
      tt->struct_vals[4].s = tdrpStrDup("/tmp/data/uf");
      tt->struct_vals[5].e = OUTPUT_FORMAT_UF;
    tt++;
    
    // Parameter 'output_filename_mode'
    // ctype is '_filename_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_filename_mode");
    tt->descr = tdrpStrDup("Mode for computing output file name.");
    tt->help = tdrpStrDup("START_AND_END_TIMES: include both start and end times in file name. START_TIME_ONLY: include only start time in file name. END_TIME_ONLY: include only end time in file name.");
    tt->val_offset = (char *) &output_filename_mode - &_start_;
    tt->enum_def.name = tdrpStrDup("filename_mode_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("START_AND_END_TIMES");
      tt->enum_def.fields[0].val = START_AND_END_TIMES;
      tt->enum_def.fields[1].name = tdrpStrDup("START_TIME_ONLY");
      tt->enum_def.fields[1].val = START_TIME_ONLY;
      tt->enum_def.fields[2].name = tdrpStrDup("END_TIME_ONLY");
      tt->enum_def.fields[2].val = END_TIME_ONLY;
    tt->single_val.e = START_AND_END_TIMES;
    tt++;
    
    // Parameter 'Comment 22'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 22");
    tt->comment_hdr = tdrpStrDup("APPENDING YEAR AND/OR DAY DIRS TO OUTPUT DIR");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'append_day_dir_to_output_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("append_day_dir_to_output_dir");
    tt->descr = tdrpStrDup("Add the day directory to the output directory.");
    tt->help = tdrpStrDup("Path will be dir/yyyymmdd/filename.");
    tt->val_offset = (char *) &append_day_dir_to_output_dir - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'append_year_dir_to_output_dir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("append_year_dir_to_output_dir");
    tt->descr = tdrpStrDup("Add the year directory to the output directory.");
    tt->help = tdrpStrDup("Path will be dir/yyyy/yyyymmdd/filename.");
    tt->val_offset = (char *) &append_year_dir_to_output_dir - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 23'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 23");
    tt->comment_hdr = tdrpStrDup("SEPARATING VOLUMES BY TYPE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'separate_output_dirs_by_scan_type'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("separate_output_dirs_by_scan_type");
    tt->descr = tdrpStrDup("Option to separate the files based on scan type.");
    tt->help = tdrpStrDup("Sometimes a scan strategy will switch between surveillance scans, sector scans, rhi scans, vertically-pointing scans and sun scans. If true, the files will be separated into subdirectories based on scan type.");
    tt->val_offset = (char *) &separate_output_dirs_by_scan_type - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_surveillance_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_surveillance_files");
    tt->descr = tdrpStrDup("Option to write out files for surveillance mode.");
    tt->help = tdrpStrDup("Only applies if 'separate_output_dirs_by_scan_type' is true.");
    tt->val_offset = (char *) &write_surveillance_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'surveillance_subdir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("surveillance_subdir");
    tt->descr = tdrpStrDup("The directory path for surveillance scan files.");
    tt->help = tdrpStrDup("See 'separate_output_dirs_by_scan_type'. If the scan mode is surveillance, this subdirectory will be created under the ouput dir.");
    tt->val_offset = (char *) &surveillance_subdir - &_start_;
    tt->single_val.s = tdrpStrDup("sur");
    tt++;
    
    // Parameter 'write_sector_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_sector_files");
    tt->descr = tdrpStrDup("Option to write out files for sector mode.");
    tt->help = tdrpStrDup("Only applies if 'separate_output_dirs_by_scan_type' is true.");
    tt->val_offset = (char *) &write_sector_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'sector_subdir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("sector_subdir");
    tt->descr = tdrpStrDup("The directory path for sector scan files.");
    tt->help = tdrpStrDup("See 'separate_output_dirs_by_scan_type'. If the scan mode is sector, this subdirectory will be created under the ouput dir.");
    tt->val_offset = (char *) &sector_subdir - &_start_;
    tt->single_val.s = tdrpStrDup("sec");
    tt++;
    
    // Parameter 'write_rhi_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_rhi_files");
    tt->descr = tdrpStrDup("Option to write out files for rhi mode.");
    tt->help = tdrpStrDup("Only applies if 'separate_output_dirs_by_scan_type' is true.");
    tt->val_offset = (char *) &write_rhi_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'rhi_subdir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("rhi_subdir");
    tt->descr = tdrpStrDup("The directory path for rhi files.");
    tt->help = tdrpStrDup("See 'separate_output_dirs_by_scan_type'. If the scan mode is rhi, this subdirectory will be created under the ouput dir.");
    tt->val_offset = (char *) &rhi_subdir - &_start_;
    tt->single_val.s = tdrpStrDup("rhi");
    tt++;
    
    // Parameter 'write_vert_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_vert_files");
    tt->descr = tdrpStrDup("Option to write out files for vertical pointing mode.");
    tt->help = tdrpStrDup("Only applies if 'separate_output_dirs_by_scan_type' is true.");
    tt->val_offset = (char *) &write_vert_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'vert_subdir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("vert_subdir");
    tt->descr = tdrpStrDup("The directory path for vert scan files.");
    tt->help = tdrpStrDup("See 'separate_output_dirs_by_scan_type'. If the scan mode is vert, this subdirectory will be created under the ouput dir.");
    tt->val_offset = (char *) &vert_subdir - &_start_;
    tt->single_val.s = tdrpStrDup("vert");
    tt++;
    
    // Parameter 'min_elevation_for_vert_files'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_elevation_for_vert_files");
    tt->descr = tdrpStrDup("The min elevation angle for vertically-pointing operations (deg).");
    tt->help = tdrpStrDup("This is the elevation threshold for vertically-pointing operations. If the specified fraction of the data has an elevation angle in excess of this angle, the volume will be considered to be from vertically-pointing operations.");
    tt->val_offset = (char *) &min_elevation_for_vert_files - &_start_;
    tt->single_val.d = 85;
    tt++;
    
    // Parameter 'min_vert_fraction_for_vert_files'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("min_vert_fraction_for_vert_files");
    tt->descr = tdrpStrDup("The min fraction of data with elevations in excess of the min elevation.");
    tt->help = tdrpStrDup("If the fraction of the data with elevation angles above the specified min_elevation exceeds this fraction,  the volume will be considered to be from vertically-pointing operations.");
    tt->val_offset = (char *) &min_vert_fraction_for_vert_files - &_start_;
    tt->single_val.d = 0.9;
    tt++;
    
    // Parameter 'write_sun_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_sun_files");
    tt->descr = tdrpStrDup("Option to write out files for sun scan mode.");
    tt->help = tdrpStrDup("Only applies if 'separate_output_dirs_by_scan_type' is true.");
    tt->val_offset = (char *) &write_sun_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'sun_subdir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("sun_subdir");
    tt->descr = tdrpStrDup("The directory path for sun scan files.");
    tt->help = tdrpStrDup("See 'separate_output_dirs_by_scan_type'. If the scan mode is sun, this subdirectory will be created under the ouput dir.");
    tt->val_offset = (char *) &sun_subdir - &_start_;
    tt->single_val.s = tdrpStrDup("sun");
    tt++;
    
    // Parameter 'solar_scan_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("solar_scan_name");
    tt->descr = tdrpStrDup("Optionally specify the scan name for the solar scan.");
    tt->help = tdrpStrDup("If the scan name from the antenna controller matches this string, it will be assumed that this is a solar scan.");
    tt->val_offset = (char *) &solar_scan_name - &_start_;
    tt->single_val.s = tdrpStrDup("Solar");
    tt++;
    
    // Parameter 'Comment 24'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 24");
    tt->comment_hdr = tdrpStrDup("OUTPUT FILE NAME OPTIONS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_filename_prefix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_filename_prefix");
    tt->descr = tdrpStrDup("Optional prefix for output filename.");
    tt->help = tdrpStrDup("If empty, the standard prefix will be used.");
    tt->val_offset = (char *) &output_filename_prefix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'include_instrument_name_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_instrument_name_in_file_name");
    tt->descr = tdrpStrDup("Option to include the instrument name in the file name.");
    tt->help = tdrpStrDup("Default is true. Only applies to CfRadial files. If true, the instrument name will be included just before the volume number in the output file name.");
    tt->val_offset = (char *) &include_instrument_name_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'include_site_name_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_site_name_in_file_name");
    tt->descr = tdrpStrDup("Option to include the site name in the file name.");
    tt->help = tdrpStrDup("Only applies to CfRadial files. If true, the site name will be included just before the volume number in the output file name.");
    tt->val_offset = (char *) &include_site_name_in_file_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'include_subsecs_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_subsecs_in_file_name");
    tt->descr = tdrpStrDup("Option to include sub-seconds in date-time part of file name.");
    tt->help = tdrpStrDup("Default is true. Only applies to CfRadial files. If true, the millisecs of the start and end time will be included in the file name.");
    tt->val_offset = (char *) &include_subsecs_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'include_scan_type_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_scan_type_in_file_name");
    tt->descr = tdrpStrDup("Option to include the scan type in the file name.");
    tt->help = tdrpStrDup("Default is true. Only applies to CfRadial files. If true, the scan type (SUR, SEC, RHI, VER etc) will be included in the file name.");
    tt->val_offset = (char *) &include_scan_type_in_file_name - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'include_scan_name_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_scan_name_in_file_name");
    tt->descr = tdrpStrDup("Option to include the scan name in the file name.");
    tt->help = tdrpStrDup("Default is false. Only applies to CfRadial files. If true, the scan name will be included in the file name.");
    tt->val_offset = (char *) &include_scan_name_in_file_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'include_vol_num_in_file_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("include_vol_num_in_file_name");
    tt->descr = tdrpStrDup("Option to include the volume number in the file name.");
    tt->help = tdrpStrDup("Default is false. Only applies to CfRadial files. If true, the volume number is included in the file name, preceded by '_v'.");
    tt->val_offset = (char *) &include_vol_num_in_file_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_hyphen_in_file_name_datetime_part'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_hyphen_in_file_name_datetime_part");
    tt->descr = tdrpStrDup("Option to use a hyphen between date and time in filename.");
    tt->help = tdrpStrDup("Default is false. Only applies to CfRadial files. Normally an underscore is used.");
    tt->val_offset = (char *) &use_hyphen_in_file_name_datetime_part - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 25'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 25");
    tt->comment_hdr = tdrpStrDup("REGISTERING LATEST DATA INFO");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_master_ldata_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_master_ldata_info");
    tt->descr = tdrpStrDup("Option to write a master latest_data_info for separated scan types.");
    tt->help = tdrpStrDup("If the files for different scan types (surveillance, sector, rhi, vert etc.) are written to separate subdirectories, you have the option of registering the latest_data_info to the master location - i.e. the output directory. This allows the system monitor to stay current, no matter which scan type is active.");
    tt->val_offset = (char *) &write_master_ldata_info - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'write_individual_ldata_info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_individual_ldata_info");
    tt->descr = tdrpStrDup("Option to write latest_data_info for each data set.");
    tt->help = tdrpStrDup("Writes a latest_data_info file for each data set written, including the separate directories for surveillance, sector, rhi etc. as appropriate. If write_master_ldata_info is true, you may consider turning this off.");
    tt->val_offset = (char *) &write_individual_ldata_info - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'register_with_data_mapper'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("register_with_data_mapper");
    tt->descr = tdrpStrDup("Option to register the latest_data_info with the data mapper.");
    tt->help = tdrpStrDup("If true, contacts the DataMapper using TCP, to update the latest time for this data set.");
    tt->val_offset = (char *) &register_with_data_mapper - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 26'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 26");
    tt->comment_hdr = tdrpStrDup("NETCDF STYLE");
    tt->comment_text = tdrpStrDup("Only applies to CfRadial format files.");
    tt++;
    
    // Parameter 'netcdf_style'
    // ctype is '_netcdf_style_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("netcdf_style");
    tt->descr = tdrpStrDup("NetCDF style - if output_format is CFRADIAL");
    tt->help = tdrpStrDup("netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls");
    tt->val_offset = (char *) &netcdf_style - &_start_;
    tt->enum_def.name = tdrpStrDup("netcdf_style_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("CLASSIC");
      tt->enum_def.fields[0].val = CLASSIC;
      tt->enum_def.fields[1].name = tdrpStrDup("OFFSET_64BIT");
      tt->enum_def.fields[1].val = OFFSET_64BIT;
      tt->enum_def.fields[2].name = tdrpStrDup("NETCDF4_CLASSIC");
      tt->enum_def.fields[2].val = NETCDF4_CLASSIC;
      tt->enum_def.fields[3].name = tdrpStrDup("NETCDF4");
      tt->enum_def.fields[3].val = NETCDF4;
    tt->single_val.e = NETCDF4;
    tt++;
    
    // Parameter 'Comment 27'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 27");
    tt->comment_hdr = tdrpStrDup("OUTPUT BYTE-SWAPPING and COMPRESSION");
    tt->comment_text = tdrpStrDup("These parameters are applied as appropriate. Not all file formats require or support them.");
    tt++;
    
    // Parameter 'output_native_byte_order'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_native_byte_order");
    tt->descr = tdrpStrDup("Option to leave data in native byte order, if appropriate.");
    tt->help = tdrpStrDup("If false, data will be byte-swapped on output. Only applies to UF and Dorade file formats.");
    tt->val_offset = (char *) &output_native_byte_order - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_compressed'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_compressed");
    tt->descr = tdrpStrDup("Option to compress data fields on output.");
    tt->help = tdrpStrDup("Applies to CfRadial netCDF and Dorade.");
    tt->val_offset = (char *) &output_compressed - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'output_compression_level'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_compression_level");
    tt->descr = tdrpStrDup("Level of compression for output data.");
    tt->help = tdrpStrDup("Valid range is 1 through 9. 1 gives lowest compression, 9 highest. Only applies to CfRadial netCDF file format.");
    tt->val_offset = (char *) &output_compression_level - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 1;
    tt->max_val.i = 9;
    tt->single_val.i = 4;
    tt++;
    
    // Parameter 'Comment 28'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 28");
    tt->comment_hdr = tdrpStrDup("OUTPUT DATA SET INFORMATION");
    tt->comment_text = tdrpStrDup("Will be stored in CfRadial files, and other formats to the extent supported by the format.");
    tt++;
    
    // Parameter 'ncf_title'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_title");
    tt->descr = tdrpStrDup("Title string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_title - &_start_;
    tt->single_val.s = tdrpStrDup("SPOL radar data");
    tt++;
    
    // Parameter 'ncf_institution'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_institution");
    tt->descr = tdrpStrDup("Institution string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_institution - &_start_;
    tt->single_val.s = tdrpStrDup("EOL/NCAR");
    tt++;
    
    // Parameter 'ncf_references'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_references");
    tt->descr = tdrpStrDup("References string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_references - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_source'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_source");
    tt->descr = tdrpStrDup("Source string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_source - &_start_;
    tt->single_val.s = tdrpStrDup("SPOL radar");
    tt++;
    
    // Parameter 'ncf_history'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_history");
    tt->descr = tdrpStrDup("History string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_history - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_comment'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_comment");
    tt->descr = tdrpStrDup("Comment string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_comment - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 29'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 29");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE MISSING VALUES");
    tt->comment_text = tdrpStrDup("Missing values are applicable to both metadata and field data. The default values should be satisfactory for most purposes. However, you can choose to override these if you are careful with the selected values.\n\nThe default values for metadata are:\n\tmissingMetaDouble = -9999.0\n\tmissingMetaFloat = -9999.0\n\tmissingMetaInt = -9999\n\tmissingMetaChar = -128\n\nThe default values for field data are:\n\tmissingFl64 = -9.0e33\n\tmissingFl32 = -9.0e33\n\tmissingSi32 = -2147483647\n\tmissingSi16 = -32768\n\tmissingSi08 = -128\n\n");
    tt++;
    
    // Parameter 'override_missing_metadata_values'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_missing_metadata_values");
    tt->descr = tdrpStrDup("Option to override the missing values for meta-data");
    tt->help = tdrpStrDup("See following parameter options.");
    tt->val_offset = (char *) &override_missing_metadata_values - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'missing_metadata_double'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("missing_metadata_double");
    tt->descr = tdrpStrDup("Missing value for metadata of type double.");
    tt->help = tdrpStrDup("Only applies if override_missing_metadata_values is TRUE");
    tt->val_offset = (char *) &missing_metadata_double - &_start_;
    tt->single_val.d = -9999;
    tt++;
    
    // Parameter 'missing_metadata_float'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("missing_metadata_float");
    tt->descr = tdrpStrDup("Missing value for metadata of type float.");
    tt->help = tdrpStrDup("Only applies if override_missing_metadata_values is TRUE");
    tt->val_offset = (char *) &missing_metadata_float - &_start_;
    tt->single_val.f = -9999;
    tt++;
    
    // Parameter 'missing_metadata_int'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("missing_metadata_int");
    tt->descr = tdrpStrDup("Missing value for metadata of type int.");
    tt->help = tdrpStrDup("Only applies if override_missing_metadata_values is TRUE");
    tt->val_offset = (char *) &missing_metadata_int - &_start_;
    tt->single_val.i = -9999;
    tt++;
    
    // Parameter 'missing_metadata_char'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("missing_metadata_char");
    tt->descr = tdrpStrDup("Missing value for metadata of type char.");
    tt->help = tdrpStrDup("Only applies if override_missing_metadata_values is TRUE");
    tt->val_offset = (char *) &missing_metadata_char - &_start_;
    tt->single_val.i = -128;
    tt++;
    
    // Parameter 'override_missing_field_values'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_missing_field_values");
    tt->descr = tdrpStrDup("Option to override the missing values for field data");
    tt->help = tdrpStrDup("See following parameter options.");
    tt->val_offset = (char *) &override_missing_field_values - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'missing_field_fl64'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("missing_field_fl64");
    tt->descr = tdrpStrDup("Missing value for field data of type 64-bit float.");
    tt->help = tdrpStrDup("Only applies if override_missing_field_values is TRUE");
    tt->val_offset = (char *) &missing_field_fl64 - &_start_;
    tt->single_val.d = -9e+33;
    tt++;
    
    // Parameter 'missing_field_fl32'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("missing_field_fl32");
    tt->descr = tdrpStrDup("Missing value for field data of type 32-bit float.");
    tt->help = tdrpStrDup("Only applies if override_missing_field_values is TRUE");
    tt->val_offset = (char *) &missing_field_fl32 - &_start_;
    tt->single_val.d = -9e+33;
    tt++;
    
    // Parameter 'missing_field_si32'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("missing_field_si32");
    tt->descr = tdrpStrDup("Missing value for field data of type 32-bit integer.");
    tt->help = tdrpStrDup("Only applies if override_missing_field_values is TRUE");
    tt->val_offset = (char *) &missing_field_si32 - &_start_;
    tt->single_val.i = -2147483647;
    tt++;
    
    // Parameter 'missing_field_si16'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("missing_field_si16");
    tt->descr = tdrpStrDup("Missing value for field data of type 16-bit integer.");
    tt->help = tdrpStrDup("Only applies if override_missing_field_values is TRUE");
    tt->val_offset = (char *) &missing_field_si16 - &_start_;
    tt->single_val.i = -232768;
    tt++;
    
    // Parameter 'missing_field_si08'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("missing_field_si08");
    tt->descr = tdrpStrDup("Missing value for field data of type 8-bit integer.");
    tt->help = tdrpStrDup("Only applies if override_missing_field_values is TRUE");
    tt->val_offset = (char *) &missing_field_si08 - &_start_;
    tt->single_val.i = -128;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
