/*********************************************************
 * parameter definitions for Radx2Grid
 *
 * Mike Dixon, EOL, NCAR, Boulder, CO, USA, 80307-3000
 *
 * May 2012
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "Radx2Grid reads data from Radx-supported format files in native radial coordinates and interpolates the data onto a regular Cartesian grid.";
  p_text = "The output is written to Cartesian files in CF-compliant NetCDF format. CEDRIC, ZEBRA and MDV output files may also be written.";
}

commentdef {
  p_header = "OVERVIEW";
  p_text = "Radx2Grid is a large application with many parameters available for controlling its operation.\n\nThis makes the use of the parameter file confusing to a new user.\n\nTherefore, the parameters are separated into sections.\n\nThe more common sections are at the top of the file, and the less common parameters lower down in the file.\n\nEach section is preceded by a header starting and ending with a line of ======================== characters.\n\nIn fact this text is itself in one of those headers."; 
}

commentdef {
  p_header = "DEBUGGING";
}

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

commentdef {
  p_header = "DATA INPUT DIRECTORY and INPUT MODE";
}

paramdef string {
  p_default = ".";
  p_descr = "Input directory for searching for files.";
  p_help = "Files will be searched for in this directory. This is ignored if the list of files is  specified on the command line using the -f option.";
} input_dir;

typedef enum {
  FILELIST, ARCHIVE, REALTIME
} mode_t;

paramdef enum mode_t {
  p_default = FILELIST;
  p_descr = "Operating mode";
  p_help = "In FILELIST mode, we move through the list of file names specified on the command line.\n\nIn REALTIME mode, the program waits for a new input file to arrive in 'input_dir'.\n\nIn ARCHIVE mode, we move through the files in input_dir between the start and end times set on the command line.\n\nIn ARCHIVE mode, input_dir must be one above the day-directory.";
} mode;

paramdef int {
  p_default = 300;
  p_descr = "Maximum age of realtime data (secs)";
  p_help =  "REALTIME mode only. Only data files less old than this will be processed.";
} max_realtime_data_age_secs;

paramdef string {
  p_default = "2015 06 26 00 00 00";
  p_descr = "Set the start time for ARCHIVE mode analysis.";
  p_help = "Format is 'yyyy mm dd hh mm ss'.";
} start_time;

paramdef string {
  p_default = "2015 06 26 12 00 00";
  p_descr = "Set the end time for ARCHIVE mode analysis.";
  p_help = "Format is 'yyyy mm dd hh mm ss'.";
} end_time;

commentdef {
  p_header = "DATA OUTPUT DIRECTORY AND FILE NAMES";
}

paramdef string {
  p_default = ".";
  p_descr = "Output directory for writing files.";
  p_help = "Files will be written to this directory.";
} output_dir;

typedef enum {
  CF_NETCDF, ZEBRA_NETCDF, MDV, CEDRIC
} output_format_t;

paramdef enum output_format_t {
  p_default = CF_NETCDF;
  p_descr = "Set the output format";
  p_help = "CF_NETCDF: CF-compliant NetCDF. See http://cf-pcmdi.llnl.gov/documents/cf-conventions. ZEBRA_NETCDF: NetCDF format specifically for ZEBRA display. This forces a conversion to a LATLON projection. MDV: legacy MDV format.";
} output_format;

commentdef {
  p_header = "INTERPOLATION MODE";
}

typedef enum {
  INTERP_MODE_CART,
  INTERP_MODE_PPI,
  INTERP_MODE_POLAR,
  INTERP_MODE_CART_REORDER,
  INTERP_MODE_CART_SAT
} interp_mode_t;

paramdef enum interp_mode_t {
  p_default = INTERP_MODE_CART;
  p_descr = "Mode for interpolation";
  p_help =
  "\nINTERP_MODE_CART: interpolate onto a regular 3-D Cartesian grid. This is the most common option and is equivalent to the legacy SPRINT application.\n"
  "\nINTERP_MODE_PPI: interpolate onto a regular 2-D Cartesian grid in (x,y), preserving the original radar elevation angles for each sweep in the vertical. The result is a volume of Cartesian PPIs, with the (x,y) dimensions in km and the vertical dimension in degrees.\n"
  "\nINTERP_MODE_POLAR: interpolate onto a regular azimuth grid, preserving the elevation angles for each sweep. The azimuths are remapped onto a regular grid. The elevation angle attached to each vertical level is derived from the sweep information in the input file.\n"
  "\nINTERP_MODE_CART_REORDER: interpolate onto a regular 3-D Cartesian grid using the reorder strategy. This should only be used for MOVING platforms only. DO NOT USE this method for FIXED platform, use INTERP_MODE_CART instead.\n"
  "\nINTERP_MODE_SAT: interpolate satellite-based lidar or radar data onto a grid, with a specified swath width along the satellite track. The remapped data can then be visualized using a Cartesian data display, such as Jazz.";
} interp_mode;

commentdef {
  p_header = "INTERPOLATION OPTIONS";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to use nearest neighbor method instead of 3D linear interpolation.";
  p_help = "If true, use the values from the nearest point instead of interpolating between the measured points that surround the grid point.";
} use_nearest_neighbor;

paramdef int {	
  p_default = 3;
  p_min = 1;
  p_max = 8;
  p_descr = "Minimum number of valid data points for theinterpolation.";
  p_help = "The program performs an 8-point linear interpolation. This is the number of valid data points, out of the possible 8, which must be present for interpolation to proceed. A high number will exclude marginal points. A low number will include marginal points.";
} min_nvalid_for_interp;

paramdef boolean {
  p_default = false;
  p_descr = "Option to use the fixed sweep angle for determining position for interpolation.";
  p_help = "If false, we use the measured elevaiton and azimuth for each ray. If true, we use the fixed angle instead of the elevation angle in PPI scan mode and the fixed angle instead of azimuth in RHI mode.";
} use_fixed_angle_for_interpolation;

paramdef boolean {
  p_default = true;
  p_descr = "Option to use the fixed sweep angle for determining the angle limits of the data.";
  p_help = "If true, we use the scan strategy sweep fixed angle for determining the angular limits to the data. If false, we use the actual measured angles. We need to find the data limits so that we can extend the interpolation by a fraction of the beam width beyond the angular limits. See also 'beam_width_fraction_for_data_limit_extension'.";
} use_fixed_angle_for_data_limits;

paramdef double {
  p_default = 0.5;
  p_descr = "Fraction of the beam width used to extend the data beyond the observed limits.";
  p_help = "At the edges of the observed region, the interpolated data is extended by an angle computed as beam_width * fraction. For extending below the lowest tilt and above the upper tilt, the vertical beam width is used. For extended to the left or right of sector limits, the horizontal beam width is used.";
} beam_width_fraction_for_data_limit_extension;

commentdef {
  p_header = "CARTESIAN GRID VERTICAL LEVELS";
  p_text = 
    "\nSet the vertical levels for the Cartesian grid.\n"
    "\nThis applies to INTERP_MODE_CART, INTERP_MODE_SAT and INTERP_MODE_REORDER.\n"
    "\nFor INTERP_MODE_PPI and INTERP_MODE_POLAR, the vertical levels are governed by the elevation angle for each sweep in the input volume.\n"
    "\nYou can either specify a grid with constant vertial spacing, or you can provide an array of heights. The latter allows you to specify a grid with irregular vertical spacing.";
}

typedef struct {
  int nz;
  double minz;
  double dz;
} grid_z_geom_t;

paramdef struct grid_z_geom_t {
  p_default = {20, 0.5, 1.0};
  p_descr = "Specifying regular vertical grid levels.";
  p_help =
    "\tnz is the number of levels.\n"
    "\tdz is constant spacing of the Z levels, in km.\n"
    "\tminz is the lowest level, in km MSL.\n"
    "\nNOTE: Applies if specify_individual_z_levels is false. Does not apply to INTERP_MODE_PPI.";
} grid_z_geom;

paramdef boolean {
  p_default = false;
  p_descr = "Option to specify each Z level individually.";
  p_help = "If true, you will fill out the z_level array to specify each Z level. This allows you to set up a grid with unequal spacing in the vertical. If false, use grid_z_geom to specify Z levels at constant spacing.";
} specify_individual_z_levels;

paramdef double {
  p_default = { 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 };
  p_descr = "Array of grid levels, in km MSL.";
  p_help = "This applies if specify_individual_z_levels is true.";
} z_level_array[];

commentdef {
  p_header = "CARTESIAN GRID XY DETAILS";
  p_text = "Specify the grid details in (x,y). This will be a regular Cartesian grid. The units for the grid paramters are in (km,km) for all projections except for PROJ_LATLON. For the LATLON projection, the units are in (deg,deg).";
}

typedef struct {
  int nx;
  int ny;
  double minx;
  double miny;
  double dx;
  double dy;
} grid_xy_geom_t;

paramdef struct grid_xy_geom_t {
  p_default = {400, 400, -199.5, -199.5, 1.0, 1.0};
  p_descr = "Specify the grid parameters in x,y.";
  p_help =
    "\tnx: the number of grid points in the X dimension.\n"
    "\tny: the number of grid points in the Y dimension.\n"
    "\tminx: the X coordinate of the center of the SW grid cell.\n"
    "\tminy: the Y coordinate of the center of the SW grid cell.\n"
    "\tdx: the grid spacing in the X dimension.\n"
    "\tdy: the grid spacing in the Y dimension.\n"
    "\nUnits are in km, except for PROJ_LATLON, which has units in degrees.";
} grid_xy_geom;

paramdef boolean {
  p_default = true;
  p_descr = "Option to set the grid origin at the radar.";
  p_help = "If true, the latitude and longitude of the grid origin will be set to the radar location. If false, grid_origin_lat and grid_origin_lon will be used. This parameter is not applicable for moving platforms.";
} center_grid_on_radar;

commentdef {
  p_header = "CARTESIAN GRID PROJECTION";
}

typedef enum {
  PROJ_LATLON = 0,
  PROJ_LAMBERT_CONF = 3,
  PROJ_MERCATOR =  4,
  PROJ_POLAR_STEREO = 5,
  PROJ_FLAT = 8,
  PROJ_OBLIQUE_STEREO = 12,
  PROJ_TRANS_MERCATOR = 15,
  PROJ_ALBERS = 16,
  PROJ_LAMBERT_AZIM = 17,
  PROJ_VERT_PERSP = 18
} projection_t;

paramdef enum projection_t {
  p_default = PROJ_FLAT;
  p_descr = "Projection details for the Cartesian grid..";
  p_help =
  "\tPROJ_LATLON: regular lat/lon grid (Equidistant Cylindrical)\n"
  "\tPROJ_FLAT: Azimuthal Equidistant (Radar)\n"
  "\tPROJ_LAMBERT_CONF: Lambert Conformal Conic\n"
  "\tPROJ_LAMBERT_AZIM: Lambert Azimuthal Equal Area\n"
  "\tPROJ_MERCATOR: Mercator - EW orientation\n"
  "\tPROJ_TRANS_MERCATOR: Tranverse Mercator - NS orientation\n"
  "\tPROJ_POLAR_STEREO: Stereographic- polar aspect\n"
  "\tPROJ_OBLIQUE_STEREO: Stereographic - oblique aspect\n"
  "\tPROJ_ALBERS: Albers Equal Area Conic\n"
  "\tPROJ_VERT_PERSP: Vertical Perspective (satellite view)\n\n";
} grid_projection;

paramdef double {
  p_default = 0.0;
  p_descr = "Grid rotation.";
  p_help = "This applies only to PROJ_FLAT projection.";
} grid_rotation;

paramdef double {
  p_default = 0.0;
  p_descr = "Grid origin latitude.";
  p_help = "This applies to all projections except LATLON.\n\nIf 'center_grid_on_radar' is true, the radar location is used instead.";
} grid_origin_lat;

paramdef double {
  p_default = 0.0;
  p_descr = "Grid origin longitude.";
  p_help = "This applies to all projections except LATLON.\n\nIf 'center_grid_on_radar' is true, the radar location is used instead.";
} grid_origin_lon;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to first interpolate to a PROJ_FLAT projection, and then automatically remap to a latlon projection on output.";
  p_help = "If TRUE, before writing the file, the app will choose a latlon grid that matches the FLAT grid extent and rsolution, and automatically remap to a PROJ_LATLON projection.";
} auto_remap_flat_to_latlon;

paramdef double {
  p_default = 0.0;
  p_descr = "Grid reference latitude 1.";
  p_help = "This applies to LAMBERT_CONF and ALBERS projections.";
} grid_lat1;

paramdef double {
  p_default = 0.0;
  p_descr = "Grid reference latitude 2.";
  p_help = "This applies to LAMBERT_CONF and ALBERS projections.";
} grid_lat2;

paramdef double {
  p_default = 1.0;
  p_descr = "Central scale for projections.";
  p_help = "This applies to POLAR_STEREO, OBLIQUE_STEREO and TRANSVERSE_MERCATOR projections.";
} grid_central_scale;

paramdef double {
  p_default = 0.0;
  p_descr = "Tangent latitude (deg).";
  p_help = "This applies to OBLIQUE_STEREO only.";
} grid_tangent_lat;

paramdef double {
  p_default = 0.0;
  p_descr = "Tangent longitude (deg).";
  p_help = "This applies to OBLIQUE_STEREO and POLAR_STEREO.";
} grid_tangent_lon;

paramdef boolean {
  p_default = true;
  p_descr = "Flag indicating stereogtraphic is over the NORTH pole.";
  p_help = "This applies to POLAR_STEREO. If false, the projection is over the south pole.";
} grid_pole_is_north;

paramdef double {
  p_default = 35786;
  p_descr = "Radius of perspective point (km).";
  p_help = "This applies to VERT_PERSP.";
} grid_persp_radius;

paramdef double {
  p_default = 0.0;
  p_descr = "False northing correction.";
  p_help = "Occasionally, this is added to the Y coordinate so that all coordinates are positive. Normally 0. As an alternative to false_northing and false_easting, you can set the offset_latitude and offset_longitude";
} grid_false_northing;

paramdef double {
  p_default = 0.0;
  p_descr = "False easting correction.";
  p_help = "Occasionally, this is added to the X coordinate so that all coordinates are positive. Normally 0.";
} grid_false_easting;

paramdef boolean {
  p_default = false;
  p_descr = "Do you want to specify an offset origin using lat/lon instead of false_northing and false_easting?";
  p_help = "If true, set grid_offset_origin_latitude and grid_offset_origin_longitude.";
} grid_set_offset_origin;

paramdef double {
  p_default = 0;
  p_descr = "Latitude of offset origin.";
  p_help = "See grid_set_offset_origin.";
} grid_offset_origin_latitude;

paramdef double {
  p_default = 0;
  p_descr = "Longitude of offset origin.";
  p_help = "See grid_set_offset_origin.";
} grid_offset_origin_longitude;

commentdef {
  p_header = "SPECIFYING THE FIELDS FOR INTERPOLATION";
  p_text = "By default, all fields in the input files will be interpolated. If you want to select individual fields to be interpolated, specify them here.";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to select the fields for interpolation.";
  p_help = "If FALSE, all fields will be processed.";
} select_fields;

typedef struct {
  string input_name;
  boolean process_this_field;
} select_field_t;

paramdef struct select_field_t {
  p_default = { 
    { "DBZ", TRUE },
    { "VEL", TRUE },
    { "WIDTH", FALSE }
  };
  p_descr = "Select the list of fields to be processed.";
  p_help = "See 'select_fields'. You specify the list of field names to be processed. In addition you need to set 'process_this_field' to TRUE or FALSE. This is provided as a convenience, so that you can select or deselect fields without having to change the list.";
} selected_fields[];

commentdef {
  p_header = "TRANSFORMING FIELDS FOR INTERPOLATION";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to perform a transform on specified fields prior to interpolation.";
  p_help = "If TRUE, the field you specify in this section will be transformed prior to interpolation, and possibly back again afterwards.";
} transform_fields_for_interpolation;

typedef enum {
  TRANSFORM_DB_TO_LINEAR,
  TRANSFORM_DB_TO_LINEAR_AND_BACK,
  TRANSFORM_LINEAR_TO_DB,
  TRANSFORM_LINEAR_TO_DB_AND_BACK
} interp_transform_t;

typedef struct {
  string input_name;
  string output_name;
  string output_units;
  interp_transform_t transform;
} transform_field_t;

paramdef struct transform_field_t {
  p_default = {
    {
      input_name = "DBZ",
      output_name = "DBZ",
      output_units = "dBZ",
      transform = TRANSFORM_DB_TO_LINEAR_AND_BACK
    }
  };
  p_descr = "Transform fields for interpolation";
  p_help = "NOTE: this is done immediately after the fields are read from the file.\n\n'input_name' refers to the name of the field read in, before any renaming occurs. If 'output_name' is the same as 'input_name', the field is transformed in place. If 'output_name' differs from 'input_name', a copy of the field is made prior to interpolation, and this field copy is named 'output_name'.\n\nNOTE: the transform occurs first, before any rename operations (see next section). 'output_name' in transform_fields matches 'input_name' in 'rename_fields'.\n\nTRANSFORM_DB_TO_LINEAR: transform the field from dB to linear units, perform the interpolation, and write out the interpolated field in linear units.\n\nTRANSFORM_DB_TO_LINEAR_AND_BACK: transform the field from dB units to linear units, perform the interpolation, and then transform back to dB units before writing to the output file.\n\nTRANSFORM_LINEAR_TO_DB: transform the field from linear units to dB units, perform the interpolation, and write out the interpolated field in dB units.\n\nTRANSFORM_LINEAR_TO_DB_AND_BACK: transform the field from linear units to dB units, perform the interpolation, and then transform back to linear units before writing to the output file.";
} transform_fields[];

commentdef {
  p_header = "OPTION TO SET FOLDING LIMITS ON SELECTED FIELDS";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to set the folding limits for individual fields.";
  p_help = "The limits are set prior to interpolation.\n\nIf TRUE, fold limits will be set for the specified fields. You should do this for fields such as VELOCITY and PHIDP. Some CfRadial files already contain the fold limits as attributes on the field - for these fields you do not need to set fold limits, unless you wish to override what is in the file. You only need to specify the limits if the file does not already have these attributes. The field_folds parameter can be set to FALSE to override an attribute set in the data file.";
} set_fold_limits;

typedef struct {
  string input_name;
  boolean field_folds;
  boolean use_global_nyquist;
  double fold_limit_lower;
  double fold_limit_upper;
} fold_field_t;

paramdef struct fold_field_t {
  p_default = {
    {
      input_name = "VEL",
      field_folds = TRUE,
      use_global_nyquist = TRUE,
      fold_limit_lower = -25.0,
      fold_limit_upper = 25.0
    }
  };
  p_descr = "Use this to set the fold limits for a particular field.";
  p_help = "If this is specified, the interpolation for this field will be performed 'on the circle' so that folding is handled correctly. If use_global_nyquist is true, the fold limits are set to plus and minus the main nyquist velocity. If false, the fold limits specified here are used instead.\n\nNOTE: 'input_name' for this step refers to the 'input_name' in 'select_fields' and 'output_name' in 'transform_fields'. This step is performed prior to renaming fields (see below).";
} folded_fields[];

commentdef {
  p_header = "OPTION TO OVERRIDE THE NYQUIST VELOCITY";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override nyquist velocity in incoming data.";
  p_help = "If true, the nyquist_velocity parameter is used to specify the nyquist. If false, the nyquist is computed from the incoming radar data stream. The nyquist is used for velocity interpolation, to ensure that folded values are treated correctlty.";
} override_nyquist;

paramdef double {
  p_default = 25.0;
  p_descr = "Specify nyquist velocity (m/s).";
  p_help = "See 'override_nyquist'.";
} nyquist_velocity;

commentdef {
  p_header = "OPTION TO DESIGNATE SELECTED FIELDS AS DISCRETE IN NATURE";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to set 'is_discrete' flag for individual fields.";
  p_help = "If TRUE, the specified fields will be treated as holding discrete values, and the nearest neighbor method will be used instead of interpolation.\n\nYou should do this for fields such as PID (particle ID). In CfRadial files there is an option to store this information as attributes on each field. You can override what is in the file, or add to it.";
} set_discrete_fields;

typedef struct {
  string input_name;
  boolean is_discrete;
} discrete_field_t;

paramdef struct discrete_field_t {
  p_default = {
    {
      input_name = "PID",
      is_discrete = TRUE
    }
  };
  p_descr = "Use this to set the 'is_discrete' flag on a field.";
  p_help = "If this is specified, nearest neighbor will be used for this field. You can use this to override the is_discrete flag on a field in the input file.\n\nNOTE: 'input_name' for this step refers to the 'input_name' in 'select_fields' and 'output_name' in 'transform_fields'. This step is performed prior to renaming fields (see below).";
} discrete_fields[];

commentdef {
  p_header = "OPTION TO RENAME FIELDS ON OUTPUT";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to rename some or all of the fields when they are written out.";
  p_help = "If FALSE, no fields will be renamed.";
} rename_fields;

typedef struct {
  string input_name;
  string output_name;
} rename_field_t;

paramdef struct rename_field_t {
  p_default = { 
    { "DBZ", "DBZ_S" },
    { "VEL", "VEL_S" },
    { "WIDTH", "WIDTH_S" }
  };
  p_descr = "Specify the list of fields to be renamed.";
  p_help = "Only applies if 'rename_fields' is TRUE.\n\nThe field name is changed from 'input_name' to 'output_name'.\n\nNOTE: for transformed fields (see previous section), 'input_name' in 'renamed_fields' matches 'output_name' in 'transform_fields'. The transform occurs first, and then the fields are renamed.";
} renamed_fields[];

commentdef {
  p_header = "OPTION TO ADD GEOMETRY AND TIME FIELDS";
  p_text = "These fields are computed from the geometry of the radar rays, and then added as input fields in native radial coordinates.";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to output angle fields.";
  p_descr = "These are the fields used for multi-Doppler analsysis, as well as the range from the radar.";
} output_angle_fields;

typedef struct {
  string azimuth_field_name;
  string elevation_field_name;
  string alpha_field_name;
  string beta_field_name;
  string gamma_field_name;
} angle_fields_t;

paramdef struct angle_fields_t {
  p_default = {
    azimuth_field_name = "azimuth",
    elevation_field_name = "elevation",
    alpha_field_name = "alpha",
    beta_field_name = "beta",
    gamma_field_name = "gamma"
  };
  p_descr = "Specify the output names of the angle fields. If set to empty, that field will not be created.";
  p_help =
    "\tazimuth: the azimuth of the ray (deg)\n"
    "\televation: the elevation of the ray (deg)\n"
    "\talpha: sin(az) * cos(el)\n"
    "\tbeta: cos(az) * cos(el)\n"
    "\tgamma: sin(el)\n";
} angle_fields;

paramdef boolean {
  p_default = false;
  p_descr = "Option to add range field to the output.";
  p_help = "This is the range, in km, from the radar to each gate.";
} output_range_field;

paramdef string {
  p_default = "range";
  p_descr = "Name of range field, if written.";
  p_help = "See 'output_range_field'.";
} range_field_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to add height field to the output.";
  p_help = "This is the height, in km msl, of the center of each gate.";
} output_height_field;

paramdef string {
  p_default = "height";
  p_descr = "Name of height field, if written.";
  p_help = "See 'output_height_field'.";
} height_field_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to output a field indicating radar coverage.";
  p_help = "This is a flag field, with a 1 indicating that the radar covers that location, and a 0 indicating that is does not. See also 'coverage_field_name'. This field is always transformed using nearest neighbor.";
} output_coverage_field;

paramdef string {
  p_default = "Coverage";
  p_descr = "Name of coverage field, if written.";
  p_help = "See 'output_coverage_field'.";
} coverage_field_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to output a field of time since start of volume (secs)";
  p_help = "If true, time time elapsed field is included in the output file. See also 'time_field_name' and 'interp_time_field'.";
} output_time_field;

paramdef string {
  p_default = "time_elapsed";
  p_descr = "Name of time field, if written.";
  p_help = "See 'output_time_field'.";
} time_field_name;

paramdef boolean {
  p_default = true;
  p_descr = "Option to perform interpolation on the time field.";
  p_help = "If false, nearest neighbor will be used for the time field.";
} interp_time_field;

commentdef {
  p_header = "OPTION TO ADD DEBUG FIELDS";
  p_text = "The debug fields are added to the output Cartesian grid. These are geometry fields, and can be used to ensure the interpolation is working as expected.";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to add debug fields for checking the interpolation.";
  p_help = "The test fields allow us to ensure that the interpolation is working correctly.\n\nThe debug fields are:\n\n\tnContrib - number of points used in interpolation\n\tgridAz: azimuth deg\n\tgridEl: elevation deg\n\tgridRange: range km\n\tllEl: lower left elevation deg\n\tllAz: lower left azimuth deg\n\tlrEl: lower right elevation deg\n\tlrAz: lower right azimuth deg\n\tulEl: upper left elevation deg\n\tulAz: upper left azimuth deg\n\turEl: upper right elevation deg\n\turAz: upper right azimuth deg";
} output_debug_fields;

commentdef {
  p_header = "CENSORING OUTPUT FIELDS";
  p_text = "You have the option of censoring the output data fields - i.e. setting the fields to missing values - at gates which meet certain criteria based on the values in the input fields.\n\nIf this is done correctly, it allows you to preserve the valid data and discard the noise, thereby improving compression. This leads to smaller data files.";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Apply censoring based on field values and thresholds.";
  p_help = "If TRUE, censoring will be performed. See 'censoring_fields' for details on how the censoring will be applied.";
} apply_censoring;

typedef enum {
  LOGICAL_AND, LOGICAL_OR
} logical_t;

typedef struct {
  string name;
  double min_valid_value;
  double max_valid_value;
  logical_t combination_method;
} censoring_field_t;

paramdef struct censoring_field_t {
  p_default = {
    { "SNR", 0.0, 1000.0, LOGICAL_OR },
    { "NCP", 0.15, 1000.0, LOGICAL_OR }
  };
  p_descr = "Fields to be used for censoring.";
  p_help = "Specify the fields to be used to determine whether a gate should be censored.\n\nThe name refers to the field name in the input files.\n\nValid field values lie in the range from min_valid_value to max_valid_value, inclusively. If the value of a field at a gate lies within this range, it is considered valid.\n\nEach specified field is examined at each gate, and is flagged as valid if its value lies in the valid range.\n\nThese field flags are then combined as follows:\n\nFirst, all of the LOGICAL_OR flags are combined, yielding a single combined_or flag which is true if any of the LOGICAL_OR fields is true.\n\nNext the combined_or flag is combined with all of the LOGICAL_AND fields, yielding a true value only if the combined_or flag and the LOGICAL_AND fields are all true.\n\nIf this computed flag is true, then the data at the gate is regarded as valid and is retained.\n\nIf the computed flag is false, the data at the gate is censored, and all of the fields at the gate are set to missing.";
} censoring_fields[];
  
paramdef int {
  p_default = 1;
  p_descr = "Minimum valid run of non-censored gates.";
  p_help = "Only active if set to 2 or greater. A check is made to remove short runs of noise. Looking along the radial, we compute the number of contiguous gates (a 'run') with uncensored data. For the gates in this run to be accepted the length of the run must exceed censoring_min_valid_run. If the number of gates in a run is less than this, then all gates in the run are censored.";
} censoring_min_valid_run;

commentdef {
  p_header = "SETTING THE PSEUDO EARTH RADIUS RATIO FOR HEIGHT COMPUTATIONS";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the standard 4/3 earth radius model for refraction.";
  p_help = "If true, the standard 4/3 earth radius will be overridden. The US NWS NEXRAD system uses 1.21 instead of 1.333.";
} override_standard_pseudo_earth_radius;

paramdef double {
  p_default = 1.33333333;
  p_descr = "Ratio for computing the pseudo earth radius for beam height computations.";
  p_help = "For standard refraction this is 4/3. For super refraction it will be less than 4.3, and for sub-refraction it will be greater. NEXRAD uses 1.21.";
} pseudo_earth_radius_ratio;

commentdef {
  p_header = "FILE READ OPTIONS";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to aggregate sweep files into a volume on read.";
  p_help = "If true, and the input data is in sweeps rather than volumes (e.g. DORADE), the sweep files from a volume will be aggregated into a volume.";
} aggregate_sweep_files_on_read;

paramdef boolean {
  p_default = true;
  p_descr = "Option to ignore data taken in IDLE mode.";
  p_help = "If true, on read will ignore files with an IDLE scan mode.";
} ignore_idle_scan_mode_on_read;

paramdef boolean {
  p_default = false;
  p_descr = "Option to remove rays taken while the antenna was in transition.";
  p_help = "If true, rays with the transition flag set will not be used. The transiton flag is set when the antenna is in transtion between one sweep and the next.";
} remove_rays_with_antenna_transitions;

paramdef int {
  p_default = 0;
  p_descr = "Number of transition rays to include as a margin";
  p_help =  "Sometimes the transition flag is turned on too early in a transition, on not turned off quickly enough after a transition. If you set this to a number greater than 0, that number of rays will be included at each end of the transition, i.e. the transition will effectively be shorter at each end by this number of rays.";
} transition_nrays_margin;

paramdef boolean {
  p_default = true;
  p_descr = "Option to remove long range rays.";
  p_help = "Applies to NEXRAD data. If true, data from the non-Doppler long-range sweeps will be removed.";
} remove_long_range_rays;

paramdef boolean {
  p_default = false;
  p_descr = "Option to remove short range rays.";
  p_help = "Applies to NEXRAD data. If true, data from the Doppler short-range sweeps will be removed.";
} remove_short_range_rays;

paramdef boolean {
  p_default = false;
  p_descr = "Option to trip surveillance sweeps so that they only cover 360 degrees.";
  p_help = "Some sweeps will have rays which cover more than a 360-degree rotation. Often these include antenna transitions. If this is set to true, rays are trimmed off either end of the sweep to limit the coverage to 360 degrees. The median elevation angle is computed and the end ray which deviates from the median in elevation is trimmed first.";
} trim_surveillance_sweeps_to_360deg;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the fixed angle with the mean angle for a sweep.";
  p_help = "If true, for each sweep the mean pointing angle is computed and then this is used to override the fixed angle.";
} override_fixed_angle_with_mean_measured_angle;

paramdef boolean {
  p_default = false;
  p_descr = "Option to reorder sweeps by ascending angles.";
  p_help = "If true, sweeps will be checked to see if they are in ascending angle order. If not they are reordered. If the sweeps are reordered, this means that the rays times will no longer be monotonically increasing";
} reorder_sweeps_by_ascending_angle;

paramdef boolean {
  p_default = false;
  p_descr = "Option to compute sweep angles using the VCP tables when reading NEXRAD data.";
  p_help = "If true, the VCP tables will be used to assign sweep angles. This is useful if rounding angles to fit the VCP is desired. For NEXRAD data files that don't follow a known VCP and the VCP header is not included, set this to false.";
} compute_sweep_angles_from_vcp_tables;

commentdef {
  p_header = "OPTION TO CORRECT TIME";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to apply an offset to the ray times.";
  p_help = "If TRUE, this offset will be ADDED to the existing ray times. This is useful, for example, for correcting time errors, or converting from local time to UTC.";
} apply_time_offset;

paramdef double {
  p_default = 0;
  p_descr = "Time offset (secs).";
  p_help = "See 'apply_time_offset'. This value will be ADDED to the existing ray times.";
} time_offset_secs;

commentdef {
  p_header = "SETTING LIMITS ON THE VALID DATA";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to set the max range for any ray.";
} set_max_range;

paramdef double {
  p_default = 9999;
  p_descr = "Specified maximim range - km.";
  p_help = "Gates beyond this range are removed.";
} max_range_km;

paramdef boolean {
  p_default = false;
  p_descr = "Option to set elevation angle limits";
  p_help = "Only use rays within the specified elevation angle limits.";
} set_elevation_angle_limits;

paramdef double {
  p_default = 0;
  p_descr = "Lower elevation angle limit (deg).";
} lower_elevation_angle_limit;

paramdef double {
  p_default = 90;
  p_descr = "Upper elevation angle limit (deg).";
} upper_elevation_angle_limit;

paramdef boolean {
  p_default = false;
  p_descr = "Option to set azimuth angle limits.";
  p_help = "Only use rays within the specified azimuth angle limits. This essentially specifies a sector for valid data. Rays outside this sector are ignored.";
} set_azimuth_angle_limits;

paramdef double {
  p_default = 0;
  p_descr = "Counter-clockwise azimuth angle limit (deg).";
  p_help = "This is the azimuth limit at the lower (counter clockwise) end of the sector. For azimuths to the west of north, use values between 180 and 360.";
} lower_azimuth_angle_limit;

paramdef double {
  p_default = 360;
  p_descr = "Clockwise azimuth angle limit (deg).";
  p_help = "This is the azimuth limit at the upper (clockwise) end of the sector.";
} upper_azimuth_angle_limit;

paramdef boolean {
  p_default = false;
  p_descr = "Option to limit the fixed angle error to a specfied maximum value.";
  p_help = "If true, we compute the error between the actual pointing angle and the fixed angle for the sweep. If the error exceeds the specified limit, we reject the ray. For PPIs, we check th elevation angle against the fixed angle. For RHIs, we check the azimuth against the fixed angle.";
} check_fixed_angle_error;

paramdef double {
  p_default = 2.0;
  p_descr = "Maximum permissable error in the pointing angle (deg).";
  p_help = "See 'check_fixed_angle'.";
} max_fixed_angle_error;

paramdef boolean {
  p_default = false;
  p_descr = "Option to check that the file has a minimum number of sweeps";
  p_help = "See 'min_number_of_sweeps'.";
} check_number_of_sweeps;

paramdef double {
  p_default = 1;
  p_descr = "Minimum number of sweeps for valid file.";
  p_help = "Applies if 'check_number_of_sweeps' is true. Only process files with this number of sweeps, or more.";
} min_number_of_sweeps;

commentdef {
  p_header = "OPTION TO OVERRIDE VOLUME NUMBER, OR AUTOINCREMENT";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the volume number in the file.";
  p_help = "Useful is there is no volume number in the data.";
} override_volume_number;

paramdef int {
  p_default = 1;
  p_descr = "Volume number at startup.";
  p_help = "Applies if 'override_volume_number' is true.";
} starting_volume_number;

paramdef boolean {
  p_default = false;
  p_descr = "Option to automatically increment the volume number.";
  p_help = "Starts at 'starting_volume_number' and increments from there.";
} autoincrement_volume_number;

commentdef {
  p_header = "OPTION TO OVERRIDE RADAR LOCATION";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the radar location.";
  p_help = "If true, the location in this file will be used. If not, the location in the time series data will be used.";
} override_radar_location;

paramdef double {
  p_default = -999;
  p_descr = "Radar latitude (deg).";
  p_help = "See override_radar_location.";
} radar_latitude_deg;

paramdef double {
  p_default = -999;
  p_descr = "Radar longitude (deg).";
  p_help = "See override_radar_location.";
} radar_longitude_deg;

paramdef double {
  p_default = -999;
  p_descr = "Radar altitude (meters).";
  p_help = "See override_radar_location.";
} radar_altitude_meters;

commentdef {
  p_header = "OPTION TO OVERRIDE INSTRUMENT AND/OR SITE NAME";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the instrument name.";
  p_help = "If true, the name provided will be used.";
} override_instrument_name;

paramdef string {
  p_default = "unknown";
  p_descr = "Instrument name.";
  p_help = "See override_instrument_name.";
} instrument_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to override the site name.";
  p_help = "If true, the name provided will be used.";
} override_site_name;

paramdef string {
  p_default = "unknown";
  p_descr = "Site name.";
  p_help = "See override_site_name.";
} site_name;

commentdef {
  p_header = "OPTION TO OVERRIDE RADAR BEAM WIDTH";
  p_text = "The beam width is used to decide how far to extend the interpolated data beyond the observed data. The data is extended below the lowest tilt and above the highest tilt, and in the case of sector scans it is extended slightly beyond the sector limits.";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to override radar beam width.";
  p_help = "If TRUE, the program will use beam width specified in the 'beam_width_deg' parameter.";
} override_beam_width;

paramdef double {
  p_default = 1.0;
  p_descr = "Horizontal beam width if override is set true (deg).";
  p_help = "Used for extending the data to the left or right of sector limits, if applicable. This is only used if 'override_beam_width' is set true. Otherwise the metadata in the input data stream is used.";
} beam_width_deg_h;

paramdef double {
  p_default = 1.0;
  p_descr = "Vertical beam width if override is set true (deg).";
  p_help = "Used for extending data above or below the observed region. This only used if 'override_beam_width' is set true. Otherwise the metadata in the input data stream is used.";
} beam_width_deg_v;

commentdef {
  p_header = "OPTION TO OVERRIDE RADAR GATE GEOMETRY";
  p_text = "If the start range and/or gate spacing is not correct in the data, you can override it using the parameters below.";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to override gate geometry.";
  p_help = "If TRUE, the program will use the start range and gate spacing specified here.";
} override_gate_geometry;

paramdef double {
  p_default = 0.125;
  p_descr = "Start range (km).";
  p_help = "Used for overriding the start range in the data.";
} start_range_km;

paramdef double {
  p_default = 0.25;
  p_descr = "Gate spacing (km).";
  p_help = "Used for overriding the gate spacing in the data.";
} gate_spacing_km;

commentdef {
  p_header = "OPTION TO APPLY ANGLE CORRECTIONS";
  p_text = "This section allows you to correct the azimuth and/or elevation angles for a known error.";
}

paramdef double {
  p_default = 0.0;
  p_descr = "Add this value to the azimuth.";
  p_help = "Normally only used for testing, but can be used if there is a constant azimuth error in the data.";
} azimuth_correction_deg;

paramdef double {
  p_default = 0.0;
  p_descr = "Add this value to the elevation.";
  p_help = "Normally only used for testing, but can be used if there is a constant elevation error in the data.";
} elevation_correction_deg;

commentdef {
  p_header = "CF NetCDF OUTPUT DETAILS";
}

paramdef boolean {
  p_default = false;
  p_descr = "If true, the file will be named 'output_filename'.";
  p_help = "If false, the file name will be computed from the data time.";
} specify_output_filename;

paramdef string {
  p_default = "ncfGrid.nc";
  p_descr = "Name of output file.";
  p_help = "Applies only if specify_output_filename is true.";
} output_filename;

paramdef boolean {
  p_default = false;
  p_descr = "If true, name the output file using the start time.";
  p_help = "If false, the end time is used, in the MDV tradition.";
} name_file_from_start_time;

paramdef string {
  p_default = "ncf_";
  p_descr = "User-specified output file prefix, comes before date_time.";
} netcdf_file_prefix;

paramdef string {
  p_default = "";
  p_descr = "User-specified output file suffix, comes after the date_time and before the .nc which gets automatically added on.";
} netcdf_file_suffix;

paramdef boolean {
  p_default = false;
  p_descr = "If true the output filename uses the prefix, followed by ISO 8601 timestamp convention";
  p_help = "eg. prefix.2008-05-22T14:00:00.nc";
} use_iso8601_filename_convention;

commentdef {
  p_header = "NETCDF COMPRESSION";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to compress data fields on output.";
  p_help = "Applies to CfRadial netCDF and Dorade.";
} netcdf_compressed;

paramdef int {
  p_default = 4;
  p_min = 1;
  p_max = 9;
  p_descr = "Level of compression for output data.";
  p_help = "Valid range is 1 through 9. 1 gives lowest compression, 9 highest. 4 is a good compromise between speed and compression efficiency. Only applies to NetCDF file format.";
} netcdf_compression_level;

commentdef {
  p_header = "NETCDF STYLE";
}

typedef enum {
  CLASSIC, 
  NC64BIT, 
  NETCDF4_CLASSIC, 
  NETCDF4
} netcdf_style_t;

paramdef enum netcdf_style_t {
  p_default = NETCDF4;
  p_descr = "NetCDF style - if output_format is CFRADIAL";
  p_help = "netCDF classic format, netCDF 64-bit offset format, netCDF4 using HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls";
} netcdf_style;

paramdef boolean {
  p_default = true;
  p_descr = "If true latitude and longitude arrays of each grid point are output";
  p_help = "The CF convention requires that these arrays are present in the netCDF file; however, the information is redundant since the lat and lon arrays could be constructed using the other projection and grid information required with a gridded data field";
} netcdf_include_latlon_arrays;

paramdef boolean {
  p_default = false;
  p_descr = "Option to output non-CF compliant MDV attributes.";
  p_help = "If true, MDV attributes which are not CF compliant will be output. This will facilitate the translation of the data back into MDV with the minimal loss of information.";
} netcdf_output_mdv_attributes;

paramdef boolean {
  p_default = false;
  p_descr = "Option to output non-CF compliant MDV chunks.";
  p_help = "If true, MDV chunks will be included as byte binary variables. This will also write the radar parameters, e.g. location, gate spacing, etc. - to the global attributes.";
} netcdf_output_mdv_chunks;

paramdef string {
  p_default = "SPOL radar data";
  p_descr = "Title string for netCDF file.";
} ncf_title;

paramdef string {
  p_default = "EOL/NCAR";
  p_descr = "Institution string for netCDF file.";
} ncf_institution;

paramdef string {
  p_default = "";
  p_descr = "References string for netCDF file.";
} ncf_references;

paramdef string {
  p_default = "SPOL radar";
  p_descr = "Source string for netCDF file.";
} ncf_source;

paramdef string {
  p_default = "";
  p_descr = "History string for netCDF file.";
} ncf_history;

paramdef string {
  p_default = "";
  p_descr = "Comment string for netCDF file.";
} ncf_comment;

commentdef {
  p_header = "PROCESS CONTROL";
}

paramdef string {
  p_default = "test";
  p_descr = "Program instance for process registration.";
  p_help = "REALTIME mode only. This application registers with procmap. This is the instance used for registration.";
} instance;

paramdef int {
  p_default = 60;
  p_descr = "Interval for registering with procmap (secs).";
  p_help = "REALTIME mode only. The app will register with procmap at this interval, to update its status. If it does not register within twice this interval, the auto_restart script will restart the app.";
} procmap_register_interval;

commentdef {
  p_header = "MEMORY HANDLING";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to free up memory between each new file.";
  p_help = "If true, we free up as much memory as possible between handling the files. If false, we reduse allocated memory to the extent possible.";
} free_memory_between_files;

commentdef {
  p_header = "THREADING FOR SPEED.";
}

paramdef boolean {
  p_default = true;
  p_descr = "Option to use multiple compute threads to improve performance.";
  p_help = "The read and write stages occur in the main thread, since netCDF is not thread safe. The compute stage can be multi-threaded to improve performance.";
} use_multiple_threads;

paramdef int {
  p_default = 4;
  p_min = 1;
  p_descr = "The number of compute threads.";
  p_help = "The moments computations are segmented in range, with each thread computing a fraction of the number of gates. For maximum performance, n_threads should be set to the number of processors multiplied by 4. For further tuning, use top to maximize CPU usage while varying the number of threads.";
} n_compute_threads;

commentdef {
  p_header = "INTERPOLATION FOR SATELLITE DATA";
  p_text = "Satellite interpolation uses the reorder params above, plus those in this section.";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to invert satellite data in range from the instrument";
  p_help = "Since satellite-based instruments look downwards, it is sometimes necessary to invert the data, so that it sorts from the ground up.";
} sat_data_invert_in_range;

paramdef boolean {
  p_default = false;
  p_descr = "Option to use the range geometry from the fields instead of the rays.";
  p_help = "If true, the field geometry will be copied into the ray metadata.";
} sat_data_set_range_geom_from_fields;

commentdef {
  p_header = "OPTION TO WRITE SEARCH MATRIX FILES";
  p_text = "This is for debugging purposes only. The search matrix data will be written to MDV files that can then be viewed in CIDD or JAZZ.";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to write files containing data from the search matrix.";
  p_help = "Applies to the 2D search matrices that are computed for INTERP_MODE_CART.";
} write_search_matrix_files;

paramdef string {
  p_default = "./mdv/search_matrix";
  p_descr = "Output directory for writing search matrix files.";
  p_help = "See 'output_search_matrix'.";
} search_matrix_dir;

commentdef {
  p_header = "OPTION TO IDENTIFY THE CONVECTIVE/STRATIFORM SPLIT";
  p_text = "Applies only to INTERP_MODE_CART.";
}

paramdef boolean {
  p_default = false;
  p_descr = "Option to identify the convective / stratiform split.";
  p_help = "Uses the standard deviation of reflectivity as a texture field for each Cartesian plane. Low variability indicates stratiform conditions.";
} identify_convective_stratiform_split;

paramdef string {
  p_default = "DBZ";
  p_descr = "Name of reflectivity field in input data.";
  p_help = "This is used for computing reflectivity texture.";
} conv_strat_dbz_field_name;

paramdef double {
  p_default = 0.0;
  p_descr = "Min height used in analysis (km).";	
  p_help = "Only data at or above this altitude is used.";
} conv_strat_min_valid_height;

paramdef double {
  p_default = 25.0;
  p_descr = "Max height used in analysis (km).";	
  p_help = "Only data at or below this altitude is used.";
} conv_strat_max_valid_height;

paramdef double {
  p_default = 10.0;
  p_descr = "Minimum reflectivity threshold for this analysis (dBZ).";
  p_help = "Reflectivity below this threshold is set to missing.";
} conv_strat_min_valid_dbz;

paramdef double {
  p_default = 53;
  p_descr = "Reflectivity value that indicates definite convection.";
  p_help = "If the reflectivity exceeds this value at a point, we assume convection is definitely active at that point. To use this, we first compute the column maximum reflectivity. If the column max dbz at a point exceeds this threshold, then we flag that point as convective.";
} conv_strat_dbz_threshold_for_definite_convection;

paramdef double {
  p_default = 5.0;
  p_descr = "Radius of convective influence (km).";
  p_help = "Given definite convection at a point (see above), we set all points within this radius to be convective.";
} conv_strat_convective_radius_km;

paramdef double {
  p_default = 7.0;
  p_descr = "Radius for texture analysis (km).";
  p_help = "We determine the reflectivity 'texture' at a point by computing the standard deviation of the square of the reflectivity, for all grid points within this radius of the central point. We then compute the square root of that sdev.";
} conv_strat_texture_radius_km;

paramdef double {
  p_default = 0.33;
  p_descr = "Minimum fraction of surroundingpoints for texture computations.";
  p_help = "For a valid computation of texture, we require at least this fraction of points around the central point to have reflectivity in excess of min_valid_dbz.";
} conv_strat_min_valid_fraction_for_texture;

paramdef double {
  p_default = 15.0;
  p_descr = "Minimum texture for convection at a point.";
  p_help = "If the texture at a point exceeds this value, we set the convective flag at this point. We then expand the convective influence around the point using convetive_radius_km.";
} conv_strat_min_texture_for_convection;

paramdef boolean {
  p_default = TRUE;
  p_descr = "Option to write out the convective/stratiform partition.";
  p_help = "If true, the 2-D partition will be added to the output file.";
} conv_strat_write_partition;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to write out the mean texture.";
  p_help = "If true, the mean texture will be written to the outptu file. This is a 2-D field - the mean over height of the 3-D texture fields.";
} conv_strat_write_mean_texture;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to write out the dbz field in convection.";
  p_help = "This is a 3D field - the reflectivity trimmed only to convective regions, based on the convective/stratiform partition.";
} conv_strat_write_convective_dbz;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Option to write out the intermediate fields for debug purposes.";
  p_help = "If true, the intermdiate fields will be written to the output file.";
} conv_strat_write_debug_fields;

commentdef {
  p_header = "INTERPOLATION USING REORDER METHOD";
  p_text = "!!!!!! WARNING - IMPORTANT NOTE - this mode should only be used for mobile platforms. Use INTERP_MODE_CART for all fixed platforms - it is much more robust and gives much better results !!!!!!!";
}

paramdef int {
  p_default = 24;
  p_descr = "Number of points retrieved around each grid point.";
  p_help = "We find this number of closest points, and then check that their distance is less than the search radius.";
} reorder_npoints_search;

paramdef double {
  p_default = 5.0;
  p_descr = "Radius searched around a grid cell for radar points that contribute to theinterpolation.";
  p_help = "We optionally scale this by range, so that the radius increases at longer ranges where the rays are more widely spaced.";
} reorder_search_radius_km;

paramdef boolean {
  p_default = true;
  p_descr = "Option to scale search radius based on range from radar.";
  p_help = "If true, we treat the specified search radius as a nominal value, and adjust it based on the range of the grid point from the radar. See also reorder_nominal_range_for_search_radius.";
} reorder_scale_search_radius_with_range;

paramdef double {
  p_default = 60.0;
  p_descr = "Range at which the xy_margin is equal to the nominal value (km).";
  p_help = "At ranges other than this, we scale the search radius linearly based on range from the radar, provided reorder_scale_xy_margin_with_range is TRUE.";
} reorder_nominal_range_for_search_radius_km;

paramdef double {
  p_default = 1.0;
  p_descr = "Ratio of search in Z dimension with respect to the XY dimensions.";
  p_help = "If this is 1.0, the search space around a grid point is effectively a sphere. If this value is less than 1, then the search space is flattened, i.e. we look farther out in the XY directions than in the Z direction. This has the effect of reducing the ringing effect seen in data with higher gradients in Z than XY. If the value is greater than 1, the reverse applies.";
} reorder_z_search_ratio;

// paramdef boolean {
//   p_default = false;
//   p_descr = "Option to only use one radar point per octant around the grid point.";
//   p_help = "You can think of the 3-D space around a selected grid point as being divided into 8 regions (octants) in the (z,y,x) space. If this parameter is set to true, then for interpolation we only use the closest available radar point in each octant, and the other points in that octant are ignored.";
// } reorder_only_use_one_point_per_octant;

paramdef boolean {
  p_default = false;
  p_descr = "Option to interpolate only if there is valid data both above and below the grid point.";
  p_help = "This enforces boundedness in the vertical coordinate. Essentially it prevents extrapolation above the upper sweep and below the lowest sweep.";
} reorder_bound_grid_point_vertically;

paramdef double {
  p_default = 0.5;
  p_descr = "Min ratio of valid weights to total weights.";
  p_help = "In deciding whether a grid point should be marked as valid or missing, we compute the ratio of the sum of the weights of the valid points over the weights of all points. If the ratio falls below this parameter, the point it marked as missing.";
} reorder_min_valid_wt_ratio;

paramdef int {
  p_default = 8;
  p_descr = "Number of rows in which grid is divided for computations, in the x direction.";
  p_help = "Reorder uses a K-dimensional tree for finding the closest radar points to a selected Cartesian point. A kd-tree search slows down non-linearly as the number of points in the tree increases. To keep the number of points to reasonable values, we divide the grid into blocks, using the specified number of rows and columns. The tree will contain points in the block, plus some surrounding points to avoid edge effects. For computational efficieny the blocks should be approximately square in shape, so set nrows and ncols accordingly.";
} reorder_blocks_nrows;

paramdef int {
  p_default = 8;
  p_descr = "Number of columns in which grid is divided for computations, in the y direction.";
  p_help = "See reorder_search_nrows.";
} reorder_blocks_ncols;

paramdef int {
  p_default = 8;
  p_descr = "Minimum Number of points used in the reorder interpolation";
  p_help = "This will make sure the number of points used for least squares fit is sufficiently large. If this is too small the least squares fit becomes unstable and results become bad.";
} reorder_min_nvalid_for_interp;

paramdef boolean {
  p_default = FALSE;
  p_descr = "Do the original weighted average reorder interpolation if set to TRUE, do the least squares reorder interpolation if FALSE.";
} reorder_weighted_interpolation;

// paramdef boolean {
//   p_default = FALSE;
//   p_descr = "Do the strict SVD interpolation if TRUE, faster SVD interpolation if FALSE, applies only when reorder_weighted_interpolation = FALSE";
// } full_svd;

commentdef {
  p_header = "OPTION TO SET BOUNDS ON SELECTED FIELDS";
}

paramdef boolean {
  p_default = FALSE;
  p_descr = "If FALSE, no fields will be bounded";
  p_help = "Option to set limits on the values of some or all of the fields.\n\nThe parameters are set BEFORE interpolation, but the bound limits are applied AFTER interpolation.\n\nThis only applies if 'interp_mode' is set to INTERP_MODE_CART_REORDER. It can be a useful option since the linear-least-squares solution used by the REORDER interpolation can have unstable solutions that that lead to very out-of-range output values. This can in turn reduce the resolution of the output data if it is stored as a scaled integer.";
} bound_fields;

typedef struct {
  string input_name;
  double min_value;
  double max_value;
} bound_field_t;

paramdef struct bound_field_t {
  p_default = { 
    { "DBZ", -50, 100 },
    { "VEL", -50, 50 }
  };
  p_descr = "Specify the list of fields to be constrained within bounds";
  p_help = "Only applies if 'bound_fields' is TRUE. At points where the output value is out of bounds, it is set to missing. \n\nNOTE: 'input_name' for this step refers to the 'input_name' in 'select_fields' and 'output_name' in 'transform_fields'. Setting the bounds on each field is performed prior to renaming fields (see below).";
} bounded_fields[];

