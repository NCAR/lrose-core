/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.hh
//
// TDRP header file for 'Params' class.
//
// Code for program RadxCartDP
//
// This header file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.hh
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @class Params
 *
 * @author automatically generated
 *
 */

#ifndef Params_hh
#define Params_hh

#include <tdrp/tdrp.h>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <cfloat>

using namespace std;

// Class definition

class Params {

public:

  // enum typedefs

  typedef enum {
    DEBUG_OFF = 0,
    DEBUG_NORM = 1,
    DEBUG_VERBOSE = 2,
    DEBUG_EXTRA = 3
  } debug_t;

  typedef enum {
    FILELIST = 0,
    ARCHIVE = 1,
    REALTIME = 2
  } mode_t;

  typedef enum {
    DBZ = 0,
    VEL = 1,
    WIDTH = 2,
    SNR = 3,
    ZDR = 4,
    LDR = 5,
    PHIDP = 6,
    RHOHV = 7,
    KDP = 8
  } radar_field_type_t;

  typedef enum {
    TEMP = 0,
    RH = 1,
    UVEL = 2,
    VVEL = 3,
    WVEL = 4
  } model_field_type_t;

  typedef enum {
    BEAME = 0
  } bblock_field_type_t;

  typedef enum {
    RATE_ZH = 0,
    RATE_ZH_SNOW = 1,
    RATE_Z_ZDR = 2,
    RATE_KDP = 3,
    RATE_KDP_ZDR = 4,
    RATE_HYBRID = 5,
    RATE_PID = 6,
    RATE_HIDRO = 7,
    RATE_BRINGI = 8,
    PID_OUT = 9,
    PID_INTEREST = 10,
    TEMP_FOR_PID = 11,
    KDP_OUT = 12,
    KDP_SC = 13,
    DBZ_ATTEN_CORRECTION = 14,
    ZDR_ATTEN_CORRECTION = 15,
    DBZ_ATTEN_CORRECTED = 16,
    ZDR_ATTEN_CORRECTED = 17
  } pid_output_field_id_t;

  typedef enum {
    PROJ_LATLON = 0,
    PROJ_LAMBERT_CONF = 3,
    PROJ_MERCATOR = 4,
    PROJ_POLAR_STEREO = 5,
    PROJ_FLAT = 8,
    PROJ_OBLIQUE_STEREO = 12,
    PROJ_TRANS_MERCATOR = 15,
    PROJ_ALBERS = 16,
    PROJ_LAMBERT_AZIM = 17,
    PROJ_VERT_PERSP = 18
  } projection_t;

  // struct typedefs

  typedef struct {
    radar_field_type_t field_type;
    char* input_name;
    char* output_name;
  } radar_field_name_t;

  typedef struct {
    model_field_type_t field_type;
    char* input_name;
    char* output_name;
  } model_field_name_t;

  typedef struct {
    bblock_field_type_t field_type;
    char* input_name;
    char* output_name;
  } bblock_field_name_t;

  typedef struct {
    pid_output_field_id_t id;
    char* name;
    char* long_name;
    char* standard_name;
    char* units;
    tdrp_bool_t do_write;
  } pid_output_field_t;

  typedef struct {
    int nz;
    double minz;
    double dz;
  } grid_z_geom_t;

  typedef struct {
    int nx;
    int ny;
    double minx;
    double miny;
    double dx;
    double dy;
  } grid_xy_geom_t;

  typedef struct {
    char* field_name;
    tdrp_bool_t censor_non_weather;
  } copy_field_t;

  typedef struct {
    char* field_name;
    tdrp_bool_t field_folds;
    tdrp_bool_t use_global_nyquist;
    double fold_limit_lower;
    double fold_limit_upper;
  } fold_field_t;

  typedef struct {
    char* azimuth_field_name;
    char* elevation_field_name;
    char* alpha_field_name;
    char* beta_field_name;
    char* gamma_field_name;
  } angle_fields_t;

  ///////////////////////////
  // Member functions
  //

  ////////////////////////////////////////////
  // Default constructor
  //

  Params ();

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params (const Params&);

  ////////////////////////////////////////////
  // Destructor
  //

  virtual ~Params ();

  ////////////////////////////////////////////
  // Assignment
  //

  void operator=(const Params&);

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadFromArgs(int argc, char **argv,
                   char **override_list,
                   char **params_path_p,
                   bool defer_exit = false);

  bool exitDeferred() { return (_exitDeferred); }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadApplyArgs(const char *params_path,
                    int argc, char **argv,
                    char **override_list,
                    bool defer_exit = false);

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  static bool isArgValid(const char *arg);

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  static int isArgValidN(const char *arg);

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int load(const char *param_file_path,
           char **override_list,
           int expand_env, int debug);

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadFromBuf(const char *param_source_str,
                  char **override_list,
                  const char *inbuf, int inlen,
                  int start_line_num,
                  int expand_env, int debug);

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadDefaults(int expand_env);

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void sync() const;

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void print(FILE *out, tdrp_print_mode_t mode = PRINT_NORM);

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int checkAllSet(FILE *out);

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int checkIsSet(const char *param_name);

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int arrayRealloc(const char *param_name,
                   int new_array_n);

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int array2DRealloc(const char *param_name,
                     int new_array_n1,
                     int new_array_n2);

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void freeAll(void);

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  static void usage(ostream &out);

  ///////////////////////////
  // Data Members
  //

  char _start_; // start of data region
                // needed for zeroing out data
                // and computing offsets

  debug_t debug;

  char* radar_input_dir;

  mode_t radar_input_mode;

  int radar_max_realtime_data_age_secs;

  char* radar_file_search_ext;

  char* radar_file_search_substr;

  char* start_time;

  char* end_time;

  radar_field_name_t *_radar_field_names;
  int radar_field_names_n;

  char* model_input_url;

  int model_search_margin_secs;

  model_field_name_t *_model_field_names;
  int model_field_names_n;

  bblock_field_name_t *_bblock_field_names;
  int bblock_field_names_n;

  char* output_dir;

  tdrp_bool_t SNR_available;

  char* SNR_field_name;

  double noise_dbz_at_100km;

  char* DBZ_field_name;

  char* ZDR_field_name;

  char* PHIDP_field_name;

  char* RHOHV_field_name;

  tdrp_bool_t LDR_available;

  char* LDR_field_name;

  char* KDP_params_file_path;

  tdrp_bool_t KDP_write_debug_fields;

  char* PID_params_file_path;

  tdrp_bool_t PID_use_KDP_self_consistency;

  tdrp_bool_t PID_use_attenuation_corrected_fields;

  tdrp_bool_t PID_write_debug_fields;

  char* RATE_params_file_path;

  tdrp_bool_t RATE_use_KDP_self_consistency;

  tdrp_bool_t RATE_use_attenuation_corrected_fields;

  pid_output_field_t *_pid_output_fields;
  int pid_output_fields_n;

  tdrp_bool_t use_nearest_neighbor;

  int min_nvalid_for_interp;

  tdrp_bool_t use_fixed_angle_for_interpolation;

  tdrp_bool_t use_fixed_angle_for_data_limits;

  double beam_width_fraction_for_data_limit_extension;

  grid_z_geom_t grid_z_geom;

  tdrp_bool_t specify_individual_z_levels;

  double *_z_level_array;
  int z_level_array_n;

  grid_xy_geom_t grid_xy_geom;

  tdrp_bool_t center_grid_on_radar;

  projection_t grid_projection;

  double grid_rotation;

  double grid_origin_lat;

  double grid_origin_lon;

  tdrp_bool_t auto_remap_flat_to_latlon;

  double grid_lat1;

  double grid_lat2;

  double grid_central_scale;

  double grid_tangent_lat;

  double grid_tangent_lon;

  tdrp_bool_t grid_pole_is_north;

  double grid_persp_radius;

  double grid_false_northing;

  double grid_false_easting;

  tdrp_bool_t grid_set_offset_origin;

  double grid_offset_origin_latitude;

  double grid_offset_origin_longitude;

  tdrp_bool_t copy_selected_input_fields_to_output;

  copy_field_t *_copy_fields;
  int copy_fields_n;

  tdrp_bool_t set_fold_limits;

  fold_field_t *_folded_fields;
  int folded_fields_n;

  tdrp_bool_t override_nyquist;

  double nyquist_velocity;

  tdrp_bool_t output_angle_fields;

  angle_fields_t angle_fields;

  tdrp_bool_t output_range_field;

  char* range_field_name;

  tdrp_bool_t output_height_field;

  char* height_field_name;

  tdrp_bool_t output_coverage_field;

  char* coverage_field_name;

  tdrp_bool_t output_time_field;

  char* time_field_name;

  tdrp_bool_t interp_time_field;

  tdrp_bool_t output_debug_fields;

  tdrp_bool_t override_standard_pseudo_earth_radius;

  double pseudo_earth_radius_ratio;

  tdrp_bool_t override_fixed_angle_with_mean_measured_angle;

  tdrp_bool_t set_max_range;

  double max_range_km;

  tdrp_bool_t override_radar_location;

  double radar_latitude_deg;

  double radar_longitude_deg;

  double radar_altitude_meters;

  tdrp_bool_t override_beam_width;

  double beam_width_deg_h;

  double beam_width_deg_v;

  tdrp_bool_t override_gate_geometry;

  double start_range_km;

  double gate_spacing_km;

  tdrp_bool_t specify_output_filename;

  char* output_filename;

  tdrp_bool_t name_file_from_start_time;

  char* netcdf_file_prefix;

  char* netcdf_file_suffix;

  tdrp_bool_t use_iso8601_filename_convention;

  char* ncf_title;

  char* ncf_institution;

  char* ncf_references;

  char* ncf_source;

  char* ncf_history;

  char* ncf_comment;

  char* instance;

  int procmap_register_interval;

  tdrp_bool_t free_memory_between_files;

  tdrp_bool_t use_multiple_threads;

  int n_compute_threads;

  tdrp_bool_t use_echo_orientation;

  double synthetic_rhis_start_az;

  double synthetic_rhis_delta_az;

  char* echo_orientation_dbz_field_name;

  int echo_orientation_n_points_sdev_h;

  int echo_orientation_n_points_sdev_v;

  tdrp_bool_t identify_convective_stratiform_split;

  char* conv_strat_dbz_field_name;

  double conv_strat_min_valid_height;

  double conv_strat_max_valid_height;

  double conv_strat_min_valid_dbz;

  double conv_strat_texture_radius_km;

  double conv_strat_min_valid_fraction_for_texture;

  double conv_strat_min_convectivity_for_convective;

  double conv_strat_max_convectivity_for_stratiform;

  int conv_strat_min_overlap_for_convective_clumps;

  tdrp_bool_t conv_strat_write_partition;

  tdrp_bool_t conv_strat_write_max_texture;

  tdrp_bool_t conv_strat_write_convective_dbz;

  tdrp_bool_t conv_strat_write_debug_fields;

  char _end_; // end of data region
              // needed for zeroing out data

private:

  void _init();

  mutable TDRPtable _table[164];

  const char *_className;

  bool _exitDeferred;

};

#endif

