//////////////////////////////////////////////////////////////////////////////////
//
// paramdef.RadxPersistentClutter
//
// This file contains the TDRP parameter definitions for setting the clutter
// pixels by processing a sufficient quantity of input data using a statistical
// approach
//
//////////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "RadxPersistentClutter app";
  p_text = "RadxPersistentClutter identifies persistent clutter in polar radar data, flags it, and writes out the statistics to a CfRadial file.\n";
};

commentdef {
  p_header = "RadxApp";
  p_text = "Parameters for general algorithm data filtering for Radx format input data";
};

paramdef string
{
  p_descr = "instance";
  p_help = "for PMU";
  p_default = "test";
} instance;

typedef enum
{NONE, DEBUG, DEBUG_VERBOSE} debug_e;

paramdef enum debug_e
{
  p_descr = "debugging mode";
  p_help = "NONE=as quiet as possible, DEBUG = minimal debug output, DEBUG_VERBOSE=more";
  p_default = DEBUG;
} debug_mode;

paramdef boolean
{
  p_descr = "triggering debug";
  p_help = "set to TRUE to debug triggering";
  p_default = FALSE;
} debug_triggering;

typedef enum {
  REALTIME, ARCHIVE, FILELIST
} mode_t;

paramdef enum mode_t
{
  p_default = FILELIST;
  p_descr = "Operating mode";
  p_help = "In REALTIME mode, the program waits for a new input file.  "
           "In ARCHIVE mode, it moves through the data between the start "
           "and end times set on the command line. "
           "In FILELIST mode, it moves through the list of file names "
           "specified on the command line. "
           "Paths (in ARCHIVE mode, at least) MUST contain a "
           "day-directory above the data file -- ./data_file.ext will not "
           "work as a file path, but ./yyyymmdd/data_file.ext will.";
} mode;

paramdef string
{
  p_descr = "output for Algorithm results";
  p_default = "";
} output_url;

//////////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header =
    "Threading";
  p_text =
    "Optional threading of beams, depends on app whether params are used or not";
}

paramdef int
{
  p_descr = "Number of threads";
  p_help = "set to 1 or 0 for no threading";
  p_default = 0;
} num_threads;

paramdef boolean
{
  p_descr = "Thread debugging";
  p_help = "TRUE to see thread related debugging";
  p_default = FALSE;
} thread_debug;

//////////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header =
    "Input paths";
  p_text =
    "Inputs can come from one or more location, a primary source, and any number of secondary sources.";
}

typedef struct 
{
  int index;
  string path;
  double file_match_time_offset_sec;
  double file_match_time_tolerance_sec;
  double ray_match_elevation_tolerance_deg;
  double ray_match_azimuth_tolerance_deg;
  double ray_match_time_tolerance_sec;
} input_t;

paramdef struct input_t
{
  p_descr = "inputs";
  p_help =
    "index = numerical value to refer to this elsewhere\n"
    "path = where the data is\n"
    "The first thing on this list is the primary data source. The geometry of non-primary files will be converted to match the primary files. The file_match_time_offset_sec and file_match_time_tolerance_sec are used to search for the best secondary file to merge. The offset is ignored for the primary field. The ray tolerances are used to match rays in the secondary file with those in the primary file.";
  p_default = {};
} input[];

commentdef {
  p_header =
    "Mapping from input field to path";
  p_text =
    "For each field that is an input to the app, it is associated with an input path using this mapping (index/field name).";
}

typedef struct
{
  string field;
  int index;
} field_map_t;

paramdef struct field_map_t
{
  p_descr = "mapping from field to url";
  p_help = "for each input field, the index to the path of that data";
  p_default = {};
} field_mapping[];

//////////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "Data Read Parameters";
  p_text = " Parameters that control the reading of input data ";
};

paramdef double
{
  p_descr = "max wait";
  p_help = "maximum wait time (minutes) for realtime=TRUE and multiple input URLs. Not used in archive mode";
  p_default = 1.0;
} max_wait_minutes;

paramdef int
{
  p_descr = "max_realtime_data_age_secs";
  p_help = "maximum allowed difference (seconds) between read request time and data time";
  p_default = 120;
} max_realtime_data_age_secs;

paramdef boolean {
  p_default = false;
  p_descr = "Option to set fixed angle limits";
  p_help = "Only read sweeps within the specified fixed angle limits. Fixed angles are elevation in PPI mode and azimuth in RHI mode.";
} read_set_fixed_angle_limits;

paramdef double {
  p_default = 0;
  p_descr = "Lower fixed angle limit - degrees.";
} read_lower_fixed_angle;

paramdef double {
  p_default = 90;
  p_descr = "Upper fixed angle limit - degrees.";
} read_upper_fixed_angle;

paramdef boolean {
  p_default = true;
  p_descr = "Option to ignore rays with antenna transition flag set.";
  p_help = "The transition flag is set when the antenna is moving between sweeps. If this parameter is true, rays containing the transition flag will not be read in.";
} ignore_antenna_transitions;

paramdef boolean {
  p_default = false;
  p_descr = "Option to set the max range for any ray.";
} set_max_range;

paramdef double {
  p_default = 9999;
  p_descr = "Specified maximim range - km.";
  p_help = "Gates beyond this range are removed.";
} max_range_km;

//////////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "RadxPersistentClutter";
  p_text = "Parameters for setting clutter locations of one input field.\n";
};

paramdef string
{
  p_descr = "input field name";
  p_help = "name of field to find clutter in";
  p_default = "unknown";
} input_field;

paramdef string
{
  p_descr = "output field name";
  p_help = "name to give final output clutter field";
  p_default = "clutter";
} output_field;

paramdef double
{
  p_descr = "threshold";
  p_help = "If data is always above this value it is a clutter location";
  p_default = 0.0;
} threshold;

paramdef double
{
  p_descr = "Clutter percentile";
  p_help = "percentile to use in clutter value determination (see the paper, section III. Correction of Radar Reflectivity";
  p_default = 0.5;
} clutter_percentile;

paramdef double
{
  p_descr = "Fixed storage elevation values";
  p_help = "List of target elevation angles (the angles seem to wobble a lot). Inputs are mapped to one of these using tolerance params";
  p_default = {};
} fixedElevations[];

paramdef double
{
  p_descr = "azimumth tolerance";
  p_help = "allowed degrees difference between azimuth values from different volumes to be considered part of the same ray";
  p_default = 0.1;
} azToleranceDegrees;

paramdef double
{
  p_descr = "elevation tolerance";
  p_help = "allowed degrees difference between elevation values from different volumes to be considered part of the same ray";
  p_default = 0.1;
} elevToleranceDegrees;

paramdef boolean
{
  p_descr = "diagnostic_output";
  p_help = "If true, output from each volume is done, to show the build up of skill through time, to the output location. Typically this is a diagnostic mode.  If false, output is only at the end of a processing phase, with output time equal to the time of the first volume processed, and output written to the final_output_url";
  p_default = FALSE;
} diagnostic_output;

paramdef string
{
  p_descr = "location for main output";
  p_help = "see diagnostic_output description";
  p_default = "unknown";
} final_output_url;

paramdef string
{
  p_descr = "Output ascii file path in which to write plottables";
  p_help = "";
  p_default = ".";
} output_ascii_path;

paramdef double
{
  p_descr = "missing clutter value";
  p_help = "value to give clutter estimates when the wanted percentile is the missing data value";
  p_default = -25.0;
} missing_clutter_value;

paramdef double
{
  p_descr = "variation in threshold for convergence";
  p_help = "The threshold as percent of total volumes to identify a point as clutter should converge to a stable value.  This value is the allowed tolerance (change) to be considered stable";
  p_default = 0.025;
} threshold_tolerance;

paramdef double
{
  p_descr = "Maximum percent of pixels that can change for convergence";
  p_help = "The percentage of pixels that change from clutter to nonclutter or back should decrease to a minimum for convergence";
  p_default = 0.001;
} maximum_percent_change;

paramdef double
{
  p_descr = "Number of volumes that show stablity prior to considering the situation stable";
  p_help = "The threshold converges, and needs to stay converged for this many volumes before giving the thumbs up";
  p_default = 10;
} minimum_stable_volumes;

paramdef double
{
  p_descr = "histogram resolution";
  p_help = "Histograms are used to set clutter value. This is the resolution";
  p_default = 0.2;
} histogram_resolution;

paramdef double
{
  p_descr = "histogram max";
  p_help = "Histograms are used to set clutter value. This is the maximum bin";
  p_default = 50.0;
} histogram_max;

