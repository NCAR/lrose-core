/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Pid2Grid
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Pid2Grid reads moments from Radx-supported format files, computes PID and rain rate, interpolates onto a Cartesian grid, and writes out the results to Cartesian files in MDV or NetCDF.");
    tt->comment_text = tdrpStrDup("The output is written to Cartesian files in CF-compliant NetCDF format.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
      tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_EXTRA");
      tt->enum_def.fields[3].val = DEBUG_EXTRA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("DATA INPUT DIRECTORY and INPUT MODE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir");
    tt->descr = tdrpStrDup("Input directory for searching for files.");
    tt->help = tdrpStrDup("Files will be searched for in this directory. This is ignored if the list of files is  specified on the command line using the -f option.");
    tt->val_offset = (char *) &input_dir - &_start_;
    tt->single_val.s = tdrpStrDup(".");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("In FILELIST mode, we move through the list of file names specified on the command line.\n\nIn REALTIME mode, the program waits for a new input file to arrive in 'input_dir'.\n\nIn ARCHIVE mode, we move through the files in input_dir between the start and end times set on the command line.\n\nIn ARCHIVE mode, input_dir must be one above the day-directory.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("FILELIST");
      tt->enum_def.fields[0].val = FILELIST;
      tt->enum_def.fields[1].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[1].val = ARCHIVE;
      tt->enum_def.fields[2].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[2].val = REALTIME;
    tt->single_val.e = FILELIST;
    tt++;
    
    // Parameter 'max_realtime_data_age_secs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_realtime_data_age_secs");
    tt->descr = tdrpStrDup("Maximum age of realtime data (secs)");
    tt->help = tdrpStrDup("REALTIME mode only. Only data files less old than this will be processed.");
    tt->val_offset = (char *) &max_realtime_data_age_secs - &_start_;
    tt->single_val.i = 300;
    tt++;
    
    // Parameter 'input_file_search_ext'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_file_search_ext");
    tt->descr = tdrpStrDup("File name extension.");
    tt->help = tdrpStrDup("If set, only files with this extension will be processed.");
    tt->val_offset = (char *) &input_file_search_ext - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_file_search_substr'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_file_search_substr");
    tt->descr = tdrpStrDup("File name sub-string.");
    tt->help = tdrpStrDup("If set, only files with names containing this sub-string will be processed.");
    tt->val_offset = (char *) &input_file_search_substr - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'start_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("start_time");
    tt->descr = tdrpStrDup("Set the start time for ARCHIVE mode analysis.");
    tt->help = tdrpStrDup("Format is 'yyyy mm dd hh mm ss'.");
    tt->val_offset = (char *) &start_time - &_start_;
    tt->single_val.s = tdrpStrDup("2015 06 26 00 00 00");
    tt++;
    
    // Parameter 'end_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("end_time");
    tt->descr = tdrpStrDup("Set the end time for ARCHIVE mode analysis.");
    tt->help = tdrpStrDup("Format is 'yyyy mm dd hh mm ss'.");
    tt->val_offset = (char *) &end_time - &_start_;
    tt->single_val.s = tdrpStrDup("2015 06 26 12 00 00");
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("DATA OUTPUT DIRECTORY AND FILE NAMES");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_dir");
    tt->descr = tdrpStrDup("Output directory for writing files.");
    tt->help = tdrpStrDup("Files will be written to this directory.");
    tt->val_offset = (char *) &output_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/pid");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("OPTION TO RENAME FIELDS ON INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'rename_fields_on_input'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("rename_fields_on_input");
    tt->descr = tdrpStrDup("Option to rename some or all of the fields when they are read in.");
    tt->help = tdrpStrDup("This operation is performed immediately after the read completes. All field names specified later in the parameter file refer to these new names.");
    tt->val_offset = (char *) &rename_fields_on_input - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'renamed_fields'
    // ctype is '_rename_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("renamed_fields");
    tt->descr = tdrpStrDup("Specify the list of fields to be renamed.");
    tt->help = tdrpStrDup("Only applies if 'rename_fields_on_input' is TRUE.\n\nThe field name is changed from 'input_name' to 'output_name'.\n\n");
    tt->array_offset = (char *) &_renamed_fields - &_start_;
    tt->array_n_offset = (char *) &renamed_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(rename_field_t);
    tt->array_n = 3;
    tt->struct_def.name = tdrpStrDup("rename_field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("input_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_renamed_fields->input_name - (char *) _renamed_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("output_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_renamed_fields->output_name - (char *) _renamed_fields;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].s = tdrpStrDup("DBZ_S");
      tt->struct_vals[2].s = tdrpStrDup("VEL");
      tt->struct_vals[3].s = tdrpStrDup("VEL_S");
      tt->struct_vals[4].s = tdrpStrDup("WIDTH");
      tt->struct_vals[5].s = tdrpStrDup("WIDTH_S");
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("INPUT FIELD INFORMATION for computing KDP, PID and RATE.");
    tt->comment_text = tdrpStrDup("Names of fields in the input file. The following fields are required: SNR, DBZ, ZDR, PHIDP and RHOHV. If SNR is not available, it is computed from DBZ.");
    tt++;
    
    // Parameter 'SNR_available'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("SNR_available");
    tt->descr = tdrpStrDup("Is SNR data available?");
    tt->help = tdrpStrDup("If not, SNR will be computed from the DBZ field. See 'noise_dbz_at_100km'.");
    tt->val_offset = (char *) &SNR_available - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'SNR_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("SNR_field_name");
    tt->descr = tdrpStrDup("Field name for SNR.");
    tt->help = tdrpStrDup("Signal-to-noise ratio (dB).");
    tt->val_offset = (char *) &SNR_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("SNR");
    tt++;
    
    // Parameter 'noise_dbz_at_100km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("noise_dbz_at_100km");
    tt->descr = tdrpStrDup("The noise value, represented as dBZ at a range of 100km.");
    tt->help = tdrpStrDup("This is used for computing the SNR from the DBZ field. It is only used if SNR_available is FALSE. The SNR will be computed by range-correcting this value and using it as the noise value.");
    tt->val_offset = (char *) &noise_dbz_at_100km - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'DBZ_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("DBZ_field_name");
    tt->descr = tdrpStrDup("Field name for DBZ.");
    tt->help = tdrpStrDup("Horizontally-polarized reflectivity factor.");
    tt->val_offset = (char *) &DBZ_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("DBZ");
    tt++;
    
    // Parameter 'ZDR_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ZDR_field_name");
    tt->descr = tdrpStrDup("Field name for ZDR.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ZDR_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("ZDR");
    tt++;
    
    // Parameter 'PHIDP_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("PHIDP_field_name");
    tt->descr = tdrpStrDup("Field name for PHIDP.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &PHIDP_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("PHIDP");
    tt++;
    
    // Parameter 'RHOHV_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("RHOHV_field_name");
    tt->descr = tdrpStrDup("Field name for RHOHV.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &RHOHV_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("RHOHV");
    tt++;
    
    // Parameter 'LDR_available'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("LDR_available");
    tt->descr = tdrpStrDup("Is LDR data available?");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &LDR_available - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'LDR_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("LDR_field_name");
    tt->descr = tdrpStrDup("Field name for LDR.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &LDR_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("LDR");
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("COMPUTING KDP");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'KDP_params_file_path'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("KDP_params_file_path");
    tt->descr = tdrpStrDup("Path for parameters for computing KDP.");
    tt->help = tdrpStrDup("If set to use-defaults, no parameter file will be read in, and the default parameters will be used.");
    tt->val_offset = (char *) &KDP_params_file_path - &_start_;
    tt->single_val.s = tdrpStrDup("use-defaults");
    tt++;
    
    // Parameter 'KDP_write_debug_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("KDP_write_debug_fields");
    tt->descr = tdrpStrDup("Write extra fields to assist with KDP debugging.");
    tt->help = tdrpStrDup("These are the intermediate fields used in computing KDP and attenuation.");
    tt->val_offset = (char *) &KDP_write_debug_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("COMPUTING PID");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'PID_params_file_path'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("PID_params_file_path");
    tt->descr = tdrpStrDup("Path for parameters for computing PID.");
    tt->help = tdrpStrDup("If set to use-defaults, no parameter file will be read in, and the default parameters will be used.");
    tt->val_offset = (char *) &PID_params_file_path - &_start_;
    tt->single_val.s = tdrpStrDup("use-defaults");
    tt++;
    
    // Parameter 'PID_use_KDP_self_consistency'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("PID_use_KDP_self_consistency");
    tt->descr = tdrpStrDup("When computing PID, using KDP conditioned for self-consistency.");
    tt->help = tdrpStrDup("When KDP is computed, we compute both a standard result, and a conditioned result based on the self-consistency method. If this parameter is set to TRUE, the self-consistency result will be used instead of the standard result.");
    tt->val_offset = (char *) &PID_use_KDP_self_consistency - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'PID_use_attenuation_corrected_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("PID_use_attenuation_corrected_fields");
    tt->descr = tdrpStrDup("Option to use Z and ZDR fields that are corrected for attenuation.");
    tt->help = tdrpStrDup("If TRUE, the attenuation-corrected Z and ZDR fields will be used for computing PID.");
    tt->val_offset = (char *) &PID_use_attenuation_corrected_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'PID_write_debug_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("PID_write_debug_fields");
    tt->descr = tdrpStrDup("Write extra fields to assist with PID debugging.");
    tt->help = tdrpStrDup("These are the intermediate fields used in computing PID.");
    tt->val_offset = (char *) &PID_write_debug_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("COMPUTING PRECIP RATE");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'RATE_params_file_path'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("RATE_params_file_path");
    tt->descr = tdrpStrDup("Path for parameters for computing PRECIP.");
    tt->help = tdrpStrDup("If set to use-defaults, no parameter file will be read in, and the default parameters will be used.");
    tt->val_offset = (char *) &RATE_params_file_path - &_start_;
    tt->single_val.s = tdrpStrDup("use-defaults");
    tt++;
    
    // Parameter 'RATE_use_KDP_self_consistency'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("RATE_use_KDP_self_consistency");
    tt->descr = tdrpStrDup("When computing PRECIP, using KDP conditioned for self-consistency.");
    tt->help = tdrpStrDup("When KDP is computed, we compute both a standard result, and a conditioned result based on the self-consistency method. If this parameter is set to TRUE, the self-consistency result will be used instead of the standard result.");
    tt->val_offset = (char *) &RATE_use_KDP_self_consistency - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'RATE_use_attenuation_corrected_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("RATE_use_attenuation_corrected_fields");
    tt->descr = tdrpStrDup("Option to use Z and ZDR fields that are corrected for attenuation.");
    tt->help = tdrpStrDup("If TRUE, the attenuation-corrected Z and ZDR fields will be used for computing PRECIP.");
    tt->val_offset = (char *) &RATE_use_attenuation_corrected_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("SPECIFYING PID OUTPUT FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'pid_output_fields'
    // ctype is '_pid_output_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("pid_output_fields");
    tt->descr = tdrpStrDup("Indicate which fields should be written to the output file.");
    tt->help = tdrpStrDup("Choose the ID from the list.\n\nThe name and units can be set however the user prefers.\n\nThe output_encoding apply to CfRadial output only. \n\n\tRATE_ZH: Precip rate from ZH\n\tRATE_ZH_SNOW: Precip rate from ZH in dry snow\n\tRATE_Z_ZDR: Precip rate from Z and ZDR\n\tRATE_KDP: Precip rate from KDP\n\tRATE_KDP_ZDR: Precip rate from KDP and ZDR\n\tRATE_HYBRID: Precip rate from NCAR hybrid\n\tRATE_PID: Precip rate using PID to select the appropriate rate\n\tRATE_HIDRO: Precip rate using CSU HIDRO hybrid\n\tRATE_BRINGI: Precip rate using Bringi hybrid\n\tPID: NCAR Particle ID\n\tPID_INTEREST: final interest map for NCAR Particle ID values\n\tTEMP_FOR_PID: temperature field for PID (C)\n\tKDP: KDP from filtering PHIDP and computing slope (deg/km)\n\tKDP_SC: KDP conditioned using ZZDR self-consistency (deg/km)\n\tDBZ_ATTEN_CORRECTION: DBZ attenuation correction (dB)\n\tZDR_ATTEN_CORRECTION: ZDR attenuation correction (dB)\n\tDBZ_ATTEN_CORRECTED: DBZ corrected for attenuation (dBZ)\n\tZDR_ATTEN_CORRECTED: ZDR corrected for attenuation (dB)\n");
    tt->array_offset = (char *) &_pid_output_fields - &_start_;
    tt->array_n_offset = (char *) &pid_output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(pid_output_field_t);
    tt->array_n = 15;
    tt->struct_def.name = tdrpStrDup("pid_output_field_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("pid_output_field_id_t");
      tt->struct_def.fields[0].fname = tdrpStrDup("id");
      tt->struct_def.fields[0].ptype = ENUM_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_pid_output_fields->id - (char *) _pid_output_fields;
        tt->struct_def.fields[0].enum_def.name = tdrpStrDup("pid_output_field_id_t");
        tt->struct_def.fields[0].enum_def.nfields = 18;
        tt->struct_def.fields[0].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[0].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[0].enum_def.fields[0].name = tdrpStrDup("RATE_ZH");
        tt->struct_def.fields[0].enum_def.fields[0].val = RATE_ZH;
        tt->struct_def.fields[0].enum_def.fields[1].name = tdrpStrDup("RATE_ZH_SNOW");
        tt->struct_def.fields[0].enum_def.fields[1].val = RATE_ZH_SNOW;
        tt->struct_def.fields[0].enum_def.fields[2].name = tdrpStrDup("RATE_Z_ZDR");
        tt->struct_def.fields[0].enum_def.fields[2].val = RATE_Z_ZDR;
        tt->struct_def.fields[0].enum_def.fields[3].name = tdrpStrDup("RATE_KDP");
        tt->struct_def.fields[0].enum_def.fields[3].val = RATE_KDP;
        tt->struct_def.fields[0].enum_def.fields[4].name = tdrpStrDup("RATE_KDP_ZDR");
        tt->struct_def.fields[0].enum_def.fields[4].val = RATE_KDP_ZDR;
        tt->struct_def.fields[0].enum_def.fields[5].name = tdrpStrDup("RATE_HYBRID");
        tt->struct_def.fields[0].enum_def.fields[5].val = RATE_HYBRID;
        tt->struct_def.fields[0].enum_def.fields[6].name = tdrpStrDup("RATE_PID");
        tt->struct_def.fields[0].enum_def.fields[6].val = RATE_PID;
        tt->struct_def.fields[0].enum_def.fields[7].name = tdrpStrDup("RATE_HIDRO");
        tt->struct_def.fields[0].enum_def.fields[7].val = RATE_HIDRO;
        tt->struct_def.fields[0].enum_def.fields[8].name = tdrpStrDup("RATE_BRINGI");
        tt->struct_def.fields[0].enum_def.fields[8].val = RATE_BRINGI;
        tt->struct_def.fields[0].enum_def.fields[9].name = tdrpStrDup("PID");
        tt->struct_def.fields[0].enum_def.fields[9].val = PID;
        tt->struct_def.fields[0].enum_def.fields[10].name = tdrpStrDup("PID_INTEREST");
        tt->struct_def.fields[0].enum_def.fields[10].val = PID_INTEREST;
        tt->struct_def.fields[0].enum_def.fields[11].name = tdrpStrDup("TEMP_FOR_PID");
        tt->struct_def.fields[0].enum_def.fields[11].val = TEMP_FOR_PID;
        tt->struct_def.fields[0].enum_def.fields[12].name = tdrpStrDup("KDP");
        tt->struct_def.fields[0].enum_def.fields[12].val = KDP;
        tt->struct_def.fields[0].enum_def.fields[13].name = tdrpStrDup("KDP_SC");
        tt->struct_def.fields[0].enum_def.fields[13].val = KDP_SC;
        tt->struct_def.fields[0].enum_def.fields[14].name = tdrpStrDup("DBZ_ATTEN_CORRECTION");
        tt->struct_def.fields[0].enum_def.fields[14].val = DBZ_ATTEN_CORRECTION;
        tt->struct_def.fields[0].enum_def.fields[15].name = tdrpStrDup("ZDR_ATTEN_CORRECTION");
        tt->struct_def.fields[0].enum_def.fields[15].val = ZDR_ATTEN_CORRECTION;
        tt->struct_def.fields[0].enum_def.fields[16].name = tdrpStrDup("DBZ_ATTEN_CORRECTED");
        tt->struct_def.fields[0].enum_def.fields[16].val = DBZ_ATTEN_CORRECTED;
        tt->struct_def.fields[0].enum_def.fields[17].name = tdrpStrDup("ZDR_ATTEN_CORRECTED");
        tt->struct_def.fields[0].enum_def.fields[17].val = ZDR_ATTEN_CORRECTED;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_pid_output_fields->name - (char *) _pid_output_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("long_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_pid_output_fields->long_name - (char *) _pid_output_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("standard_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_pid_output_fields->standard_name - (char *) _pid_output_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("units");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_pid_output_fields->units - (char *) _pid_output_fields;
      tt->struct_def.fields[5].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[5].fname = tdrpStrDup("do_write");
      tt->struct_def.fields[5].ptype = BOOL_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_pid_output_fields->do_write - (char *) _pid_output_fields;
    tt->n_struct_vals = 90;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].e = RATE_ZH;
      tt->struct_vals[1].s = tdrpStrDup("RATE_ZH");
      tt->struct_vals[2].s = tdrpStrDup("precip_rate_from_z");
      tt->struct_vals[3].s = tdrpStrDup("precip_rate_from_z");
      tt->struct_vals[4].s = tdrpStrDup("mm/hr");
      tt->struct_vals[5].b = pTRUE;
      tt->struct_vals[6].e = RATE_ZH_SNOW;
      tt->struct_vals[7].s = tdrpStrDup("RATE_ZH_SNOW");
      tt->struct_vals[8].s = tdrpStrDup("precip_rate_from_z_for_snow");
      tt->struct_vals[9].s = tdrpStrDup("precip_rate_from_z_for_snow");
      tt->struct_vals[10].s = tdrpStrDup("mm/hr");
      tt->struct_vals[11].b = pTRUE;
      tt->struct_vals[12].e = RATE_Z_ZDR;
      tt->struct_vals[13].s = tdrpStrDup("RATE_Z_ZDR");
      tt->struct_vals[14].s = tdrpStrDup("precip_rate_from_z_and_zdr");
      tt->struct_vals[15].s = tdrpStrDup("precip_rate_from_z_and_zdr");
      tt->struct_vals[16].s = tdrpStrDup("mm/hr");
      tt->struct_vals[17].b = pTRUE;
      tt->struct_vals[18].e = RATE_KDP;
      tt->struct_vals[19].s = tdrpStrDup("RATE_KDP");
      tt->struct_vals[20].s = tdrpStrDup("precip_rate_from_kdp");
      tt->struct_vals[21].s = tdrpStrDup("precip_rate_from_kdp");
      tt->struct_vals[22].s = tdrpStrDup("mm/hr");
      tt->struct_vals[23].b = pTRUE;
      tt->struct_vals[24].e = RATE_KDP_ZDR;
      tt->struct_vals[25].s = tdrpStrDup("RATE_KDP_ZDR");
      tt->struct_vals[26].s = tdrpStrDup("precip_rate_from_kdp_and_zdr");
      tt->struct_vals[27].s = tdrpStrDup("precip_rate_from_kdp_and_zdr");
      tt->struct_vals[28].s = tdrpStrDup("mm/hr");
      tt->struct_vals[29].b = pTRUE;
      tt->struct_vals[30].e = RATE_HYBRID;
      tt->struct_vals[31].s = tdrpStrDup("RATE_HYBRID");
      tt->struct_vals[32].s = tdrpStrDup("precip_rate_hybrid_of_zh_zzdr_kdp_and_kdpzdr");
      tt->struct_vals[33].s = tdrpStrDup("precip_rate_hybrid_of_zh_zzdr_kdp_and_kdpzdr");
      tt->struct_vals[34].s = tdrpStrDup("mm/hr");
      tt->struct_vals[35].b = pTRUE;
      tt->struct_vals[36].e = RATE_PID;
      tt->struct_vals[37].s = tdrpStrDup("RATE_PID");
      tt->struct_vals[38].s = tdrpStrDup("precip_rate_based_on_pid");
      tt->struct_vals[39].s = tdrpStrDup("precip_rate_based_on_pid");
      tt->struct_vals[40].s = tdrpStrDup("mm/hr");
      tt->struct_vals[41].b = pTRUE;
      tt->struct_vals[42].e = PID;
      tt->struct_vals[43].s = tdrpStrDup("PID");
      tt->struct_vals[44].s = tdrpStrDup("particle_id");
      tt->struct_vals[45].s = tdrpStrDup("hydrometeor_type");
      tt->struct_vals[46].s = tdrpStrDup("");
      tt->struct_vals[47].b = pTRUE;
      tt->struct_vals[48].e = PID_INTEREST;
      tt->struct_vals[49].s = tdrpStrDup("PID_INTEREST");
      tt->struct_vals[50].s = tdrpStrDup("final_interest_value_for_pid_decision");
      tt->struct_vals[51].s = tdrpStrDup("final_interest_value_for_pid_decision");
      tt->struct_vals[52].s = tdrpStrDup("");
      tt->struct_vals[53].b = pFALSE;
      tt->struct_vals[54].e = TEMP_FOR_PID;
      tt->struct_vals[55].s = tdrpStrDup("TEMP_FOR_PID");
      tt->struct_vals[56].s = tdrpStrDup("temperature_for_computing_pid");
      tt->struct_vals[57].s = tdrpStrDup("temperature");
      tt->struct_vals[58].s = tdrpStrDup("C");
      tt->struct_vals[59].b = pFALSE;
      tt->struct_vals[60].e = KDP;
      tt->struct_vals[61].s = tdrpStrDup("KDP");
      tt->struct_vals[62].s = tdrpStrDup("specific_differential_phase");
      tt->struct_vals[63].s = tdrpStrDup("specific_differential_phase_hv");
      tt->struct_vals[64].s = tdrpStrDup("deg/km");
      tt->struct_vals[65].b = pTRUE;
      tt->struct_vals[66].e = KDP_SC;
      tt->struct_vals[67].s = tdrpStrDup("KDP_SC");
      tt->struct_vals[68].s = tdrpStrDup("kdp_conditioned_using_ZZDR_self_consistency");
      tt->struct_vals[69].s = tdrpStrDup("specific_differential_phase_hv");
      tt->struct_vals[70].s = tdrpStrDup("deg/km");
      tt->struct_vals[71].b = pFALSE;
      tt->struct_vals[72].e = ZDR_ATTEN_CORRECTION;
      tt->struct_vals[73].s = tdrpStrDup("ZDR_ATTEN_CORRECTION");
      tt->struct_vals[74].s = tdrpStrDup("correction_to_zdr_for_attenuation");
      tt->struct_vals[75].s = tdrpStrDup("zdr_attenuation_correction");
      tt->struct_vals[76].s = tdrpStrDup("dB");
      tt->struct_vals[77].b = pFALSE;
      tt->struct_vals[78].e = DBZ_ATTEN_CORRECTED;
      tt->struct_vals[79].s = tdrpStrDup("DBZ_ATTEN_CORRECTED");
      tt->struct_vals[80].s = tdrpStrDup("dbz_corrected_for_attenuation");
      tt->struct_vals[81].s = tdrpStrDup("dbz_corrected_for_attenuation");
      tt->struct_vals[82].s = tdrpStrDup("dBZ");
      tt->struct_vals[83].b = pFALSE;
      tt->struct_vals[84].e = ZDR_ATTEN_CORRECTED;
      tt->struct_vals[85].s = tdrpStrDup("ZDR_ATTEN_CORRECTED");
      tt->struct_vals[86].s = tdrpStrDup("zdr_corrected_for_attenuation");
      tt->struct_vals[87].s = tdrpStrDup("zdr_corrected_for_attenuation");
      tt->struct_vals[88].s = tdrpStrDup("dB");
      tt->struct_vals[89].b = pFALSE;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("INTERPOLATION OPTIONS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_nearest_neighbor'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_nearest_neighbor");
    tt->descr = tdrpStrDup("Option to use nearest neighbor method instead of 3D linear interpolation.");
    tt->help = tdrpStrDup("If true, use the values from the nearest point instead of interpolating between the measured points that surround the grid point.");
    tt->val_offset = (char *) &use_nearest_neighbor - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'min_nvalid_for_interp'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_nvalid_for_interp");
    tt->descr = tdrpStrDup("Minimum number of valid data points for theinterpolation.");
    tt->help = tdrpStrDup("The program performs an 8-point linear interpolation. This is the number of valid data points, out of the possible 8, which must be present for interpolation to proceed. A high number will exclude marginal points. A low number will include marginal points.");
    tt->val_offset = (char *) &min_nvalid_for_interp - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 1;
    tt->max_val.i = 8;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'use_fixed_angle_for_interpolation'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_fixed_angle_for_interpolation");
    tt->descr = tdrpStrDup("Option to use the fixed sweep angle for determining position for interpolation.");
    tt->help = tdrpStrDup("If false, we use the measured elevaiton and azimuth for each ray. If true, we use the fixed angle instead of the elevation angle in PPI scan mode and the fixed angle instead of azimuth in RHI mode.");
    tt->val_offset = (char *) &use_fixed_angle_for_interpolation - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'use_fixed_angle_for_data_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_fixed_angle_for_data_limits");
    tt->descr = tdrpStrDup("Option to use the fixed sweep angle for determining the angle limits of the data.");
    tt->help = tdrpStrDup("If true, we use the scan strategy sweep fixed angle for determining the angular limits to the data. If false, we use the actual measured angles. We need to find the data limits so that we can extend the interpolation by a fraction of the beam width beyond the angular limits. See also 'beam_width_fraction_for_data_limit_extension'.");
    tt->val_offset = (char *) &use_fixed_angle_for_data_limits - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'beam_width_fraction_for_data_limit_extension'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("beam_width_fraction_for_data_limit_extension");
    tt->descr = tdrpStrDup("Fraction of the beam width used to extend the data beyond the observed limits.");
    tt->help = tdrpStrDup("At the edges of the observed region, the interpolated data is extended by an angle computed as beam_width * fraction. For extending below the lowest tilt and above the upper tilt, the vertical beam width is used. For extended to the left or right of sector limits, the horizontal beam width is used.");
    tt->val_offset = (char *) &beam_width_fraction_for_data_limit_extension - &_start_;
    tt->single_val.d = 0.5;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("CARTESIAN GRID VERTICAL LEVELS");
    tt->comment_text = tdrpStrDup("\nSet the vertical levels for the Cartesian grid.\n\nYou can either specify a grid with constant vertial spacing, or you can provide an array of heights. The latter allows you to specify a grid with irregular vertical spacing.");
    tt++;
    
    // Parameter 'grid_z_geom'
    // ctype is '_grid_z_geom_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("grid_z_geom");
    tt->descr = tdrpStrDup("Specifying regular vertical grid levels.");
    tt->help = tdrpStrDup("\tnz is the number of levels.\n\tdz is constant spacing of the Z levels, in km.\n\tminz is the lowest level, in km MSL.\n\nNOTE: Applies if specify_individual_z_levels is false.");
    tt->val_offset = (char *) &grid_z_geom - &_start_;
    tt->struct_def.name = tdrpStrDup("grid_z_geom_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nz");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &grid_z_geom.nz - (char *) &grid_z_geom;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("minz");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &grid_z_geom.minz - (char *) &grid_z_geom;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("dz");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &grid_z_geom.dz - (char *) &grid_z_geom;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 20;
      tt->struct_vals[1].d = 0.5;
      tt->struct_vals[2].d = 1;
    tt++;
    
    // Parameter 'specify_individual_z_levels'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("specify_individual_z_levels");
    tt->descr = tdrpStrDup("Option to specify each Z level individually.");
    tt->help = tdrpStrDup("If true, you will fill out the z_level array to specify each Z level. This allows you to set up a grid with unequal spacing in the vertical. If false, use grid_z_geom to specify Z levels at constant spacing.");
    tt->val_offset = (char *) &specify_individual_z_levels - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'z_level_array'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("z_level_array");
    tt->descr = tdrpStrDup("Array of grid levels, in km MSL.");
    tt->help = tdrpStrDup("This applies if specify_individual_z_levels is true.");
    tt->array_offset = (char *) &_z_level_array - &_start_;
    tt->array_n_offset = (char *) &z_level_array_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(double);
    tt->array_n = 13;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].d = 0.5;
      tt->array_vals[1].d = 1;
      tt->array_vals[2].d = 1.5;
      tt->array_vals[3].d = 2;
      tt->array_vals[4].d = 2.5;
      tt->array_vals[5].d = 3;
      tt->array_vals[6].d = 4;
      tt->array_vals[7].d = 5;
      tt->array_vals[8].d = 6;
      tt->array_vals[9].d = 7;
      tt->array_vals[10].d = 8;
      tt->array_vals[11].d = 9;
      tt->array_vals[12].d = 10;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("CARTESIAN GRID XY DETAILS");
    tt->comment_text = tdrpStrDup("Specify the grid details in (x,y). This will be a regular Cartesian grid. The units for the grid paramters are in (km,km) for all projections except for PROJ_LATLON. For the LATLON projection, the units are in (deg,deg).");
    tt++;
    
    // Parameter 'grid_xy_geom'
    // ctype is '_grid_xy_geom_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("grid_xy_geom");
    tt->descr = tdrpStrDup("Specify the grid parameters in x,y.");
    tt->help = tdrpStrDup("\tnx: the number of grid points in the X dimension.\n\tny: the number of grid points in the Y dimension.\n\tminx: the X coordinate of the center of the SW grid cell.\n\tminy: the Y coordinate of the center of the SW grid cell.\n\tdx: the grid spacing in the X dimension.\n\tdy: the grid spacing in the Y dimension.\n\nUnits are in km, except for PROJ_LATLON, which has units in degrees.");
    tt->val_offset = (char *) &grid_xy_geom - &_start_;
    tt->struct_def.name = tdrpStrDup("grid_xy_geom_t");
    tt->struct_def.nfields = 6;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nx");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &grid_xy_geom.nx - (char *) &grid_xy_geom;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("ny");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &grid_xy_geom.ny - (char *) &grid_xy_geom;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("minx");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &grid_xy_geom.minx - (char *) &grid_xy_geom;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("miny");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &grid_xy_geom.miny - (char *) &grid_xy_geom;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("dx");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &grid_xy_geom.dx - (char *) &grid_xy_geom;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("dy");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &grid_xy_geom.dy - (char *) &grid_xy_geom;
    tt->n_struct_vals = 6;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 400;
      tt->struct_vals[1].i = 400;
      tt->struct_vals[2].d = -199.5;
      tt->struct_vals[3].d = -199.5;
      tt->struct_vals[4].d = 1;
      tt->struct_vals[5].d = 1;
    tt++;
    
    // Parameter 'center_grid_on_radar'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("center_grid_on_radar");
    tt->descr = tdrpStrDup("Option to set the grid origin at the radar.");
    tt->help = tdrpStrDup("If true, the latitude and longitude of the grid origin will be set to the radar location. If false, grid_origin_lat and grid_origin_lon will be used. This parameter is not applicable for moving platforms.");
    tt->val_offset = (char *) &center_grid_on_radar - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("CARTESIAN GRID PROJECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'grid_projection'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("grid_projection");
    tt->descr = tdrpStrDup("Projection details for the Cartesian grid..");
    tt->help = tdrpStrDup("\tPROJ_LATLON: regular lat/lon grid (Equidistant Cylindrical)\n\tPROJ_FLAT: Azimuthal Equidistant (Radar)\n\tPROJ_LAMBERT_CONF: Lambert Conformal Conic\n\tPROJ_LAMBERT_AZIM: Lambert Azimuthal Equal Area\n\tPROJ_MERCATOR: Mercator - EW orientation\n\tPROJ_TRANS_MERCATOR: Tranverse Mercator - NS orientation\n\tPROJ_POLAR_STEREO: Stereographic- polar aspect\n\tPROJ_OBLIQUE_STEREO: Stereographic - oblique aspect\n\tPROJ_ALBERS: Albers Equal Area Conic\n\tPROJ_VERT_PERSP: Vertical Perspective (satellite view)\n\n");
    tt->val_offset = (char *) &grid_projection - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 10;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_LATLON");
      tt->enum_def.fields[0].val = PROJ_LATLON;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_LAMBERT_CONF");
      tt->enum_def.fields[1].val = PROJ_LAMBERT_CONF;
      tt->enum_def.fields[2].name = tdrpStrDup("PROJ_MERCATOR");
      tt->enum_def.fields[2].val = PROJ_MERCATOR;
      tt->enum_def.fields[3].name = tdrpStrDup("PROJ_POLAR_STEREO");
      tt->enum_def.fields[3].val = PROJ_POLAR_STEREO;
      tt->enum_def.fields[4].name = tdrpStrDup("PROJ_FLAT");
      tt->enum_def.fields[4].val = PROJ_FLAT;
      tt->enum_def.fields[5].name = tdrpStrDup("PROJ_OBLIQUE_STEREO");
      tt->enum_def.fields[5].val = PROJ_OBLIQUE_STEREO;
      tt->enum_def.fields[6].name = tdrpStrDup("PROJ_TRANS_MERCATOR");
      tt->enum_def.fields[6].val = PROJ_TRANS_MERCATOR;
      tt->enum_def.fields[7].name = tdrpStrDup("PROJ_ALBERS");
      tt->enum_def.fields[7].val = PROJ_ALBERS;
      tt->enum_def.fields[8].name = tdrpStrDup("PROJ_LAMBERT_AZIM");
      tt->enum_def.fields[8].val = PROJ_LAMBERT_AZIM;
      tt->enum_def.fields[9].name = tdrpStrDup("PROJ_VERT_PERSP");
      tt->enum_def.fields[9].val = PROJ_VERT_PERSP;
    tt->single_val.e = PROJ_FLAT;
    tt++;
    
    // Parameter 'grid_rotation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_rotation");
    tt->descr = tdrpStrDup("Grid rotation.");
    tt->help = tdrpStrDup("This applies only to PROJ_FLAT projection.");
    tt->val_offset = (char *) &grid_rotation - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_origin_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_origin_lat");
    tt->descr = tdrpStrDup("Grid origin latitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.\n\nIf 'center_grid_on_radar' is true, the radar location is used instead.");
    tt->val_offset = (char *) &grid_origin_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_origin_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_origin_lon");
    tt->descr = tdrpStrDup("Grid origin longitude.");
    tt->help = tdrpStrDup("This applies to all projections except LATLON.\n\nIf 'center_grid_on_radar' is true, the radar location is used instead.");
    tt->val_offset = (char *) &grid_origin_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'auto_remap_flat_to_latlon'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_remap_flat_to_latlon");
    tt->descr = tdrpStrDup("Option to first interpolate to a PROJ_FLAT projection, and then automatically remap to a latlon projection on output.");
    tt->help = tdrpStrDup("If TRUE, before writing the file, the app will choose a latlon grid that matches the FLAT grid extent and rsolution, and automatically remap to a PROJ_LATLON projection.");
    tt->val_offset = (char *) &auto_remap_flat_to_latlon - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'grid_lat1'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_lat1");
    tt->descr = tdrpStrDup("Grid reference latitude 1.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &grid_lat1 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_lat2'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_lat2");
    tt->descr = tdrpStrDup("Grid reference latitude 2.");
    tt->help = tdrpStrDup("This applies to LAMBERT_CONF and ALBERS projections.");
    tt->val_offset = (char *) &grid_lat2 - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_central_scale'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_central_scale");
    tt->descr = tdrpStrDup("Central scale for projections.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO, OBLIQUE_STEREO and TRANSVERSE_MERCATOR projections.");
    tt->val_offset = (char *) &grid_central_scale - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'grid_tangent_lat'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_tangent_lat");
    tt->descr = tdrpStrDup("Tangent latitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO only.");
    tt->val_offset = (char *) &grid_tangent_lat - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_tangent_lon'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_tangent_lon");
    tt->descr = tdrpStrDup("Tangent longitude (deg).");
    tt->help = tdrpStrDup("This applies to OBLIQUE_STEREO and POLAR_STEREO.");
    tt->val_offset = (char *) &grid_tangent_lon - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_pole_is_north'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("grid_pole_is_north");
    tt->descr = tdrpStrDup("Flag indicating stereogtraphic is over the NORTH pole.");
    tt->help = tdrpStrDup("This applies to POLAR_STEREO. If false, the projection is over the south pole.");
    tt->val_offset = (char *) &grid_pole_is_north - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'grid_persp_radius'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_persp_radius");
    tt->descr = tdrpStrDup("Radius of perspective point (km).");
    tt->help = tdrpStrDup("This applies to VERT_PERSP.");
    tt->val_offset = (char *) &grid_persp_radius - &_start_;
    tt->single_val.d = 35786;
    tt++;
    
    // Parameter 'grid_false_northing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_false_northing");
    tt->descr = tdrpStrDup("False northing correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the Y coordinate so that all coordinates are positive. Normally 0. As an alternative to false_northing and false_easting, you can set the offset_latitude and offset_longitude");
    tt->val_offset = (char *) &grid_false_northing - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_false_easting'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_false_easting");
    tt->descr = tdrpStrDup("False easting correction.");
    tt->help = tdrpStrDup("Occasionally, this is added to the X coordinate so that all coordinates are positive. Normally 0.");
    tt->val_offset = (char *) &grid_false_easting - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_set_offset_origin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("grid_set_offset_origin");
    tt->descr = tdrpStrDup("Do you want to specify an offset origin using lat/lon instead of false_northing and false_easting?");
    tt->help = tdrpStrDup("If true, set grid_offset_origin_latitude and grid_offset_origin_longitude.");
    tt->val_offset = (char *) &grid_set_offset_origin - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'grid_offset_origin_latitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_offset_origin_latitude");
    tt->descr = tdrpStrDup("Latitude of offset origin.");
    tt->help = tdrpStrDup("See grid_set_offset_origin.");
    tt->val_offset = (char *) &grid_offset_origin_latitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'grid_offset_origin_longitude'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("grid_offset_origin_longitude");
    tt->descr = tdrpStrDup("Longitude of offset origin.");
    tt->help = tdrpStrDup("See grid_set_offset_origin.");
    tt->val_offset = (char *) &grid_offset_origin_longitude - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("SPECIFY COPY-THROUGH FIELDS");
    tt->comment_text = tdrpStrDup("These input fields are read from the input file and added to the interpolated output. This allows the user to consolidate the input and output data set in a single file.");
    tt++;
    
    // Parameter 'copy_selected_input_fields_to_output'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("copy_selected_input_fields_to_output");
    tt->descr = tdrpStrDup("Option to copy input fields unchanged to the output file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &copy_selected_input_fields_to_output - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'copy_fields'
    // ctype is '_copy_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("copy_fields");
    tt->descr = tdrpStrDup("These fields are copied through unchanged, and then interpolated.");
    tt->help = tdrpStrDup("Optionally you can censor the non-weather echoes, based on the PID.");
    tt->array_offset = (char *) &_copy_fields - &_start_;
    tt->array_n_offset = (char *) &copy_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(copy_field_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("copy_field_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_copy_fields->field_name - (char *) _copy_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("censor_non_weather");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_copy_fields->censor_non_weather - (char *) _copy_fields;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("DBZ");
      tt->struct_vals[1].b = pFALSE;
      tt->struct_vals[2].s = tdrpStrDup("VEL");
      tt->struct_vals[3].b = pFALSE;
    tt++;
    
    // Parameter 'Comment 15'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 15");
    tt->comment_hdr = tdrpStrDup("OPTION TO SET FOLDING LIMITS ON SELECTED FIELDS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_fold_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_fold_limits");
    tt->descr = tdrpStrDup("Option to set the folding limits for individual fields.");
    tt->help = tdrpStrDup("The limits are set prior to interpolation.\n\nIf TRUE, fold limits will be set for the specified fields. You should do this for fields such as VELOCITY and PHIDP. Some CfRadial files already contain the fold limits as attributes on the field - for these fields you do not need to set fold limits, unless you wish to override what is in the file. You only need to specify the limits if the file does not already have these attributes. The field_folds parameter can be set to FALSE to override an attribute set in the data file.");
    tt->val_offset = (char *) &set_fold_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'folded_fields'
    // ctype is '_fold_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("folded_fields");
    tt->descr = tdrpStrDup("Use this to set the fold limits for a particular field.");
    tt->help = tdrpStrDup("If this is specified, the interpolation for this field will be performed 'on the circle' so that folding is handled correctly. If use_global_nyquist is true, the fold limits are set to plus and minus the main nyquist velocity. If false, the fold limits specified here are used instead.\n\nNOTE: 'field_name' for this step refers to the 'field_name' in 'select_fields' and 'output_name' in 'transform_fields'. This step is performed prior to renaming fields (see below).");
    tt->array_offset = (char *) &_folded_fields - &_start_;
    tt->array_n_offset = (char *) &folded_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(fold_field_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("fold_field_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_folded_fields->field_name - (char *) _folded_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("field_folds");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_folded_fields->field_folds - (char *) _folded_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[2].fname = tdrpStrDup("use_global_nyquist");
      tt->struct_def.fields[2].ptype = BOOL_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_folded_fields->use_global_nyquist - (char *) _folded_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("fold_limit_lower");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_folded_fields->fold_limit_lower - (char *) _folded_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("fold_limit_upper");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_folded_fields->fold_limit_upper - (char *) _folded_fields;
    tt->n_struct_vals = 5;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("VEL");
      tt->struct_vals[1].b = pTRUE;
      tt->struct_vals[2].b = pTRUE;
      tt->struct_vals[3].d = -25;
      tt->struct_vals[4].d = 25;
    tt++;
    
    // Parameter 'Comment 16'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 16");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE THE NYQUIST VELOCITY");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_nyquist'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_nyquist");
    tt->descr = tdrpStrDup("Option to override nyquist velocity in incoming data.");
    tt->help = tdrpStrDup("If true, the nyquist_velocity parameter is used to specify the nyquist. If false, the nyquist is computed from the incoming radar data stream. The nyquist is used for velocity interpolation, to ensure that folded values are treated correctlty.");
    tt->val_offset = (char *) &override_nyquist - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'nyquist_velocity'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("nyquist_velocity");
    tt->descr = tdrpStrDup("Specify nyquist velocity (m/s).");
    tt->help = tdrpStrDup("See 'override_nyquist'.");
    tt->val_offset = (char *) &nyquist_velocity - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'Comment 17'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 17");
    tt->comment_hdr = tdrpStrDup("OPTION TO ADD GEOMETRY AND TIME FIELDS");
    tt->comment_text = tdrpStrDup("These fields are computed from the geometry of the radar rays, and then added as input fields in native radial coordinates.");
    tt++;
    
    // Parameter 'output_angle_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_angle_fields");
    tt->descr = tdrpStrDup("Option to output angle fields.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_angle_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'angle_fields'
    // ctype is '_angle_fields_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("angle_fields");
    tt->descr = tdrpStrDup("Specify the output names of the angle fields. If set to empty, that field will not be created.");
    tt->help = tdrpStrDup("\tazimuth: the azimuth of the ray (deg)\n\televation: the elevation of the ray (deg)\n\talpha: sin(az) * cos(el)\n\tbeta: cos(az) * cos(el)\n\tgamma: sin(el)\n");
    tt->val_offset = (char *) &angle_fields - &_start_;
    tt->struct_def.name = tdrpStrDup("angle_fields_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("azimuth_field_name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &angle_fields.azimuth_field_name - (char *) &angle_fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("elevation_field_name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &angle_fields.elevation_field_name - (char *) &angle_fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("alpha_field_name");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &angle_fields.alpha_field_name - (char *) &angle_fields;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("beta_field_name");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &angle_fields.beta_field_name - (char *) &angle_fields;
      tt->struct_def.fields[4].ftype = tdrpStrDup("string");
      tt->struct_def.fields[4].fname = tdrpStrDup("gamma_field_name");
      tt->struct_def.fields[4].ptype = STRING_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &angle_fields.gamma_field_name - (char *) &angle_fields;
    tt->n_struct_vals = 5;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("azimuth");
      tt->struct_vals[1].s = tdrpStrDup("elevation");
      tt->struct_vals[2].s = tdrpStrDup("alpha");
      tt->struct_vals[3].s = tdrpStrDup("beta");
      tt->struct_vals[4].s = tdrpStrDup("gamma");
    tt++;
    
    // Parameter 'output_range_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_range_field");
    tt->descr = tdrpStrDup("Option to add range field to the output.");
    tt->help = tdrpStrDup("This is the range, in km, from the radar to each gate.");
    tt->val_offset = (char *) &output_range_field - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'range_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("range_field_name");
    tt->descr = tdrpStrDup("Name of range field, if written.");
    tt->help = tdrpStrDup("See 'output_range_field'.");
    tt->val_offset = (char *) &range_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("range");
    tt++;
    
    // Parameter 'output_height_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_height_field");
    tt->descr = tdrpStrDup("Option to add height field to the output.");
    tt->help = tdrpStrDup("This is the height, in km msl, of the center of each gate.");
    tt->val_offset = (char *) &output_height_field - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'height_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("height_field_name");
    tt->descr = tdrpStrDup("Name of height field, if written.");
    tt->help = tdrpStrDup("See 'output_height_field'.");
    tt->val_offset = (char *) &height_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("height");
    tt++;
    
    // Parameter 'output_coverage_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_coverage_field");
    tt->descr = tdrpStrDup("Option to output a field indicating radar coverage.");
    tt->help = tdrpStrDup("This is a flag field, with a 1 indicating that the radar covers that location, and a 0 indicating that is does not. See also 'coverage_field_name'. This field is always transformed using nearest neighbor.");
    tt->val_offset = (char *) &output_coverage_field - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'coverage_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("coverage_field_name");
    tt->descr = tdrpStrDup("Name of coverage field, if written.");
    tt->help = tdrpStrDup("See 'output_coverage_field'.");
    tt->val_offset = (char *) &coverage_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("Coverage");
    tt++;
    
    // Parameter 'output_time_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_time_field");
    tt->descr = tdrpStrDup("Option to output a field of time since start of volume (secs)");
    tt->help = tdrpStrDup("If true, time time elapsed field is included in the output file. See also 'time_field_name' and 'interp_time_field'.");
    tt->val_offset = (char *) &output_time_field - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'time_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("time_field_name");
    tt->descr = tdrpStrDup("Name of time field, if written.");
    tt->help = tdrpStrDup("See 'output_time_field'.");
    tt->val_offset = (char *) &time_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("time_elapsed");
    tt++;
    
    // Parameter 'interp_time_field'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("interp_time_field");
    tt->descr = tdrpStrDup("Option to perform interpolation on the time field.");
    tt->help = tdrpStrDup("If false, nearest neighbor will be used for the time field.");
    tt->val_offset = (char *) &interp_time_field - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 18'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 18");
    tt->comment_hdr = tdrpStrDup("OPTION TO ADD DEBUG FIELDS");
    tt->comment_text = tdrpStrDup("The debug fields are added to the output Cartesian grid. These are geometry fields, and can be used to ensure the interpolation is working as expected.");
    tt++;
    
    // Parameter 'output_debug_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_debug_fields");
    tt->descr = tdrpStrDup("Option to add debug fields for checking the interpolation.");
    tt->help = tdrpStrDup("The test fields allow us to ensure that the interpolation is working correctly.\n\nThe debug fields are:\n\n\tnContrib - number of points used in interpolation\n\tgridAz: azimuth deg\n\tgridEl: elevation deg\n\tgridRange: range km\n\tllEl: lower left elevation deg\n\tllAz: lower left azimuth deg\n\tlrEl: lower right elevation deg\n\tlrAz: lower right azimuth deg\n\tulEl: upper left elevation deg\n\tulAz: upper left azimuth deg\n\turEl: upper right elevation deg\n\turAz: upper right azimuth deg");
    tt->val_offset = (char *) &output_debug_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 19'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 19");
    tt->comment_hdr = tdrpStrDup("SETTING THE PSEUDO EARTH RADIUS RATIO FOR HEIGHT COMPUTATIONS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_standard_pseudo_earth_radius'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_standard_pseudo_earth_radius");
    tt->descr = tdrpStrDup("Option to override the standard 4/3 earth radius model for refraction.");
    tt->help = tdrpStrDup("If true, the standard 4/3 earth radius will be overridden. The US NWS NEXRAD system uses 1.21 instead of 1.333.");
    tt->val_offset = (char *) &override_standard_pseudo_earth_radius - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'pseudo_earth_radius_ratio'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("pseudo_earth_radius_ratio");
    tt->descr = tdrpStrDup("Ratio for computing the pseudo earth radius for beam height computations.");
    tt->help = tdrpStrDup("For standard refraction this is 4/3. For super refraction it will be less than 4.3, and for sub-refraction it will be greater. NEXRAD uses 1.21.");
    tt->val_offset = (char *) &pseudo_earth_radius_ratio - &_start_;
    tt->single_val.d = 1.33333;
    tt++;
    
    // Parameter 'Comment 20'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 20");
    tt->comment_hdr = tdrpStrDup("FILE READ OPTIONS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'remove_long_range_rays'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_long_range_rays");
    tt->descr = tdrpStrDup("Option to remove long range rays.");
    tt->help = tdrpStrDup("Applies to NEXRAD data. If true, data from the non-Doppler long-range sweeps will be removed.");
    tt->val_offset = (char *) &remove_long_range_rays - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'remove_short_range_rays'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_short_range_rays");
    tt->descr = tdrpStrDup("Option to remove short range rays.");
    tt->help = tdrpStrDup("Applies to NEXRAD data. If true, data from the Doppler short-range sweeps will be removed.");
    tt->val_offset = (char *) &remove_short_range_rays - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'trim_surveillance_sweeps_to_360deg'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("trim_surveillance_sweeps_to_360deg");
    tt->descr = tdrpStrDup("Option to trip surveillance sweeps so that they only cover 360 degrees.");
    tt->help = tdrpStrDup("Some sweeps will have rays which cover more than a 360-degree rotation. Often these include antenna transitions. If this is set to true, rays are trimmed off either end of the sweep to limit the coverage to 360 degrees. The median elevation angle is computed and the end ray which deviates from the median in elevation is trimmed first.");
    tt->val_offset = (char *) &trim_surveillance_sweeps_to_360deg - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'override_fixed_angle_with_mean_measured_angle'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_fixed_angle_with_mean_measured_angle");
    tt->descr = tdrpStrDup("Option to override the fixed angle with the mean angle for a sweep.");
    tt->help = tdrpStrDup("If true, for each sweep the mean pointing angle is computed and then this is used to override the fixed angle.");
    tt->val_offset = (char *) &override_fixed_angle_with_mean_measured_angle - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'reorder_sweeps_by_ascending_angle'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("reorder_sweeps_by_ascending_angle");
    tt->descr = tdrpStrDup("Option to reorder sweeps by ascending angles.");
    tt->help = tdrpStrDup("If true, sweeps will be checked to see if they are in ascending angle order. If not they are reordered. If the sweeps are reordered, this means that the rays times will no longer be monotonically increasing");
    tt->val_offset = (char *) &reorder_sweeps_by_ascending_angle - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'compute_sweep_angles_from_vcp_tables'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("compute_sweep_angles_from_vcp_tables");
    tt->descr = tdrpStrDup("Option to compute sweep angles using the VCP tables when reading NEXRAD data.");
    tt->help = tdrpStrDup("If true, the VCP tables will be used to assign sweep angles. This is useful if rounding angles to fit the VCP is desired. For NEXRAD data files that don't follow a known VCP and the VCP header is not included, set this to false.");
    tt->val_offset = (char *) &compute_sweep_angles_from_vcp_tables - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 21'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 21");
    tt->comment_hdr = tdrpStrDup("SETTING LIMITS ON THE VALID DATA");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'set_max_range'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("set_max_range");
    tt->descr = tdrpStrDup("Option to set the max range for any ray.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &set_max_range - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'max_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("max_range_km");
    tt->descr = tdrpStrDup("Specified maximim range - km.");
    tt->help = tdrpStrDup("Gates beyond this range are removed.");
    tt->val_offset = (char *) &max_range_km - &_start_;
    tt->single_val.d = 9999;
    tt++;
    
    // Parameter 'Comment 22'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 22");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE RADAR LOCATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_radar_location'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_radar_location");
    tt->descr = tdrpStrDup("Option to override the radar location.");
    tt->help = tdrpStrDup("If true, the location in this file will be used. If not, the location in the time series data will be used.");
    tt->val_offset = (char *) &override_radar_location - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'radar_latitude_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_latitude_deg");
    tt->descr = tdrpStrDup("Radar latitude (deg).");
    tt->help = tdrpStrDup("See override_radar_location.");
    tt->val_offset = (char *) &radar_latitude_deg - &_start_;
    tt->single_val.d = -999;
    tt++;
    
    // Parameter 'radar_longitude_deg'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_longitude_deg");
    tt->descr = tdrpStrDup("Radar longitude (deg).");
    tt->help = tdrpStrDup("See override_radar_location.");
    tt->val_offset = (char *) &radar_longitude_deg - &_start_;
    tt->single_val.d = -999;
    tt++;
    
    // Parameter 'radar_altitude_meters'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("radar_altitude_meters");
    tt->descr = tdrpStrDup("Radar altitude (meters).");
    tt->help = tdrpStrDup("See override_radar_location.");
    tt->val_offset = (char *) &radar_altitude_meters - &_start_;
    tt->single_val.d = -999;
    tt++;
    
    // Parameter 'Comment 23'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 23");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE INSTRUMENT AND/OR SITE NAME");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'override_instrument_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_instrument_name");
    tt->descr = tdrpStrDup("Option to override the instrument name.");
    tt->help = tdrpStrDup("If true, the name provided will be used.");
    tt->val_offset = (char *) &override_instrument_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instrument_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instrument_name");
    tt->descr = tdrpStrDup("Instrument name.");
    tt->help = tdrpStrDup("See override_instrument_name.");
    tt->val_offset = (char *) &instrument_name - &_start_;
    tt->single_val.s = tdrpStrDup("unknown");
    tt++;
    
    // Parameter 'override_site_name'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_site_name");
    tt->descr = tdrpStrDup("Option to override the site name.");
    tt->help = tdrpStrDup("If true, the name provided will be used.");
    tt->val_offset = (char *) &override_site_name - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'site_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("site_name");
    tt->descr = tdrpStrDup("Site name.");
    tt->help = tdrpStrDup("See override_site_name.");
    tt->val_offset = (char *) &site_name - &_start_;
    tt->single_val.s = tdrpStrDup("unknown");
    tt++;
    
    // Parameter 'Comment 24'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 24");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE RADAR BEAM WIDTH");
    tt->comment_text = tdrpStrDup("The beam width is used to decide how far to extend the interpolated data beyond the observed data. The data is extended below the lowest tilt and above the highest tilt, and in the case of sector scans it is extended slightly beyond the sector limits.");
    tt++;
    
    // Parameter 'override_beam_width'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_beam_width");
    tt->descr = tdrpStrDup("Option to override radar beam width.");
    tt->help = tdrpStrDup("If TRUE, the program will use beam width specified in the 'beam_width_deg' parameter.");
    tt->val_offset = (char *) &override_beam_width - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'beam_width_deg_h'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("beam_width_deg_h");
    tt->descr = tdrpStrDup("Horizontal beam width if override is set true (deg).");
    tt->help = tdrpStrDup("Used for extending the data to the left or right of sector limits, if applicable. This is only used if 'override_beam_width' is set true. Otherwise the metadata in the input data stream is used.");
    tt->val_offset = (char *) &beam_width_deg_h - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'beam_width_deg_v'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("beam_width_deg_v");
    tt->descr = tdrpStrDup("Vertical beam width if override is set true (deg).");
    tt->help = tdrpStrDup("Used for extending data above or below the observed region. This only used if 'override_beam_width' is set true. Otherwise the metadata in the input data stream is used.");
    tt->val_offset = (char *) &beam_width_deg_v - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'Comment 25'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 25");
    tt->comment_hdr = tdrpStrDup("OPTION TO OVERRIDE RADAR GATE GEOMETRY");
    tt->comment_text = tdrpStrDup("If the start range and/or gate spacing is not correct in the data, you can override it using the parameters below.");
    tt++;
    
    // Parameter 'override_gate_geometry'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("override_gate_geometry");
    tt->descr = tdrpStrDup("Option to override gate geometry.");
    tt->help = tdrpStrDup("If TRUE, the program will use the start range and gate spacing specified here.");
    tt->val_offset = (char *) &override_gate_geometry - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'start_range_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("start_range_km");
    tt->descr = tdrpStrDup("Start range (km).");
    tt->help = tdrpStrDup("Used for overriding the start range in the data.");
    tt->val_offset = (char *) &start_range_km - &_start_;
    tt->single_val.d = 0.125;
    tt++;
    
    // Parameter 'gate_spacing_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("gate_spacing_km");
    tt->descr = tdrpStrDup("Gate spacing (km).");
    tt->help = tdrpStrDup("Used for overriding the gate spacing in the data.");
    tt->val_offset = (char *) &gate_spacing_km - &_start_;
    tt->single_val.d = 0.25;
    tt++;
    
    // Parameter 'Comment 26'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 26");
    tt->comment_hdr = tdrpStrDup("CF NetCDF OUTPUT DETAILS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'specify_output_filename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("specify_output_filename");
    tt->descr = tdrpStrDup("If true, the file will be named 'output_filename'.");
    tt->help = tdrpStrDup("If false, the file name will be computed from the data time.");
    tt->val_offset = (char *) &specify_output_filename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_filename'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_filename");
    tt->descr = tdrpStrDup("Name of output file.");
    tt->help = tdrpStrDup("Applies only if specify_output_filename is true.");
    tt->val_offset = (char *) &output_filename - &_start_;
    tt->single_val.s = tdrpStrDup("ncfGrid.nc");
    tt++;
    
    // Parameter 'name_file_from_start_time'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("name_file_from_start_time");
    tt->descr = tdrpStrDup("If true, name the output file using the start time.");
    tt->help = tdrpStrDup("If false, the end time is used, in the MDV tradition.");
    tt->val_offset = (char *) &name_file_from_start_time - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'netcdf_file_prefix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("netcdf_file_prefix");
    tt->descr = tdrpStrDup("User-specified output file prefix, comes before date_time.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &netcdf_file_prefix - &_start_;
    tt->single_val.s = tdrpStrDup("ncf_");
    tt++;
    
    // Parameter 'netcdf_file_suffix'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("netcdf_file_suffix");
    tt->descr = tdrpStrDup("User-specified output file suffix, comes after the date_time and before the .nc which gets automatically added on.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &netcdf_file_suffix - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_iso8601_filename_convention'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_iso8601_filename_convention");
    tt->descr = tdrpStrDup("If true the output filename uses the prefix, followed by ISO 8601 timestamp convention");
    tt->help = tdrpStrDup("eg. prefix.2008-05-22T14:00:00.nc");
    tt->val_offset = (char *) &use_iso8601_filename_convention - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'ncf_title'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_title");
    tt->descr = tdrpStrDup("Title string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_title - &_start_;
    tt->single_val.s = tdrpStrDup("SPOL radar data");
    tt++;
    
    // Parameter 'ncf_institution'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_institution");
    tt->descr = tdrpStrDup("Institution string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_institution - &_start_;
    tt->single_val.s = tdrpStrDup("EOL/NCAR");
    tt++;
    
    // Parameter 'ncf_references'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_references");
    tt->descr = tdrpStrDup("References string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_references - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_source'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_source");
    tt->descr = tdrpStrDup("Source string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_source - &_start_;
    tt->single_val.s = tdrpStrDup("SPOL radar");
    tt++;
    
    // Parameter 'ncf_history'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_history");
    tt->descr = tdrpStrDup("History string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_history - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'ncf_comment'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ncf_comment");
    tt->descr = tdrpStrDup("Comment string for netCDF file.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ncf_comment - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 27'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 27");
    tt->comment_hdr = tdrpStrDup("PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Program instance for process registration.");
    tt->help = tdrpStrDup("REALTIME mode only. This application registers with procmap. This is the instance used for registration.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("test");
    tt++;
    
    // Parameter 'procmap_register_interval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("procmap_register_interval");
    tt->descr = tdrpStrDup("Interval for registering with procmap (secs).");
    tt->help = tdrpStrDup("REALTIME mode only. The app will register with procmap at this interval, to update its status. If it does not register within twice this interval, the auto_restart script will restart the app.");
    tt->val_offset = (char *) &procmap_register_interval - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'Comment 28'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 28");
    tt->comment_hdr = tdrpStrDup("MEMORY HANDLING");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'free_memory_between_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("free_memory_between_files");
    tt->descr = tdrpStrDup("Option to free up memory between each new file.");
    tt->help = tdrpStrDup("If true, we free up as much memory as possible between handling the files. If false, we reduce allocated memory to the extent possible.");
    tt->val_offset = (char *) &free_memory_between_files - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 29'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 29");
    tt->comment_hdr = tdrpStrDup("THREADING FOR SPEED.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_multiple_threads'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_multiple_threads");
    tt->descr = tdrpStrDup("Option to use multiple compute threads to improve performance.");
    tt->help = tdrpStrDup("The read and write stages occur in the main thread, since netCDF is not thread safe. The compute stage can be multi-threaded to improve performance.");
    tt->val_offset = (char *) &use_multiple_threads - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'n_compute_threads'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("n_compute_threads");
    tt->descr = tdrpStrDup("The number of compute threads.");
    tt->help = tdrpStrDup("The moments computations are segmented in range, with each thread computing a fraction of the number of gates. For maximum performance, n_threads should be set to the number of processors multiplied by 4. For further tuning, use top to maximize CPU usage while varying the number of threads.");
    tt->val_offset = (char *) &n_compute_threads - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 8;
    tt++;
    
    // Parameter 'Comment 30'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 30");
    tt->comment_hdr = tdrpStrDup("USE ECHO ORIENTATION TO INFORM INTERPOLATION GEOMETRY");
    tt->comment_text = tdrpStrDup("Vertically-oriented echoes (convective) should be interpolated in the vertical. Horizontally-oriented echoes (stratiform, bright-band, anvil) should be interpolated in the horizontal. This attempts to prevent the typical ringing behavior we see in Cartesian products in regionis with layered structures, for example anvils.");
    tt++;
    
    // Parameter 'use_echo_orientation'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_echo_orientation");
    tt->descr = tdrpStrDup("If TRUE, we will try to determine echo orientation to inform interpolation.");
    tt->help = tdrpStrDup("Vertically-oriented echoes should be interpolated in the vertical. Horizontally-oriented echoes should be interpolated in the horizontal. We try to determine the principal orientation of the echoes, so that we will use the correct gates for interpolation.");
    tt->val_offset = (char *) &use_echo_orientation - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'synthetic_rhis_start_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("synthetic_rhis_start_az");
    tt->descr = tdrpStrDup("Starting azimuth for set of synthetic RHIs computed for determining echo orientation.");
    tt->help = tdrpStrDup("To find the orientation of echoes, we use a set of synthetic RHIs. These are computed on regular azimuths. This is the starting azimuth for the set of synthetic RHIs.");
    tt->val_offset = (char *) &synthetic_rhis_start_az - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'synthetic_rhis_delta_az'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("synthetic_rhis_delta_az");
    tt->descr = tdrpStrDup("Delta azimuth for set of synthetic RHIs computed for determining echo orientation.");
    tt->help = tdrpStrDup("To find the orientation of echoes, we use a set of synthetic RHIs. These are computed on regular azimuths. This is the delta azimuth for the set of synthetic RHIs.");
    tt->val_offset = (char *) &synthetic_rhis_delta_az - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'echo_orientation_dbz_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("echo_orientation_dbz_field_name");
    tt->descr = tdrpStrDup("Name of reflectivity field in input data.");
    tt->help = tdrpStrDup("This is used for determining the orientation of echoes.");
    tt->val_offset = (char *) &echo_orientation_dbz_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("DBZ");
    tt++;
    
    // Parameter 'echo_orientation_n_points_sdev_h'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("echo_orientation_n_points_sdev_h");
    tt->descr = tdrpStrDup("Number of grid points used to compute the standard deviation of DBZ horizontally.");
    tt->help = tdrpStrDup("To decide on echo orientation, we need to determine whether the dbz is more constanthorizonatally or vertically. To do this we compute the standard deviation of the dbz field, horizontally and vertically.");
    tt->val_offset = (char *) &echo_orientation_n_points_sdev_h - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'echo_orientation_n_points_sdev_v'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("echo_orientation_n_points_sdev_v");
    tt->descr = tdrpStrDup("Number of grid points used to compute the standard deviation of DBZ vertically.");
    tt->help = tdrpStrDup("To decide on echo orientation, we need to determine whether the dbz is more constanthorizonatally or vertically. To do this we compute the standard deviation of the dbz field, horizontally and vertically.");
    tt->val_offset = (char *) &echo_orientation_n_points_sdev_v - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'Comment 31'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 31");
    tt->comment_hdr = tdrpStrDup("OPTION TO IDENTIFY THE CONVECTIVE/STRATIFORM SPLIT");
    tt->comment_text = tdrpStrDup("Applies only to INTERP_MODE_CART.");
    tt++;
    
    // Parameter 'identify_convective_stratiform_split'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("identify_convective_stratiform_split");
    tt->descr = tdrpStrDup("Option to identify the convective / stratiform split.");
    tt->help = tdrpStrDup("Uses the standard deviation of reflectivity as a texture field for each Cartesian plane. Low variability indicates stratiform conditions.");
    tt->val_offset = (char *) &identify_convective_stratiform_split - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'conv_strat_dbz_field_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_dbz_field_name");
    tt->descr = tdrpStrDup("Name of reflectivity field in input data.");
    tt->help = tdrpStrDup("This is used for computing reflectivity texture.");
    tt->val_offset = (char *) &conv_strat_dbz_field_name - &_start_;
    tt->single_val.s = tdrpStrDup("DBZ");
    tt++;
    
    // Parameter 'conv_strat_min_valid_height'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_min_valid_height");
    tt->descr = tdrpStrDup("Min height used in analysis (km).");
    tt->help = tdrpStrDup("Only data at or above this altitude is used.");
    tt->val_offset = (char *) &conv_strat_min_valid_height - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'conv_strat_max_valid_height'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_max_valid_height");
    tt->descr = tdrpStrDup("Max height used in analysis (km).");
    tt->help = tdrpStrDup("Only data at or below this altitude is used.");
    tt->val_offset = (char *) &conv_strat_max_valid_height - &_start_;
    tt->single_val.d = 25;
    tt++;
    
    // Parameter 'conv_strat_min_valid_dbz'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_min_valid_dbz");
    tt->descr = tdrpStrDup("Minimum reflectivity threshold for this analysis (dBZ).");
    tt->help = tdrpStrDup("Reflectivity below this threshold is set to missing.");
    tt->val_offset = (char *) &conv_strat_min_valid_dbz - &_start_;
    tt->single_val.d = 10;
    tt++;
    
    // Parameter 'conv_strat_texture_radius_km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_texture_radius_km");
    tt->descr = tdrpStrDup("Radius for texture analysis (km).");
    tt->help = tdrpStrDup("We determine the reflectivity 'texture' at a point by computing the standard deviation of the square of the reflectivity, for all grid points within this radius of the central point. We then compute the square root of that sdev.");
    tt->val_offset = (char *) &conv_strat_texture_radius_km - &_start_;
    tt->single_val.d = 7;
    tt++;
    
    // Parameter 'conv_strat_min_valid_fraction_for_texture'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_min_valid_fraction_for_texture");
    tt->descr = tdrpStrDup("Minimum fraction of surroundingpoints for texture computations.");
    tt->help = tdrpStrDup("For a valid computation of texture, we require at least this fraction of points around the central point to have reflectivity in excess of min_valid_dbz.");
    tt->val_offset = (char *) &conv_strat_min_valid_fraction_for_texture - &_start_;
    tt->single_val.d = 0.33;
    tt++;
    
    // Parameter 'conv_strat_min_convectivity_for_convective'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_min_convectivity_for_convective");
    tt->descr = tdrpStrDup("Minimum convectivity for convective at a point.");
    tt->help = tdrpStrDup("If the convectivity at a point exceeds this value, we set the convective flag at this point.");
    tt->val_offset = (char *) &conv_strat_min_convectivity_for_convective - &_start_;
    tt->single_val.d = 0.5;
    tt++;
    
    // Parameter 'conv_strat_max_convectivity_for_stratiform'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_max_convectivity_for_stratiform");
    tt->descr = tdrpStrDup("Maximum convectivity for stratiform at a point.");
    tt->help = tdrpStrDup("If the convectivity at a point is less than this value, we set the stratiform flag at this point. If it is above this but less than min_convectivity_for_convective we flag the point as MIXED.");
    tt->val_offset = (char *) &conv_strat_max_convectivity_for_stratiform - &_start_;
    tt->single_val.d = 0.4;
    tt++;
    
    // Parameter 'conv_strat_min_overlap_for_convective_clumps'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_min_overlap_for_convective_clumps");
    tt->descr = tdrpStrDup("Minimum grid overlap in convective regions.");
    tt->help = tdrpStrDup("A convective region is identified as a series of adjacent 'runs' of grid cells data in the EW direction. When testing for overlap, some minimum number of overlap grids must be used. This is that minimum overlap in grid units.");
    tt->val_offset = (char *) &conv_strat_min_overlap_for_convective_clumps - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'conv_strat_write_partition'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_write_partition");
    tt->descr = tdrpStrDup("Option to write out the convective/stratiform partition.");
    tt->help = tdrpStrDup("If true, the 2-D partition will be added to the output file.");
    tt->val_offset = (char *) &conv_strat_write_partition - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'conv_strat_write_max_texture'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_write_max_texture");
    tt->descr = tdrpStrDup("Option to write out the max texture.");
    tt->help = tdrpStrDup("If true, the mean texture will be written to the output file. This is a 2-D field - the max over height of the 3-D texture fields.");
    tt->val_offset = (char *) &conv_strat_write_max_texture - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'conv_strat_write_convective_dbz'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_write_convective_dbz");
    tt->descr = tdrpStrDup("Option to write out the dbz field in convection.");
    tt->help = tdrpStrDup("This is a 3D field - the reflectivity trimmed only to convective regions, based on the convective/stratiform partition.");
    tt->val_offset = (char *) &conv_strat_write_convective_dbz - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'conv_strat_write_debug_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("conv_strat_write_debug_fields");
    tt->descr = tdrpStrDup("Option to write out the intermediate fields for debug purposes.");
    tt->help = tdrpStrDup("If true, the intermdiate fields will be written to the output file.");
    tt->val_offset = (char *) &conv_strat_write_debug_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
