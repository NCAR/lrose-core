/**********************************************************************
 * TDRP params for RadxClutter
 **********************************************************************/

//======================================================================
//
// RadxPersistentClutter identifies persistent clutter in polar radar 
//   data, flags it, and writes out the statistics to a CfRadial file.
//
// This method is based on the following paper: Lakshmanan V., J. Zhang, 
//   K. Hondl and C. Langston. A Statistical Approach to Mitigating 
//   Persistent Clutter in Radar Reflectivity Data. IEEE Journal of 
//   Selected Topics in Applied Earth Observations and Remote Sensing, 
//   Vol. 5, No. 2, April 2012.
//
//======================================================================
 
//======================================================================
//
// Debugging and process control.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
//
// If set, debug messages will be printed appropriately.
//
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_NORM
//     DEBUG_VERBOSE
//     DEBUG_EXTRA
//

debug = DEBUG_OFF;

///////////// instance ////////////////////////////////
//
// Program instance for process registration.
//
// This application registers with procmap. This is the instance used 
//   for registration.
//
//
// Type: string
//

instance = "test";

//======================================================================
//
// DATA INPUT.
//
//======================================================================
 
///////////// input_dir ///////////////////////////////
//
// Input directory for searching for files.
//
// Files will be searched for in this directory.
//
//
// Type: string
//

input_dir = "$(HOME)/data/precip/grids/spol/radarPolar/field/moments/sband/sur";

///////////// file_name_substr ////////////////////////
//
// Substring that needs to exist in the file name.
//
// Set to empty to avoid this check.
//
//
// Type: string
//

file_name_substr = "Sur1";

///////////// mode ////////////////////////////////////
//
// Operating mode.
//
// In REALTIME mode, the program waits for a new input file.  In ARCHIVE 
//   mode, it moves through the data between the start and end times set 
//   on the command line. In FILELIST mode, it moves through the list of 
//   file names specified on the command line. Paths (in ARCHIVE mode, at 
//   least) MUST contain a day-directory above the data file -- 
//   ./data_file.ext will not work as a file path, but 
//   ./yyyymmdd/data_file.ext will.
//
//
// Type: enum
// Options:
//     REALTIME
//     ARCHIVE
//     FILELIST
//

mode = ARCHIVE;

///////////// max_realtime_data_age_secs //////////////
//
// Maximum age of realtime data (secs).
//
// Only data less old than this will be used.
//
//
// Type: int
//

max_realtime_data_age_secs = 300;

//======================================================================
//
// ACTION.
//
// There are 2 possible actions: (a) analyze the clutter from a number 
//   of volumes, and store the results in a CfRadial file; or (b) use the 
//   clutter statistics file in the analysis step to remove clutter from 
//   files containing clutter.
//
//======================================================================
 
///////////// action //////////////////////////////////
//
// Action to be performed.
//

// ANALYZE_CLUTTER: given a series of volumes containing clutter, 
//   analyze the clutter and store the clutter statistics in 
//   CfRadialFiles.
//
// FILTER_CLUTTER: using the clutter statistics analyzed in the first 
//   step, filter reflectivity power from those clutter gates that are not 
//   overridden by weather. If the weather echo is stronger that the mean 
//   clutter, it is left unchanged.
//
//
// Type: enum
// Options:
//     ANALYZE_CLUTTER
//     FILTER_CLUTTER
//

action = ANALYZE_CLUTTER;

//======================================================================
//
// SCAN DETAILS.
//
// We specify the scan angles for which the clutter will be analyzed. 
//   This is the 'ideal'. The actual measurements are mapped onto this 
//   ideal scan.
//
//======================================================================
 
///////////// scan_mode ///////////////////////////////
//
// Scan mode.
//
// PPI - horizontal scanning, e.g. surveillance. RHI - vertical scanning.
//
//
// Type: enum
// Options:
//     PPI
//     RHI
//

scan_mode = PPI;

///////////// sweep_fixed_angles //////////////////////
//
// List of fixed angles for desired sweeps (deg).
//
// PPI mode: elevations. RHIs: azimuths.
//
//
// Type: double
// 1D array - variable length.
//

sweep_fixed_angles = {
 0.5,
 1,
 1.5,
 2
};

///////////// first_ray_angle /////////////////////////
//
// Starting scan angle for rays (deg).
//
// In PPI mode, this is the first azimuth in a clockwise sweep. In RHI 
//   mode, this is the lowest elevation in a sweep.
//
//
// Type: double
//

first_ray_angle = 0;

///////////// last_ray_angle //////////////////////////
//
// Ending scan angle for rays (deg).
//
// In PPI mode, this is the last azimuth in a clockwise sweep. In RHI 
//   mode, this is the highest elevation in a sweep.
//
//
// Type: double
//

last_ray_angle = 359.99;

///////////// delta_ray_angle /////////////////////////
//
// Delta scan angle between consecutive rays (deg).
//
// In PPI mode, this is the azimuth difference between rays. In PPI mode 
//   the delta should be positive, i.e. for a clockwise sweep. In RHI 
//   mode, this is the elevation difference between rays.
//
//
// Type: double
//

delta_ray_angle = 0.75;

///////////// az_tolerance_deg ////////////////////////
//
// Azimumth tolerance.
//
// Allowed degrees difference between azimuth values for rays from 
//   measured volumes to be mapped onto the clutter grids.
//
//
// Type: double
//

az_tolerance_deg = 0.1;

///////////// elev_tolerance_deg //////////////////////
//
// Elevation tolerance.
//
// Allowed degrees difference between elevation values for rays from 
//   measured volumes to be mapped onto the clutter grids.
//
//
// Type: double
//

elev_tolerance_deg = 0.1;

///////////// max_range_km ////////////////////////////
//
// Specified maximim range - km.
//
// Gates beyond this range are removed.
//
//
// Type: double
//

max_range_km = 60;

//======================================================================
//
// ALGORITHM DETAILS.
//
//======================================================================
 
///////////// dbz_field_name //////////////////////////
//
// Reflectivity field name.
//
// Name of field on which clutter will be based.
//
//
// Type: string
//

dbz_field_name = "DBZ";

///////////// clutter_dbz_threshold ///////////////////
//
// DBZ threshold for clutter at a gate.
//
// If data is persistently above this value then the gate is a clutter 
//   location.
//
//
// Type: double
//

clutter_dbz_threshold = 10;

///////////// use_vel_field ///////////////////////////
//
// Option to make use of the velocity field to identify clutter.
//
// If true, then we check the absolute value of velocity. If it is 
//   outside the limit we do not treat the point as clutter.
//
//
// Type: boolean
//

use_vel_field = TRUE;

///////////// vel_field_name //////////////////////////
//
// Velocity field name.
//
//
// Type: string
//

vel_field_name = "VEL";

///////////// max_abs_vel /////////////////////////////
//
// Maximimum absolute radial velocity for clutter (m/s).
//
// If the absolute velocity at a gate exceeds this, the point cannot be 
//   clutter.
//
//
// Type: double
//

max_abs_vel = 1;

///////////// specify_clutter_fraction_threshold //////
//
// Option to specify the clutter threshold write out _latest_data_info 
//   files.
//
// If true, the _latest_data_info files will be written after the 
//   converted file is written.
//
//
// Type: boolean
//

specify_clutter_fraction_threshold = TRUE;

///////////// clutter_fraction_threshold //////////////
//
// Clutter percentile.
//
// Percentile to use in clutter value determination (see the paper, 
//   section III. Correction of Radar Reflectivity.
//
//
// Type: double
//

clutter_fraction_threshold = 0.97;

//======================================================================
//
// Clutter statistics output.
//
// Writing out the results of identifying clutter.
//
//======================================================================
 
///////////// clutter_stats_output_dir ////////////////
//
// Location for final clutter statistics.
//
// Final output is only written at the end of a processing phase, with 
//   the output time equal to the time of the first volume processed.
//
//
// Type: string
//

clutter_stats_output_dir = "$(HOME)/data/precip/grids/spol/radarPolar/clutter/sband/sur";

///////////// dbz_mean_field_name /////////////////////
//
// Field name for mean dbz.
//
// The dbz mean field is added to the output data set.
//
//
// Type: string
//

dbz_mean_field_name = "dbzMean";

///////////// dbz_sdev_field_name /////////////////////
//
// Field name for standard deviation of dbz.
//
// The dbz sdev field is added to the output data set.
//
//
// Type: string
//

dbz_sdev_field_name = "dbzSdev";

///////////// clut_freq_field_name ////////////////////
//
// Field name for clutter frequency.
//
// This is the fraction of time that a gate has dbz above the threshold.
//
//
// Type: string
//

clut_freq_field_name = "clutFreq";

///////////// clut_flag_field_name ////////////////////
//
// Field name for clutter flag.
//
// This flag indicates that the gate has persistent clutter.
//
//
// Type: string
//

clut_flag_field_name = "clutFlag";

///////////// write_latest_data_info //////////////////
//
// Option to write out _latest_data_info files.
//
// If true, the _latest_data_info files will be written after the 
//   converted file is written.
//
//
// Type: boolean
//

write_latest_data_info = FALSE;

//======================================================================
//
// FILTERED OUTPUT.
//
// Writing out volumes with clutter filtered.
//
//======================================================================
 
///////////// dbz_filt_field_name /////////////////////
//
// Field name for filtered dbz.
//
// The filtered dbz field is added to the output data set.
//
//
// Type: string
//

dbz_filt_field_name = "dbzFilt";

///////////// clutter_stats_path //////////////////////
//
// Path to volume containing the clutter statistics.
//
// This volume is created by this app in ANALYZE_CLUTTER action. Select 
//   a volume towards at end of the analysis sequence.
//
//
// Type: string
//

clutter_stats_path = "unknown";

///////////// n_sdev_for_clut_threshold ///////////////
//
// The number of standard deviations above the mean for the clutter 
//   threshold.
//
// For each gate we compare the measured dbz with the clutter dbz. The 
//   clutter threshold is computed as the mean dbz plus the dbz sdev 
//   multipled by this parameter. If the measured dbz exceeds this 
//   threshold it is preserved. Otherwise the reflectivity at the gate is 
//   set to a low value.
//
//
// Type: double
//

n_sdev_for_clut_threshold = 1;

///////////// min_dbz_filt ////////////////////////////
//
// The dbz value used to store filtered reflectivity.
//
// For filtered gates, we store this value in place of the original 
//   measured value.
//
//
// Type: double
//

min_dbz_filt = -20;

///////////// filt_output_dir /////////////////////////
//
// Directory for filtered output volumes.
//
// These volumes have a filtered reflectivity field, with the clutter in 
//   the stats volume removed.
//
//
// Type: string
//

filt_output_dir = "unknown";

