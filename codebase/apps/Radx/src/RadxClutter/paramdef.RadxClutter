//////////////////////////////////////////////////////////////////////////////////
//
// paramdef.RadxClutter
//
// This file contains the TDRP parameter definitions for setting the clutter
// pixels by processing a sufficient quantity of input data using a statistical
// approach.
//
// This cleaned-up app is based on the original RadxPersistentClutter.
//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// Based on following paper:
// Lakshmanan V., J. Zhang, K. Hondl and C. Langston.
// A Statistical Approach to Mitigating Persistent Clutter in
// Radar Reflectivity Data.
// IEEE Journal of Selected Topics in Applied Earth Observations
// and Remote Sensing, Vol. 5, No. 2, April 2012.
//////////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "RadxPersistentClutter identifies persistent clutter in polar radar data, flags it, and writes out the statistics to a CfRadial file.";
  p_text = "This method is based on the following paper: Lakshmanan V., J. Zhang, K. Hondl and C. Langston. A Statistical Approach to Mitigating Persistent Clutter in Radar Reflectivity Data. IEEE Journal of Selected Topics in Applied Earth Observations and Remote Sensing, Vol. 5, No. 2, April 2012.";
};

commentdef {
  p_header = "Debugging and process control";
};

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef string {
  p_default = "test";
  p_descr = "Program instance for process registration.";
  p_help = "This application registers with procmap. This is the instance used for registration.";
} instance;

commentdef {
  p_header = "DATA INPUT";
}

paramdef string {
  p_default = ".";
  p_descr = "Input directory for searching for files.";
  p_help = "Files will be searched for in this directory.";
} input_dir;

paramdef string
  {
   p_default = "";
   p_descr = "Substring that needs to exist in the file name.";
   p_help = "Set to empty to avoid this check.";
  } file_name_substr;

typedef enum {
  REALTIME, ARCHIVE, FILELIST
} mode_t;

paramdef enum mode_t {
  p_default = ARCHIVE;
  p_descr = "Operating mode";
  p_help = "In REALTIME mode, the program waits for a new input file.  "
           "In ARCHIVE mode, it moves through the data between the start "
           "and end times set on the command line. "
           "In FILELIST mode, it moves through the list of file names "
           "specified on the command line. "
           "Paths (in ARCHIVE mode, at least) MUST contain a "
           "day-directory above the data file -- ./data_file.ext will not "
           "work as a file path, but ./yyyymmdd/data_file.ext will.";
} mode;

paramdef int {
  p_default = 300;
  p_descr = "Maximum age of realtime data (secs)";
  p_help =  "Only data less old than this will be used.";
} max_realtime_data_age_secs;

commentdef {
  p_header = "SCAN DETAILS";
  p_text = "We specify the scan angles for which the clutter will be analyzed. This is the 'ideal'. The actual measurements are mapped onto this ideal scan.";
};

typedef enum
  {
   PPI, RHI
  } scan_mode_t;

paramdef enum scan_mode_t
{
  p_descr = "Scan mode";
  p_help = "PPI - horizontal scanning, e.g. surveillance. RHI - vertical scanning";
  p_default = PPI;
} scan_mode;

paramdef double
{
  p_descr = "List of fixed angles for desired sweeps (deg)";
  p_help = "PPI mode: elevations. RHIs: azimuths.";
  p_default = { 0.5 };
} sweep_fixed_angles[];

paramdef double
{
  p_descr = "Starting scan angle for rays (deg).";
  p_help = "In PPI mode, this is the first azimuth in a clockwise sweep. In RHI mode, this is the lowest elevation in a sweep.";
  p_default = 0.0;
} first_ray_angle;

paramdef double
{
  p_descr = "Ending scan angle for rays (deg).";
  p_help = "In PPI mode, this is the last azimuth in a clockwise sweep. In RHI mode, this is the highest elevation in a sweep.";
  p_default = 359.99;
} last_ray_angle;

paramdef double
{
  p_descr = "Delta scan angle between consecutive rays (deg).";
  p_help = "In PPI mode, this is the azimuth difference between rays. In PPI mode the delta should be positive, i.e. for a clockwise sweep. In RHI mode, this is the elevation difference between rays.";
  p_default = 1.0;
} delta_ray_angle;

paramdef double
{
  p_descr = "Azimumth tolerance";
  p_help = "Allowed degrees difference between azimuth values for rays from measured volumes to be mapped onto the clutter grids";
  p_default = 0.1;
} az_tolerance_deg;

paramdef double
{
  p_descr = "Elevation tolerance";
  p_help = "Allowed degrees difference between elevation values for rays from measured volumes to be mapped onto the clutter grids";
  p_default = 0.1;
} elev_tolerance_deg;

paramdef double {
  p_default = 60.0;
  p_descr = "Specified maximim range - km.";
  p_help = "Gates beyond this range are removed.";
} max_range_km;

//////////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "ALGORITHM DETAILS";
};

paramdef string
{
  p_descr = "Input field name.";
  p_help = "Name of field on which clutter will be based.";
  p_default = "DBZ";
} dbz_field_name;

paramdef double
{
  p_descr = "DBZ threshold for a clutter gate.";
  p_help = "If data is persistently above this value it is a clutter location.";
  p_default = 0.0;
} dbz_clutter_threshold;

paramdef double
{
  p_descr = "Clutter percentile";
  p_help = "Percentile to use in clutter value determination (see the paper, section III. Correction of Radar Reflectivity.";
  p_default = 0.5;
} clutter_percentile;

paramdef double
{
  p_descr = "Missing clutter value.";
  p_help = "Value to assign to clutter estimates when the wanted percentile is the missing data value";
  p_default = -25.0;
} missing_clutter_value;

paramdef double
{
  p_descr = "Variation in threshold for convergence.";
  p_help = "The threshold as percent of total number of scans to identify a point as clutter should converge to a stable value.  This value is the allowed tolerance (change) to be considered stable.";
  p_default = 0.025;
} threshold_tolerance;

paramdef double
{
  p_descr = "Maximum percent of pixels that can change for convergence.";
  p_help = "The percentage of pixels that change from clutter to nonclutter or back should decrease to a minimum for convergence.";
  p_default = 0.001;
} maximum_percent_change;

paramdef double
{
  p_descr = "Number of volumes that show stablity prior to considering the situation stable";
  p_help = "The threshold converges, and needs to stay converged for this many volumes before giving the thumbs up.";
  p_default = 10;
} minimum_stable_volumes;

paramdef double
{
  p_descr = "Resolution of histogram for analysis.";
  p_help = "Histograms are used to determine the statistics of the clutter properties. See the paper.";
  p_default = 0.2;
} histogram_resolution;

paramdef double
{
  p_descr = "Histogram maximum bin value.";
  p_help = "Histograms are used to determine the statistics of the clutter properties. See the paper.";
  p_default = 50.0;
} histogram_max;

//////////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "Data output";
  p_text = "Parameters for writing results";
};

paramdef string
{
  p_descr = "Location for final clutter statistics.";
  p_help = "Final output is only written at the end of a processing phase, with the output time equal to the time of the first volume processed.";
  p_default = "unknown";
} output_dir;

paramdef boolean {
  p_default = false;
  p_descr = "Option to write out _latest_data_info files.";
  p_help = "If true, the _latest_data_info files will be written after the converted file is written.";
} write_latest_data_info;

paramdef boolean
{
  p_descr = "Write out diagnostic output";
  p_default = FALSE;
} write_diagnostic_output;

paramdef string
{
  p_descr = "Dir for diagnostic output";
  p_help = "If true, output from each volume is written, to show the build up of skill through time.";
  p_default = "unknown";
} diagnostic_volume_dir;

paramdef string
{
  p_descr = "Output ascii dir to which to write plottables";
  p_help = "";
  p_default = "unknown";
} diagnostic_ascii_dir;

paramdef string
{
  p_descr = "Field name for mean dbz.";
  p_help = "The dbz mean field will be added to the output data set.";
  p_default = "dbzMean";
} dbz_mean_field_name;

paramdef string
{
  p_descr = "Field name for clutter frequency.";
  p_help = "This is the fraction of time that a gate has dbz above the threshold.";
  p_default = "clutFreq";
} clut_freq_field_name;

