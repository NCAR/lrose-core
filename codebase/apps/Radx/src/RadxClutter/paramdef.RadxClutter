//////////////////////////////////////////////////////////////////////////////////
//
// paramdef.RadxClutter
//
// This file contains the TDRP parameter definitions for setting the clutter
// pixels by processing a sufficient quantity of input data using a statistical
// approach.
//
// This cleaned-up app is based on the original RadxPersistentClutter.
//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// Based on following paper:
// Lakshmanan V., J. Zhang, K. Hondl and C. Langston.
// A Statistical Approach to Mitigating Persistent Clutter in
// Radar Reflectivity Data.
// IEEE Journal of Selected Topics in Applied Earth Observations
// and Remote Sensing, Vol. 5, No. 2, April 2012.
//////////////////////////////////////////////////////////////////////////////////

commentdef {
  p_header = "RadxPersistentClutter identifies persistent clutter in polar radar data, flags it, and writes out the statistics to a CfRadial file.";
  p_text = "This method is based on the following paper: Lakshmanan V., J. Zhang, K. Hondl and C. Langston. A Statistical Approach to Mitigating Persistent Clutter in Radar Reflectivity Data. IEEE Journal of Selected Topics in Applied Earth Observations and Remote Sensing, Vol. 5, No. 2, April 2012.";
};

commentdef {
  p_header = "Debugging and process control";
};

typedef enum {
  DEBUG_OFF, DEBUG_NORM, DEBUG_VERBOSE, DEBUG_EXTRA
} debug_t;

paramdef enum debug_t {
  p_default = DEBUG_OFF;
  p_descr = "Debug option";
  p_help = "If set, debug messages will be printed appropriately";
} debug;

paramdef string {
  p_default = "test";
  p_descr = "Program instance for process registration.";
  p_help = "This application registers with procmap. This is the instance used for registration.";
} instance;

commentdef {
  p_header = "DATA INPUT";
}

paramdef string {
  p_default = ".";
  p_descr = "Input directory for searching for files.";
  p_help = "Files will be searched for in this directory.";
} input_dir;

paramdef string
  {
   p_default = "";
   p_descr = "Substring that needs to exist in the file name.";
   p_help = "Set to empty to avoid this check.";
  } file_name_substr;

typedef enum {
  REALTIME, ARCHIVE, FILELIST
} mode_t;

paramdef enum mode_t {
  p_default = ARCHIVE;
  p_descr = "Operating mode";
  p_help = "In REALTIME mode, the program waits for a new input file.  "
           "In ARCHIVE mode, it moves through the data between the start "
           "and end times set on the command line. "
           "In FILELIST mode, it moves through the list of file names "
           "specified on the command line. "
           "Paths (in ARCHIVE mode, at least) MUST contain a "
           "day-directory above the data file -- ./data_file.ext will not "
           "work as a file path, but ./yyyymmdd/data_file.ext will.";
} mode;

paramdef int {
  p_default = 300;
  p_descr = "Maximum age of realtime data (secs)";
  p_help =  "Only data less old than this will be used.";
} max_realtime_data_age_secs;

commentdef {
  p_header = "ACTION";
  p_text = "There are 2 possible actions: (a) analyze the clutter from a number of volumes, and store the results in a CfRadial file; or (b) use the clutter statistics file in the analysis step to remove clutter from files containing clutter.";
};

typedef enum
  {
   CLUTTER_ANALYSIS, CLUTTER_REMOVAL
  } action_t;

paramdef enum action_t
  {
   p_default = CLUTTER_ANALYSIS;
   p_descr = "Action to be performed";
   p_help = "CLUTTER_ANALYSIS: given a series of volumes containing clutter, analyze the clutter and store the cliutter statistics in CfRadialFiles. CLUTTER_REMOVAL: using the clutter statistics analyzed in the first step, remove reflectivity power from those clutter gates that are not overridden by weather. If the weather echo is stronger that the mean clutter, it is left unchanged.";
  } action;

commentdef {
  p_header = "SCAN DETAILS";
  p_text = "We specify the scan angles for which the clutter will be analyzed. This is the 'ideal'. The actual measurements are mapped onto this ideal scan.";
};

typedef enum
  {
   PPI, RHI
  } scan_mode_t;

paramdef enum scan_mode_t
{
  p_descr = "Scan mode";
  p_help = "PPI - horizontal scanning, e.g. surveillance. RHI - vertical scanning";
  p_default = PPI;
} scan_mode;

paramdef double
{
  p_descr = "List of fixed angles for desired sweeps (deg)";
  p_help = "PPI mode: elevations. RHIs: azimuths.";
  p_default = { 0.5, 1.0, 1.5, 2.0 };
} sweep_fixed_angles[];

paramdef double
{
  p_descr = "Starting scan angle for rays (deg).";
  p_help = "In PPI mode, this is the first azimuth in a clockwise sweep. In RHI mode, this is the lowest elevation in a sweep.";
  p_default = 0.0;
} first_ray_angle;

paramdef double
{
  p_descr = "Ending scan angle for rays (deg).";
  p_help = "In PPI mode, this is the last azimuth in a clockwise sweep. In RHI mode, this is the highest elevation in a sweep.";
  p_default = 359.99;
} last_ray_angle;

paramdef double
{
  p_descr = "Delta scan angle between consecutive rays (deg).";
  p_help = "In PPI mode, this is the azimuth difference between rays. In PPI mode the delta should be positive, i.e. for a clockwise sweep. In RHI mode, this is the elevation difference between rays.";
  p_default = 1.0;
} delta_ray_angle;

paramdef double
{
  p_descr = "Azimumth tolerance";
  p_help = "Allowed degrees difference between azimuth values for rays from measured volumes to be mapped onto the clutter grids";
  p_default = 0.1;
} az_tolerance_deg;

paramdef double
{
  p_descr = "Elevation tolerance";
  p_help = "Allowed degrees difference between elevation values for rays from measured volumes to be mapped onto the clutter grids";
  p_default = 0.1;
} elev_tolerance_deg;

paramdef double {
  p_default = 60.0;
  p_descr = "Specified maximim range - km.";
  p_help = "Gates beyond this range are removed.";
} max_range_km;

//////////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "ALGORITHM DETAILS";
};

paramdef string
{
  p_descr = "Reflectivity field name.";
  p_help = "Name of field on which clutter will be based.";
  p_default = "DBZ";
} dbz_field_name;

paramdef double
{
  p_descr = "DBZ threshold for clutter at a gate.";
  p_help = "If data is persistently above this value then the gate is a clutter location.";
  p_default = 10.0;
} clutter_dbz_threshold;

paramdef boolean {
  p_default = true;
  p_descr = "Option to make use of the velocity field to identify clutter.";
  p_help = "If true, then we check the absolute value of velocity. If it is outside the limit we do not treat the point as clutter.";
} use_vel_field;

paramdef string
{
  p_descr = "Velocity field name.";
  p_default = "VEL";
} vel_field_name;

paramdef double
{
  p_descr = "Maximimum absolute radial velocity for clutter (m/s).";
  p_help = "If the absolute velocity at a gate exceeds this, the point cannot be clutter.";
  p_default = 1.0;
} max_abs_vel;

paramdef boolean {
  p_default = false;
  p_descr = "Option to specify the clutter threshold write out _latest_data_info files.";
  p_help = "If true, the _latest_data_info files will be written after the converted file is written.";
} specify_clutter_fraction_threshold;

paramdef double
{
  p_descr = "Clutter percentile";
  p_help = "Percentile to use in clutter value determination (see the paper, section III. Correction of Radar Reflectivity.";
  p_default = 0.95;
} clutter_fraction_threshold;

//////////////////////////////////////////////////////////////////////////////////

commentdef
{
  p_header = "Clutter statistics output";
  p_text = "Writing out the results of identifying clutter";
};

paramdef string
{
  p_descr = "Location for final clutter statistics.";
  p_help = "Final output is only written at the end of a processing phase, with the output time equal to the time of the first volume processed.";
  p_default = "unknown";
} clutter_stats_output_dir;

paramdef string
{
  p_descr = "Field name for mean dbz.";
  p_help = "The dbz mean field is added to the output data set.";
  p_default = "dbzMean";
} dbz_mean_field_name;

paramdef string
{
  p_descr = "Field name for standard deviation of dbz.";
  p_help = "The dbz sdev field is added to the output data set.";
  p_default = "dbzSdev";
} dbz_sdev_field_name;

paramdef string
{
  p_descr = "Field name for clutter frequency.";
  p_help = "This is the fraction of time that a gate has dbz above the threshold.";
  p_default = "clutFreq";
} clut_freq_field_name;

paramdef string
{
  p_descr = "Field name for clutter flag.";
  p_help = "This flag indicates that the gate has persistent clutter.";
  p_default = "clutFlag";
} clut_flag_field_name;

paramdef boolean {
  p_default = false;
  p_descr = "Option to write out _latest_data_info files.";
  p_help = "If true, the _latest_data_info files will be written after the converted file is written.";
} write_latest_data_info;

commentdef
{
  p_header = "Clutter-removed output";
  p_text = "Writing out volumes with clutter removed.";
};

paramdef string
{
  p_descr = "Location for final clutter statistics.";
  p_help = "Final output is only written at the end of a processing phase, with the output time equal to the time of the first volume processed.";
  p_default = "unknown";
} clutter_removed_output_dir;

