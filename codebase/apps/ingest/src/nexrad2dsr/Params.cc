// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c)
// ** University Corporation for Atmospheric Research(UCAR)
// ** National Center for Atmospheric Research(NCAR)
// ** Boulder, Colorado, USA
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program nexrad2dsr
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed");
    tt->val_offset = (char *) &debug - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'build5'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("build5");
    tt->descr = tdrpStrDup("Option for build 5 data.");
    tt->help = tdrpStrDup("If set, build 5 level II nexrad data are expected.\nHOW TO TELL IF A RADAR SWITCHED TO BUILD 5 FORMAT\n-------------------------------------------------\n\nAt the time of writing some radar data are delivered\nin build 5 format and some in the previous format. Radars\nare in the process of switching to build 5, so it is important\nto be able to recognise when this switch has happened so that\nthe line :\n\nbuild5 = TRUE;\n\ncan be added to the nexrad2dsr param file.\n\nThere are two ways to tell if a radar has switched to\ndelivering build 5 data - by the ldm filename, and from\nthe header contents in the first file in a volume\ndelivered by the ldm.\n\n1/ FILENAME : \n\n  Build 5 data start with a filename with sequence\n  number 1, like :\n\n   KLOT/20040825/023325_1.BZIP2\n   KLOT/20040825/023325_2.BZIP2\n   KLOT/20040825/023325_3.BZIP2\n   KLOT/20040825/023325_4.BZIP2\n   KLOT/20040825/023325_5.BZIP2\n\n  While preivous data start with sequence number 0 :\n\n   KIND/20040825/023325_0.BZIP2\n   KIND/20040825/023325_1.BZIP2\n   KIND/20040825/023325_2.BZIP2\n   KIND/20040825/023325_3.BZIP2\n   KIND/20040825/023325_4.BZIP2\n   KIND/20040825/023325_5.BZIP2\n\n2/ HEADER :\n\n The header for build 5 will contain the string\n 'AR2V0001', and this can be checked by running the 'strings'\n command on the first file in a volume :\n\n The command : strings KLOT/20040825/023325_1.BZIP2 |& grep AR\n\n gives the result :\n\n AR2V0001.090\n\n Previous data contain the string 'ARCHIVE2' and this can\n again be checked with the 'strings' command on the\n first file in a volume :\n\n The command : strings KIND/20040825/023325_0.BZIP2\n\n gives the result :\n\n ARCHIVE2.127\n\n NOTE : There is ONE IMPORTANT EXECPTION to all this - if\n you are dealing with archived radar data, then build5 seems\n to need to be FALSE, no matter what the strings in the data\n file are set to.\nNiles Oien August 24 2004");
    tt->val_offset = (char *) &build5 - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'oneFilePerVolume'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("oneFilePerVolume");
    tt->descr = tdrpStrDup("Option for dealing with input for which there\nis one input file per volume. Only relevant if build5 is true.\nIf these files are delivered via LDM they will typically have\nthe extension .raw");
    tt->help = tdrpStrDup("Typically this should be FALSE for realtime LDM\noperations. Relevant only if delivery method is LDM.");
    tt->val_offset = (char *) &oneFilePerVolume - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'print_summary'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("print_summary");
    tt->descr = tdrpStrDup("Print summary");
    tt->help = tdrpStrDup("If TRUE, summary information will be printed");
    tt->val_offset = (char *) &print_summary - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'summary_interval'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("summary_interval");
    tt->descr = tdrpStrDup("Summary interval (in #beams) for printing information on radar data written to the output radar queue");
    tt->help = tdrpStrDup("Used only if print_summary is set to TRUE");
    tt->val_offset = (char *) &summary_interval - &_start_;
    tt->has_min = TRUE;
    tt->min_val.l = 0;
    tt->single_val.l = 90;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance.");
    tt->help = tdrpStrDup("Used for procmap registration and auto restarting");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("primary");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("CONSTANT RADAR CHARACTERISTICS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'radar_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_name");
    tt->descr = tdrpStrDup("Radar name");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_name - &_start_;
    tt->single_val.s = tdrpStrDup("NEXRAD-KFTG");
    tt++;
    
    // Parameter 'site_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("site_name");
    tt->descr = tdrpStrDup("Site name");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &site_name - &_start_;
    tt->single_val.s = tdrpStrDup("Denver");
    tt++;
    
    // Parameter 'radar_id'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("radar_id");
    tt->descr = tdrpStrDup("Radar ID");
    tt->help = tdrpStrDup("Project-specific ID for the radar");
    tt->val_offset = (char *) &radar_id - &_start_;
    tt->single_val.l = 0;
    tt++;
    
    // Parameter 'radar_location'
    // ctype is '_radar_location_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("radar_location");
    tt->descr = tdrpStrDup("Radar location");
    tt->help = tdrpStrDup("Latitude and longitued in degrees, altitude in km.");
    tt->val_offset = (char *) &radar_location - &_start_;
    tt->struct_def.name = tdrpStrDup("radar_location_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("latitude");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &radar_location.latitude - (char *) &radar_location;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("longitude");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &radar_location.longitude - (char *) &radar_location;
      tt->struct_def.fields[2].ftype = tdrpStrDup("float");
      tt->struct_def.fields[2].fname = tdrpStrDup("altitude");
      tt->struct_def.fields[2].ptype = FLOAT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &radar_location.altitude - (char *) &radar_location;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = 39.787;
      tt->struct_vals[1].f = -104.546;
      tt->struct_vals[2].f = 1.71;
    tt++;
    
    // Parameter 'samples_per_beam'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("samples_per_beam");
    tt->descr = tdrpStrDup("Samples per beam");
    tt->help = tdrpStrDup("Number of pulses used to compute data from a beam");
    tt->val_offset = (char *) &samples_per_beam - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 64;
    tt++;
    
    // Parameter 'noise_dbz_at_100km'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("noise_dbz_at_100km");
    tt->descr = tdrpStrDup("Receiver noise in dBZ at a range of 100km.");
    tt->help = tdrpStrDup("Used in calculating signal-to-noise (SNR) output field.");
    tt->val_offset = (char *) &noise_dbz_at_100km - &_start_;
    tt->single_val.d = -14;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("RADAR DATA INPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_mechanism'
    // ctype is '_input_stream_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("input_mechanism");
    tt->descr = tdrpStrDup("Type of radar input stream");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_mechanism - &_start_;
    tt->enum_def.name = tdrpStrDup("input_stream_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("LDM");
      tt->enum_def.fields[0].val = LDM;
      tt->enum_def.fields[1].name = tdrpStrDup("TAPE");
      tt->enum_def.fields[1].val = TAPE;
      tt->enum_def.fields[2].name = tdrpStrDup("TCP_IP");
      tt->enum_def.fields[2].val = TCP_IP;
    tt->single_val.e = LDM;
    tt++;
    
    // Parameter 'use_wallclock_time'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_wallclock_time");
    tt->descr = tdrpStrDup("Option to override actual data time with wall clock time.");
    tt->help = tdrpStrDup("Setting this option to TRUE provides a mechanism for simulating a realtime data stream from archive data.");
    tt->val_offset = (char *) &use_wallclock_time - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'offset_sec'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("offset_sec");
    tt->descr = tdrpStrDup("Offset in seconds to add to actual data time.");
    tt->help = tdrpStrDup("Used for testing.");
    tt->val_offset = (char *) &offset_sec - &_start_;
    tt->single_val.l = 0;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("LDM INPUT PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'radar_input_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_input_dir");
    tt->descr = tdrpStrDup("Directory location of LDM input");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to LDM");
    tt->val_offset = (char *) &radar_input_dir - &_start_;
    tt->single_val.s = tdrpStrDup("$(DATA_DIR)/$(PROJECT)/ldm/radarSite");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("SPECIFYING THE REALTIME INPUT FILENAME CONVENTION");
    tt->comment_text = tdrpStrDup("The dated_dir_format and file_time_format parameters\nspecify the realtime file naming convention used for input files\n(which at the time of writing are generated by the LDM). The\ncharacters have the following significance :\n\nC (or any other character not listed below) - literal character\n  in the filename, no decoding should be attempted.\nY - Four digit year.\nM - two digit month.\nD - two digit day.\nh - two digit hour.\nm - two digit minute.\ns - two digit second.\nS - Sequence number, integer of unspecified length.\n\nThe following are examples of how to set these parameters.\nExample filename              dated_dir_format       file_time_format\n20031119/204118_12.BZIP2      YMD                   hms_S\n2003111920/4118_12.BZIP2      YMDh                  ms_S\n200311/19204118_12.BZIP2      YM                    Dhms_S\n20031119_204118_12.BZIP2      Empty                 YMD_hms_S\n20031119/KYSH_204118_12.BZIP2 YMD                   CCCC_hms_S\n\nThe intent is to cover all the possibilities that the LDM can\nreasonably produce.\n\nNOTE : Because the program seeks out the next filename in a\nsequence according to a naming convention, any _latest_data_info\nfiles are ignored.");
    tt++;
    
    // Parameter 'dated_dir_format'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("dated_dir_format");
    tt->descr = tdrpStrDup("Format for dated subdirectories off of\nradar_input_dir. Default is YMD which means\nthat the year, month and day will be in the directory name.\nValid characters are C,Y,M,D and h");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to LDM");
    tt->val_offset = (char *) &dated_dir_format - &_start_;
    tt->single_val.s = tdrpStrDup("YMD");
    tt++;
    
    // Parameter 'file_time_format'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("file_time_format");
    tt->descr = tdrpStrDup("Format for the file names in the dated directories.Default is hms_S which means that the hour, minute\nand seconds, followed by an underscore and then the sequence\nnumber. Valid characters are C,Y,M,D,h,m,s and S.");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to LDM");
    tt->val_offset = (char *) &file_time_format - &_start_;
    tt->single_val.s = tdrpStrDup("hms_S");
    tt++;
    
    // Parameter 'ldm_compression'
    // ctype is '_ldm_compression_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("ldm_compression");
    tt->descr = tdrpStrDup("Type of LDM compression used on input stream");
    tt->help = tdrpStrDup("Requires that you have the utility 'nexradII_bz' in your executable search path");
    tt->val_offset = (char *) &ldm_compression - &_start_;
    tt->enum_def.name = tdrpStrDup("ldm_compression_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("UNCOMPRESSED");
      tt->enum_def.fields[0].val = UNCOMPRESSED;
      tt->enum_def.fields[1].name = tdrpStrDup("BZIP2");
      tt->enum_def.fields[1].val = BZIP2;
      tt->enum_def.fields[2].name = tdrpStrDup("ZLIB");
      tt->enum_def.fields[2].val = ZLIB;
    tt->single_val.e = BZIP2;
    tt++;
    
    // Parameter 'tmp_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("tmp_dir");
    tt->descr = tdrpStrDup("Temporary directory for uncompressing input files");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to LDM and the input data files are compressed.");
    tt->val_offset = (char *) &tmp_dir - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("In REALTIME mode, the 'radar_input_dir' is watched for new incoming files.  In ARCHIVE mode input files are specified using the -f or -start/-end command line options for processing a specified list of input files. Used only if 'input_mechanism' is set to LDM");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[0].val = REALTIME;
      tt->enum_def.fields[1].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[1].val = ARCHIVE;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'file_quiescence_sec'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("file_quiescence_sec");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("The quiescence time allows an input file to be completely written to disk before attempting to read as input data. Used only if 'input_mechanism' is set to LDM.");
    tt->val_offset = (char *) &file_quiescence_sec - &_start_;
    tt->single_val.i = 5;
    tt++;
    
    // Parameter 'min_file_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_file_size");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Used in conjunction with quiesence to\navoid grabbing a file prematurely.");
    tt->val_offset = (char *) &min_file_size - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'max_valid_age_min'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_valid_age_min");
    tt->descr = tdrpStrDup("Maximum valid age (in min) of input data files.");
    tt->help = tdrpStrDup("Input files older than this will not be processed.\nUsed only if 'input_mechanism' is set to LDM. Note that\nThe age of a file is computed by subtracting the time\nrepresented in the filaname from the current time, NOT\nby subracting the time the file was written to disk from\nthe current time. The latter requires that a stat be done\neach file, which is not practical (the program cannot\nkeep up in realtime if it has to do this in some cases).");
    tt->val_offset = (char *) &max_valid_age_min - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'max_elapsed_search_time'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_elapsed_search_time");
    tt->descr = tdrpStrDup("Maximum time (in min) to search for an input file.");
    tt->help = tdrpStrDup("If this is exceeded, we restart the serach.\nUsed only if 'input_mechanism' is set to LDM");
    tt->val_offset = (char *) &max_elapsed_search_time - &_start_;
    tt->single_val.i = 15;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("TCP/IP INPUT PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'hostname'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("hostname");
    tt->descr = tdrpStrDup("Host name of machine providing TCP/IP input data.");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to TCP_IP");
    tt->val_offset = (char *) &hostname - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'port'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("port");
    tt->descr = tdrpStrDup("Port number for TCP/IP socketing.");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to TCP_IP");
    tt->val_offset = (char *) &port - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("TAPE INPUT PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_tape_device'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_tape_device");
    tt->descr = tdrpStrDup("Tape device name for input.");
    tt->help = tdrpStrDup("Used only if 'input_mechanism' is set to TAPE.");
    tt->val_offset = (char *) &input_tape_device - &_start_;
    tt->single_val.s = tdrpStrDup("/dev/nst0");
    tt++;
    
    // Parameter 'short_tape'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("short_tape");
    tt->descr = tdrpStrDup("Short tape option.");
    tt->help = tdrpStrDup("Set to FALSE if reading a standard NCDC Nexrad Level 2 archive tape.  Set to TRUE if reading a RAP generated Level 2 archive tape.  Used only if 'input_mechanism' is TAPE.");
    tt->val_offset = (char *) &short_tape - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("RADAR DATA OUTPUT");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_url");
    tt->descr = tdrpStrDup("Output URL for DsRadar data via FMQ");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://$(HOST)::$(PROJECT)/fmq/dsRadar");
    tt++;
    
    // Parameter 'separate_fmq_flags'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("separate_fmq_flags");
    tt->descr = tdrpStrDup("Option to output DsRadarFlags as separate fmq messages");
    tt->help = tdrpStrDup("Required for Dsr2Mdv and Jing Dealias");
    tt->val_offset = (char *) &separate_fmq_flags - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'params_on_filtered_tilts'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("params_on_filtered_tilts");
    tt->descr = tdrpStrDup("Option to turn off flags when filtering tilt");
    tt->help = tdrpStrDup("If we are combining the 1Km dbz data with the velocity data on the lower tilts, usually the radar parameters and field parameters are output anyway for the dbz data during the ingest of the 1Km tilt. If set to false, this will turn off those flags during that tilt.");
    tt->val_offset = (char *) &params_on_filtered_tilts - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_available_fields_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("Output radar fields");
    tt->help = tdrpStrDup("Data fields extracted or derived from the input radar stream\nDBZ   =  Reflectivity factor in dBz\nVEL   =  Doppler velocity in m/s\nSPW   =  Spectral width in m/s\nSNR   =  Signal to noise ratio in dB");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(available_fields_t);
    tt->array_n = 2;
    tt->enum_def.name = tdrpStrDup("available_fields_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DBZ");
      tt->enum_def.fields[0].val = DBZ;
      tt->enum_def.fields[1].name = tdrpStrDup("VEL");
      tt->enum_def.fields[1].val = VEL;
      tt->enum_def.fields[2].name = tdrpStrDup("SPW");
      tt->enum_def.fields[2].val = SPW;
      tt->enum_def.fields[3].name = tdrpStrDup("SNR");
      tt->enum_def.fields[3].val = SNR;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].e = DBZ;
      tt->array_vals[1].e = VEL;
    tt++;
    
    // Parameter 'filter_1km_dbz'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("filter_1km_dbz");
    tt->descr = tdrpStrDup("Filter out 1km reflectivity only from output radar stream");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &filter_1km_dbz - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'beam_wait'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("beam_wait");
    tt->descr = tdrpStrDup("Beam output delay (millisecs).");
    tt->help = tdrpStrDup("Pause after writing each radar beam to allow the user to simulate varying data rates and to provide a more constant flow of radar data.  In ARCHIVE mode a beam_wait of 30ms is suggested");
    tt->val_offset = (char *) &beam_wait - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'output_fmq_size'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_size");
    tt->descr = tdrpStrDup("Size of output FMQ, in bytes.");
    tt->help = tdrpStrDup("This is the total size of the output FMQ buffer. The default has been caclulate to accommodate a 16-tilt NEXRAD volume (vcp 11 -- the most dense NEXRAD scan strategy) with all four output fields.");
    tt->val_offset = (char *) &output_fmq_size - &_start_;
    tt->single_val.i = 25000000;
    tt++;
    
    // Parameter 'output_fmq_nslots'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_nslots");
    tt->descr = tdrpStrDup("Number of slots in output FMQ.");
    tt->help = tdrpStrDup("The number of slots corresponds to the maximum number of messages which may be written to the buffer before overwrites occur. However, overwrites may occur sooner if the size is not set large enough. The default has been calculated to accommodate a 16-tilt NEXRAD volume (vcp 11 -- the most dense NEXRAD scan strategy)");
    tt->val_offset = (char *) &output_fmq_nslots - &_start_;
    tt->single_val.i = 6000;
    tt++;
    
    // Parameter 'output_fmq_compress'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_compress");
    tt->descr = tdrpStrDup("FMQ compression option.");
    tt->help = tdrpStrDup("If TRUE FMQ messages are compressed.");
    tt->val_offset = (char *) &output_fmq_compress - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("DATA TRIMMING - OPTIONALLY ONLY SEND FIRST ROTATION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'firstRotationOnly'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("firstRotationOnly");
    tt->descr = tdrpStrDup("Option to only send first antenna rotation.");
    tt->help = tdrpStrDup("Defaults to FALSE for backwards compatibility, but\nshould be set if you may be dealing with VCP 121 data.");
    tt->val_offset = (char *) &firstRotationOnly - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'azTol'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("azTol");
    tt->descr = tdrpStrDup("Azimuth tolerance, degrees.");
    tt->help = tdrpStrDup("Used to compare azimuths if firstRotationOnly is set.");
    tt->val_offset = (char *) &azTol - &_start_;
    tt->single_val.d = 3;
    tt++;
    
    // Parameter 'numBeamsPostRotation'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("numBeamsPostRotation");
    tt->descr = tdrpStrDup("Number of beams to allow after first rotation,\nunless the geometry has changed.");
    tt->help = tdrpStrDup("Useful for getting a full volume by filling the gaps\nleft by the azimuth tolerance. The dealiaser JamesD cannot\ncope with less than a full volume");
    tt->val_offset = (char *) &numBeamsPostRotation - &_start_;
    tt->single_val.i = 10;
    tt++;
    
    // Parameter 'decompress_mechanism'
    // ctype is '_decompress_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("decompress_mechanism");
    tt->descr = tdrpStrDup("Method to decompress input data files.");
    tt->help = tdrpStrDup("Default is to run nexradII_bz on the input data. This\napp is checked in under apps/ingest/src/nexradII_bz and is\nbased on code external to RAL. The DECOMPRESS_NEXRAD_BZIP_DECOMPRESS\nwill run apps/ingest/src/NexradBzipDecompress which was\ndeveloped at RAL and as such is somewhat more maintained,\nbut only supports BZIP zipped data.\nApplies only to LDM input data.");
    tt->val_offset = (char *) &decompress_mechanism - &_start_;
    tt->enum_def.name = tdrpStrDup("decompress_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DECOMPRESS_NEXRADII_BZ");
      tt->enum_def.fields[0].val = DECOMPRESS_NEXRADII_BZ;
      tt->enum_def.fields[1].name = tdrpStrDup("DECOMPRESS_NEXRAD_BZIP_DECOMPRESS");
      tt->enum_def.fields[1].val = DECOMPRESS_NEXRAD_BZIP_DECOMPRESS;
    tt->single_val.e = DECOMPRESS_NEXRADII_BZ;
    tt++;
    
    // Parameter 'overrideInputTiltNumbers'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("overrideInputTiltNumbers");
    tt->descr = tdrpStrDup("Option to override input tilt numbers.");
    tt->help = tdrpStrDup("Set to TRUE if it's important that tilt numbers are sequential.");
    tt->val_offset = (char *) &overrideInputTiltNumbers - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specifiedGateSpacing'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("specifiedGateSpacing");
    tt->descr = tdrpStrDup("If this value is greater than 0, it is used\nas the gate spacing in Km");
    tt->help = tdrpStrDup("Default value of -1.0 will take gate spacing from the\ninput data stream and this should almost always be used.\nThis was added to cope with a case in which data had been\nincorrectly formatted to the nexrad format.");
    tt->val_offset = (char *) &specifiedGateSpacing - &_start_;
    tt->single_val.d = -1;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
