/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Grib2Mdv
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Grib2Mdv PARAMETER FILE");
    tt->comment_text = tdrpStrDup("Grib2Mdv creates MDV data from GRIB model data files. A number of different model output is supported.");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("PROGRAM MODES OF OPERATION.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed.");
    tt->val_offset = (char *) &debug - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'always_swap_ns'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("always_swap_ns");
    tt->descr = tdrpStrDup("Always swaps grids from N-S to S-N");
    tt->help = tdrpStrDup("Some NCEP data has corrupt headers and can't be used to determine grid order");
    tt->val_offset = (char *) &always_swap_ns - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'type'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("type");
    tt->descr = tdrpStrDup("GRIB Type");
    tt->help = tdrpStrDup("Type of GRIB file to convert.");
    tt->val_offset = (char *) &type - &_start_;
    tt->single_val.s = tdrpStrDup("ruc");
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Instance");
    tt->help = tdrpStrDup("Process instance for registration with process mapper.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operation mode");
    tt->help = tdrpStrDup("\tREALTIME - In REALTIME mode, files are processed as they are received, as indicated by the latest_data_info file in the input directory. In REALTIME mode, the LDATA_FMQ_ACTIVE environment variable must be set to \"true\" if the raw RUC files might be received more quickly than Grib2Mdv can process them.\n\tREALTIME_DIR - In REALTIME_DIR mode, files are processed as they are written to the input directory. In this case new files are recognized by creating a directory listing so there is no need for a latest_data_info file in the input directory to trigger processing. The input_substring parameter is used to indicate which files in the input directory should be processed when running in REALTIME_DIR mode.\n\tFILELIST - In FILELIST mode, the files listed on the command line using the -f command line option are processed and then Grib2Mdv exits. FILELIST mode is automatically invoked by -f option on the command line and if the FILELIST mode is specified, the -f option is required on the command line.\n\tNEWFILES - In NEWFILES mode, new files are detected in the input directory by their appearance and file size.  This mode is intended to be used with rsync.  It is similar to REALTIME_DIR.\n");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[0].val = REALTIME;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME_DIR");
      tt->enum_def.fields[1].val = REALTIME_DIR;
      tt->enum_def.fields[2].name = tdrpStrDup("FILELIST");
      tt->enum_def.fields[2].val = FILELIST;
      tt->enum_def.fields[3].name = tdrpStrDup("NEWFILES");
      tt->enum_def.fields[3].val = NEWFILES;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'input_substring'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_substring");
    tt->descr = tdrpStrDup("Substring contained in the filenames of all files to be processed from the input directory when running in REALTIME, REALTIME_DIR or NEWFILES mode.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_substring - &_start_;
    tt->single_val.s = tdrpStrDup("f00.ruc20b");
    tt++;
    
    // Parameter 'runOnOldRuc40File'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("runOnOldRuc40File");
    tt->descr = tdrpStrDup("Flag to indicate that the input files are from the old RUC2 40km data");
    tt->help = tdrpStrDup("If set, the program will recognize the water vapor mixing ratio (WVMR) field. In the old GRIB files WVMR's field code is 185, which conflicts with the GRIB standard. The field code 185 is supposed to represent Turbulence SIGMET/AIRMET. Note that humidity mixing ratio supercedes WVMR in the latest RUC output.");
    tt->val_offset = (char *) &runOnOldRuc40File - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("INPUT DATA PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'input_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("input_dir");
    tt->descr = tdrpStrDup("Input directory");
    tt->help = tdrpStrDup("Directory which contains input RUC 2 files. Used only if files are not specified on the command line. ");
    tt->val_offset = (char *) &input_dir - &_start_;
    tt->single_val.s = tdrpStrDup("./");
    tt++;
    
    // Parameter 'max_input_data_age'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("max_input_data_age");
    tt->descr = tdrpStrDup("Max age (in seconds) of input data");
    tt->help = tdrpStrDup("Used only if files are not specified on the command line");
    tt->val_offset = (char *) &max_input_data_age - &_start_;
    tt->has_min = TRUE;
    tt->min_val.l = 0;
    tt->single_val.l = 10800;
    tt++;
    
    // Parameter 'input_grib_type'
    // ctype is '_grib_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("input_grib_type");
    tt->descr = tdrpStrDup("Type of input GRIB file");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &input_grib_type - &_start_;
    tt->enum_def.name = tdrpStrDup("grib_type_t");
    tt->enum_def.nfields = 7;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("GRIB_TYPE_GENERIC");
      tt->enum_def.fields[0].val = GRIB_TYPE_GENERIC;
      tt->enum_def.fields[1].name = tdrpStrDup("GRIB_TYPE_RUC");
      tt->enum_def.fields[1].val = GRIB_TYPE_RUC;
      tt->enum_def.fields[2].name = tdrpStrDup("GRIB_TYPE_AVN");
      tt->enum_def.fields[2].val = GRIB_TYPE_AVN;
      tt->enum_def.fields[3].name = tdrpStrDup("GRIB_TYPE_ETA");
      tt->enum_def.fields[3].val = GRIB_TYPE_ETA;
      tt->enum_def.fields[4].name = tdrpStrDup("GRIB_TYPE_WAFS");
      tt->enum_def.fields[4].val = GRIB_TYPE_WAFS;
      tt->enum_def.fields[5].name = tdrpStrDup("GRIB_TYPE_AFWA");
      tt->enum_def.fields[5].val = GRIB_TYPE_AFWA;
      tt->enum_def.fields[6].name = tdrpStrDup("GRIB_TYPE_DTRA");
      tt->enum_def.fields[6].val = GRIB_TYPE_DTRA;
    tt->single_val.e = GRIB_TYPE_GENERIC;
    tt++;
    
    // Parameter 'process_old_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("process_old_files");
    tt->descr = tdrpStrDup("Flag to direct processing of pre-existing files. ");
    tt->help = tdrpStrDup("If set, the program will treat any pre-existing files in the input directory as newly arrived files. ");
    tt->val_offset = (char *) &process_old_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("MDV OUTPUT PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'write_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_forecast");
    tt->descr = tdrpStrDup("Write mdv files in a forecast directory structure");
    tt->help = tdrpStrDup("If this is true, mdv files will be written in the rap forecast directory structure.  Note that if write_non_forecast is also set to true, two mdv files will be written");
    tt->val_offset = (char *) &write_forecast - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'forecast_mdv_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("forecast_mdv_url");
    tt->descr = tdrpStrDup("Url for mdv files in forecast structure");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &forecast_mdv_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp:://localhost::./mdv");
    tt++;
    
    // Parameter 'write_non_forecast'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("write_non_forecast");
    tt->descr = tdrpStrDup("Write mdv files in a non-forecast directory structure");
    tt->help = tdrpStrDup("If this is true, mdv files will be written in the regular (non-forecast) rap directory structure.  Note that if write_forecast is also set to true, two mdv files will be written.  Note also that this option allows for overwriting files, since the forecast time will be used as the data time in this case.  This is a temporary option to allow for easier display of the data");
    tt->val_offset = (char *) &write_non_forecast - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'non_forecast_mdv_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("non_forecast_mdv_url");
    tt->descr = tdrpStrDup("Url for mdv files in non-forecast structure");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &non_forecast_mdv_url - &_start_;
    tt->single_val.s = tdrpStrDup("mdvp:://localhost::./mdv");
    tt++;
    
    // Parameter 'encoding_type'
    // ctype is '_encoding_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("encoding_type");
    tt->descr = tdrpStrDup("Set encoding type.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &encoding_type - &_start_;
    tt->enum_def.name = tdrpStrDup("encoding_type_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ENCODING_ASIS");
      tt->enum_def.fields[0].val = ENCODING_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("ENCODING_INT8");
      tt->enum_def.fields[1].val = ENCODING_INT8;
      tt->enum_def.fields[2].name = tdrpStrDup("ENCODING_INT16");
      tt->enum_def.fields[2].val = ENCODING_INT16;
      tt->enum_def.fields[3].name = tdrpStrDup("ENCODING_FLOAT32");
      tt->enum_def.fields[3].val = ENCODING_FLOAT32;
    tt->single_val.e = ENCODING_INT8;
    tt++;
    
    // Parameter 'compression_type'
    // ctype is '_compression_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("compression_type");
    tt->descr = tdrpStrDup("Set compression type.");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &compression_type - &_start_;
    tt->enum_def.name = tdrpStrDup("compression_type_t");
    tt->enum_def.nfields = 7;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("COMPRESSION_ASIS");
      tt->enum_def.fields[0].val = COMPRESSION_ASIS;
      tt->enum_def.fields[1].name = tdrpStrDup("COMPRESSION_NONE");
      tt->enum_def.fields[1].val = COMPRESSION_NONE;
      tt->enum_def.fields[2].name = tdrpStrDup("COMPRESSION_RLE");
      tt->enum_def.fields[2].val = COMPRESSION_RLE;
      tt->enum_def.fields[3].name = tdrpStrDup("COMPRESSION_LZO");
      tt->enum_def.fields[3].val = COMPRESSION_LZO;
      tt->enum_def.fields[4].name = tdrpStrDup("COMPRESSION_ZLIB");
      tt->enum_def.fields[4].val = COMPRESSION_ZLIB;
      tt->enum_def.fields[5].name = tdrpStrDup("COMPRESSION_BZIP");
      tt->enum_def.fields[5].val = COMPRESSION_BZIP;
      tt->enum_def.fields[6].name = tdrpStrDup("COMPRESSION_GZIP");
      tt->enum_def.fields[6].val = COMPRESSION_GZIP;
    tt->single_val.e = COMPRESSION_RLE;
    tt++;
    
    // Parameter 'non_forecast_timestamp'
    // ctype is '_timestamp_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("non_forecast_timestamp");
    tt->descr = tdrpStrDup("This parameter allows user to timestamp non-forecast mdv files based on the model's run time or the forecast time.");
    tt->help = tdrpStrDup("The choices are TIMESTAMP_GEN_TIME and TIMESTAMP_FCAST_TIME");
    tt->val_offset = (char *) &non_forecast_timestamp - &_start_;
    tt->enum_def.name = tdrpStrDup("timestamp_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("TIMESTAMP_GEN_TIME");
      tt->enum_def.fields[0].val = TIMESTAMP_GEN_TIME;
      tt->enum_def.fields[1].name = tdrpStrDup("TIMESTAMP_FCAST_TIME");
      tt->enum_def.fields[1].val = TIMESTAMP_FCAST_TIME;
    tt->single_val.e = TIMESTAMP_FCAST_TIME;
    tt++;
    
    // Parameter 'data_set_info'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_info");
    tt->descr = tdrpStrDup("Data set info.");
    tt->help = tdrpStrDup("This is placed in the MDV master header for documentation purposes.");
    tt->val_offset = (char *) &data_set_info - &_start_;
    tt->single_val.s = tdrpStrDup("This MDV file was created by RUC 2.");
    tt++;
    
    // Parameter 'data_set_name'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_name");
    tt->descr = tdrpStrDup("Data set name.");
    tt->help = tdrpStrDup("This is placed in the MDV master header for documentation purposes.");
    tt->val_offset = (char *) &data_set_name - &_start_;
    tt->single_val.s = tdrpStrDup("RUC 2 model output.");
    tt++;
    
    // Parameter 'data_set_source'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_set_source");
    tt->descr = tdrpStrDup("Data set source details.");
    tt->help = tdrpStrDup("This is placed in the MDV master header for documentation purposes.");
    tt->val_offset = (char *) &data_set_source - &_start_;
    tt->single_val.s = tdrpStrDup("RUC 2 output.");
    tt++;
    
    // Parameter 'mdv_proj_type'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mdv_proj_type");
    tt->descr = tdrpStrDup("Projection type for the output mdv files.If mdv_proj_type is set to OUTPUT_PROJ_NATIVE, then output_origin, output_rotation, output_parallel, and output_grid do not need to be set");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mdv_proj_type - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("OUTPUT_PROJ_FLAT");
      tt->enum_def.fields[0].val = OUTPUT_PROJ_FLAT;
      tt->enum_def.fields[1].name = tdrpStrDup("OUTPUT_PROJ_LATLON");
      tt->enum_def.fields[1].val = OUTPUT_PROJ_LATLON;
      tt->enum_def.fields[2].name = tdrpStrDup("OUTPUT_PROJ_LAMBERT_CONF");
      tt->enum_def.fields[2].val = OUTPUT_PROJ_LAMBERT_CONF;
      tt->enum_def.fields[3].name = tdrpStrDup("OUTPUT_PROJ_NATIVE");
      tt->enum_def.fields[3].val = OUTPUT_PROJ_NATIVE;
    tt->single_val.e = OUTPUT_PROJ_FLAT;
    tt++;
    
    // Parameter 'output_origin'
    // ctype is '_output_origin_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_origin");
    tt->descr = tdrpStrDup("Origin of output grid.");
    tt->help = tdrpStrDup("Used with OUTPUT_PROJ_FLAT and OUTPUT_PROJ_LAMBERT_CONF only.");
    tt->val_offset = (char *) &output_origin - &_start_;
    tt->struct_def.name = tdrpStrDup("output_origin_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("lat");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &output_origin.lat - (char *) &output_origin;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("lon");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &output_origin.lon - (char *) &output_origin;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 40;
      tt->struct_vals[1].d = -104;
    tt++;
    
    // Parameter 'output_rotation'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("output_rotation");
    tt->descr = tdrpStrDup("rotation of output grid.");
    tt->help = tdrpStrDup("Used with OUTPUT_PROJ_FLAT only.");
    tt->val_offset = (char *) &output_rotation - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'output_parallel'
    // ctype is '_output_parallel_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_parallel");
    tt->descr = tdrpStrDup("Standard parallels of output projection.");
    tt->help = tdrpStrDup("Used with OUTPUT_PROJ_LAMBERT_CONF only.");
    tt->val_offset = (char *) &output_parallel - &_start_;
    tt->struct_def.name = tdrpStrDup("output_parallel_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("double");
      tt->struct_def.fields[0].fname = tdrpStrDup("lat1");
      tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &output_parallel.lat1 - (char *) &output_parallel;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("lat2");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &output_parallel.lat2 - (char *) &output_parallel;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].d = 25;
      tt->struct_vals[1].d = 25;
    tt++;
    
    // Parameter 'output_grid'
    // ctype is '_output_grid_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_grid");
    tt->descr = tdrpStrDup("Output grid parameters.");
    tt->help = tdrpStrDup("The grid params for the output grid.  Note that the units of minz and dz will depend on the type of output levels selected.  If natural levels are selected, the units will in level numbers, and the value of dz will be overridden.  Note also that if the output grid is lat/lon, the units of minx, miny, dx and dy are in degrees; otherwise they are in km");
    tt->val_offset = (char *) &output_grid - &_start_;
    tt->struct_def.name = tdrpStrDup("output_grid_t");
    tt->struct_def.nfields = 9;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("nx");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &output_grid.nx - (char *) &output_grid;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("ny");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &output_grid.ny - (char *) &output_grid;
      tt->struct_def.fields[2].ftype = tdrpStrDup("int");
      tt->struct_def.fields[2].fname = tdrpStrDup("nz");
      tt->struct_def.fields[2].ptype = INT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &output_grid.nz - (char *) &output_grid;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("minx");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &output_grid.minx - (char *) &output_grid;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("miny");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &output_grid.miny - (char *) &output_grid;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("minz");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &output_grid.minz - (char *) &output_grid;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("dx");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &output_grid.dx - (char *) &output_grid;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("dy");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &output_grid.dy - (char *) &output_grid;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("dz");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &output_grid.dz - (char *) &output_grid;
    tt->n_struct_vals = 9;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 151;
      tt->struct_vals[1].i = 113;
      tt->struct_vals[2].i = 40;
      tt->struct_vals[3].d = -3000;
      tt->struct_vals[4].d = -3000;
      tt->struct_vals[5].d = 0;
      tt->struct_vals[6].d = 40;
      tt->struct_vals[7].d = 40;
      tt->struct_vals[8].d = 1;
    tt++;
    
    // Parameter 'output_fields'
    // ctype is '_out_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("output_fields");
    tt->descr = tdrpStrDup("List of output fields, which are descibed by the field parameter, vertical level type and output units. This list is only needed if output_all_fields is set to FALSE.\n The list of GRIB parameters are:\nPRESSURE=1                        PRESSURE_TENDENCY=3\nGEOPOTENTIAL_HEIGHT=7             CLOUD_HEIGHT=8\nTEMPERATURE=11                    POTENTIAL_TEMPERATURE=13\nEQUIVALENT_POTENTIAL_TEMP=14      DEW_POINT_TEMPERATURE=17\nDEW_POINT_DEPRESSION=18           VISIBILITY=20 \nWDIR=31                           WIND=32\nU_WIND=33                         V_WIND=34\nVERTICAL_VELOCITY=39              SPECIFIC_HUMIDITY=51\nRELATIVE_HUMIDITY=52              HUMIDITY_MIXING_RATIO=53\nPRECIPITABLE_WATER=54             PRECIPITATION_RATE=59\nTOTAL_PRECIPITATION=61            LARGE_SCALE_PRECIPITATION=62\nCONVECTIVE_PRECIPITATION=63       WATER_EQIV_ACCUM_SNOW_DEPTH=65\nSNOW_DEPTH=66                     LOW_CLOUD_COVER=73\nMED_CLOUD_COVER=74                HIGH_CLOUD_COVER=75 \nBEST_LIFTED_INDEX=77              ALBEDO=84\nSOIL_TEMPERATURE=85               TSOIL=85\nSOIL_MOISTURE_CONTENT=86\nSNOW_MELT=99                      SHORTWAVE_RAD_AT_SURFACE=111\nLONGWAVE_RAD_AT_SURFACE=112       SHORTWAVE_RAD_AT_TOP=113\nLONGWAVE_RAD_AT_TOP=114           LATENT_HEAT_FLUX=121\nSENSIBLE_HEAT_FLUX=122            MEAN_SEA_LEVEL_PRESS_SAR=128\nMEAN_SEA_LEVEL_PRESS_MAPS=129     SURFACE_LIFTED_INDEX=131\nPRESS=131\nHORZ_MOISTURE_CONVERGENCE=135     PBLHGT=137\nCATEGORICAL_RAIN=140\nCATEGORICAL_FREEZING_RAIN=141     CATEGORICAL_ICE_PELLETS=142\nCATEGORICAL_SNOW=143              VOL_SOIL_MOISTURE_CONTENT=144\nSOILW=144\nPOTENTIAL_VORTICITY=149           CLOUD_WATER_MIXING_RATIO=153\nCONVECTIVE_INHIBITION=156         CONVEC_AVIAL_POT_ENERGY=157\nSOILL=160\nTURBULENT_KINETIC_ENERGY=158      RAIN_WATER_MIXING_RATIO=170\nSNOW_MIXING_RATIO=171             MOMENTUM_FLUX=172\nNLAT=176                          ELON=177\nICE_MIXING_RATIO=178              GRAUPEL_MIXING_RATIO=179\nTURB_SIGMET_AIRMET=185            ICING_SIGMET_AIRMET=186\nLIGHTNING=187                     RATE_WATER_CANOPY2GROUND=188\nVIRTUAL_POTENTIAL_TEMP=189        STORM_RELATIVE_HELICITY=190\nPSTAR=191                         PRSPRT=192\nPBLREG=193                        FRIVEL=194\nU_STORM_MOTION=196                V_STORM_MOTION=197\nNUM_CONCEN_ICE_PARTICLES=198      DIRECT_EVAPORATION_BARE_SOIL=199\nMAPSCL=199\nDOWN_SHORTWAVE_RAD_FLUX=204       DOWN_LONGWAVE_RAD_FLUX=205\nUP_SHORTWAVE_RAD_FLUX=211         UP_LONGWAVE_RAD_FLUX=212\nPBL_HEIGHT=221                    PLANT_CANOPY_SURFACE_WATER=223\nSOIL_TYPE=224                     VEGETATION_TYPE=225\nVGTYP=225                         TB=226\nSNOW_PHASE_CHANGE_HEAT_FLUX=229   BASEFLOW_GRDWATER_RUNOFF=234\nSTORM_SURFACE_RUNOFF=235          SNOW_TEMPERATURE=239\nDRAG_COEFFICIENT=253              GUST_WIND_SPEED=255\nWATER_VAPOR_MIXING_RATIO=185\n\n\nThe list of available vertical levels are:\nGROUND_OR_WATER_SURFACE=1      CLOUD_BASE_LEVEL=2\nCLOUD_TOP_LEVEL=3              LEVEL_OF_0_DEGREE_ISOTHERM=4\nMAXIMUM_WIND_LEVEL=6           TROPOPAUSE=7\nISOBARIC=100                   MEAN_SEA_LEVEL=102\nSPECF_HEIGHT_ABOVE_GROUND=105  HYBRID=109\nDEPTH_BELOW_SURFACE=111\nLAYER_BETWEEN_TWO_DEPTHS_BELOW_SURFACE=112\nLAYER_BETWEEN_TWO_LEVELS_AT_SPECIFIED_PRESSURES=116\nENTIRE_ATMOSPHERE=200          HIGHEST_TROPO_FREEZE_LEVEL=204\nCONVECTIVE_CLOUD_TOP_LEVEL=243 MAXIMUM_EPOT_LEVEL=246\nEQUILIBRIUM_LEVEL=247\n\n\nThe list of unit conversions are:\nNO_CHANGE            -- no change to units\nMPS_TO_KNOTS         -- convert m/s to knots\nM_TO_KM              -- convert meters to kilometers\nM_TO_100FT           -- convert meters to 100's of feet, fligh levels\nPASCALS_TO_MBAR      -- convert pascals to millibars\nKELVIN_TO_CELSIUS    -- convert degrees kelvin to to degrees celsius\nKGPKG_TO_GPKG        -- convert kilogram per kilogram to gram\n                        per kilogram\nKGPM2PS_TO_MMPHR     -- convert kg/m^2/s to mm/hr\nPERCENT_TO_FRACTION  -- convert percentage to fraction, values\n                        between 0 and 1\n\n\n");
    tt->help = tdrpStrDup("The integers following each GRIB field and vertical type are the actual values used in the GRIB files. They are present to provide a reference for the GRIB and RUC documentation. For a more detailed description of the GRIB fields and types of vertical levels see the listings at http://maps.fsl.noaa.gov/ruc2gribtable.html. For a description of the GRIB file format see the documentation at http://www.wmo.ch/web/www/reports/Guide-binary-2.html\n\nThe expected fields and their associated vertical levels in the hybrid RUC GRIB file are:\nPRESSURE			HYBRID\nGEOPOTENTIAL_HEIGHT		HYBRID\nVIRTUAL_POTENTIAL_TEMP	HYBRID\nHUMIDITY_MIXING_RATIO	HYBRID\nU_WIND			HYBRID\nV_WIND			HYBRID\nVERTICAL_VELOCITY		HYBRID\nCLOUD_WATER_MIXING_RATIO	HYBRID\nRAIN_WATER_MIXING_RATIO	HYBRID\nICE_MIXING_RATIO		HYBRID\nSNOW_MIXING_RATIO		HYBRID\nGRAUPEL_MIXING_RATIO		HYBRID\nNUM_CONCEN_ICE_PARTICLES	HYBRID\nTURBULENT_KINETIC_ENERGY	HYBRID\nMEAN_SEA_LEVEL_PRESS_MAPS	MEAN_SEA_LEVEL\nSOIL_TEMPERATURE		GROUND_OR_WATER_SURFACE\nSENSIBLE_HEAT_FLUX		GROUND_OR_WATER_SURFACE\nLATENT_HEAT_FLUX		GROUND_OR_WATER_SURFACE\nLONGWAVE_RAD_AT_SURFACE	GROUND_OR_WATER_SURFACE\nPRECIPITATION_RATE		GROUND_OR_WATER_SURFACE\nLARGE_SCALE_PRECIPITATION	GROUND_OR_WATER_SURFACE\nCONVECTIVE_PRECIPITATION	GROUND_OR_WATER_SURFACE\nPRECIPITABLE_WATER		ENTIRE_ATMOSPHERE\nPRESSURE			TROPOPAUSE\nPOTENTIAL_TEMPERATURE	TROPOPAUSE\nU_WIND			TROPOPAUSE\nV_WIND			TROPOPAUSE\nCONVEC_AVIAL_POT_ENERGY	GROUND_OR_WATER_SURFACE\nCONVECTIVE_INHIBITION	GROUND_OR_WATER_SURFACE\nSOIL_TYPE			GROUND_OR_WATER_SURFACE\nVEGETATION_TYPE		GROUND_OR_WATER_SURFACE\nICING_SIGMET_AIRMET		GROUND_OR_WATER_SURFACE\nLIGHTNING			GROUND_OR_WATER_SURFACE\nSHORTWAVE_RAD_AT_SURFACE	GROUND_OR_WATER_SURFACE\nWATER_EQIV_ACCUM_SNOW_DEPTH	GROUND_OR_WATER_SURFACE\nSNOW_DEPTH			GROUND_OR_WATER_SURFACE\nSTORM_SURFACE_RUNOFF		GROUND_OR_WATER_SURFACE\nPLANT_CANOPY_SURFACE_WATER	GROUND_OR_WATER_SURFACE\nHUMIDITY_MIXING_RATIO	GROUND_OR_WATER_SURFACE\n\nThe expected fields and their associated vertical levels in the pressure RUC GRIB file are:\nGEOPOTENTIAL_HEIGHT		ISOBARIC\nTEMPERATURE			ISOBARIC\nRELATIVE_HUMIDITY		ISOBARIC\nU_WIND			ISOBARIC\nV_WIND			ISOBARIC\nVERTICAL_VELOCITY		ISOBARIC\nMEAN_SEA_LEVEL_PRESS_MAPS	MEAN_SEA_LEVEL\nPRESSURE			GROUND_OR_WATER_SURFACE\nPRESSURE_TENDENCY		GROUND_OR_WATER_SURFACE\nEQUIVALENT_POTENTIAL_TEMP	GROUND_OR_WATER_SURFACE\nCONVEC_AVIAL_POT_ENERGY	GROUND_OR_WATER_SURFACE\nCONVECTIVE_INHIBITION	GROUND_OR_WATER_SURFACE\nSURFACE_LIFTED_INDEX		GROUND_OR_WATER_SURFACE\nBEST_LIFTED_INDEX		GROUND_OR_WATER_SURFACE\nLARGE_SCALE_PRECIPITATION	GROUND_OR_WATER_SURFACE\nCONVECTIVE_PRECIPITATION	GROUND_OR_WATER_SURFACE\nCATEGORICAL_RAIN		GROUND_OR_WATER_SURFACE\nCATEGORICAL_FREEZING_RAIN	GROUND_OR_WATER_SURFACE\nCATEGORICAL_ICE_PELLETS	GROUND_OR_WATER_SURFACE\nCATEGORICAL_SNOW		GROUND_OR_WATER_SURFACE\nWATER_EQIV_ACCUM_SNOW_DEPTH	GROUND_OR_WATER_SURFACE\nSTORM_RELATIVE_HELICITY	GROUND_OR_WATER_SURFACE\nPRESSURE			LEVEL_OF_0_DEGREE_ISOTHERM\nGEOPOTENTIAL_HEIGHT		LEVEL_OF_0_DEGREE_ISOTHERM\nRELATIVE_HUMIDITY		LEVEL_OF_0_DEGREE_ISOTHERM\nPRESSURE			TROPOPAUSE\nPOTENTIAL_TEMPERATURE	TROPOPAUSE\nU_WIND			TROPOPAUSE\nV_WIND			TROPOPAUSE\nPRESSURE			MAXIMUM_WIND_LEVEL\nU_WIND			MAXIMUM_WIND_LEVEL\nV_WIND			MAXIMUM_WIND_LEVEL\nPRECIPITATION_RATE		GROUND_OR_WATER_SURFACE\nDIRECT_EVAPORATION_BARE_SOIL	GROUND_OR_WATER_SURFACE\nSTORM_SURFACE_RUNOFF		GROUND_OR_WATER_SURFACE\nPRESSURE			GROUND_OR_WATER_SURFACE\nGEOPOTENTIAL_HEIGHT		GROUND_OR_WATER_SURFACE\nPRESSURE			HIGHEST_TROPO_FREEZE_LEVEL\nGEOPOTENTIAL_HEIGHT		HIGHEST_TROPO_FREEZE_LEVEL\nRELATIVE_HUMIDITY		HIGHEST_TROPO_FREEZE_LEVEL\nSNOW_DEPTH			GROUND_OR_WATER_SURFACE\nPRECIPITABLE_WATER		ENTIRE_ATMOSPHERE\nU_STORM_MOTION		GROUND_OR_WATER_SURFACE\nV_STORM_MOTION		GROUND_OR_WATER_SURFACE\nPBL_HEIGHT			GROUND_OR_WATER_SURFACE\nCLOUD_HEIGHT			CLOUD_BASE_LEVEL\nCLOUD_HEIGHT			CLOUD_TOP_LEVEL\nVISIBILITY			GROUND_OR_WATER_SURFACE\nGEOPOTENTIAL_HEIGHT		CONVECTIVE_CLOUD_TOP_LEVEL\n\nThe expected fields and their associated vertical levels in the surface RUC GRIB file are:\nMEAN_SEA_LEVEL_PRESS_MAPS	MEAN_SEA_LEVEL\nMEAN_SEA_LEVEL_PRESS_SAR	MEAN_SEA_LEVEL\nPRESSURE_TENDENCY		GROUND_OR_WATER_SURFACE\nEQUIVALENT_POTENTIAL_TEMP	GROUND_OR_WATER_SURFACE\nCONVEC_AVIAL_POT_ENERGY	GROUND_OR_WATER_SURFACE\nCONVECTIVE_INHIBITION	GROUND_OR_WATER_SURFACE\nSURFACE_LIFTED_INDEX		GROUND_OR_WATER_SURFACE\nBEST_LIFTED_INDEX		GROUND_OR_WATER_SURFACE\nLARGE_SCALE_PRECIPITATION	GROUND_OR_WATER_SURFACE\nCONVECTIVE_PRECIPITATION	GROUND_OR_WATER_SURFACE\nCATEGORICAL_RAIN		GROUND_OR_WATER_SURFACE\nCATEGORICAL_FREEZING_RAIN	GROUND_OR_WATER_SURFACE\nCATEGORICAL_ICE_PELLETS	GROUND_OR_WATER_SURFACE\nCATEGORICAL_SNOW		GROUND_OR_WATER_SURFACE\nWATER_EQIV_ACCUM_SNOW_DEPTH	GROUND_OR_WATER_SURFACE\nSTORM_RELATIVE_HELICITY	GROUND_OR_WATER_SURFACE\n");
    tt->array_offset = (char *) &_output_fields - &_start_;
    tt->array_n_offset = (char *) &output_fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(out_field_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("out_field_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("param_id_t");
      tt->struct_def.fields[0].fname = tdrpStrDup("param_id");
      tt->struct_def.fields[0].ptype = ENUM_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_output_fields->param_id - (char *) _output_fields;
        tt->struct_def.fields[0].enum_def.name = tdrpStrDup("param_id_t");
        tt->struct_def.fields[0].enum_def.nfields = 150;
        tt->struct_def.fields[0].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[0].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[0].enum_def.fields[0].name = tdrpStrDup("UNKNOWN");
        tt->struct_def.fields[0].enum_def.fields[0].val = UNKNOWN;
        tt->struct_def.fields[0].enum_def.fields[1].name = tdrpStrDup("PRESSURE");
        tt->struct_def.fields[0].enum_def.fields[1].val = PRESSURE;
        tt->struct_def.fields[0].enum_def.fields[2].name = tdrpStrDup("PRES");
        tt->struct_def.fields[0].enum_def.fields[2].val = PRES;
        tt->struct_def.fields[0].enum_def.fields[3].name = tdrpStrDup("PRMSL");
        tt->struct_def.fields[0].enum_def.fields[3].val = PRMSL;
        tt->struct_def.fields[0].enum_def.fields[4].name = tdrpStrDup("PRESSURE_TENDENCY");
        tt->struct_def.fields[0].enum_def.fields[4].val = PRESSURE_TENDENCY;
        tt->struct_def.fields[0].enum_def.fields[5].name = tdrpStrDup("GEOPOTENTIAL_HEIGHT");
        tt->struct_def.fields[0].enum_def.fields[5].val = GEOPOTENTIAL_HEIGHT;
        tt->struct_def.fields[0].enum_def.fields[6].name = tdrpStrDup("HGT");
        tt->struct_def.fields[0].enum_def.fields[6].val = HGT;
        tt->struct_def.fields[0].enum_def.fields[7].name = tdrpStrDup("CLOUD_HEIGHT");
        tt->struct_def.fields[0].enum_def.fields[7].val = CLOUD_HEIGHT;
        tt->struct_def.fields[0].enum_def.fields[8].name = tdrpStrDup("TOZNE");
        tt->struct_def.fields[0].enum_def.fields[8].val = TOZNE;
        tt->struct_def.fields[0].enum_def.fields[9].name = tdrpStrDup("TEMPERATURE");
        tt->struct_def.fields[0].enum_def.fields[9].val = TEMPERATURE;
        tt->struct_def.fields[0].enum_def.fields[10].name = tdrpStrDup("TMP");
        tt->struct_def.fields[0].enum_def.fields[10].val = TMP;
        tt->struct_def.fields[0].enum_def.fields[11].name = tdrpStrDup("POTENTIAL_TEMPERATURE");
        tt->struct_def.fields[0].enum_def.fields[11].val = POTENTIAL_TEMPERATURE;
        tt->struct_def.fields[0].enum_def.fields[12].name = tdrpStrDup("POT");
        tt->struct_def.fields[0].enum_def.fields[12].val = POT;
        tt->struct_def.fields[0].enum_def.fields[13].name = tdrpStrDup("EQUIVALENT_POTENTIAL_TEMP");
        tt->struct_def.fields[0].enum_def.fields[13].val = EQUIVALENT_POTENTIAL_TEMP;
        tt->struct_def.fields[0].enum_def.fields[14].name = tdrpStrDup("DEW_POINT_TEMPERATURE");
        tt->struct_def.fields[0].enum_def.fields[14].val = DEW_POINT_TEMPERATURE;
        tt->struct_def.fields[0].enum_def.fields[15].name = tdrpStrDup("DEW_POINT_DEPRESSION");
        tt->struct_def.fields[0].enum_def.fields[15].val = DEW_POINT_DEPRESSION;
        tt->struct_def.fields[0].enum_def.fields[16].name = tdrpStrDup("VISIBILITY");
        tt->struct_def.fields[0].enum_def.fields[16].val = VISIBILITY;
        tt->struct_def.fields[0].enum_def.fields[17].name = tdrpStrDup("PLI");
        tt->struct_def.fields[0].enum_def.fields[17].val = PLI;
        tt->struct_def.fields[0].enum_def.fields[18].name = tdrpStrDup("GPA");
        tt->struct_def.fields[0].enum_def.fields[18].val = GPA;
        tt->struct_def.fields[0].enum_def.fields[19].name = tdrpStrDup("WDIR");
        tt->struct_def.fields[0].enum_def.fields[19].val = WDIR;
        tt->struct_def.fields[0].enum_def.fields[20].name = tdrpStrDup("WIND_DIRECTION_FROM");
        tt->struct_def.fields[0].enum_def.fields[20].val = WIND_DIRECTION_FROM;
        tt->struct_def.fields[0].enum_def.fields[21].name = tdrpStrDup("WIND");
        tt->struct_def.fields[0].enum_def.fields[21].val = WIND;
        tt->struct_def.fields[0].enum_def.fields[22].name = tdrpStrDup("WIND_SPEED");
        tt->struct_def.fields[0].enum_def.fields[22].val = WIND_SPEED;
        tt->struct_def.fields[0].enum_def.fields[23].name = tdrpStrDup("U_WIND");
        tt->struct_def.fields[0].enum_def.fields[23].val = U_WIND;
        tt->struct_def.fields[0].enum_def.fields[24].name = tdrpStrDup("UGRD");
        tt->struct_def.fields[0].enum_def.fields[24].val = UGRD;
        tt->struct_def.fields[0].enum_def.fields[25].name = tdrpStrDup("V_WIND");
        tt->struct_def.fields[0].enum_def.fields[25].val = V_WIND;
        tt->struct_def.fields[0].enum_def.fields[26].name = tdrpStrDup("VGRD");
        tt->struct_def.fields[0].enum_def.fields[26].val = VGRD;
        tt->struct_def.fields[0].enum_def.fields[27].name = tdrpStrDup("VERTICAL_VELOCITY");
        tt->struct_def.fields[0].enum_def.fields[27].val = VERTICAL_VELOCITY;
        tt->struct_def.fields[0].enum_def.fields[28].name = tdrpStrDup("VVEL");
        tt->struct_def.fields[0].enum_def.fields[28].val = VVEL;
        tt->struct_def.fields[0].enum_def.fields[29].name = tdrpStrDup("DZDT");
        tt->struct_def.fields[0].enum_def.fields[29].val = DZDT;
        tt->struct_def.fields[0].enum_def.fields[30].name = tdrpStrDup("ABSV");
        tt->struct_def.fields[0].enum_def.fields[30].val = ABSV;
        tt->struct_def.fields[0].enum_def.fields[31].name = tdrpStrDup("SPECIFIC_HUMIDITY");
        tt->struct_def.fields[0].enum_def.fields[31].val = SPECIFIC_HUMIDITY;
        tt->struct_def.fields[0].enum_def.fields[32].name = tdrpStrDup("SPFH");
        tt->struct_def.fields[0].enum_def.fields[32].val = SPFH;
        tt->struct_def.fields[0].enum_def.fields[33].name = tdrpStrDup("RELATIVE_HUMIDITY");
        tt->struct_def.fields[0].enum_def.fields[33].val = RELATIVE_HUMIDITY;
        tt->struct_def.fields[0].enum_def.fields[34].name = tdrpStrDup("RH");
        tt->struct_def.fields[0].enum_def.fields[34].val = RH;
        tt->struct_def.fields[0].enum_def.fields[35].name = tdrpStrDup("HUMIDITY_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[35].val = HUMIDITY_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[36].name = tdrpStrDup("PRECIPITABLE_WATER");
        tt->struct_def.fields[0].enum_def.fields[36].val = PRECIPITABLE_WATER;
        tt->struct_def.fields[0].enum_def.fields[37].name = tdrpStrDup("PWAT");
        tt->struct_def.fields[0].enum_def.fields[37].val = PWAT;
        tt->struct_def.fields[0].enum_def.fields[38].name = tdrpStrDup("CICE");
        tt->struct_def.fields[0].enum_def.fields[38].val = CICE;
        tt->struct_def.fields[0].enum_def.fields[39].name = tdrpStrDup("PRECIPITATION_RATE");
        tt->struct_def.fields[0].enum_def.fields[39].val = PRECIPITATION_RATE;
        tt->struct_def.fields[0].enum_def.fields[40].name = tdrpStrDup("TOTAL_PRECIPITATION");
        tt->struct_def.fields[0].enum_def.fields[40].val = TOTAL_PRECIPITATION;
        tt->struct_def.fields[0].enum_def.fields[41].name = tdrpStrDup("LARGE_SCALE_PRECIPITATION");
        tt->struct_def.fields[0].enum_def.fields[41].val = LARGE_SCALE_PRECIPITATION;
        tt->struct_def.fields[0].enum_def.fields[42].name = tdrpStrDup("CONVECTIVE_PRECIPITATION");
        tt->struct_def.fields[0].enum_def.fields[42].val = CONVECTIVE_PRECIPITATION;
        tt->struct_def.fields[0].enum_def.fields[43].name = tdrpStrDup("WATER_EQIV_ACCUM_SNOW_DEPTH");
        tt->struct_def.fields[0].enum_def.fields[43].val = WATER_EQIV_ACCUM_SNOW_DEPTH;
        tt->struct_def.fields[0].enum_def.fields[44].name = tdrpStrDup("WEASD");
        tt->struct_def.fields[0].enum_def.fields[44].val = WEASD;
        tt->struct_def.fields[0].enum_def.fields[45].name = tdrpStrDup("SNOW_DEPTH");
        tt->struct_def.fields[0].enum_def.fields[45].val = SNOW_DEPTH;
        tt->struct_def.fields[0].enum_def.fields[46].name = tdrpStrDup("TCDC");
        tt->struct_def.fields[0].enum_def.fields[46].val = TCDC;
        tt->struct_def.fields[0].enum_def.fields[47].name = tdrpStrDup("LOW_CLOUD_COVER");
        tt->struct_def.fields[0].enum_def.fields[47].val = LOW_CLOUD_COVER;
        tt->struct_def.fields[0].enum_def.fields[48].name = tdrpStrDup("MED_CLOUD_COVER");
        tt->struct_def.fields[0].enum_def.fields[48].val = MED_CLOUD_COVER;
        tt->struct_def.fields[0].enum_def.fields[49].name = tdrpStrDup("HIGH_CLOUD_COVER");
        tt->struct_def.fields[0].enum_def.fields[49].val = HIGH_CLOUD_COVER;
        tt->struct_def.fields[0].enum_def.fields[50].name = tdrpStrDup("CWAT");
        tt->struct_def.fields[0].enum_def.fields[50].val = CWAT;
        tt->struct_def.fields[0].enum_def.fields[51].name = tdrpStrDup("BEST_LIFTED_INDEX");
        tt->struct_def.fields[0].enum_def.fields[51].val = BEST_LIFTED_INDEX;
        tt->struct_def.fields[0].enum_def.fields[52].name = tdrpStrDup("LAND");
        tt->struct_def.fields[0].enum_def.fields[52].val = LAND;
        tt->struct_def.fields[0].enum_def.fields[53].name = tdrpStrDup("ALBEDO");
        tt->struct_def.fields[0].enum_def.fields[53].val = ALBEDO;
        tt->struct_def.fields[0].enum_def.fields[54].name = tdrpStrDup("SOIL_TEMPERATURE");
        tt->struct_def.fields[0].enum_def.fields[54].val = SOIL_TEMPERATURE;
        tt->struct_def.fields[0].enum_def.fields[55].name = tdrpStrDup("TSOIL");
        tt->struct_def.fields[0].enum_def.fields[55].val = TSOIL;
        tt->struct_def.fields[0].enum_def.fields[56].name = tdrpStrDup("SOIL_MOISTURE_CONTENT");
        tt->struct_def.fields[0].enum_def.fields[56].val = SOIL_MOISTURE_CONTENT;
        tt->struct_def.fields[0].enum_def.fields[57].name = tdrpStrDup("ICEC");
        tt->struct_def.fields[0].enum_def.fields[57].val = ICEC;
        tt->struct_def.fields[0].enum_def.fields[58].name = tdrpStrDup("SNOW_MELT");
        tt->struct_def.fields[0].enum_def.fields[58].val = SNOW_MELT;
        tt->struct_def.fields[0].enum_def.fields[59].name = tdrpStrDup("SHORTWAVE_RAD_AT_SURFACE");
        tt->struct_def.fields[0].enum_def.fields[59].val = SHORTWAVE_RAD_AT_SURFACE;
        tt->struct_def.fields[0].enum_def.fields[60].name = tdrpStrDup("LONGWAVE_RAD_AT_SURFACE");
        tt->struct_def.fields[0].enum_def.fields[60].val = LONGWAVE_RAD_AT_SURFACE;
        tt->struct_def.fields[0].enum_def.fields[61].name = tdrpStrDup("SHORTWAVE_RAD_AT_TOP");
        tt->struct_def.fields[0].enum_def.fields[61].val = SHORTWAVE_RAD_AT_TOP;
        tt->struct_def.fields[0].enum_def.fields[62].name = tdrpStrDup("LONGWAVE_RAD_AT_TOP");
        tt->struct_def.fields[0].enum_def.fields[62].val = LONGWAVE_RAD_AT_TOP;
        tt->struct_def.fields[0].enum_def.fields[63].name = tdrpStrDup("LATENT_HEAT_FLUX");
        tt->struct_def.fields[0].enum_def.fields[63].val = LATENT_HEAT_FLUX;
        tt->struct_def.fields[0].enum_def.fields[64].name = tdrpStrDup("SENSIBLE_HEAT_FLUX");
        tt->struct_def.fields[0].enum_def.fields[64].val = SENSIBLE_HEAT_FLUX;
        tt->struct_def.fields[0].enum_def.fields[65].name = tdrpStrDup("SHTFL");
        tt->struct_def.fields[0].enum_def.fields[65].val = SHTFL;
        tt->struct_def.fields[0].enum_def.fields[66].name = tdrpStrDup("MEAN_SEA_LEVEL_PRESS_SAR");
        tt->struct_def.fields[0].enum_def.fields[66].val = MEAN_SEA_LEVEL_PRESS_SAR;
        tt->struct_def.fields[0].enum_def.fields[67].name = tdrpStrDup("PBL_REGIME");
        tt->struct_def.fields[0].enum_def.fields[67].val = PBL_REGIME;
        tt->struct_def.fields[0].enum_def.fields[68].name = tdrpStrDup("MEAN_SEA_LEVEL_PRESS_MAPS");
        tt->struct_def.fields[0].enum_def.fields[68].val = MEAN_SEA_LEVEL_PRESS_MAPS;
        tt->struct_def.fields[0].enum_def.fields[69].name = tdrpStrDup("SURFACE_LIFTED_INDEX");
        tt->struct_def.fields[0].enum_def.fields[69].val = SURFACE_LIFTED_INDEX;
        tt->struct_def.fields[0].enum_def.fields[70].name = tdrpStrDup("LFTX");
        tt->struct_def.fields[0].enum_def.fields[70].val = LFTX;
        tt->struct_def.fields[0].enum_def.fields[71].name = tdrpStrDup("PRESS");
        tt->struct_def.fields[0].enum_def.fields[71].val = PRESS;
        tt->struct_def.fields[0].enum_def.fields[72].name = tdrpStrDup("FOUR_LFTX");
        tt->struct_def.fields[0].enum_def.fields[72].val = FOUR_LFTX;
        tt->struct_def.fields[0].enum_def.fields[73].name = tdrpStrDup("HORZ_MOISTURE_CONVERGENCE");
        tt->struct_def.fields[0].enum_def.fields[73].val = HORZ_MOISTURE_CONVERGENCE;
        tt->struct_def.fields[0].enum_def.fields[74].name = tdrpStrDup("VWSH");
        tt->struct_def.fields[0].enum_def.fields[74].val = VWSH;
        tt->struct_def.fields[0].enum_def.fields[75].name = tdrpStrDup("PBLHGT");
        tt->struct_def.fields[0].enum_def.fields[75].val = PBLHGT;
        tt->struct_def.fields[0].enum_def.fields[76].name = tdrpStrDup("CATEGORICAL_RAIN");
        tt->struct_def.fields[0].enum_def.fields[76].val = CATEGORICAL_RAIN;
        tt->struct_def.fields[0].enum_def.fields[77].name = tdrpStrDup("CATEGORICAL_FREEZING_RAIN");
        tt->struct_def.fields[0].enum_def.fields[77].val = CATEGORICAL_FREEZING_RAIN;
        tt->struct_def.fields[0].enum_def.fields[78].name = tdrpStrDup("CATEGORICAL_ICE_PELLETS");
        tt->struct_def.fields[0].enum_def.fields[78].val = CATEGORICAL_ICE_PELLETS;
        tt->struct_def.fields[0].enum_def.fields[79].name = tdrpStrDup("CATEGORICAL_SNOW");
        tt->struct_def.fields[0].enum_def.fields[79].val = CATEGORICAL_SNOW;
        tt->struct_def.fields[0].enum_def.fields[80].name = tdrpStrDup("VOL_SOIL_MOISTURE_CONTENT");
        tt->struct_def.fields[0].enum_def.fields[80].val = VOL_SOIL_MOISTURE_CONTENT;
        tt->struct_def.fields[0].enum_def.fields[81].name = tdrpStrDup("SOILW");
        tt->struct_def.fields[0].enum_def.fields[81].val = SOILW;
        tt->struct_def.fields[0].enum_def.fields[82].name = tdrpStrDup("POTENTIAL_VORTICITY");
        tt->struct_def.fields[0].enum_def.fields[82].val = POTENTIAL_VORTICITY;
        tt->struct_def.fields[0].enum_def.fields[83].name = tdrpStrDup("CLOUD_WATER_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[83].val = CLOUD_WATER_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[84].name = tdrpStrDup("CLWMR");
        tt->struct_def.fields[0].enum_def.fields[84].val = CLWMR;
        tt->struct_def.fields[0].enum_def.fields[85].name = tdrpStrDup("O3MR");
        tt->struct_def.fields[0].enum_def.fields[85].val = O3MR;
        tt->struct_def.fields[0].enum_def.fields[86].name = tdrpStrDup("CONVECTIVE_INHIBITION");
        tt->struct_def.fields[0].enum_def.fields[86].val = CONVECTIVE_INHIBITION;
        tt->struct_def.fields[0].enum_def.fields[87].name = tdrpStrDup("CIN");
        tt->struct_def.fields[0].enum_def.fields[87].val = CIN;
        tt->struct_def.fields[0].enum_def.fields[88].name = tdrpStrDup("CONVEC_AVIAL_POT_ENERGY");
        tt->struct_def.fields[0].enum_def.fields[88].val = CONVEC_AVIAL_POT_ENERGY;
        tt->struct_def.fields[0].enum_def.fields[89].name = tdrpStrDup("CAPE");
        tt->struct_def.fields[0].enum_def.fields[89].val = CAPE;
        tt->struct_def.fields[0].enum_def.fields[90].name = tdrpStrDup("TURBULENT_KINETIC_ENERGY");
        tt->struct_def.fields[0].enum_def.fields[90].val = TURBULENT_KINETIC_ENERGY;
        tt->struct_def.fields[0].enum_def.fields[91].name = tdrpStrDup("SOILL");
        tt->struct_def.fields[0].enum_def.fields[91].val = SOILL;
        tt->struct_def.fields[0].enum_def.fields[92].name = tdrpStrDup("CLOUD_FORCING_NET_LONG_WAVE_FLUX");
        tt->struct_def.fields[0].enum_def.fields[92].val = CLOUD_FORCING_NET_LONG_WAVE_FLUX;
        tt->struct_def.fields[0].enum_def.fields[93].name = tdrpStrDup("VISIBLE_BEAM_DOWNWARD_SOLAR_FLUX");
        tt->struct_def.fields[0].enum_def.fields[93].val = VISIBLE_BEAM_DOWNWARD_SOLAR_FLUX;
        tt->struct_def.fields[0].enum_def.fields[94].name = tdrpStrDup("VISIBLE_DIFFUSE_DOWNWARD_SOLAR_FLUX");
        tt->struct_def.fields[0].enum_def.fields[94].val = VISIBLE_DIFFUSE_DOWNWARD_SOLAR_FLUX;
        tt->struct_def.fields[0].enum_def.fields[95].name = tdrpStrDup("NEAR_IR_BEAM_DOWNWARD_SOLAR_FLUX");
        tt->struct_def.fields[0].enum_def.fields[95].val = NEAR_IR_BEAM_DOWNWARD_SOLAR_FLUX;
        tt->struct_def.fields[0].enum_def.fields[96].name = tdrpStrDup("RAIN_WATER_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[96].val = RAIN_WATER_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[97].name = tdrpStrDup("SNOW_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[97].val = SNOW_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[98].name = tdrpStrDup("MOMENTUM_FLUX");
        tt->struct_def.fields[0].enum_def.fields[98].val = MOMENTUM_FLUX;
        tt->struct_def.fields[0].enum_def.fields[99].name = tdrpStrDup("NLAT");
        tt->struct_def.fields[0].enum_def.fields[99].val = NLAT;
        tt->struct_def.fields[0].enum_def.fields[100].name = tdrpStrDup("ELON");
        tt->struct_def.fields[0].enum_def.fields[100].val = ELON;
        tt->struct_def.fields[0].enum_def.fields[101].name = tdrpStrDup("ICE_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[101].val = ICE_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[102].name = tdrpStrDup("GRAUPEL_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[102].val = GRAUPEL_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[103].name = tdrpStrDup("WATER_VAPOR_MIXING_RATIO");
        tt->struct_def.fields[0].enum_def.fields[103].val = WATER_VAPOR_MIXING_RATIO;
        tt->struct_def.fields[0].enum_def.fields[104].name = tdrpStrDup("TURB_SIGMET_AIRMET");
        tt->struct_def.fields[0].enum_def.fields[104].val = TURB_SIGMET_AIRMET;
        tt->struct_def.fields[0].enum_def.fields[105].name = tdrpStrDup("ICING_SIGMET_AIRMET");
        tt->struct_def.fields[0].enum_def.fields[105].val = ICING_SIGMET_AIRMET;
        tt->struct_def.fields[0].enum_def.fields[106].name = tdrpStrDup("LIGHTNING");
        tt->struct_def.fields[0].enum_def.fields[106].val = LIGHTNING;
        tt->struct_def.fields[0].enum_def.fields[107].name = tdrpStrDup("RATE_WATER_CANOPY2GROUND");
        tt->struct_def.fields[0].enum_def.fields[107].val = RATE_WATER_CANOPY2GROUND;
        tt->struct_def.fields[0].enum_def.fields[108].name = tdrpStrDup("VIRTUAL_POTENTIAL_TEMP");
        tt->struct_def.fields[0].enum_def.fields[108].val = VIRTUAL_POTENTIAL_TEMP;
        tt->struct_def.fields[0].enum_def.fields[109].name = tdrpStrDup("STORM_RELATIVE_HELICITY");
        tt->struct_def.fields[0].enum_def.fields[109].val = STORM_RELATIVE_HELICITY;
        tt->struct_def.fields[0].enum_def.fields[110].name = tdrpStrDup("PSTAR");
        tt->struct_def.fields[0].enum_def.fields[110].val = PSTAR;
        tt->struct_def.fields[0].enum_def.fields[111].name = tdrpStrDup("PRSPRT");
        tt->struct_def.fields[0].enum_def.fields[111].val = PRSPRT;
        tt->struct_def.fields[0].enum_def.fields[112].name = tdrpStrDup("PBLREG");
        tt->struct_def.fields[0].enum_def.fields[112].val = PBLREG;
        tt->struct_def.fields[0].enum_def.fields[113].name = tdrpStrDup("FRIVEL");
        tt->struct_def.fields[0].enum_def.fields[113].val = FRIVEL;
        tt->struct_def.fields[0].enum_def.fields[114].name = tdrpStrDup("U_STORM_MOTION");
        tt->struct_def.fields[0].enum_def.fields[114].val = U_STORM_MOTION;
        tt->struct_def.fields[0].enum_def.fields[115].name = tdrpStrDup("V_STORM_MOTION");
        tt->struct_def.fields[0].enum_def.fields[115].val = V_STORM_MOTION;
        tt->struct_def.fields[0].enum_def.fields[116].name = tdrpStrDup("NUM_CONCEN_ICE_PARTICLES");
        tt->struct_def.fields[0].enum_def.fields[116].val = NUM_CONCEN_ICE_PARTICLES;
        tt->struct_def.fields[0].enum_def.fields[117].name = tdrpStrDup("DIRECT_EVAPORATION_BARE_SOIL");
        tt->struct_def.fields[0].enum_def.fields[117].val = DIRECT_EVAPORATION_BARE_SOIL;
        tt->struct_def.fields[0].enum_def.fields[118].name = tdrpStrDup("MAPSCL");
        tt->struct_def.fields[0].enum_def.fields[118].val = MAPSCL;
        tt->struct_def.fields[0].enum_def.fields[119].name = tdrpStrDup("UUE");
        tt->struct_def.fields[0].enum_def.fields[119].val = UUE;
        tt->struct_def.fields[0].enum_def.fields[120].name = tdrpStrDup("VVE");
        tt->struct_def.fields[0].enum_def.fields[120].val = VVE;
        tt->struct_def.fields[0].enum_def.fields[121].name = tdrpStrDup("UVE");
        tt->struct_def.fields[0].enum_def.fields[121].val = UVE;
        tt->struct_def.fields[0].enum_def.fields[122].name = tdrpStrDup("DOWN_SHORTWAVE_RAD_FLUX");
        tt->struct_def.fields[0].enum_def.fields[122].val = DOWN_SHORTWAVE_RAD_FLUX;
        tt->struct_def.fields[0].enum_def.fields[123].name = tdrpStrDup("DOWN_LONGWAVE_RAD_FLUX");
        tt->struct_def.fields[0].enum_def.fields[123].val = DOWN_LONGWAVE_RAD_FLUX;
        tt->struct_def.fields[0].enum_def.fields[124].name = tdrpStrDup("UP_SHORTWAVE_RAD_FLUX");
        tt->struct_def.fields[0].enum_def.fields[124].val = UP_SHORTWAVE_RAD_FLUX;
        tt->struct_def.fields[0].enum_def.fields[125].name = tdrpStrDup("UP_LONGWAVE_RAD_FLUX");
        tt->struct_def.fields[0].enum_def.fields[125].val = UP_LONGWAVE_RAD_FLUX;
        tt->struct_def.fields[0].enum_def.fields[126].name = tdrpStrDup("PBL_HEIGHT");
        tt->struct_def.fields[0].enum_def.fields[126].val = PBL_HEIGHT;
        tt->struct_def.fields[0].enum_def.fields[127].name = tdrpStrDup("HPBL");
        tt->struct_def.fields[0].enum_def.fields[127].val = HPBL;
        tt->struct_def.fields[0].enum_def.fields[128].name = tdrpStrDup("FIVE_WAVH");
        tt->struct_def.fields[0].enum_def.fields[128].val = FIVE_WAVH;
        tt->struct_def.fields[0].enum_def.fields[129].name = tdrpStrDup("PLANT_CANOPY_SURFACE_WATER");
        tt->struct_def.fields[0].enum_def.fields[129].val = PLANT_CANOPY_SURFACE_WATER;
        tt->struct_def.fields[0].enum_def.fields[130].name = tdrpStrDup("SOIL_TYPE");
        tt->struct_def.fields[0].enum_def.fields[130].val = SOIL_TYPE;
        tt->struct_def.fields[0].enum_def.fields[131].name = tdrpStrDup("VEGETATION_TYPE");
        tt->struct_def.fields[0].enum_def.fields[131].val = VEGETATION_TYPE;
        tt->struct_def.fields[0].enum_def.fields[132].name = tdrpStrDup("VGTYP");
        tt->struct_def.fields[0].enum_def.fields[132].val = VGTYP;
        tt->struct_def.fields[0].enum_def.fields[133].name = tdrpStrDup("TB");
        tt->struct_def.fields[0].enum_def.fields[133].val = TB;
        tt->struct_def.fields[0].enum_def.fields[134].name = tdrpStrDup("POTENTIAL_EVAPORATION");
        tt->struct_def.fields[0].enum_def.fields[134].val = POTENTIAL_EVAPORATION;
        tt->struct_def.fields[0].enum_def.fields[135].name = tdrpStrDup("SNOW_PHASE_CHANGE_HEAT_FLUX");
        tt->struct_def.fields[0].enum_def.fields[135].val = SNOW_PHASE_CHANGE_HEAT_FLUX;
        tt->struct_def.fields[0].enum_def.fields[136].name = tdrpStrDup("FIVE_WAVA");
        tt->struct_def.fields[0].enum_def.fields[136].val = FIVE_WAVA;
        tt->struct_def.fields[0].enum_def.fields[137].name = tdrpStrDup("LAT");
        tt->struct_def.fields[0].enum_def.fields[137].val = LAT;
        tt->struct_def.fields[0].enum_def.fields[138].name = tdrpStrDup("LON");
        tt->struct_def.fields[0].enum_def.fields[138].val = LON;
        tt->struct_def.fields[0].enum_def.fields[139].name = tdrpStrDup("MFLUX");
        tt->struct_def.fields[0].enum_def.fields[139].val = MFLUX;
        tt->struct_def.fields[0].enum_def.fields[140].name = tdrpStrDup("TERHGT");
        tt->struct_def.fields[0].enum_def.fields[140].val = TERHGT;
        tt->struct_def.fields[0].enum_def.fields[141].name = tdrpStrDup("TER_HT");
        tt->struct_def.fields[0].enum_def.fields[141].val = TER_HT;
        tt->struct_def.fields[0].enum_def.fields[142].name = tdrpStrDup("BASEFLOW_GRDWATER_RUNOFF");
        tt->struct_def.fields[0].enum_def.fields[142].val = BASEFLOW_GRDWATER_RUNOFF;
        tt->struct_def.fields[0].enum_def.fields[143].name = tdrpStrDup("STORM_SURFACE_RUNOFF");
        tt->struct_def.fields[0].enum_def.fields[143].val = STORM_SURFACE_RUNOFF;
        tt->struct_def.fields[0].enum_def.fields[144].name = tdrpStrDup("SNOW_TEMPERATURE");
        tt->struct_def.fields[0].enum_def.fields[144].val = SNOW_TEMPERATURE;
        tt->struct_def.fields[0].enum_def.fields[145].name = tdrpStrDup("TOTACP");
        tt->struct_def.fields[0].enum_def.fields[145].val = TOTACP;
        tt->struct_def.fields[0].enum_def.fields[146].name = tdrpStrDup("LNDUSE");
        tt->struct_def.fields[0].enum_def.fields[146].val = LNDUSE;
        tt->struct_def.fields[0].enum_def.fields[147].name = tdrpStrDup("PCPTYPE");
        tt->struct_def.fields[0].enum_def.fields[147].val = PCPTYPE;
        tt->struct_def.fields[0].enum_def.fields[148].name = tdrpStrDup("DRAG_COEFFICIENT");
        tt->struct_def.fields[0].enum_def.fields[148].val = DRAG_COEFFICIENT;
        tt->struct_def.fields[0].enum_def.fields[149].name = tdrpStrDup("GUST_WIND_SPEED");
        tt->struct_def.fields[0].enum_def.fields[149].val = GUST_WIND_SPEED;
      tt->struct_def.fields[1].ftype = tdrpStrDup("level_id_t");
      tt->struct_def.fields[1].fname = tdrpStrDup("level_id");
      tt->struct_def.fields[1].ptype = ENUM_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_output_fields->level_id - (char *) _output_fields;
        tt->struct_def.fields[1].enum_def.name = tdrpStrDup("level_id_t");
        tt->struct_def.fields[1].enum_def.nfields = 25;
        tt->struct_def.fields[1].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[1].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[1].enum_def.fields[0].name = tdrpStrDup("GROUND_OR_WATER_SURFACE");
        tt->struct_def.fields[1].enum_def.fields[0].val = GROUND_OR_WATER_SURFACE;
        tt->struct_def.fields[1].enum_def.fields[1].name = tdrpStrDup("SFC");
        tt->struct_def.fields[1].enum_def.fields[1].val = SFC;
        tt->struct_def.fields[1].enum_def.fields[2].name = tdrpStrDup("CLOUD_BASE_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[2].val = CLOUD_BASE_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[3].name = tdrpStrDup("CBL");
        tt->struct_def.fields[1].enum_def.fields[3].val = CBL;
        tt->struct_def.fields[1].enum_def.fields[4].name = tdrpStrDup("CLOUD_TOP_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[4].val = CLOUD_TOP_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[5].name = tdrpStrDup("CTL");
        tt->struct_def.fields[1].enum_def.fields[5].val = CTL;
        tt->struct_def.fields[1].enum_def.fields[6].name = tdrpStrDup("LEVEL_OF_0_DEGREE_ISOTHERM");
        tt->struct_def.fields[1].enum_def.fields[6].val = LEVEL_OF_0_DEGREE_ISOTHERM;
        tt->struct_def.fields[1].enum_def.fields[7].name = tdrpStrDup("MAXIMUM_WIND_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[7].val = MAXIMUM_WIND_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[8].name = tdrpStrDup("TROPOPAUSE");
        tt->struct_def.fields[1].enum_def.fields[8].val = TROPOPAUSE;
        tt->struct_def.fields[1].enum_def.fields[9].name = tdrpStrDup("ISOBARIC");
        tt->struct_def.fields[1].enum_def.fields[9].val = ISOBARIC;
        tt->struct_def.fields[1].enum_def.fields[10].name = tdrpStrDup("MEAN_SEA_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[10].val = MEAN_SEA_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[11].name = tdrpStrDup("ALTITUDE_ABOVE_MSL");
        tt->struct_def.fields[1].enum_def.fields[11].val = ALTITUDE_ABOVE_MSL;
        tt->struct_def.fields[1].enum_def.fields[12].name = tdrpStrDup("SPECF_HEIGHT_ABOVE_GROUND");
        tt->struct_def.fields[1].enum_def.fields[12].val = SPECF_HEIGHT_ABOVE_GROUND;
        tt->struct_def.fields[1].enum_def.fields[13].name = tdrpStrDup("HTGY");
        tt->struct_def.fields[1].enum_def.fields[13].val = HTGY;
        tt->struct_def.fields[1].enum_def.fields[14].name = tdrpStrDup("SIGMA_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[14].val = SIGMA_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[15].name = tdrpStrDup("HYBRID");
        tt->struct_def.fields[1].enum_def.fields[15].val = HYBRID;
        tt->struct_def.fields[1].enum_def.fields[16].name = tdrpStrDup("DEPTH_BELOW_SURFACE");
        tt->struct_def.fields[1].enum_def.fields[16].val = DEPTH_BELOW_SURFACE;
        tt->struct_def.fields[1].enum_def.fields[17].name = tdrpStrDup("LAYER_BETWEEN_TWO_DEPTHS_BELOW_SURFACE");
        tt->struct_def.fields[1].enum_def.fields[17].val = LAYER_BETWEEN_TWO_DEPTHS_BELOW_SURFACE;
        tt->struct_def.fields[1].enum_def.fields[18].name = tdrpStrDup("LAYER_BETWEEN_TWO_LEVELS_AT_SPECIFIED_PRESSURES");
        tt->struct_def.fields[1].enum_def.fields[18].val = LAYER_BETWEEN_TWO_LEVELS_AT_SPECIFIED_PRESSURES;
        tt->struct_def.fields[1].enum_def.fields[19].name = tdrpStrDup("ENTIRE_ATMOSPHERE");
        tt->struct_def.fields[1].enum_def.fields[19].val = ENTIRE_ATMOSPHERE;
        tt->struct_def.fields[1].enum_def.fields[20].name = tdrpStrDup("HIGHEST_TROPO_FREEZE_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[20].val = HIGHEST_TROPO_FREEZE_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[21].name = tdrpStrDup("CONVECTIVE_CLOUD_TOP_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[21].val = CONVECTIVE_CLOUD_TOP_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[22].name = tdrpStrDup("CONVECTIVE_TOTAL_CLOUD_COVER");
        tt->struct_def.fields[1].enum_def.fields[22].val = CONVECTIVE_TOTAL_CLOUD_COVER;
        tt->struct_def.fields[1].enum_def.fields[23].name = tdrpStrDup("MAXIMUM_EPOT_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[23].val = MAXIMUM_EPOT_LEVEL;
        tt->struct_def.fields[1].enum_def.fields[24].name = tdrpStrDup("EQUILIBRIUM_LEVEL");
        tt->struct_def.fields[1].enum_def.fields[24].val = EQUILIBRIUM_LEVEL;
      tt->struct_def.fields[2].ftype = tdrpStrDup("out_units_t");
      tt->struct_def.fields[2].fname = tdrpStrDup("out_units");
      tt->struct_def.fields[2].ptype = ENUM_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_output_fields->out_units - (char *) _output_fields;
        tt->struct_def.fields[2].enum_def.name = tdrpStrDup("out_units_t");
        tt->struct_def.fields[2].enum_def.nfields = 9;
        tt->struct_def.fields[2].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[2].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[2].enum_def.fields[0].name = tdrpStrDup("NO_CHANGE");
        tt->struct_def.fields[2].enum_def.fields[0].val = NO_CHANGE;
        tt->struct_def.fields[2].enum_def.fields[1].name = tdrpStrDup("MPS_TO_KNOTS");
        tt->struct_def.fields[2].enum_def.fields[1].val = MPS_TO_KNOTS;
        tt->struct_def.fields[2].enum_def.fields[2].name = tdrpStrDup("M_TO_KM");
        tt->struct_def.fields[2].enum_def.fields[2].val = M_TO_KM;
        tt->struct_def.fields[2].enum_def.fields[3].name = tdrpStrDup("M_TO_100FT");
        tt->struct_def.fields[2].enum_def.fields[3].val = M_TO_100FT;
        tt->struct_def.fields[2].enum_def.fields[4].name = tdrpStrDup("PASCALS_TO_MBAR");
        tt->struct_def.fields[2].enum_def.fields[4].val = PASCALS_TO_MBAR;
        tt->struct_def.fields[2].enum_def.fields[5].name = tdrpStrDup("KELVIN_TO_CELSIUS");
        tt->struct_def.fields[2].enum_def.fields[5].val = KELVIN_TO_CELSIUS;
        tt->struct_def.fields[2].enum_def.fields[6].name = tdrpStrDup("KGPKG_TO_GPKG");
        tt->struct_def.fields[2].enum_def.fields[6].val = KGPKG_TO_GPKG;
        tt->struct_def.fields[2].enum_def.fields[7].name = tdrpStrDup("PERCENT_TO_FRACTION");
        tt->struct_def.fields[2].enum_def.fields[7].val = PERCENT_TO_FRACTION;
        tt->struct_def.fields[2].enum_def.fields[8].name = tdrpStrDup("KGPM2PS_TO_MMPHR");
        tt->struct_def.fields[2].enum_def.fields[8].val = KGPM2PS_TO_MMPHR;
    tt->n_struct_vals = 3;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].e = UNKNOWN;
      tt->struct_vals[1].e = GROUND_OR_WATER_SURFACE;
      tt->struct_vals[2].e = NO_CHANGE;
    tt++;
    
    // Parameter 'output_all_fields'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_all_fields");
    tt->descr = tdrpStrDup("Flag to override the requested field list and output all fields. ");
    tt->help = tdrpStrDup("If set, the program will treat all fields as if they were in the output_fields[] list.  Any level will be accepted and the units will not change. ");
    tt->val_offset = (char *) &output_all_fields - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'afwa_code_name_map'
    // ctype is '_code_name_map_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("afwa_code_name_map");
    tt->descr = tdrpStrDup("AFWA ensemble mapping from code to field name.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_afwa_code_name_map - &_start_;
    tt->array_n_offset = (char *) &afwa_code_name_map_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(code_name_map_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("code_name_map_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("code");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_afwa_code_name_map->code - (char *) _afwa_code_name_map;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_afwa_code_name_map->name - (char *) _afwa_code_name_map;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("description");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_afwa_code_name_map->description - (char *) _afwa_code_name_map;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("units");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_afwa_code_name_map->units - (char *) _afwa_code_name_map;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].s = tdrpStrDup("not_set");
      tt->struct_vals[2].s = tdrpStrDup("not_set");
      tt->struct_vals[3].s = tdrpStrDup("not_set");
    tt++;
    
    // Parameter 'ncep_code_name_map'
    // ctype is '_code_name_map_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ncep_code_name_map");
    tt->descr = tdrpStrDup("NCEP ensemble mapping from code to field name.");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_ncep_code_name_map - &_start_;
    tt->array_n_offset = (char *) &ncep_code_name_map_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(code_name_map_t);
    tt->array_n = 1;
    tt->struct_def.name = tdrpStrDup("code_name_map_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("code");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_ncep_code_name_map->code - (char *) _ncep_code_name_map;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_ncep_code_name_map->name - (char *) _ncep_code_name_map;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("description");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_ncep_code_name_map->description - (char *) _ncep_code_name_map;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("units");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_ncep_code_name_map->units - (char *) _ncep_code_name_map;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].s = tdrpStrDup("not_set");
      tt->struct_vals[2].s = tdrpStrDup("not_set");
      tt->struct_vals[3].s = tdrpStrDup("not_set");
    tt++;
    
    // Parameter 'overrideGeom'
    // ctype is '_overrideGeom_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("overrideGeom");
    tt->descr = tdrpStrDup("Values for projection that will be written directly into the output MDV file if the first boolean is TRUE.");
    tt->help = tdrpStrDup("Only do this if there is some issue with the input geometry.");
    tt->val_offset = (char *) &overrideGeom - &_start_;
    tt->struct_def.name = tdrpStrDup("overrideGeom_t");
    tt->struct_def.nfields = 10;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[0].fname = tdrpStrDup("override");
      tt->struct_def.fields[0].ptype = BOOL_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &overrideGeom.override - (char *) &overrideGeom;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("dx");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &overrideGeom.dx - (char *) &overrideGeom;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("dy");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &overrideGeom.dy - (char *) &overrideGeom;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("dz");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &overrideGeom.dz - (char *) &overrideGeom;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("minx");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &overrideGeom.minx - (char *) &overrideGeom;
      tt->struct_def.fields[5].ftype = tdrpStrDup("double");
      tt->struct_def.fields[5].fname = tdrpStrDup("miny");
      tt->struct_def.fields[5].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &overrideGeom.miny - (char *) &overrideGeom;
      tt->struct_def.fields[6].ftype = tdrpStrDup("double");
      tt->struct_def.fields[6].fname = tdrpStrDup("minz");
      tt->struct_def.fields[6].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &overrideGeom.minz - (char *) &overrideGeom;
      tt->struct_def.fields[7].ftype = tdrpStrDup("double");
      tt->struct_def.fields[7].fname = tdrpStrDup("rotation");
      tt->struct_def.fields[7].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &overrideGeom.rotation - (char *) &overrideGeom;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("projParam0");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &overrideGeom.projParam0 - (char *) &overrideGeom;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("projParam1");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &overrideGeom.projParam1 - (char *) &overrideGeom;
    tt->n_struct_vals = 10;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].b = pFALSE;
      tt->struct_vals[1].d = 1;
      tt->struct_vals[2].d = 1;
      tt->struct_vals[3].d = 1;
      tt->struct_vals[4].d = -100;
      tt->struct_vals[5].d = -100;
      tt->struct_vals[6].d = 0;
      tt->struct_vals[7].d = 0;
      tt->struct_vals[8].d = 0;
      tt->struct_vals[9].d = 0;
    tt++;
    
    // Parameter 'overrideGeomProj'
    // ctype is '_overrideGeomProj_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("overrideGeomProj");
    tt->descr = tdrpStrDup("Projection type to use if the geometry is being overridden.");
    tt->help = tdrpStrDup("Only relevant if the boolean in the overrideGeom is set to TRUE");
    tt->val_offset = (char *) &overrideGeomProj - &_start_;
    tt->enum_def.name = tdrpStrDup("overrideGeomProj_t");
    tt->enum_def.nfields = 5;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_LAMBERT_CONF");
      tt->enum_def.fields[0].val = PROJ_LAMBERT_CONF;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_LATLON");
      tt->enum_def.fields[1].val = PROJ_LATLON;
      tt->enum_def.fields[2].name = tdrpStrDup("PROJ_POLAR_STEREO");
      tt->enum_def.fields[2].val = PROJ_POLAR_STEREO;
      tt->enum_def.fields[3].name = tdrpStrDup("PROJ_OBLIQUE_STEREO");
      tt->enum_def.fields[3].val = PROJ_OBLIQUE_STEREO;
      tt->enum_def.fields[4].name = tdrpStrDup("PROJ_FLAT");
      tt->enum_def.fields[4].val = PROJ_FLAT;
    tt->single_val.e = PROJ_LAMBERT_CONF;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
