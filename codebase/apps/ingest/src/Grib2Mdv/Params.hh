/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.hh
//
// TDRP header file for 'Params' class.
//
// Code for program Grib2Mdv
//
// This header file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.hh
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @class Params
 *
 * @author automatically generated
 *
 */

#ifndef Params_hh
#define Params_hh

#include <tdrp/tdrp.h>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <cfloat>

using namespace std;

// Class definition

class Params {

public:

  // enum typedefs

  typedef enum {
    GRIB_TYPE_GENERIC = 0,
    GRIB_TYPE_RUC = 1,
    GRIB_TYPE_AVN = 2,
    GRIB_TYPE_ETA = 3,
    GRIB_TYPE_WAFS = 4,
    GRIB_TYPE_AFWA = 5,
    GRIB_TYPE_DTRA = 6
  } grib_type_t;

  typedef enum {
    ENCODING_ASIS = 0,
    ENCODING_INT8 = 1,
    ENCODING_INT16 = 2,
    ENCODING_FLOAT32 = 5
  } encoding_type_t;

  typedef enum {
    COMPRESSION_ASIS = -1,
    COMPRESSION_NONE = 0,
    COMPRESSION_RLE = 1,
    COMPRESSION_LZO = 2,
    COMPRESSION_ZLIB = 3,
    COMPRESSION_BZIP = 4,
    COMPRESSION_GZIP = 5
  } compression_type_t;

  typedef enum {
    TIMESTAMP_GEN_TIME = 0,
    TIMESTAMP_FCAST_TIME = 1
  } timestamp_t;

  typedef enum {
    OUTPUT_PROJ_FLAT = 0,
    OUTPUT_PROJ_LATLON = 1,
    OUTPUT_PROJ_LAMBERT_CONF = 2,
    OUTPUT_PROJ_NATIVE = 3
  } projection_t;

  typedef enum {
    UNKNOWN = 0,
    PRESSURE = 1,
    PRES = 1,
    PRMSL = 2,
    PRESSURE_TENDENCY = 3,
    GEOPOTENTIAL_HEIGHT = 7,
    HGT = 7,
    CLOUD_HEIGHT = 8,
    TOZNE = 10,
    TEMPERATURE = 11,
    TMP = 11,
    POTENTIAL_TEMPERATURE = 13,
    POT = 13,
    EQUIVALENT_POTENTIAL_TEMP = 14,
    DEW_POINT_TEMPERATURE = 17,
    DEW_POINT_DEPRESSION = 18,
    VISIBILITY = 20,
    PLI = 24,
    GPA = 27,
    WDIR = 31,
    WIND_DIRECTION_FROM = 31,
    WIND = 32,
    WIND_SPEED = 32,
    U_WIND = 33,
    UGRD = 33,
    V_WIND = 34,
    VGRD = 34,
    VERTICAL_VELOCITY = 39,
    VVEL = 39,
    DZDT = 40,
    ABSV = 41,
    SPECIFIC_HUMIDITY = 51,
    SPFH = 51,
    RELATIVE_HUMIDITY = 52,
    RH = 52,
    HUMIDITY_MIXING_RATIO = 53,
    PRECIPITABLE_WATER = 54,
    PWAT = 54,
    CICE = 58,
    PRECIPITATION_RATE = 59,
    TOTAL_PRECIPITATION = 61,
    LARGE_SCALE_PRECIPITATION = 62,
    CONVECTIVE_PRECIPITATION = 63,
    WATER_EQIV_ACCUM_SNOW_DEPTH = 65,
    WEASD = 65,
    SNOW_DEPTH = 66,
    TCDC = 71,
    LOW_CLOUD_COVER = 73,
    MED_CLOUD_COVER = 74,
    HIGH_CLOUD_COVER = 75,
    CWAT = 76,
    BEST_LIFTED_INDEX = 77,
    LAND = 81,
    ALBEDO = 84,
    SOIL_TEMPERATURE = 85,
    TSOIL = 85,
    SOIL_MOISTURE_CONTENT = 86,
    ICEC = 91,
    SNOW_MELT = 99,
    SHORTWAVE_RAD_AT_SURFACE = 111,
    LONGWAVE_RAD_AT_SURFACE = 112,
    SHORTWAVE_RAD_AT_TOP = 113,
    LONGWAVE_RAD_AT_TOP = 114,
    LATENT_HEAT_FLUX = 121,
    SENSIBLE_HEAT_FLUX = 122,
    SHTFL = 122,
    MEAN_SEA_LEVEL_PRESS_SAR = 128,
    PBL_REGIME = 128,
    MEAN_SEA_LEVEL_PRESS_MAPS = 129,
    SURFACE_LIFTED_INDEX = 131,
    LFTX = 131,
    PRESS = 131,
    FOUR_LFTX = 132,
    HORZ_MOISTURE_CONVERGENCE = 135,
    VWSH = 136,
    PBLHGT = 137,
    CATEGORICAL_RAIN = 140,
    CATEGORICAL_FREEZING_RAIN = 141,
    CATEGORICAL_ICE_PELLETS = 142,
    CATEGORICAL_SNOW = 143,
    VOL_SOIL_MOISTURE_CONTENT = 144,
    SOILW = 144,
    POTENTIAL_VORTICITY = 149,
    CLOUD_WATER_MIXING_RATIO = 153,
    CLWMR = 153,
    O3MR = 154,
    CONVECTIVE_INHIBITION = 156,
    CIN = 156,
    CONVEC_AVIAL_POT_ENERGY = 157,
    CAPE = 157,
    TURBULENT_KINETIC_ENERGY = 158,
    SOILL = 160,
    CLOUD_FORCING_NET_LONG_WAVE_FLUX = 165,
    VISIBLE_BEAM_DOWNWARD_SOLAR_FLUX = 166,
    VISIBLE_DIFFUSE_DOWNWARD_SOLAR_FLUX = 167,
    NEAR_IR_BEAM_DOWNWARD_SOLAR_FLUX = 168,
    RAIN_WATER_MIXING_RATIO = 170,
    SNOW_MIXING_RATIO = 171,
    MOMENTUM_FLUX = 172,
    NLAT = 176,
    ELON = 177,
    ICE_MIXING_RATIO = 178,
    GRAUPEL_MIXING_RATIO = 179,
    WATER_VAPOR_MIXING_RATIO = 185,
    TURB_SIGMET_AIRMET = 185,
    ICING_SIGMET_AIRMET = 186,
    LIGHTNING = 187,
    RATE_WATER_CANOPY2GROUND = 188,
    VIRTUAL_POTENTIAL_TEMP = 189,
    STORM_RELATIVE_HELICITY = 190,
    PSTAR = 191,
    PRSPRT = 192,
    PBLREG = 193,
    FRIVEL = 194,
    U_STORM_MOTION = 196,
    V_STORM_MOTION = 197,
    NUM_CONCEN_ICE_PARTICLES = 198,
    DIRECT_EVAPORATION_BARE_SOIL = 199,
    MAPSCL = 199,
    UUE = 203,
    VVE = 204,
    UVE = 205,
    DOWN_SHORTWAVE_RAD_FLUX = 204,
    DOWN_LONGWAVE_RAD_FLUX = 205,
    UP_SHORTWAVE_RAD_FLUX = 211,
    UP_LONGWAVE_RAD_FLUX = 212,
    PBL_HEIGHT = 221,
    HPBL = 221,
    FIVE_WAVH = 222,
    PLANT_CANOPY_SURFACE_WATER = 223,
    SOIL_TYPE = 224,
    VEGETATION_TYPE = 225,
    VGTYP = 225,
    TB = 226,
    POTENTIAL_EVAPORATION = 228,
    SNOW_PHASE_CHANGE_HEAT_FLUX = 229,
    FIVE_WAVA = 230,
    LAT = 230,
    LON = 231,
    MFLUX = 231,
    TERHGT = 233,
    TER_HT = 233,
    BASEFLOW_GRDWATER_RUNOFF = 234,
    STORM_SURFACE_RUNOFF = 235,
    SNOW_TEMPERATURE = 239,
    TOTACP = 240,
    LNDUSE = 241,
    PCPTYPE = 244,
    DRAG_COEFFICIENT = 253,
    GUST_WIND_SPEED = 255
  } param_id_t;

  typedef enum {
    GROUND_OR_WATER_SURFACE = 1,
    SFC = 1,
    CLOUD_BASE_LEVEL = 2,
    CBL = 2,
    CLOUD_TOP_LEVEL = 3,
    CTL = 3,
    LEVEL_OF_0_DEGREE_ISOTHERM = 4,
    MAXIMUM_WIND_LEVEL = 6,
    TROPOPAUSE = 7,
    ISOBARIC = 100,
    MEAN_SEA_LEVEL = 102,
    ALTITUDE_ABOVE_MSL = 103,
    SPECF_HEIGHT_ABOVE_GROUND = 105,
    HTGY = 106,
    SIGMA_LEVEL = 107,
    HYBRID = 109,
    DEPTH_BELOW_SURFACE = 111,
    LAYER_BETWEEN_TWO_DEPTHS_BELOW_SURFACE = 112,
    LAYER_BETWEEN_TWO_LEVELS_AT_SPECIFIED_PRESSURES = 116,
    ENTIRE_ATMOSPHERE = 200,
    HIGHEST_TROPO_FREEZE_LEVEL = 204,
    CONVECTIVE_CLOUD_TOP_LEVEL = 243,
    CONVECTIVE_TOTAL_CLOUD_COVER = 244,
    MAXIMUM_EPOT_LEVEL = 246,
    EQUILIBRIUM_LEVEL = 247
  } level_id_t;

  typedef enum {
    NO_CHANGE = 0,
    MPS_TO_KNOTS = 1,
    M_TO_KM = 2,
    M_TO_100FT = 3,
    PASCALS_TO_MBAR = 4,
    KELVIN_TO_CELSIUS = 5,
    KGPKG_TO_GPKG = 6,
    PERCENT_TO_FRACTION = 7,
    KGPM2PS_TO_MMPHR = 8
  } out_units_t;

  typedef enum {
    REALTIME = 0,
    REALTIME_DIR = 1,
    FILELIST = 2,
    NEWFILES = 3
  } mode_t;

  typedef enum {
    PROJ_LAMBERT_CONF = 0,
    PROJ_LATLON = 1,
    PROJ_POLAR_STEREO = 2,
    PROJ_OBLIQUE_STEREO = 3,
    PROJ_FLAT = 4
  } overrideGeomProj_t;

  // struct typedefs

  typedef struct {
    double lat;
    double lon;
  } output_origin_t;

  typedef struct {
    double lat1;
    double lat2;
  } output_parallel_t;

  typedef struct {
    int nx;
    int ny;
    int nz;
    double minx;
    double miny;
    double minz;
    double dx;
    double dy;
    double dz;
  } output_grid_t;

  typedef struct {
    param_id_t param_id;
    level_id_t level_id;
    out_units_t out_units;
  } out_field_t;

  typedef struct {
    int code;
    char* name;
    char* description;
    char* units;
  } code_name_map_t;

  typedef struct {
    tdrp_bool_t override;
    double dx;
    double dy;
    double dz;
    double minx;
    double miny;
    double minz;
    double rotation;
    double projParam0;
    double projParam1;
  } overrideGeom_t;

  ///////////////////////////
  // Member functions
  //

  ////////////////////////////////////////////
  // Default constructor
  //

  Params ();

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params (const Params&);

  ////////////////////////////////////////////
  // Destructor
  //

  virtual ~Params ();

  ////////////////////////////////////////////
  // Assignment
  //

  void operator=(const Params&);

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadFromArgs(int argc, char **argv,
                   char **override_list,
                   char **params_path_p,
                   bool defer_exit = false);

  bool exitDeferred() { return (_exitDeferred); }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadApplyArgs(const char *params_path,
                    int argc, char **argv,
                    char **override_list,
                    bool defer_exit = false);

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  static bool isArgValid(const char *arg);

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  static int isArgValidN(const char *arg);

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int load(const char *param_file_path,
           char **override_list,
           int expand_env, int debug);

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadFromBuf(const char *param_source_str,
                  char **override_list,
                  const char *inbuf, int inlen,
                  int start_line_num,
                  int expand_env, int debug);

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int loadDefaults(int expand_env);

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void sync() const;

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void print(FILE *out, tdrp_print_mode_t mode = PRINT_NORM);

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int checkAllSet(FILE *out);

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int checkIsSet(const char *param_name);

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int arrayRealloc(const char *param_name,
                   int new_array_n);

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int array2DRealloc(const char *param_name,
                     int new_array_n1,
                     int new_array_n2);

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void freeAll(void);

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  static void usage(ostream &out);

  ///////////////////////////
  // Data Members
  //

  char _start_; // start of data region
                // needed for zeroing out data
                // and computing offsets

  tdrp_bool_t debug;

  tdrp_bool_t always_swap_ns;

  char* type;

  char* instance;

  mode_t mode;

  char* input_substring;

  tdrp_bool_t runOnOldRuc40File;

  char* input_dir;

  long max_input_data_age;

  grib_type_t input_grib_type;

  tdrp_bool_t process_old_files;

  tdrp_bool_t write_forecast;

  char* forecast_mdv_url;

  tdrp_bool_t write_non_forecast;

  char* non_forecast_mdv_url;

  encoding_type_t encoding_type;

  compression_type_t compression_type;

  timestamp_t non_forecast_timestamp;

  char* data_set_info;

  char* data_set_name;

  char* data_set_source;

  projection_t mdv_proj_type;

  output_origin_t output_origin;

  float output_rotation;

  output_parallel_t output_parallel;

  output_grid_t output_grid;

  out_field_t *_output_fields;
  int output_fields_n;

  tdrp_bool_t output_all_fields;

  code_name_map_t *_afwa_code_name_map;
  int afwa_code_name_map_n;

  code_name_map_t *_ncep_code_name_map;
  int ncep_code_name_map_n;

  overrideGeom_t overrideGeom;

  overrideGeomProj_t overrideGeomProj;

  char _end_; // end of data region
              // needed for zeroing out data

private:

  void _init();

  mutable TDRPtable _table[37];

  const char *_className;

  bool _exitDeferred;

};

#endif

