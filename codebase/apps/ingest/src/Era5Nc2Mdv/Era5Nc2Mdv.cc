//*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
///////////////////////////////////////////////////////////////
// Era5Nc2Mdv.cc
//
// Mike Dixon, EOL, NCAR, P.O.Box 3000, Boulder, CO, 80307-3000, USA
//
// Oct 2023
//
///////////////////////////////////////////////////////////////
//
// Era5Nc2Mdv reads ERA5 data in NetCDF format, as generated by
// NCAR CISL software, and converts to MDV
//
////////////////////////////////////////////////////////////////

#include <cmath>
#include <set>
#include <algorithm>
#include <toolsa/toolsa_macros.h>
#include <toolsa/umisc.h>
#include <toolsa/DateTime.hh>
#include <toolsa/Path.hh>
#include <toolsa/TaArray.hh>
#include <Mdv/MdvxField.hh>
#include <didss/DataFileNames.hh>
#include <dsserver/DsLdataInfo.hh>
#include "Era5Nc2Mdv.hh"
#include "Era5File.hh"
#include "HtInterp.hh"
using namespace std;

// Constructor

Era5Nc2Mdv::Era5Nc2Mdv(int argc, char **argv)

{

  isOK = true;
  _input = NULL;

  // g is 9.80665 for Era5 conversion from geopotential to height in meters  

  _g = 9.80665;

  // set programe name

  _progName = "Era5Nc2Mdv";
  ucopyright((char *) _progName.c_str());

  // get command line args

  if (_args.parse(argc, argv, _progName)) {
    cerr << "ERROR: " << _progName << endl;
    cerr << "Problem with command line args" << endl;
    isOK = false;
    return;
  }

  // get TDRP params
  
  _paramsPath = (char *) "unknown";
  if (_params.loadFromArgs(argc, argv, _args.override.list,
			   &_paramsPath)) {
    cerr << "ERROR: " << _progName << endl;
    cerr << "Problem with TDRP parameters" << endl;
    isOK = false;
  }

  // check that file list set in archive mode
  
  if (_params.mode == Params::FILELIST && _args.inputFileList.size() == 0) {
    cerr << "ERROR: Era5Nc2Mdv" << endl;
    cerr << "  Mode is ARCHIVE."; 
    cerr << "  You must use -f to specify files on the command line."
	 << endl;
    _args.usage(cerr);
    isOK = false;
  }

  // initialize the data input object
  
  if (_params.mode == Params::ARCHIVE) {

    // get start and end times
    
    time_t startTime = DateTime::parseDateTime(_params.start_time);
    if (startTime == DateTime::NEVER) {
      cerr << "ERROR - Radx2Grid::_runArchive()" << endl;
      cerr << "  Start time format incorrect: " << _params.start_time << endl;
      if (_args.startTimeSet) {
        cerr << "  Check command line" << endl;
      } else {
        cerr << "  Check params file: " << _paramsPath << endl;
      }
      isOK = false;
      return;
    }
    
    time_t endTime = DateTime::parseDateTime(_params.end_time);
    if (endTime == DateTime::NEVER) {
      cerr << "ERROR - Radx2Grid::_runArchive()" << endl;
      cerr << "  End time format incorrect: " << _params.end_time << endl;
      if (_args.endTimeSet) {
        cerr << "  Check command line" << endl;
      } else {
        cerr << "  Check params file: " << _paramsPath << endl;
      }
      isOK = false;
      return;
    }
    
    _input = new DsInputPath(_progName,
			     _params.debug >= Params::DEBUG_VERBOSE,
			     _params.input_dir,
			     startTime, endTime);
    
  } else if (_params.mode == Params::FILELIST) {

    if (_params.debug) {
      for (int ii = 0; ii < (int) _args.inputFileList.size(); ii++) {
        cerr << "Adding path: " << _args.inputFileList[ii] << endl;
      }
    }

    _input = new DsInputPath(_progName,
			     _params.debug >= Params::DEBUG_VERBOSE,
			     _args.inputFileList);
  }

}

///////////////////////////////////////////////////
// destructor

Era5Nc2Mdv::~Era5Nc2Mdv()

{

  // free up

  if (_input) {
    delete _input;
  }

}

//////////////////////////////////////////////////
// Run
//
// We need to combined multiple files to create
// 3-D volumes.
//
// The files we are reading are in NetCDF format,
// with one file per field and level.
// Each file contains multiple times, usually
// one per hour for a day - i.e. 24 times.
// We read one file, which we call the 'seed'
// and then create a list of file paths for
// that same time. And then we read all the
// data in that list, to create 3-D volumes
// containing multiple fields.

int Era5Nc2Mdv::Run ()
{
  
  // get first file in list, as initial seed
  
  char *inputPath = _input->next();
  if (inputPath == NULL) {
    cerr << "ERROR = Era5Nc2Mdv::Run" << endl;
    cerr << "  No files found" << endl;
    return -1;
  }
  string seedPath = inputPath;
  
  // loop until data is exhausted
  
  while (seedPath.size() > 0) {

    // get seed time
    
    time_t seedTime;
    bool dateOnly;
    if (DataFileNames::getDataTime(seedPath, seedTime, dateOnly)) {
      cerr << "ERROR - Era5Nc2Mdv::Run" << endl;
      cerr << "  Bad time for seed path: " << seedPath << endl;
      return -1;
    }

    // create set of paths at the seed time
    
    vector<string> pathsAtTime;
    while ((inputPath = _input->next()) != NULL) {
      
      time_t fileTime;
      if (DataFileNames::getDataTime(inputPath, fileTime, dateOnly)) {
        cerr << "WARNING - Era5Nc2Mdv::Run" << endl;
        cerr << "  Bad time for path: " << inputPath << endl;
        cerr << "  ignoring" << endl;
        continue;
      }

      if (fileTime == seedTime) {
        pathsAtTime.push_back(inputPath);
      } else {
        seedPath = inputPath;
        break;
      }
      
    } // while ((inputPath = _input->next()) != NULL)

    // set the geometry for this time set

    if (_setGeom(pathsAtTime)) {
      cerr << "ERROR - Era5Nc2Mdv::Run" << endl;
      cerr << "  cannot set geom" << endl;
      cerr << "  seed time: " << DateTime::strm(seedTime) << endl;
      return -1;
    }
    
    // create a volume for each hour of the time set
    
    for (size_t itime = 0; itime < _nTimesInFile; itime++) {
      if (_createVol(pathsAtTime, itime)) {
        cerr << "ERROR - Era5Nc2Mdv::Run" << endl;
        cerr << "  cannot create volume for time index: " << itime << endl;
        cerr << "  seed time: " << DateTime::strm(seedTime) << endl;
      }
    }
    
    if (inputPath == NULL) {
      // done
      return 0;
    }

  } // while (seedPath.size() > 0)
  
  return 0;

}

//////////////////////////////////
// set the geometry for this time

int Era5Nc2Mdv::_setGeom(const vector<string> &pathsAtTime)

{

  // read all of the files and check that the geometry is
  // constant throughout the data set
  
  set<double> levelsSet;
  set<string> fieldNamesSet;

  for (size_t ii = 0; ii < pathsAtTime.size(); ii++) {
    
    // read file metadata
    
    Era5File eraFile(_params);
    if (eraFile.readFromPath(pathsAtTime[ii], 0)) {
      cerr << "ERROR - Era5Nc2Mdv::_processFile" << endl;
      cerr << "  File path: " << pathsAtTime[ii] << endl;
      cerr << eraFile.getErrStr() << endl;
      return -1;
    }

    // check geometry is constant
    
    if (ii == 0) {
      _nTimesInFile = eraFile.getNTimesInFile();
      _nLat = eraFile.getNLat();
      _nLon = eraFile.getNLon();
      _lat = eraFile.getLat();
      _lon = eraFile.getLon();
      _dataTimes = eraFile.getDataTimes();
    } else {
      if (_nTimesInFile != eraFile.getNTimesInFile()) {
        cerr << "ERROR - Era5Nc2Mdv::_processTime()" << endl;
        cerr << "  number of times not constant" << endl;
        cerr << "  file path: " << pathsAtTime[ii] << endl;
        return -1;
      }
      if (_nLat != eraFile.getNLat()) {
        cerr << "ERROR - Era5Nc2Mdv::_processTime()" << endl;
        cerr << "  number of latitudes not constant" << endl;
        cerr << "  file path: " << pathsAtTime[ii] << endl;
        return -1;
      }
      if (_nLon != eraFile.getNLon()) {
        cerr << "ERROR - Era5Nc2Mdv::_processTime()" << endl;
        cerr << "  number of longitudes not constant" << endl;
        cerr << "  file path: " << pathsAtTime[ii] << endl;
        return -1;
      }
      if (_lat != eraFile.getLat()) {
        cerr << "ERROR - Era5Nc2Mdv::_processTime()" << endl;
        cerr << "  latitudes not constant" << endl;
        cerr << "  file path: " << pathsAtTime[ii] << endl;
        return -1;
      }
      if (_lon != eraFile.getLon()) {
        cerr << "ERROR - Era5Nc2Mdv::_processTime()" << endl;
        cerr << "  longitudes not constant" << endl;
        cerr << "  file path: " << pathsAtTime[ii] << endl;
        return -1;
      }
      if (_dataTimes != eraFile.getDataTimes()) {
        cerr << "ERROR - Era5Nc2Mdv::_processTime()" << endl;
        cerr << "  data times not constant" << endl;
        cerr << "  file path: " << pathsAtTime[ii] << endl;
        return -1;
      }
    }

    levelsSet.insert(eraFile.getLevel());
    fieldNamesSet.insert(eraFile.getFieldName());

  } // ii

  // copy level set to vectors

  _levels.clear();
  for (auto ii = levelsSet.begin(); ii != levelsSet.end(); ii++) {
    _levels.push_back(*ii);
  }
  // reverse the order, so that high pressures are first
  std::reverse(_levels.begin(), _levels.end());

  // copy field name set to vectors

  _fieldNames.clear();
  for (auto ii = fieldNamesSet.begin(); ii != fieldNamesSet.end(); ii++) {
    _fieldNames.push_back(*ii);
  }

  // set geom

  _deltaTimeSecs =
    (int) ((_dataTimes[_dataTimes.size()-1] - _dataTimes[0]) /
           (_dataTimes.size()-1.0) + 0.5);

  _ny = _nLat;
  _miny = _lat[0];
  _dy = (_lat[_nLat-1] - _lat[0]) / (_lat.size() - 1.0);
  _inverty = false;
  if (_dy < 0) {
    _dy *= -1.0;
    _miny = _lat[_nLat-1];
    _inverty = true;
  }
  
  _nx = _nLon;
  _minx = _lon[0];
  _dx = (_lon[_nLon-1] - _lon[0]) / (_lon.size() - 1.0);
  if (_minx > 180.0) {
    _minx -= 360.0;
  }

  _minz = _levels[0];
  _dz = (_levels[_levels.size() - 1] - _minz) / (_levels.size() - 1.0);
  _nz = _levels.size();
  
  if (_params.debug >= Params::DEBUG_VERBOSE) {
    _printGeom(cerr);
  }
  
  return 0;

}

////////////////////////////////////////
// create volume for given time index

int Era5Nc2Mdv::_createVol(const vector<string> &pathsAtTime,
                           size_t timeIndex)

{

  DateTime volTime = _dataTimes[timeIndex];

  // create output Mdvx file object
  
  DsMdvx mdvx;
  if (_params.debug >= Params::DEBUG_VERBOSE) {
    mdvx.setDebug(true);
  }
    
  // set master header
  
  if (_setMasterHeader(mdvx, volTime.utime())) {
    return -1;
  }

  // create and add the field objects, with empty data arrays

  for (size_t ii = 0; ii < _fieldNames.size(); ii++) {
    MdvxField *fld = _createMdvxField(_fieldNames[ii]);
    mdvx.addField(fld);
  }

  // loop through the files, adding the field data to the arrays

  for (size_t ipath = 0; ipath < pathsAtTime.size(); ipath++) {
    
    // read file metadata
    
    Era5File eraFile(_params);
    if (eraFile.readFromPath(pathsAtTime[ipath], timeIndex)) {
      cerr << "ERROR - Era5Nc2Mdv::_createVol" << endl;
      cerr << "  File path: " << pathsAtTime[ipath] << endl;
      cerr << eraFile.getErrStr() << endl;
      return -1;
    }
    string fieldName = eraFile.getFieldName();

    // get the relevant Mdvx field
    
    MdvxField *field = mdvx.getField(fieldName.c_str());
    if (field == NULL) {
      cerr << "ERROR - Era5Nc2Mdv::_createVol" << endl;
      cerr << "  File path: " << pathsAtTime[ipath] << endl;
      cerr << "  Ignoring field: " << fieldName << endl;
      continue;
    }

    // set metadata
    
    field->setFieldNameLong(eraFile.getLongName().c_str());
    field->setUnits(eraFile.getUnits().c_str());
    
    int levelNum = _getLevelIndex(eraFile.getLevel());
    int nLatLon = _nLat * _nLon;
    long offset = nLatLon * levelNum;
    const float *inData = eraFile.getFieldData().data();
    float *outData = (float *) field->getVol() + offset;

    if (_inverty) {
      // copy in reverse row order
      for (size_t ilat = 0; ilat < _nLat; ilat++) {
        int jlat = _nLat - ilat - 1;
        const float *source = inData + jlat * _nLon;
        float *dest = outData + ilat * _nLon;
        memcpy(dest, source, _nLon * sizeof(float));
      }
    } else {
      // copy array unchanged
      memcpy(outData, inData, nLatLon * sizeof(float));
    }
    
  } // ipath

  // create height field from geopotential, for interpolation onto height levels

  _addHeightField(mdvx);
  if (_params.interp_to_height_levels) {
    HtInterp interp(_params);
    interp.interpVlevelsToHeight(mdvx);
  }

  // write output file
  
  if (_params.debug) {
    cerr << "Writing file to url: " << _params.output_dir << endl;
  }
  
  if (mdvx.writeToDir(_params.output_dir)) {
    cerr << "ERROR - Era5Nc2Mdv" << endl;
    cerr << "  Cannot write file to url: " << _params.output_dir << endl;
    cerr << mdvx.getErrStr() << endl;
    return -1;
  }
  
  if (_params.debug) {
    cerr << "  Wrote output file: " << mdvx.getPathInUse() << endl;
  }
  
  return 0;

}

///////////////////////////////////////////////
// print geometry

void Era5Nc2Mdv::_printGeom(ostream &out)
{

  out << "================================================" << endl;
  out << "  nTimesInFile: " << _nTimesInFile << endl;
  out << "  nLat: " << _nLat << endl;
  out << "  nLon: " << _nLon << endl;
  out << "=========>> lats: ";
  for (size_t ii = 0; ii < _lat.size(); ii++) {
    out << _lat[ii];
    if (ii < _lat.size() - 1) {
      out << ", ";
    }
  }
  out << endl;
  out << "=========>> lons: ";
  for (size_t ii = 0; ii < _lon.size(); ii++) {
    out << _lon[ii];
    if (ii < _lon.size() - 1) {
      out << ", ";
    }
  }
  out << endl;
  for (size_t ii = 0; ii < _dataTimes.size(); ii++) {
    out << "    ii, dataTime: "
         << ii << ", "
         << _dataTimes[ii].asString() << endl;
  }
  out << "=========>> _deltaTimeSecs: " << _deltaTimeSecs << endl;
  out << "=========>> _levels: ";
  for (size_t ii = 0; ii < _levels.size(); ii++) {
    out << _levels[ii];
    if (ii < _levels.size() - 1) {
      out << ", ";
    }
  }
  out << endl;

  out << "=====>> nz, ny, nx: "
      << _nz << ", " << _ny << ", " << _nx << endl;
  out << "=====>> minz, miny, minx: "
      << _minz << ", " << _miny << ", " << _minx << endl;
  out << "====>> dz, dy, dx: "
      << _dz << ", " << _dy << ", " << _dx << endl;
  out << "====>> inverty: " << (_inverty? "Y":"N") << endl;
  out << "=========>> fieldNames: ";
  for (size_t ii = 0; ii < _fieldNames.size(); ii++) {
    out << _fieldNames[ii];
    if (ii < _fieldNames.size() - 1) {
      out << ", ";
    }
  }
  out << endl;
  out << "================================================" << endl;
    
}

/////////////////////////////////////////////////
// Set the master header from the NCF file
//
// Returns 0 on success, -1 on failure

int Era5Nc2Mdv::_setMasterHeader(DsMdvx &mdvx, time_t volTime)
  
{

  mdvx.clearMasterHeader();
  mdvx.setValidTime(volTime);
  mdvx.setBeginTime(volTime - _deltaTimeSecs / 2);
  mdvx.setEndTime(volTime + _deltaTimeSecs / 2);
  mdvx.setForecastLeadSecs(0);
  mdvx.setDataCollectionType(Mdvx::DATA_SYNTHESIS);
  mdvx.setDataSetName(_datasetDoi.c_str());
  mdvx.setDataSetSource(_dataSource.c_str());
  mdvx.setDataSetInfo(_history.c_str());
  mdvx.setAppName("Era5Nc2Mdv");

  return 0;

}

///////////////////////////////
// Create Mdvx field

MdvxField *Era5Nc2Mdv::_createMdvxField(const string &fieldName)

{

  // check max levels

  if (_nz > MDV_MAX_VLEVELS) {
    _nz = MDV_MAX_VLEVELS;
  }

  // set up MdvxField headers

  Mdvx::field_header_t fhdr;
  MEM_zero(fhdr);
  
  // initialize projection
  
  double midLon = _minx + _nx * _dx / 2.0;
  fhdr.proj_type = Mdvx::PROJ_LATLON;
  fhdr.proj_origin_lon = midLon;
  
  fhdr.compression_type = Mdvx::COMPRESSION_NONE;
  fhdr.transform_type = Mdvx::DATA_TRANSFORM_NONE;
  fhdr.scaling_type = Mdvx::SCALING_NONE;
  
  fhdr.native_vlevel_type = Mdvx::VERT_TYPE_PRESSURE;
  fhdr.vlevel_type = Mdvx::VERT_TYPE_PRESSURE;
  fhdr.dz_constant = false;
  fhdr.data_dimension = 3;

  fhdr.bad_data_value = -9999.0;
  fhdr.missing_data_value = -9999.0;
  
  fhdr.encoding_type = Mdvx::ENCODING_FLOAT32;
  fhdr.data_element_nbytes = sizeof(fl32);
  fhdr.volume_size = _nx * _ny * _nz * sizeof(fl32);
  
  fhdr.nx = _nx;
  fhdr.ny = _ny;
  fhdr.nz = _nz;

  fhdr.grid_minx = _minx;
  fhdr.grid_miny = _miny;
  fhdr.grid_minz = _minz;

  fhdr.grid_dx = _dx;
  fhdr.grid_dy = _dy;
  fhdr.grid_dz = _dz;
  
  Mdvx::vlevel_header_t vhdr;
  MEM_zero(vhdr);
  
  for (int ii = 0; ii < _nz; ii++) {
    vhdr.type[ii] = Mdvx::VERT_TYPE_PRESSURE;
    vhdr.level[ii] = _levels[ii];
  }

  // create MdvxField object
  // this will create an empty array for the data
  
  MdvxField *field = new MdvxField(fhdr, vhdr);

  // set names etc
  
  field->setFieldName(fieldName.c_str());
  field->setTransform("");

  return field;

}

/////////////////////////////////////////////////
// Get file index for a specified level
//
// Returns index on success, -1 on failure

int Era5Nc2Mdv::_getLevelIndex(double level)

{

  double minDiff = 1.0e99;
  int levelIndex = 0;
  
  for (size_t ii = 0; ii < _levels.size(); ii++) {
    double thisDiff = fabs(level - _levels[ii]);
    if (thisDiff < minDiff) {
      levelIndex = ii;
      minDiff = thisDiff;
    }
  }

  return levelIndex;
  
}

////////////////////////////////////////////////////////
// create height field from geopotential, add to volume
//
// Returns 0 on success, -1 on failure

int Era5Nc2Mdv::_addHeightField(DsMdvx &mdvx)

{

  // copy the geopeotential field
  
  const MdvxField *zField = mdvx.getField(_params.geopotential_field_name);
  if (zField == NULL) {
    cerr << "ERROR - Era5Nc2Mdv::_createHeightField" << endl;
    cerr << "  Cannot find geopotential field: "
         << _params.geopotential_field_name <<endl;
    cerr << "Interpolation onto height fields will not be done.";
    return -1;
  }

  // create the height field
  // the geopotential must be divided by g
  
  MdvxField *htField = new MdvxField(*zField);
  float *zData = (float*) htField->getVol();
  int64_t nPoints = htField->getVolNumValues();
  for (int64_t ii = 0; ii < nPoints; ii++) {
    double htm = zData[ii] / (_g * 1000.0); // meters to km
    zData[ii] = htm;
  }
  htField->setFieldName("height");
  htField->setFieldNameLong("ht_derived_from_geopotential_ht");
  htField->setUnits("km");

  mdvx.addField(htField);
  
  // Add a pressure field which will then be interpolated

  MdvxField *presField = new MdvxField(*zField);
  presField->setFieldName("pressure");
  presField->setFieldNameLong("pressure");
  presField->setUnits("hPa");
  
  // set the data to the vertical level
  
  const Mdvx::field_header_t &fhdr = presField->getFieldHeader();
  const Mdvx::vlevel_header_t &vhdr = presField->getVlevelHeader();

  int nz = fhdr.nz;
  int ny = fhdr.ny;
  int nx = fhdr.nx;
  int nptsXy = ny * nx;
  
  fl32 *pp = (fl32 *) presField->getVol();
  for (int iz = 0; iz < nz; iz++) {
    double pres = vhdr.level[iz];
    for (int ipt = 0; ipt < nptsXy; ipt++, pp++) {
      *pp = pres;
    }
  }
  
  mdvx.addField(presField);

  return 0;

}

