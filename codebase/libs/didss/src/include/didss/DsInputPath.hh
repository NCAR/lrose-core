// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
/////////////////////////////////////////////////////////////
// DsInputPath.hh
//
// Handling of input paths for data system files into archive and
// realtime programs.  Data system files are expected to be stored
// in files whose paths match the following pattern:
//         <file_path>/YYYYMMDD/hhmmss.<ext>
//
// There are three modes of operation, reflected by the different
// constructors.
//
// Archive mode:
//   The constructor passes in a list of data file paths.
//   This list is stored, and then the paths are served out
//   when next() is called. If next() returns NULL, the list
//   is exhausted.
//
// Realtime mode:
//   The constructor passes in an input directory to watch, as well as
//   as max valid age and a heartbeat function to be called while
//   waiting for new data to arrive. When next() is called, the
//   routine will watch the input directory for a new file. When
//   a new file arrives the path is returned by next(). If the
//   heartbeat_func is not NULL, it gets called every second while
//   next() is waiting for a file to arrive.
//
// Triggered mode:
//   The constructor passes in an input directory to use.  In this
//   mode, it is expected that the calling program is triggering off
//   of another data source and then just wants the closest data
//   from this data source to be used with the triggering data.
//   This can be used in both archive and realtime modes.  In realtime
//   mode, the blocking routine can be used to wait for new data to
//   arrive within the specified interval.
//
// Mike Dixon, RAP, NCAR, P.O.Box 3000, Boulder, CO, 80307-3000, USA
//
// March 1998
//
/////////////////////////////////////////////////////////////

#ifndef DsInputPath_HH
#define DsInputPath_HH

#include <string>
#include <vector>
#include <map>
#include <deque>
#include <didss/LdataInfo.hh>

#ifndef __APPLE__
#include <sys/inotify.h>
#endif

using namespace std;

// typedef for heartbeat function. If heartbeat_func is non-null,
// the client must provide a pointer to a function which fits this
// prototype. The label will be generated by this class prior
// to calling the heartbeat function.

typedef void (*DsInput_heartbeat_t)(const char *label);

class DsInputPath {
  
public:

  typedef multimap<string, time_t, less<string> > PathTimeMap;
  typedef pair<string, time_t > PathTimePair;
  typedef PathTimeMap::iterator PathTimeIter;

  typedef multimap<time_t, string, less<time_t> > TimePathMap;
  typedef pair<time_t, string > TimePathPair;
  typedef TimePathMap::iterator TimePathIter;

  // mode typedef

  typedef enum {
    REALTIME_MODE,
    ARCHIVE_MODE,
    TRIGGERED_MODE,
    ARCHIVE_FCST_GENTIME_MODE
  } mode_t;

  // Dataset time information typedef

  typedef struct {
    time_t gen_time;      // Dataset generation time.
    time_t forecast_time; // Dataset forecast time.  Set to -1 for datasets
                          // that don't contain forecasts.
  } dataset_time_t;

  /////////////////////////////
  // Constructor - Archive mode
  //
  // Pass in a list of file paths.
  //

  DsInputPath (const string &prog_name,
	       bool debug,
	       int n_files,
	       char **file_paths);
    
  /////////////////////////////
  // Constructor - Archive mode
  //
  // Pass in a vector of file paths.
  // If sort is true, list of paths will be sorted into alphabetic order.
  //

  DsInputPath (const string &prog_name,
	       bool debug,
	       const vector< string >& file_paths,
               bool sort = true);
    
  /////////////////////////////
  // Constructor - Archive mode
  //
  // Pass in data directory and start and end times.
  //

  DsInputPath (const string &prog_name,
	       bool debug,
	       const string &input_dir,
	       time_t start_time,
	       time_t end_time, bool use_fcst_gentime = false);

  //////////////////////////////
  // Constructor - realtime mode
  //
  // Pass in (a) the input directory to be watched.
  //         (b) the max valid age for a realtime file (secs)
  //             the routine will wait for a file with the age
  //             less than this.
  //         (c) pointer to heartbeat_func. If NULL this is ignored.
  //             If non-NULL, this is called once per second while
  //             the routine is waiting for new data.
  //         (d) use_ldata_info flag. If true, we use the latest_data_info
  //             file, if false we watch the directory recursively
  //             for new files.
  //         (e) latest_file_only flag. Only applies if use_ldata_info is
  //             false. If set, the routine returns the latest file.
  //             If false, it returns the earliest file which is younger than
  //             the max valid age and which has not been used yet.
  //
  // If use_ldata_info is false, next() will recurse looking for files
  // in subdirectories. However, you need to understand the way in which
  // directory modify times are set. A directory modify time is set only when
  // a file is added or removed from the directory, not if an existing file
  // is modified. next() will traverse into a subdirectory if is has been 
  // modified within the last max_file_age secs.

  DsInputPath (const string &prog_name,
	       bool debug,
	       const string &input_dir,
	       int max_file_age,
	       DsInput_heartbeat_t heartbeat_func,
	       bool use_ldata_info = true,
	       bool latest_file_only = true);
  
  /////////////////////////////
  // Constructor - Triggered mode
  //
  // Pass in data directory.
  //

  DsInputPath (const string &prog_name,
	       bool debug,
	       const string &input_dir);

  /////////////
  // destructor

  ~DsInputPath();

  /////////////
  // set debug
  
  void setDebug(bool state) { _debug = state; }

  /////////////////////////
  // reset to start of list
  // 
  // Archive mode only.

  void reset();

  /////////////////////////
  // step back by one entry
  // 
  // Archive mode only.
  //
  // Returns 0 on success, -1 if already at start of list
  
  int stepBack();

  ///////////////////////////////////////
  // set the heartbeat function
  //

  void setHeartbeatFunc( DsInput_heartbeat_t func);

  ///////////////////////////////////////
  // set the required data file extension
  //
  // If set, only files with this extension will be returned

  void setSearchExt(const string &search_ext);

  ///////////////////////////////////////
  // set a substring that must be in the filename
  // for it to be considered valid.
  // If set, only files with this string in
  // their full path will be returned.

  void setSubString(const string &subString);

  ///////////////////////////////////////////////////////////
  // set the directory scan sleep interval - secs
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used. This is the time the search routine
  // sleeps between each scan of the directory looking for
  // new data. The default is 5, and the maximum is 50,
  // so that the routine will register with the procmap
  // at least once per minute.
  
  void setDirScanSleep(int dir_scan_sleep_secs = 5);

  ///////////////////////////////////////////////////////////
  // set the file quiescence time - secs
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used. The next() routine, when searching for
  // new files, waits for files to be quiescent before assuming they
  // are complete on disk. This is the number of secs of quiescence
  // we wait.
  
  void setFileQuiescence(int file_quiescence_secs = 5);

  ///////////////////////////////////////////////////////////
  // set the recursion flag (default is true)
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used. The next() routine, when searching for
  // new files, will recurse down new directories unless the
  // recursion flag is set to false.

  void setRecursion(bool recursionFlag = true);

  ///////////////////////////////////////////////////////////
  // set the max recursion depth.
  //
  // Only applies is recursion is set on.
  // This is the maximum depth, below input_dir, to which the
  // recursive scan will be carried out.
  // Defaults to 20.

  void setMaxRecursionDepth(int max_depth);

  ///////////////////////////////////////////////////////////
  // When set, only scan subdirs that look like daily subdirs
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used. Subdirs must begin with:
  // YYYYMMDD or g_YYYYMMDD in order to qualify for scanning.
  
  void setStrictDirScan(bool value = false);

  ///////////////////////////////////////////////////////////
  // Set max age for scanning subdirectories - secs.
  // If set to -1, no age check is applied.
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used.
  //
  // Defaults to max_file_age from constructor.
  
  void setMaxDirAge(int age);

  ///////////////////////////////////////////////////////////
  // set the follow_links flag (default is true)
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used. The next() routine, when searching for
  // new files, will decide whether to follow symbolic links
  // based on the value of this flag

  void setFollowLinks(bool followLinksFlag = true);

  ///////////////////////////////////////////////////////////
  // set whether to use inotify for watching for new files
  // default is true
  //
  // This only applies to REALTIME mode, when the latest_data_info
  // file is NOT being used. The next() routine, when searching for
  // new files, will use inotify instead of actively scanning the
  // directories for new files. This is more efficient.
  // The default is for this to state to be set.

  void setUseInotify(bool useInotifyFlag = true);

  ///////////////////////////////////////////////////////////
  // Option to set _latest_file_only flag
  //
  // If set to true, only the latest file found will be 
  // added to the list of available files.
  // If false, all files since the last active time will be
  // added to the list.
  
  void setLatestFileOnly(bool latest_only = true);

  ///////////////////////////////////////////////////////////
  // Option to save the latest read info.
  //
  // If set to true, the latest read info will be saved out in
  // a file to preserve state in case the application dies. On
  // restart, the latest read info will be read in to re-initialize
  // the object, so that data will not be lost.
  //
  // This is off by default.
  //
  // The label supplied will be used to form the file name of the
  // file used to save the state, to help keep it unique. Generally,
  // a good strategy is to build the label from the application name 
  // and the instance.

  void setSaveLatestReadInfo(const string &label,
			     bool save = true);

  //////////////////////////////////////////////////
  // get next file path
  //
  // Realtime and Archive modes only
  //
  // If block is true, blocks until data is available.
  // If block is false, returns immediately if no data is available.
  // Blocking is only applicable in Realtime mode.
  //
  // Returns the path of the next available file.
  // If no file is available, returns NULL.

  char *next(bool block = true);

  /////////////////////
  // get latest file written to the input directory
  //
  // Realtime mode only
  //
  // returns NULL on failure

  char *latest(bool force = true);
  
  /////////////////////////
  // get new file written to the input directory since
  // given last data time.
  //
  // Realtime mode only
  //
  // returns NULL on failure

  char *new_data(time_t last_data_time);
  
  /////////////////////////////////////////////////////////////////////
  // Get the data time information from the given file path.
  //
  // The following formats are supported:
  //
  //     */yyyymmdd/g_hhmmss/f_llllllll.ext
  //     */yyyymmdd/hhmmss.ext
  //     */*yyyymmdd?hhmmss*
  //     */*yyyymmddhhmmss*
  //     */*yyyymmddhhmm*
  //     */*yyyymmddhh.tmhhmm (mm5 forecast)
  //     */*yyyymmddhh*
  //     */*yyyyjjjhh*
  //     */*yyyymmdd?hhmm*
  //     */*yyyymmdd?hh*
  //     */*yyyymmdd*
  //     */*yyjjj*
  //
  // Returns 0 on success, -1 on error.
  // On success, sets data_time.
  
  static int getDataTime(const string &file_path, time_t &data_time);
  static int getDataTime(const string &file_path, time_t &data_time, bool &date_only);
  static int getGenTime(const string &file_path, time_t &data_time);
  static int getGenTime(const string &file_path, time_t &data_time, bool &date_only);


  /////////////////////////////////////////////////////////////////////
  // Get the data time information from the given file path.
  // See above for supported types.

  static time_t getDataTime(const string &file_path);
  static time_t getDataTime(const char *file_path);
  static time_t getGenTime(const string &file_path);
  static time_t getGenTime(const char *file_path);


  /////////////////////////////
  // Get the LdataInfo object
  
  const LdataInfo &getLdataInfo() const { return _ldata; }
  
  /////////////////////////////////////////////////////////////////
  // get closest file to given time within the given time limits
  //
  // If more that 1 path has the same time, returns the last
  // path with that time.
  //
  // On success, returns the name of the closest file.  This pointer
  // points to memory which should NOT be freed by the caller.
  // On failure, returns NULL.
  //
  // Returns the data_time of the file (based on the file name) in
  // the argument list.
  
  char *getClosest(time_t search_time,
                   time_t start_time,
                   time_t end_time,
                   time_t *data_time) const;

  /////////////////////////////////////////////////////////////////
  // get closest file to given time within the given time margin
  //
  // If more that 1 path has the same time, returns the last
  // path with that time.
  //
  // On success, returns the name of the closest file.  This pointer
  // points to static memory which should not be freed by the caller.
  // On failure, returns NULL.
  //
  // Returns the data time of the file (based on the file name) in
  // the argument list.
  
  char *getClosest(time_t search_time,
		   int max_time_offset,
		   time_t *data_time) const;
  
  ////////////////////////////////////////////////////////////////////
  // get closest file to given time within the given time margin, wait
  // if there is currently no data within the time margin.
  //
  // If more that 1 path has the same time, returns the last
  // path with that time.
  //
  // On success, returns the name of the closest file.  This pointer
  // points to static memory which should not be freed by the caller.
  // On failure, returns NULL.
  //
  // Returns the data time of the file (based on the file name) in
  // the argument list.

  char *getClosestBlocking(time_t search_time,
			   int max_time_offset,
			   DsInput_heartbeat_t heartbeat_func,
			   time_t *data_time) const;
  
  ////////////////////////////////////////////////////////////////
  // get latest data file before the given time, but within the
  // given offset.
  //
  // If more that 1 path has the same time, returns the last
  // path with that time.
  //
  // On success, returns the name of the closest file.  This pointer
  // points to static memory which should not be freed by the caller.
  // On failure, returns NULL.
  //
  // Returns the data time of the file (based on the file name) in
  // the argument list.

  char *getFirstBefore(time_t search_time,
		       int max_time_offset,
		       time_t *data_time) const;
  
  /////////////////////////////////////////////////////////////////////
  // get latest data file after the given time, but within the
  // given offset.
  //
  // If more that 1 path has the same time, returns the last
  // path with that time.
  //
  // On success, returns the name of the closest file.  This pointer
  // points to static memory which should not be freed by the caller.
  // On failure, returns NULL.
  //
  // Returns the data time of the file (based on the file name) in
  // the argument list.

  char *getFirstAfter(time_t search_time,
		      int max_time_offset,
		      time_t *data_time) const;

  ////////////////////////////////////////////////////////////////////
  // access to selected data members

  const string &getInputDir() { return _input_dir; } 
  const string &getSearchExt() { return _search_ext; } 
  mode_t getMode() { return _mode; };

  const PathTimeMap &getPathTimes() { return _pathTimeList; }
  const vector<string> &getPathList() const { return _pathList; }
  
protected:

private:

  string _input_dir;
  string _prog_name;
  string _search_ext;

  bool _check_sub_str; // TRUE if filenames must contain a substring
  string _sub_str;     // The substring to check for.
  
  mode_t _mode;
  int _max_file_age;
  int _max_dir_age;
  int _max_recursion_depth;
  int _dir_scan_sleep_secs;
  int _file_quiescence_secs;
  bool _strict_scan;
  bool _recurse;
  bool _follow_links;
  bool _debug;

  bool _use_ldata_info;
  bool _latest_file_only;
  time_t _latest_time_used;
  bool _save_latest_read_info;
  mutable LdataInfo _latest_read_info;

  bool _use_inotify;
  int _inotifyFd;
  map<int, string> _watchList;
  deque<string> _inotifyFileQueue;

  DsInput_heartbeat_t _heartbeat_func;
  
  vector<string> _pathList;
  int _pathPosn;

  PathTimeMap _pathTimeList;
 
  TimePathMap _timePathList;
  TimePathMap _prevPathTimeList;
  TimePathIter _timePathPosn;

  mutable LdataInfo _ldata;
  mutable string _returned_path;

  // default constructor - only used by class itself

  DsInputPath();

  void _init();

  int _load_pathlist_archive_by_time(const string &input_dir,
				     time_t start_time, time_t end_time);
  
  int _load_pathlist_archive_by_name(const string &input_dir,
				     time_t start_time, time_t end_time,
				     int depth);

  void _load_pathlist_day(const string &input_dir,
			  int day_num,
			  time_t start_time,
			  time_t end_time,
			  bool &have_valid_time_format,
			  bool &have_forecast_format);

  void _load_gen(const string &gendir_path,
		 time_t start_time,
		 time_t end_time);

  int _nextArchive();

  int _nextRealtimeLdata(bool block);
  
  int _nextRealtimeInotify(bool block);

  int _nextRealtimeNoLdata(bool block);

  void _load_timelist_realtime(const string &input_dir, int depth);

  bool _hasExt(const string &path);
  bool _hasExt(const string &path, string ext);

  bool _hasSubStr(const string &path);

  bool _scanThisDir(char* name, int age);

  void _insertPathPair(const string &path, time_t file_time);

  void _insertTimePair(time_t file_time, const string &path);

  void _fillLdataInfo(const char *latest_path);

#ifndef __APPLE__

  int _loadTimelistInotify(bool block);

  int _inotifyInit();

  void _loadInotifySubDirs(const string &dir,
                           int depth,
                           vector<string> &dirList);

  void _handleInotifyEvent(struct inotify_event *event);
    
  void _printInotifyEvent(struct inotify_event *event, 
                          ostream &out);

#endif

};

#endif
