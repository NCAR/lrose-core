/*********************************************************
 * parameter definitions for KdpFilt lib module
 *
 * Mike Dixon, EOL, NCAR, Boulder, CO, USA, 80307-3000
 *
 * November 2018
 */

//////////////////////////////////////////////////////////

commentdef {
  p_header = "KdpFilt computes KDP using a filtering technique, and modifies the KDP location using the Z-ZDR self consistency principle.";
}

typedef enum {
  FIR_LEN_125, FIR_LEN_60, FIR_LEN_40, FIR_LEN_30, FIR_LEN_20, FIR_LEN_10
} fir_filter_len_t;
  
paramdef enum fir_filter_len_t {
  p_default = FIR_LEN_10;
  p_descr = "Filter length for the FIR filter for PHIDP (gates)";
  p_help = "When computing KDP, an FIR filter is first applied to PHIDP to smooth it. This is the length of that filter, in gates.";
} KDP_fir_filter_len;

paramdef int {
  p_default = 2;
  p_descr = "Sets the number of iterations for the initial FIR filter for unfolded PHIDP.";
  p_help = "After unfolding PHIDP, the FIR filter is applied to the unfolded phidp, a number of times, to smooth it. The effect of the filter is a combination of the filter length and the number of iterations.";
} KDP_n_filt_iterations_unfolded;

paramdef int {
  p_default = 4;
  p_descr = "Sets the number of iterations for the final FIR filter for conditioned PHIDP.";
  p_help = "In order to identify phase shift on backscatter (PSOB), we condition the PHIDP to keep it generally increasing with range. The FIR filter is applied to the conditioned phidp a number of times, to smooth it. The effect of the filter is a combination of the filter length and the number of iterations.";
} KDP_n_filt_iterations_conditioned;

paramdef boolean {
  p_default = false;
  p_descr = "Perform iterative filtering to locate backscatter phase shift.";
  p_descr = "This is the Hubbert-Bringi method.";
} KDP_use_iterative_filtering;

paramdef double {
  p_default = 4.0;
  p_descr = "Difference threshold for the iterative filtering method.";
  p_help = "The FIR filter is applied successively, KDP_n_filt_iterations_conditioned times. After each iteration the result is checked against the original. If the difference is less than this parameter, the original value at that gate is retained. If the difference exceeds this parameter, the new filtered value is retained.";
} KDP_phidp_difference_threshold;

paramdef int {
  p_default = 9;
  p_descr = "Number of gates over which the phidp mean, sdev and jitter are computed.";
  p_help = "The mean, sdev and jitter of phidp are computed over a consecutive number of gates in range, centered on the current gate of interest. This parameter is the number of gates over which these statistics are computed.";
} KDP_ngates_for_stats;

paramdef double {
  p_default = 20.0;
  p_descr = "Sets the threshold for the standard deviation of phidp in range.";
  p_help = "The sdev of phidp is a good test for valid phidp. The sdev is computed in the circle, so that it takes account of folding if present. If the sdev is less than this value, it is assumed we are in weather. Applies to computation of KDP only.";
} KDP_phidp_sdev_max;

paramdef double {
  p_default = 25.0;
  p_descr = "Sets the threshold for the jitter of phidp in range.";
  p_help = "The jitter of phidp is defined as the mean absolute change in angle between successive phidp measurements in range. It is computed on the circle to take account of folding. If the jitter is less than this value, it is assumed we are in weather. Applies to computation of KDP only.";
} KDP_phidp_jitter_max;

paramdef double {
  p_default = 0.01;
  p_descr = "Sets the min valid KDP value.";
  p_help = "Values less than this are set to 0.";
} KDP_min_valid_abs_kdp;

paramdef boolean {
  p_default = false;
  p_descr = "Check the SNR.";
  p_descr = "This test can help identify regions of good PHIDP.";
} KDP_check_snr;

paramdef double {
  p_default = -6.0;
  p_descr = "Sets the threshold for checking SNR (dB).";
  p_help = "If the SNR drops below this value, KDP will not be computed at this gate.";
} KDP_snr_threshold;

paramdef boolean {
  p_default = true;
  p_descr = "Check the RHOHV.";
  p_descr = "This test can help identify regions of good PHIDP.";
} KDP_check_rhohv;

paramdef double {
  p_default = 0.95;
  p_descr = "Sets the threshold for checking RHOHV.";
  p_help = "If the RHOHV drops below this value, KDP will not be computed at this gate.";
} KDP_rhohv_threshold;

paramdef boolean {
  p_default = false;
  p_descr = "Check the standard deviation of ZDR in range?";
  p_descr = "This test can help identify regions of clutter, and hence noisy PHIDP.";
} KDP_check_zdr_sdev;

paramdef double {
  p_default = 2.0;
  p_descr = "Sets the threshold for the standard deviation of zdr in range.";
  p_help = "The sdev of zdr is a good test for clutter. If the sdev is less than this value, it is assumed we are in weather. Applies to computation of KDP only.";
} KDP_zdr_sdev_max;

paramdef double {
  p_default = 0.25;
  p_descr = "Sets the threshold for computing conditional KDP from Z and ZDR.";
  p_help = "We can estimate KDP from Z and ZDR - we call this KDP_ZZDR. We can then compute the conditioned KDP - we call this KDP_COND. To compute KDP_COND, we first find the gates over which regular KDP exceeds this threshold. Over this run of gates we compute the PHIDP change from the regular KDP and from KDP_ZZDR. By taking the ratio of sum(KDP) / sum(KDP_ZZDR), and applying that ratio to KDP_ZZDR over these gates, we can compute KDP_COND such that the PHIDP change is the same for both KDP and KDP_COND.";
} KDP_threshold_for_ZZDR;

paramdef int {
  p_default = 5;
  p_descr = "Sets the length of the median filter when computing KDP_ZZDR.";
  p_help = "The Z and ZDR fields are smoothed with a median filter of this length prior to estimating KDP_ZZDR.";
} KDP_median_filter_len_for_ZZDR;

paramdef boolean {
  p_default = false;
  p_descr = "Option to print debug messages in KDP computation.";
} KDP_debug;

paramdef boolean {
  p_default = false;
  p_descr = "Option to write ray files to debug KDP computation.";
} KDP_write_ray_files;

paramdef string {
  p_default = "/tmp/kdp_ray_files";
  p_descr = "Directory for KDP ray files.";
} KDP_ray_files_dir;

